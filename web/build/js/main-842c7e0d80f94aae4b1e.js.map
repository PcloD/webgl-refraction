{"version":3,"sources":["webpack:///js/main-842c7e0d80f94aae4b1e.js","webpack:///webpack/bootstrap 842c7e0d80f94aae4b1e","webpack:///./web/js/index.js","webpack:///./~/babel-runtime/core-js/get-iterator.js","webpack:///./~/core-js/library/fn/get-iterator.js","webpack:///./~/core-js/library/modules/web.dom.iterable.js","webpack:///./~/core-js/library/modules/es6.array.iterator.js","webpack:///./~/core-js/library/modules/_add-to-unscopables.js","webpack:///./~/core-js/library/modules/_iter-step.js","webpack:///./~/core-js/library/modules/_iterators.js","webpack:///./~/core-js/library/modules/_to-iobject.js","webpack:///./~/core-js/library/modules/_iobject.js","webpack:///./~/core-js/library/modules/_cof.js","webpack:///./~/core-js/library/modules/_defined.js","webpack:///./~/core-js/library/modules/_iter-define.js","webpack:///./~/core-js/library/modules/_library.js","webpack:///./~/core-js/library/modules/_export.js","webpack:///./~/core-js/library/modules/_global.js","webpack:///./~/core-js/library/modules/_core.js","webpack:///./~/core-js/library/modules/_ctx.js","webpack:///./~/core-js/library/modules/_a-function.js","webpack:///./~/core-js/library/modules/_hide.js","webpack:///./~/core-js/library/modules/_object-dp.js","webpack:///./~/core-js/library/modules/_an-object.js","webpack:///./~/core-js/library/modules/_is-object.js","webpack:///./~/core-js/library/modules/_ie8-dom-define.js","webpack:///./~/core-js/library/modules/_descriptors.js","webpack:///./~/core-js/library/modules/_fails.js","webpack:///./~/core-js/library/modules/_dom-create.js","webpack:///./~/core-js/library/modules/_to-primitive.js","webpack:///./~/core-js/library/modules/_property-desc.js","webpack:///./~/core-js/library/modules/_redefine.js","webpack:///./~/core-js/library/modules/_has.js","webpack:///./~/core-js/library/modules/_iter-create.js","webpack:///./~/core-js/library/modules/_object-create.js","webpack:///./~/core-js/library/modules/_object-dps.js","webpack:///./~/core-js/library/modules/_object-keys.js","webpack:///./~/core-js/library/modules/_object-keys-internal.js","webpack:///./~/core-js/library/modules/_array-includes.js","webpack:///./~/core-js/library/modules/_to-length.js","webpack:///./~/core-js/library/modules/_to-integer.js","webpack:///./~/core-js/library/modules/_to-index.js","webpack:///./~/core-js/library/modules/_shared-key.js","webpack:///./~/core-js/library/modules/_shared.js","webpack:///./~/core-js/library/modules/_uid.js","webpack:///./~/core-js/library/modules/_enum-bug-keys.js","webpack:///./~/core-js/library/modules/_html.js","webpack:///./~/core-js/library/modules/_set-to-string-tag.js","webpack:///./~/core-js/library/modules/_wks.js","webpack:///./~/core-js/library/modules/_object-gpo.js","webpack:///./~/core-js/library/modules/_to-object.js","webpack:///./~/core-js/library/modules/es6.string.iterator.js","webpack:///./~/core-js/library/modules/_string-at.js","webpack:///./~/core-js/library/modules/core.get-iterator.js","webpack:///./~/core-js/library/modules/core.get-iterator-method.js","webpack:///./~/core-js/library/modules/_classof.js","webpack:///./~/babel-runtime/helpers/classCallCheck.js","webpack:///./~/babel-runtime/helpers/createClass.js","webpack:///./~/babel-runtime/core-js/object/define-property.js","webpack:///./~/core-js/library/fn/object/define-property.js","webpack:///./~/core-js/library/modules/es6.object.define-property.js","webpack:///./web/index.html","webpack:///./~/three/three.js","webpack:///./web/js/particle.js","webpack:///./~/babel-runtime/core-js/object/get-prototype-of.js","webpack:///./~/core-js/library/fn/object/get-prototype-of.js","webpack:///./~/core-js/library/modules/es6.object.get-prototype-of.js","webpack:///./~/core-js/library/modules/_object-sap.js","webpack:///./~/babel-runtime/helpers/possibleConstructorReturn.js","webpack:///./~/babel-runtime/helpers/typeof.js","webpack:///./~/babel-runtime/core-js/symbol/iterator.js","webpack:///./~/core-js/library/fn/symbol/iterator.js","webpack:///./~/core-js/library/modules/_wks-ext.js","webpack:///./~/babel-runtime/core-js/symbol.js","webpack:///./~/core-js/library/fn/symbol/index.js","webpack:///./~/core-js/library/modules/es6.symbol.js","webpack:///./~/core-js/library/modules/_meta.js","webpack:///./~/core-js/library/modules/_wks-define.js","webpack:///./~/core-js/library/modules/_keyof.js","webpack:///./~/core-js/library/modules/_enum-keys.js","webpack:///./~/core-js/library/modules/_object-gops.js","webpack:///./~/core-js/library/modules/_object-pie.js","webpack:///./~/core-js/library/modules/_is-array.js","webpack:///./~/core-js/library/modules/_object-gopn-ext.js","webpack:///./~/core-js/library/modules/_object-gopn.js","webpack:///./~/core-js/library/modules/_object-gopd.js","webpack:///./~/core-js/library/modules/es7.symbol.async-iterator.js","webpack:///./~/core-js/library/modules/es7.symbol.observable.js","webpack:///./~/babel-runtime/helpers/inherits.js","webpack:///./~/babel-runtime/core-js/object/set-prototype-of.js","webpack:///./~/core-js/library/fn/object/set-prototype-of.js","webpack:///./~/core-js/library/modules/es6.object.set-prototype-of.js","webpack:///./~/core-js/library/modules/_set-proto.js","webpack:///./~/babel-runtime/core-js/object/create.js","webpack:///./~/core-js/library/fn/object/create.js","webpack:///./~/core-js/library/modules/es6.object.create.js","webpack:///./web/textures/crystal.jpg","webpack:///./~/three/examples/js/libs/stats.min.js","webpack:///./web/textures/checkerboard.png","webpack:///./~/three/examples/js/controls/OrbitControls.js","webpack:///./~/three/examples/js/libs/dat.gui.min.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","global","_interopRequireDefault","obj","__esModule","default","_getIterator2","_getIterator3","_classCallCheck2","_classCallCheck3","_createClass2","_createClass3","_index","_style","_three","_three2","_particle","_particle2","_stats","_stats2","scene","THREE","dat","stats","showPanel","document","body","appendChild","dom","App","_this","this","Scene","camera","PerspectiveCamera","window","innerWidth","innerHeight","position","z","stars","i","l","buildStar","add","geometry","BoxBufferGeometry","material","MeshBasicMaterial","side","BackSide","map","TextureLoader","load","precision","cube","Mesh","set","renderer","WebGLRenderer","canvas","getElementById","antialias","setSize","OrbitControls","domElement","render","bind","resize","bindEvents","update","params","color1","color2","color3","color4","intensity","scale","opacity","fresnel","fresnelBias","fresnelPow","gui","GUI","color","addColor","onChange","v","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_step","_iterator","children","next","done","child","value","uniforms","emissive","Color","err","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_step3","_iterator3","_iteratorNormalCompletion4","_didIteratorError4","_iteratorError4","_step4","_iterator4","r","addFolder","open","refraction","_iteratorNormalCompletion5","_didIteratorError5","_iteratorError5","_step5","_iterator5","star","_iteratorNormalCompletion6","_didIteratorError6","_iteratorError6","_step6","_iterator6","_iteratorNormalCompletion7","_didIteratorError7","_iteratorError7","_step7","_iterator7","_iteratorNormalCompletion8","_didIteratorError8","_iteratorError8","_step8","_iterator8","refractionIntensity","_iteratorNormalCompletion9","_didIteratorError9","_iteratorError9","_step9","_iterator9","_iteratorNormalCompletion10","_didIteratorError10","_iteratorError10","_step10","_iterator10","vScale","Vector2","_iteratorNormalCompletion11","_didIteratorError11","_iteratorError11","_step11","_iterator11","_iteratorNormalCompletion12","_didIteratorError12","_iteratorError12","_step12","_iterator12","fresnelMix","_iteratorNormalCompletion13","_didIteratorError13","_iteratorError13","_step13","_iterator13","_iteratorNormalCompletion14","_didIteratorError14","_iteratorError14","_step14","_iterator14","_iteratorNormalCompletion15","_didIteratorError15","_iteratorError15","_step15","_iterator15","_iteratorNormalCompletion16","_didIteratorError16","_iteratorError16","_step16","_iterator16","key","addEventListener","Object3D","Math","random","particle","rotation","PI","aspect","updateProjectionMatrix","_iteratorNormalCompletion17","_didIteratorError17","_iteratorError17","_step17","_iterator17","resolution","_this2","slice","sort","a","b","pb","getWorldPosition","project","pa","_iteratorNormalCompletion18","_didIteratorError18","_iteratorError18","_step18","_iterator18","visible","_iteratorNormalCompletion19","_didIteratorError19","_iteratorError19","_step19","_iterator19","_star","y","x","translateY","_iteratorNormalCompletion20","_didIteratorError20","_iteratorError20","_step20","_iterator20","_iteratorNormalCompletion21","_didIteratorError21","_iteratorError21","_step21","_iterator21","_child","renderTarget","offset","begin","end","requestAnimationFrame","hide","Iterators","TO_STRING_TAG","collections","NAME","Collection","proto","prototype","Array","addToUnscopables","step","toIObject","iterated","kind","_t","_i","_k","O","index","length","Arguments","IObject","defined","it","cof","Object","propertyIsEnumerable","split","toString","TypeError","LIBRARY","$export","redefine","has","$iterCreate","setToStringTag","getPrototypeOf","ITERATOR","BUGGY","keys","FF_ITERATOR","KEYS","VALUES","returnThis","Base","Constructor","DEFAULT","IS_SET","FORCED","methods","IteratorPrototype","getMethod","TAG","DEF_VALUES","VALUES_BUG","$native","$default","$entries","$anyNative","entries","name","values","P","F","core","ctx","PROTOTYPE","type","source","own","out","IS_FORCED","IS_GLOBAL","G","IS_STATIC","S","IS_PROTO","IS_BIND","B","IS_WRAP","W","expProto","target","C","arguments","apply","Function","virtual","R","U","self","__g","version","__e","aFunction","fn","that","dP","createDesc","object","f","anObject","IE8_DOM_DEFINE","toPrimitive","defineProperty","Attributes","e","isObject","get","exec","is","createElement","val","valueOf","bitmap","enumerable","configurable","writable","hasOwnProperty","create","descriptor","dPs","enumBugKeys","IE_PROTO","Empty","createDict","iframeDocument","iframe","gt","style","display","src","contentWindow","write","close","Properties","result","getKeys","defineProperties","$keys","arrayIndexOf","names","push","toLength","toIndex","IS_INCLUDES","$this","el","fromIndex","toInteger","min","ceil","floor","isNaN","max","shared","uid","SHARED","store","px","concat","documentElement","def","tag","stat","Symbol","USE_SYMBOL","$exports","toObject","ObjectProto","constructor","$at","String","point","TO_STRING","pos","s","charCodeAt","charAt","getIterator","iterFn","classof","getIteratorMethod","ARG","tryGet","T","callee","instance","_defineProperty","_defineProperty2","props","protoProps","staticProps","$Object","desc","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_RESULT__","REVISION","Number","EPSILON","pow","sign","match","assign","to","n","nextSource","keysArray","nextIndex","len","nextKey","getOwnPropertyDescriptor","MOUSE","LEFT","MIDDLE","RIGHT","CullFaceNone","CullFaceBack","CullFaceFront","CullFaceFrontBack","FrontFaceDirectionCW","FrontFaceDirectionCCW","BasicShadowMap","PCFShadowMap","PCFSoftShadowMap","FrontSide","DoubleSide","FlatShading","SmoothShading","NoColors","FaceColors","VertexColors","NoBlending","NormalBlending","AdditiveBlending","SubtractiveBlending","MultiplyBlending","CustomBlending","AddEquation","SubtractEquation","ReverseSubtractEquation","MinEquation","MaxEquation","ZeroFactor","OneFactor","SrcColorFactor","OneMinusSrcColorFactor","SrcAlphaFactor","OneMinusSrcAlphaFactor","DstAlphaFactor","OneMinusDstAlphaFactor","DstColorFactor","OneMinusDstColorFactor","SrcAlphaSaturateFactor","NeverDepth","AlwaysDepth","LessDepth","LessEqualDepth","EqualDepth","GreaterEqualDepth","GreaterDepth","NotEqualDepth","MultiplyOperation","MixOperation","AddOperation","NoToneMapping","LinearToneMapping","ReinhardToneMapping","Uncharted2ToneMapping","CineonToneMapping","UVMapping","CubeReflectionMapping","CubeRefractionMapping","EquirectangularReflectionMapping","EquirectangularRefractionMapping","SphericalReflectionMapping","CubeUVReflectionMapping","CubeUVRefractionMapping","RepeatWrapping","ClampToEdgeWrapping","MirroredRepeatWrapping","NearestFilter","NearestMipMapNearestFilter","NearestMipMapLinearFilter","LinearFilter","LinearMipMapNearestFilter","LinearMipMapLinearFilter","UnsignedByteType","ByteType","ShortType","UnsignedShortType","IntType","UnsignedIntType","FloatType","HalfFloatType","UnsignedShort4444Type","UnsignedShort5551Type","UnsignedShort565Type","AlphaFormat","RGBFormat","RGBAFormat","LuminanceFormat","LuminanceAlphaFormat","RGBEFormat","DepthFormat","RGB_S3TC_DXT1_Format","RGBA_S3TC_DXT1_Format","RGBA_S3TC_DXT3_Format","RGBA_S3TC_DXT5_Format","RGB_PVRTC_4BPPV1_Format","RGB_PVRTC_2BPPV1_Format","RGBA_PVRTC_4BPPV1_Format","RGBA_PVRTC_2BPPV1_Format","RGB_ETC1_Format","LoopOnce","LoopRepeat","LoopPingPong","InterpolateDiscrete","InterpolateLinear","InterpolateSmooth","ZeroCurvatureEnding","ZeroSlopeEnding","WrapAroundEnding","TrianglesDrawMode","TriangleStripDrawMode","TriangleFanDrawMode","LinearEncoding","sRGBEncoding","GammaEncoding","RGBEEncoding","LogLuvEncoding","RGBM7Encoding","RGBM16Encoding","RGBDEncoding","BasicDepthPacking","RGBADepthPacking","fromArray","g","copy","setHex","setStyle","setScalar","scalar","hex","setRGB","setHSL","hue2rgb","q","t","h","euclideanModulo","clamp","handleAlpha","string","parseFloat","console","warn","components","parseInt","size","ColorKeywords","clone","copyGammaToLinear","gammaFactor","copyLinearToGamma","safeInverse","convertGammaToLinear","convertLinearToGamma","sqrt","getHex","getHexString","getHSL","optionalTarget","hue","saturation","hsl","lightness","delta","getStyle","offsetHSL","addColors","addScalar","multiply","multiplyScalar","lerp","alpha","equals","array","toArray","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","green","greenyellow","grey","honeydew","hotpink","indianred","indigo","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","red","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","tan","teal","thistle","tomato","turquoise","violet","wheat","white","whitesmoke","yellow","yellowgreen","Quaternion","w","_x","_y","_z","_w","onChangeCallback","quaternion","setFromEuler","euler","Euler","Error","c1","cos","c2","c3","s1","sin","s2","s3","order","setFromAxisAngle","axis","angle","halfAngle","setFromRotationMatrix","te","elements","m11","m12","m13","m21","m22","m23","m31","m32","m33","trace","setFromUnitVectors","v1","EPS","vFrom","vTo","Vector3","dot","abs","crossVectors","normalize","inverse","conjugate","lengthSq","multiplyQuaternions","qax","qay","qaz","qaw","qbx","qby","qbz","qbw","slerp","qb","cosHalfTheta","sinHalfTheta","halfTheta","atan2","ratioA","ratioB","callback","qa","qm","slerpFlat","dst","dstOffset","src0","srcOffset0","src1","srcOffset1","x0","y0","z0","w0","x1","y1","z1","w1","dir","sqrSin","tDir","width","height","setX","setY","setComponent","getComponent","addVectors","addScaledVector","sub","subVectors","subScalar","isFinite","divide","divideScalar","clampScalar","minVal","maxVal","clampLength","round","roundToZero","negate","lengthManhattan","distanceTo","distanceToSquared","dx","dy","setLength","lerpVectors","v2","fromAttribute","attribute","itemSize","rotateAround","center","setZ","multiplyVectors","applyEuler","error","applyQuaternion","applyAxisAngle","applyMatrix3","applyMatrix4","applyProjection","d","qx","qy","qz","qw","ix","iy","iz","iw","matrix","Matrix4","multiplyMatrices","projectionMatrix","getInverse","matrixWorld","unproject","transformDirection","cross","ax","ay","az","bx","by","bz","projectOnVector","vector","projectOnPlane","planeNormal","reflect","normal","angleTo","theta","acos","dz","setFromSpherical","sinPhiRadius","phi","radius","setFromMatrixPosition","setFromMatrixColumn","setFromMatrixScale","sx","sy","sz","Vector4","setW","setAxisAngleFromQuaternion","setAxisAngleFromRotationMatrix","epsilon","epsilon2","xx","yy","zz","xy","xz","yz","_order","DefaultOrder","RotationOrders","asin","setFromQuaternion","makeRotationFromQuaternion","setFromVector3","reorder","newOrder","toVector3","optionalResult","Line3","start","line","distanceSq","distance","at","closestPointToPointParameter","startP","startEnd","clampToLine","startEnd2","startEnd_startP","closestPointToPoint","Box2","Infinity","setFromPoints","points","makeEmpty","il","expandByPoint","setFromCenterAndSize","halfSize","box","isEmpty","expandByVector","expandByScalar","containsPoint","containsBox","getParameter","intersectsBox","clampPoint","distanceToPoint","clampedPoint","intersect","union","translate","Box3","setFromArray","minX","minY","minZ","maxX","maxY","maxZ","setFromObject","scope","updateMatrixWorld","traverse","node","Geometry","vertices","BufferGeometry","attributes","positions","intersectsSphere","closestPoint","sphere","intersectsPlane","plane","constant","getBoundingSphere","Sphere","Matrix3","Float32Array","n11","n12","n13","n21","n22","n23","n31","n32","n33","identity","me","setFromMatrix4","applyToVector3Array","j","applyToBuffer","buffer","getX","getY","getZ","setXYZ","determinant","throwOnDegenerate","t11","t12","t13","det","msg","transpose","tmp","flattenToArrayOffset","getNormalMatrix","matrix4","transposeIntoArray","n14","n24","n34","n41","n42","n43","n44","copyPosition","extractBasis","xAxis","yAxis","zAxis","makeBasis","extractRotation","scaleX","scaleY","scaleZ","makeRotationFromEuler","ae","af","be","bf","ce","cf","de","df","ac","ad","bc","bd","x2","y2","z2","wx","wy","wz","lookAt","eye","up","premultiply","a11","a12","a13","a14","a21","a22","a23","a24","a31","a32","a33","a34","a41","a42","a43","a44","b11","b12","b13","b14","b21","b22","b23","b24","b31","b32","b33","b34","b41","b42","b43","b44","multiplyToArray","getPosition","setPosition","t14","getMaxScaleOnAxis","scaleXSq","scaleYSq","scaleZSq","makeTranslation","makeRotationX","makeRotationY","makeRotationZ","makeRotationAxis","tx","ty","makeScale","compose","decompose","invSX","invSY","invSZ","makeFrustum","left","right","bottom","top","near","far","makePerspective","fov","ymax","DEG2RAD","ymin","xmin","xmax","makeOrthographic","Ray","origin","direction","ray","recast","directionDistance","distanceSqToPoint","distanceSqToSegment","segCenter","segDir","diff","v0","optionalPointOnRay","optionalPointOnSegment","s0","sqrDist","extDet","segExtent","a01","b0","b1","invDet","intersectSphere","tca","d2","radius2","thc","t0","t1","distanceToPlane","denominator","intersectPlane","distToPoint","intersectBox","tmin","tmax","tymin","tymax","tzmin","tzmax","invdirx","invdiry","invdirz","intersectTriangle","edge1","edge2","backfaceCulling","DdN","DdQxE2","DdE1xQ","QdN","optionalCenter","maxRadiusSq","empty","radiusSum","deltaLengthSq","getBoundingBox","Frustum","p0","p1","p2","p3","p4","p5","planes","Plane","frustum","setFromMatrix","me0","me1","me2","me3","me4","me5","me6","me7","me8","me9","me10","me11","me12","me13","me14","me15","setComponents","intersectsObject","boundingSphere","computeBoundingSphere","negRadius","d1","setFromNormalAndCoplanarPoint","setFromCoplanarPoints","inverseNormalLength","distanceToSphere","projectPoint","orthoPoint","perpendicularMagnitude","intersectLine","intersectsLine","startSign","endSign","coplanarPoint","m1","optionalNormalMatrix","referencePoint","normalMatrix","Spherical","other","makeSafe","vec3","RAD2DEG","generateUUID","chars","uuid","rnd","join","mapLinear","a1","a2","b2","smoothstep","smootherstep","random16","randInt","low","high","randFloat","randFloatSpread","range","degToRad","degrees","radToDeg","radians","isPowerOfTwo","nearestPowerOfTwo","log","LN2","nextPowerOfTwo","Spline","interpolate","t2","t3","intPoint","weight","w2","w3","pc","pd","v3","initFromArray","getPoint","k","getControlPointsArray","coords","getLength","nSubDivisions","nSamples","oldIntPoint","oldPosition","tmpVec","chunkLengths","totalLength","chunks","total","reparametrizeByArcLength","samplingCoef","indexCurrent","indexNext","realDistance","sampling","newpoints","sl","Triangle","resultLengthSq","barycoordFromPoint","dot00","dot01","dot02","dot11","dot12","denom","invDenom","u","setFromPointsAndIndices","i0","i1","i2","triangle","area","midpoint","edgeList","projectedPoint","minDistance","Interpolant","parameterPositions","sampleValues","sampleSize","resultBuffer","_cachedIndex","valueSize","evaluate","pp","validate_interval","seek","linear_scan","forward_scan","giveUpAt","afterEnd_","t1global","beforeStart_","mid","intervalChanged_","interpolate_","settings","DefaultSettings_","getSettings_","copySampleValue_","stride","CubicInterpolant","_weightPrev","_offsetPrev","_weightNext","_offsetNext","endingStart","endingEnd","iPrev","iNext","tPrev","tNext","halfDt","o1","o0","oP","oN","wP","wN","ppp","sP","sN","DiscreteInterpolant","LinearInterpolant","offset1","offset0","weight1","weight0","QuaternionLinearInterpolant","Clock","autoStart","startTime","oldTime","elapsedTime","running","performance","Date","now","stop","getElapsedTime","getDelta","newTime","EventDispatcher","hasEventListener","removeEventListener","dispatchEvent","listener","_listeners","listeners","indexOf","listenerArray","splice","event","Layers","mask","channel","enable","toggle","disable","test","layers","ascSort","intersectObject","raycaster","intersects","recursive","raycast","Raycaster","Line","LOD","Points","threshold","Sprite","PointCloud","linePrecision","setFromCamera","OrthographicCamera","intersectObjects","objects","isArray","onRotationChange","onQuaternionChange","Object3DIdCount","parent","DefaultUp","modelViewMatrix","rotationAutoUpdate","matrixAutoUpdate","DefaultMatrixAutoUpdate","matrixWorldNeedsUpdate","castShadow","receiveShadow","frustumCulled","renderOrder","userData","applyMatrix","setRotationFromAxisAngle","setRotationFromEuler","setRotationFromMatrix","setRotationFromQuaternion","rotateOnAxis","q1","rotateX","rotateY","rotateZ","translateOnAxis","translateX","translateZ","localToWorld","worldToLocal","remove","getObjectById","getObjectByProperty","getObjectByName","getWorldQuaternion","getWorldRotation","getWorldScale","getWorldDirection","traverseVisible","traverseAncestors","updateMatrix","force","toJSON","meta","extractFromCache","cache","data","metadata","isRootObject","output","geometries","materials","textures","images","generator","JSON","stringify","parse","Face3","materialIndex","vertexNormals","vertexColors","BufferAttribute","normalized","dynamic","updateRange","count","needsUpdate","setDynamic","copyAt","index1","index2","copyArray","copyColorsArray","colors","copyIndicesArray","indices","copyVector2sArray","vectors","copyVector3sArray","copyVector4sArray","getW","setXY","setXYZW","Int8Attribute","Int8Array","Uint8Attribute","Uint8Array","Uint8ClampedAttribute","Uint8ClampedArray","Int16Attribute","Int16Array","Uint16Attribute","Uint16Array","Int32Attribute","Int32Array","Uint32Attribute","Uint32Array","Float32Attribute","Float64Attribute","Float64Array","DynamicBufferAttribute","InstancedBufferAttribute","meshPerAttribute","InterleavedBuffer","InstancedInterleavedBuffer","InterleavedBufferAttribute","interleavedBuffer","GeometryIdCount","faces","faceVertexUvs","morphTargets","morphNormals","skinWeights","skinIndices","lineDistances","boundingBox","verticesNeedUpdate","elementsNeedUpdate","uvsNeedUpdate","normalsNeedUpdate","colorsNeedUpdate","lineDistancesNeedUpdate","groupsNeedUpdate","vertex","face","jl","computeBoundingBox","fromBufferGeometry","addFace","normals","tempNormals","uvs","tempUVs","uvs2","tempUVs2","uv","uv2","groups","group","computeFaceNormals","cb","ab","fl","vA","vB","vC","computeVertexNormals","areaWeighted","vl","computeMorphNormals","__originalFaceNormal","__originalVertexNormals","tmpGeo","faceNormals","faceNormal","dstNormalsFace","dstNormalsVertex","computeTangents","computeLineDistances","merge","materialIndexOffset","vertexOffset","vertices1","vertices2","faces1","faces2","uvs1","vertexCopy","faceCopy","faceVertexNormals","faceVertexColors","uvCopy","mergeMesh","mesh","mergeVertices","verticesMap","unique","changes","precisionPoints","faceIndicesToRemove","dupIndex","idx","sortFacesByMaterialIndex","materialIndexSort","_id","newUvs1","newUvs2","setBit","enabled","getNormalIndex","hash","normalsHash","getColorIndex","colorsHash","getUvIndex","uvsHash","parameters","hasMaterial","hasFaceUv","hasFaceVertexUv","hasFaceNormal","hasFaceVertexNormal","hasFaceColor","hasFaceVertexColor","faceType","uvsCopy","kl","dispose","DirectGeometry","computeGroups","fromGeometry","morphTargetsPosition","hasFaceVertexUv2","morphTargetsLength","morphTargetsNormal","morphNormalsLength","hasSkinIndices","hasSkinWeights","vertexUvs","morphTarget","morphNormal","morphAttributes","drawRange","getIndex","setIndex","addAttribute","getAttribute","removeAttribute","addGroup","clearGroups","setDrawRange","updateFromObject","direct","__directGeometry","lineDistance","fromDirectGeometry","TypeArray","pA","pB","pC","normalizeNormals","attribute1","attributeArray1","attribute2","attributeArray2","attributeSize","toNonIndexed","geometry2","array2","MaxIndex","InstancedBufferGeometry","maxInstancedCount","instances","Uniform","onUpdate","onUpdateCallback","AnimationClip","duration","tracks","resetDuration","trim","optimize","track","times","json","jsonTracks","frameTime","fps","KeyframeTrack","clip","clipTracks","CreateFromMorphTargetSequence","morphTargetSequence","noLoop","numMorphTargets","AnimationUtils","getKeyframeOrder","sortedArray","NumberKeyframeTrack","findByName","clipArray","CreateClipsFromMorphTargetSequences","animationToMorphTargets","pattern","parts","animationMorphTargets","clips","parseAnimation","animation","bones","nodeName","addNonemptyTrack","trackType","trackName","animationKeys","propertyName","destTracks","flattenJSON","clipName","hierarchyTracks","hierarchy","morphTargetNames","morphTargetName","animationKey","time","boneName","VectorKeyframeTrack","QuaternionKeyframeTrack","AnimationMixer","root","_root","_initMemoryManager","_accuIndex","timeScale","clipAction","optionalRoot","prototypeAction","rootUuid","clipObject","actionsForClip","_actionsByClip","existingAction","actionByRoot","knownActions","_clip","newAction","_Action","_bindAction","_addInactiveAction","stopAllAction","actions","_actions","nActions","_nActiveActions","bindings","_bindings","nBindings","_nActiveBindings","reset","useCount","deltaTime","timeDirection","accuIndex","action","_update","getRoot","uncacheClip","actionsByClip","actionsToRemove","_deactivateAction","cacheIndex","_cacheIndex","lastInactiveAction","_byClipCacheIndex","pop","_removeInactiveBindingsForAction","uncacheRoot","_removeInactiveAction","bindingsByRoot","_bindingsByRootAndName","bindingByName","binding","restoreOriginalState","_removeInactiveBinding","uncacheAction","mixer","localRoot","_mixer","_localRoot","nTracks","interpolants","interpolantSettings","interpolant","createInterpolant","_interpolantSettings","_interpolants","_propertyBindings","_timeScaleInterpolant","_weightInterpolant","loop","_loopCount","_startTime","_effectiveTimeScale","_effectiveWeight","repetitions","paused","clampWhenFinished","zeroSlopeAtStart","zeroSlopeAtEnd","play","_activateAction","stopFading","stopWarping","isRunning","_isActiveAction","isScheduled","startAt","setLoop","mode","setEffectiveWeight","getEffectiveWeight","fadeIn","_scheduleFading","fadeOut","crossFadeFrom","fadeOutAction","warp","fadeInDuration","fadeOutDuration","startEndRatio","endStartRatio","crossFadeTo","fadeInAction","weightInterpolant","_takeBackControlInterpolant","setEffectiveTimeScale","getEffectiveTimeScale","setDuration","syncWith","halt","_currentTimeScale","startTimeScale","endTimeScale","_lendControlInterpolant","timeScaleInterpolant","getMixer","getClip","timeRunning","_updateTimeScale","clipTime","_updateTime","_updateWeight","propertyMixers","accumulate","interpolantValue","pause","loopCount","pingPong","_setEndings","loopDelta","pending","atStart","atEnd","weightNow","weightThen","bindingsByName","referenceCount","_addInactiveBinding","path","parsedPath","PropertyMixer","PropertyBinding","ValueTypeName","getValueSize","_lendBinding","saveOriginalState","_lendAction","_takeBackBinding","_takeBackAction","_controlInterpolants","_nActiveControlInterpolants","inUse","controlInterpolants","knownActionsForClip","lastKnownAction","byClipCacheIndex","prevIndex","lastActiveIndex","firstInactiveAction","firstInactiveIndex","lastActiveAction","propBinding","rootNode","lastInactiveBinding","remove_empty_map","_","firstInactiveBinding","lastActiveBinding","_controlInterpolantsResultBuffer","__cacheIndex","lastActiveInterpolant","AnimationObjectGroup","var_args","_objects","nCachedObjects_","_indicesByUUID","_paths","_parsedPaths","_bindingsIndicesByPath","bindingsPerObject","nObjects","nCachedObjects","indicesByUUID","paths","parsedPaths","knownObject","firstActiveIndex","lastCachedObject","bindingsForPath","lastCached","lastCachedIndex","firstActiveObject","firstActive","uncache","lastIndex","lastObject","last","subscribe_","indicesByPath","unsubscribe_","lastBindingsIndex","lastBindings","lastBindingsPath","arraySlice","from","isTypedArray","subarray","convertArray","forceClone","BYTES_PER_ELEMENT","ArrayBuffer","isView","DataView","compareTime","nValues","srcOffset","jsonKeys","valuePropertyName","interpolation","TimeBufferType","ValueBufferType","setInterpolation","DefaultInterpolation","validate","InterpolantFactoryMethodDiscrete","InterpolantFactoryMethodLinear","InterpolantFactoryMethodSmooth","factoryMethod","message","getInterpolation","shift","timeOffset","endTime","nKeys","valid","prevTime","currTime","writeIndex","keep","timeNext","offsetP","offsetN","readOffset","writeOffset","_getTrackTypeForValueTypeName","typeName","toLowerCase","ColorKeyframeTrack","BooleanKeyframeTrack","StringKeyframeTrack","parseTrackName","findNode","getValue","targetArray","setValue","sourceArray","targetObject","objectName","propertyIndex","_getValue_unavailable","_setValue_unavailable","objectIndex","skeleton","nodeProperty","versioning","Versioning","None","NeedsUpdate","MatrixWorldNeedsUpdate","bindingType","BindingType","Direct","ArrayElement","resolvedProperty","HasFromToArray","EntireArray","GetterByBindingType","SetterByBindingTypeAndVersioning","unbind","_getValue_unbound","_setValue_unbound","dest","Composite","targetGroup","optionalParsedPath","_targetGroup","firstValidIndex","re","matches","results","searchSkeleton","bone","searchNodeSubtree","childNode","subTreeNode","mixFunction","bufferType","_slerp","_select","_lerp","_mixBufferRegion","cumulativeWeight","currentWeight","mix","originalValueOffset","Audio","context","createBufferSource","onended","onEnded","gain","createGain","connect","getInput","autoplay","playbackRate","isPlaying","hasPlaybackControl","sourceType","filter","getOutput","setNodeSource","audioNode","setBuffer","audioBuffer","currentTime","disconnect","getFilter","setFilter","setPlaybackRate","getPlaybackRate","getLoop","setVolume","getVolume","AudioAnalyser","audio","fftSize","analyser","createAnalyser","frequencyBinCount","getData","getByteFrequencyData","AudioContext","webkitAudioContext","PositionalAudio","panner","createPanner","setRefDistance","refDistance","getRefDistance","setRolloffFactor","rolloffFactor","getRolloffFactor","setDistanceModel","distanceModel","getDistanceModel","setMaxDistance","maxDistance","getMaxDistance","AudioListener","destination","removeFilter","setMasterVolume","getMasterVolume","orientation","setOrientation","Camera","matrixWorldInverse","CubeCamera","cubeResolution","cameraPX","cameraNX","cameraPY","cameraNY","cameraPZ","cameraNZ","options","format","magFilter","minFilter","WebGLRenderTargetCube","updateCubeMap","generateMipmaps","texture","activeCubeFace","setRenderTarget","zoom","cx","cy","focus","view","filmGauge","filmOffset","setLens","focalLength","setFocalLength","vExtentSlope","getFilmHeight","atan","getFocalLength","getEffectiveFOV","getFilmWidth","setViewOffset","fullWidth","fullHeight","offsetX","offsetY","skew","StereoCamera","cameraL","cameraR","eyeRight","eyeLeft","eyeSep","eyeSepOnProjection","Light","groundColor","decay","penumbra","LightShadow","bias","mapSize","AmbientLight","DirectionalLight","shadow","DirectionalLightShadow","light","HemisphereLight","skyColor","PointLight","power","SpotLight","SpotLightShadow","AudioLoader","manager","DefaultLoadingManager","url","onLoad","onProgress","onError","loader","XHRLoader","setResponseType","decodeAudioData","Cache","files","file","clear","Loader","onLoadStart","onLoadProgress","onLoadComplete","crossOrigin","extractUrlBase","initMaterials","texturePath","createMaterial","textureLoader","materialLoader","loadTexture","repeat","wrap","anisotropy","fullPath","Handlers","setCrossOrigin","wrapS","wrapT","MaterialLoader","blending","specular","shininess","mapDiffuseRepeat","mapDiffuseOffset","mapDiffuseWrap","mapDiffuseAnisotropy","lightMap","mapLightRepeat","mapLightOffset","mapLightWrap","mapLightAnisotropy","aoMap","mapAORepeat","mapAOOffset","mapAOWrap","mapAOAnisotropy","bumpMap","mapBumpRepeat","mapBumpOffset","mapBumpWrap","mapBumpAnisotropy","bumpScale","normalMap","mapNormalRepeat","mapNormalOffset","mapNormalWrap","mapNormalAnisotropy","normalScale","specularMap","mapSpecularRepeat","mapSpecularOffset","mapSpecularWrap","mapSpecularAnisotropy","alphaMap","mapAlphaRepeat","mapAlphaOffset","mapAlphaWrap","mapAlphaAnisotropy","transparent","setTextures","handlers","regex","cached","setTimeout","request","XMLHttpRequest","overrideMimeType","response","status","itemEnd","itemError","responseType","withCredentials","send","itemStart","setPath","setWithCredentials","FontLoader","text","Font","substring","ImageLoader","image","JSONLoader","statusDomElement","_statusDomElement","setTexturePath","parseModel","isBitSet","fi","zLength","colorIndex","normalIndex","uvIndex","isQuad","faceA","faceB","uvLayer","nUvLayers","parseSkin","influencesPerVertex","parseMorphing","dstVertices","srcVertices","morphColors","parseAnimations","outputAnimations","animations","morphAnimationClips","LoadingManager","isLoading","itemsLoaded","itemsTotal","onStart","BufferGeometryLoader","TYPED_ARRAYS","typedArray","drawcalls","offsets","getTexture","roughness","metalness","vertexShader","fragmentShader","shading","alphaTest","depthTest","depthWrite","colorWrite","wireframe","wireframeLinewidth","sizeAttenuation","displacementMap","displacementScale","displacementBias","roughnessMap","metalnessMap","emissiveMap","emissiveIntensity","envMap","combine","reflectivity","lightMapIntensity","aoMapIntensity","ObjectLoader","lastIndexOf","parseGeometries","parseImages","parseTextures","parseMaterials","parseObject","geometryLoader","bufferGeometryLoader","widthSegments","heightSegments","depth","depthSegments","segments","thetaStart","thetaLength","radiusTop","radiusBottom","radialSegments","openEnded","phiStart","phiLength","DodecahedronGeometry","detail","IcosahedronGeometry","OctahedronGeometry","TetrahedronGeometry","innerRadius","outerRadius","thetaSegments","phiSegments","tube","tubularSegments","arc","loadImage","parseConstant","Texture","mapping","getGeometry","getMaterial","SkinnedMesh","Group","levels","level","addLevel","CubeTextureLoader","urls","CubeTexture","DataTextureLoader","BinaryTextureLoader","_parser","DataTexture","texData","mipmaps","mipmapCount","CompressedTextureLoader","texDatas","CompressedTexture","isCubemap","Material","MaterialIdCount","blendSrc","blendDst","blendEquation","blendSrcAlpha","blendDstAlpha","blendEquationAlpha","depthFunc","clippingPlanes","clipShadows","polygonOffset","polygonOffsetFactor","polygonOffsetUnits","premultipliedAlpha","overdraw","_needsUpdate","setValues","newValue","currentValue","isRoot","srcPlanes","dstPlanes","LineBasicMaterial","linewidth","linecap","linejoin","fog","LineDashedMaterial","dashSize","gapSize","refractionRatio","wireframeLinecap","wireframeLinejoin","skinning","MeshDepthMaterial","depthPacking","MeshLambertMaterial","MeshNormalMaterial","MeshPhongMaterial","MeshStandardMaterial","defines","STANDARD","envMapIntensity","MeshPhysicalMaterial","PHYSICAL","MultiMaterial","PointsMaterial","ShaderMaterial","lights","clipping","extensions","derivatives","fragDepth","drawBuffers","shaderTextureLOD","defaultAttributeValues","index0AttributeName","UniformsUtils","RawShaderMaterial","SpriteMaterial","encoding","TextureIdCount","sourceFile","DEFAULT_IMAGE","DEFAULT_MAPPING","premultiplyAlpha","flipY","unpackAlignment","getDataURL","toDataURL","getContext","drawImage","transformUv","DepthTexture","CanvasTexture","VideoTexture","video","readyState","HAVE_CURRENT_DATA","inverseMatrix","testPoint","rayPointDistanceSq","localThresholdSq","intersectPoint","distanceToRay","localThreshold","LineSegments","precisionSq","vStart","vEnd","interSegment","interRay","distSq","faceIndex","nbVertices","LineStrip","LinePieces","drawMode","updateMorphTargets","setDrawMode","morphTargetBase","morphTargetInfluences","morphTargetDictionary","ml","getMorphTargetIndexByName","uvIntersection","uv1","uv3","barycoord","checkIntersection","intersectionPointWorld","checkBufferGeometryIntersection","intersection","intersectionPoint","uvA","uvB","uvC","tempA","tempB","tempC","fvA","fvB","fvC","isFaceMaterial","faceMaterial","morphInfluences","tl","influence","targets","uvs_f","Bone","skin","Skeleton","boneInverses","useVertexTexture","identityMatrix","boneTextureWidth","boneTextureHeight","boneMatrices","boneTexture","calculateInverses","bl","pose","offsetMatrix","bindMode","bindMatrix","bindMatrixInverse","gbone","rotq","scl","normalizeSkinWeights","sw","vec","skinWeight","getObjectForDistance","matrixPosition","guessSizeSq","Particle","LensFlare","lensFlares","positionScreen","customUpdateCallback","updateLensFlares","flare","vecX","vecY","wantedRotation","overrideMaterial","autoUpdate","Fog","FogExp2","density","ShaderChunk","merged","uniforms_src","uniforms_dst","parameter_src","UniformsLib","common","diffuse","offsetRepeat","flipEnvMap","aomap","lightmap","emissivemap","bumpmap","normalmap","displacementmap","roughnessmap","metalnessmap","fogDensity","fogNear","fogFar","fogColor","ambientLightColor","directionalLights","properties","shadowBias","shadowRadius","shadowMapSize","directionalShadowMap","directionalShadowMatrix","spotLights","coneCos","penumbraCos","spotShadowMap","spotShadowMatrix","pointLights","pointShadowMap","pointShadowMatrix","hemisphereLights","ShaderLib","basic","lambert","phong","standard","dashed","totalSize","tCube","tFlip","equirect","tEquirect","distanceRGBA","lightPos","getTargetPixelRatio","_currentRenderTarget","_pixelRatio","glClearColor","_premultipliedAlpha","state","clearColor","setDefaultGLState","init","scissor","_currentScissor","_scissor","viewport","_currentViewport","_viewport","_clearColor","_clearAlpha","resetGLState","_currentProgram","_currentCamera","_currentGeometryProgram","_currentMaterialId","onContextLost","preventDefault","onTextureDispose","deallocateTexture","_infoMemory","onRenderTargetDispose","deallocateRenderTarget","onMaterialDispose","deallocateMaterial","textureProperties","__image__webglTextureCube","_gl","deleteTexture","__webglInit","__webglTexture","renderTargetProperties","depthTexture","deleteFramebuffer","__webglFramebuffer","__webglDepthbuffer","deleteRenderbuffer","releaseMaterialProgramReference","programInfo","program","programCache","releaseProgram","setupVertexAttributes","startIndex","extension","initAttributes","geometryAttributes","programAttributes","getAttributes","materialDefaultAttributeValues","programAttribute","geometryAttribute","FLOAT","UNSIGNED_SHORT","SHORT","UNSIGNED_INT","INT","BYTE","UNSIGNED_BYTE","getAttributeBuffer","enableAttributeAndDivisor","enableAttribute","bindBuffer","ARRAY_BUFFER","vertexAttribPointer","vertexAttrib2fv","vertexAttrib3fv","vertexAttrib4fv","vertexAttrib1fv","disableUnusedAttributes","absNumericalSort","painterSortStable","reversePainterSortStable","pushRenderItem","transparentObjects","transparentObjectsLastIndex","opaqueObjects","opaqueObjectsLastIndex","renderItem","_vector3","isObjectViewable","_sphere","_frustum","_numClippingPlanes","negRad","projectObject","sprites","ImmediateRenderObject","sortObjects","_projScreenMatrix","groupMaterial","renderObjects","renderList","setMaterial","setProgram","renderBufferImmediate","renderBufferDirect","initMaterial","materialProperties","getParameters","_lights","code","getProgramCode","programChange","shaderID","shader","__webglShader","acquireProgram","numSupportedMorphTargets","maxMorphTargets","numSupportedMorphNormals","maxMorphNormals","numClippingPlanes","_clippingPlanesUniform","lightsHash","ambient","directional","spot","hemi","progUniforms","getUniforms","uniformsList","WebGLUniforms","seqWithValue","seq","dynamicUniforms","splitDynamic","setMaterialFaces","setBlending","setDepthFunc","setDepthTest","setDepthWrite","setColorWrite","setPolygonOffset","CULL_FACE","setFlipSided","_usedTextureUnits","_clippingEnabled","_localClippingEnabled","useCache","setClippingState","refreshProgram","refreshMaterial","refreshLights","p_uniforms","m_uniforms","useProgram","capabilities","logarithmicDepthBuffer","uCamPos","cameraPosition","setOptional","floatVertexTextures","markUniformsLightsNeedsUpdate","refreshUniformsFog","refreshUniformsCommon","refreshUniformsLine","refreshUniformsDash","refreshUniformsPoints","refreshUniformsLambert","refreshUniformsPhong","refreshUniformsPhysical","refreshUniformsStandard","upload","dynUniforms","evalDynamic","uvScaleMap","WebGLRenderTarget","_canvas","clientHeight","setupShadows","lightShadowsLength","shadows","setupLights","ll","viewMatrix","directionalLength","pointLength","spotLength","hemiLength","lightCache","setupGlobalClippingPlanes","localClippingEnabled","_numGlobalClippingPlanes","_globalClippingState","setupClippingPlanes","skipTransform","nPlanes","dstArray","flatSize","viewNormalMatrix","_matrix3","i4","_plane","resetGlobalClippingState","fromCache","_clipRenderingShadows","nGlobal","lGlobal","clippingState","allocTextureUnit","textureUnit","maxTextures","setTextureParameters","textureType","isPowerOfTwoImage","texParameteri","TEXTURE_WRAP_S","paramThreeToGL","TEXTURE_WRAP_T","TEXTURE_MAG_FILTER","TEXTURE_MIN_FILTER","CLAMP_TO_EDGE","filterFallback","__currentAnisotropy","texParameterf","TEXTURE_MAX_ANISOTROPY_EXT","getMaxAnisotropy","uploadTexture","slot","createTexture","activeTexture","TEXTURE0","bindTexture","TEXTURE_2D","pixelStorei","UNPACK_FLIP_Y_WEBGL","UNPACK_PREMULTIPLY_ALPHA_WEBGL","UNPACK_ALIGNMENT","clampToMaxSize","maxTextureSize","textureNeedsPowerOfTwo","makePowerOfTwo","glFormat","glType","mipmap","internalFormat","DEPTH_COMPONENT","_isWebGL2","DEPTH_COMPONENT32F","DEPTH_COMPONENT16","texImage2D","getCompressedTextureFormats","compressedTexImage2D","generateMipmap","__version","setTexture2D","complete","maxSize","HTMLImageElement","HTMLCanvasElement","setCubeTexture","TEXTURE_CUBE_MAP","isCompressed","isDataTexture","cubeImage","autoScaleCubemaps","maxCubemapSize","TEXTURE_CUBE_MAP_POSITIVE_X","setCubeTextureDynamic","setupFrameBufferTexture","framebuffer","attachment","textureTarget","bindFramebuffer","FRAMEBUFFER","framebufferTexture2D","setupRenderBufferStorage","renderbuffer","bindRenderbuffer","RENDERBUFFER","depthBuffer","stencilBuffer","renderbufferStorage","framebufferRenderbuffer","DEPTH_ATTACHMENT","DEPTH_STENCIL","DEPTH_STENCIL_ATTACHMENT","RGBA4","setupDepthTexture","isCube","setTexture","webglDepthTexture","setupDepthRenderbuffer","createRenderbuffer","setupRenderTarget","isTargetPowerOfTwo","createFramebuffer","COLOR_ATTACHMENT0","updateRenderTargetMipmap","NEAREST","LINEAR","REPEAT","MIRRORED_REPEAT","NEAREST_MIPMAP_NEAREST","NEAREST_MIPMAP_LINEAR","LINEAR_MIPMAP_NEAREST","LINEAR_MIPMAP_LINEAR","UNSIGNED_SHORT_4_4_4_4","UNSIGNED_SHORT_5_5_5_1","UNSIGNED_SHORT_5_6_5","HALF_FLOAT_OES","ALPHA","RGB","RGBA","LUMINANCE","LUMINANCE_ALPHA","FUNC_ADD","FUNC_SUBTRACT","FUNC_REVERSE_SUBTRACT","ZERO","ONE","SRC_COLOR","ONE_MINUS_SRC_COLOR","SRC_ALPHA","ONE_MINUS_SRC_ALPHA","DST_ALPHA","ONE_MINUS_DST_ALPHA","DST_COLOR","ONE_MINUS_DST_COLOR","SRC_ALPHA_SATURATE","COMPRESSED_RGB_S3TC_DXT1_EXT","COMPRESSED_RGBA_S3TC_DXT1_EXT","COMPRESSED_RGBA_S3TC_DXT3_EXT","COMPRESSED_RGBA_S3TC_DXT5_EXT","COMPRESSED_RGB_PVRTC_4BPPV1_IMG","COMPRESSED_RGB_PVRTC_2BPPV1_IMG","COMPRESSED_RGBA_PVRTC_4BPPV1_IMG","COMPRESSED_RGBA_PVRTC_2BPPV1_IMG","COMPRESSED_RGB_ETC1_WEBGL","MIN_EXT","MAX_EXT","_context","_alpha","_depth","_stencil","stencil","_antialias","_preserveDrawingBuffer","preserveDrawingBuffer","autoClear","autoClearColor","autoClearDepth","autoClearStencil","gammaInput","gammaOutput","physicallyCorrectLights","toneMapping","toneMappingExposure","toneMappingWhitePoint","_currentFramebuffer","_currentScissorTest","_width","_height","_scissorTest","_infoRender","calls","info","memory","programs","getShaderPrecisionFormat","rangeMin","rangeMax","WebGL2RenderingContext","WebGLExtensions","WebGLCapabilities","WebGLState","WebGLProperties","WebGLObjects","WebGLPrograms","WebGLLights","bufferRenderer","WebGLBufferRenderer","indexedBufferRenderer","WebGLIndexedBufferRenderer","shadowMap","WebGLShadowMap","spritePlugin","SpritePlugin","lensFlarePlugin","LensFlarePlugin","getContextAttributes","forceContextLoss","loseContext","MAX_TEXTURE_MAX_ANISOTROPY_EXT","getPrecision","getPixelRatio","setPixelRatio","getSize","updateStyle","setViewport","setScissor","setScissorTest","boolean","getClearColor","setClearColor","getClearAlpha","setClearAlpha","bits","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","STENCIL_BUFFER_BIT","clearDepth","clearStencil","clearTarget","buffers","hasPositions","createBuffer","hasNormals","hasUvs","hasColors","bufferData","positionArray","DYNAMIC_DRAW","normalArray","nx","ny","nz","uvArray","colorArray","drawArrays","TRIANGLES","updateBuffers","geometryProgram","activeInfluences","getWireframeAttribute","ELEMENT_ARRAY_BUFFER","dataStart","dataCount","rangeStart","rangeCount","groupStart","groupCount","drawStart","drawEnd","drawCount","setLineWidth","setMode","LINES","TRIANGLE_STRIP","TRIANGLE_FAN","lineWidth","LINE_STRIP","POINTS","renderInstances","forceClear","setFaceCulling","cullFace","frontFaceDirection","frontFace","CW","CCW","BACK","FRONT","FRONT_AND_BACK","setTextureWarned","setTextureCube","getCurrentRenderTarget","scissorTest","activeMipMapLevel","readRenderTargetPixels","restore","IMPLEMENTATION_COLOR_READ_FORMAT","IMPLEMENTATION_COLOR_READ_TYPE","checkFramebufferStatus","FRAMEBUFFER_COMPLETE","readPixels","drawArraysInstancedANGLE","drawElements","drawElementsInstancedANGLE","gl","getExtension","getMaxPrecision","VERTEX_SHADER","HIGH_FLOAT","FRAGMENT_SHADER","MEDIUM_FLOAT","MAX_TEXTURE_IMAGE_UNITS","maxVertexTextures","MAX_VERTEX_TEXTURE_IMAGE_UNITS","MAX_TEXTURE_SIZE","MAX_CUBE_MAP_TEXTURE_SIZE","maxAttributes","MAX_VERTEX_ATTRIBS","maxVertexUniforms","MAX_VERTEX_UNIFORM_VECTORS","maxVaryings","MAX_VARYING_VECTORS","maxFragmentUniforms","MAX_FRAGMENT_UNIFORM_VECTORS","vertexTextures","floatFragmentTextures","_maxPrecision","WebGLGeometries","onGeometryDispose","buffergeometry","_bufferGeometry","deleteAttribute","deleteAttributes","property","bufferproperty","__webglBuffer","deleteBuffer","removeAttributeBuffer","updateAttribute","attributeProperties","updateBuffer","usage","STATIC_DRAW","bufferSubData","edges","checkEdge","list","WebGLProgram","getEncodingComponents","getTexelDecodingFunction","functionName","getTexelEncodingFunction","getToneMappingFunction","toneMappingName","generateExtensions","rendererExtensions","envMapCubeUV","flatShading","filterEmptyLine","generateDefines","fetchAttributeLocations","identifiers","getProgramParameter","ACTIVE_ATTRIBUTES","getActiveAttrib","getAttribLocation","replaceLightNums","replace","numDirLights","numSpotLights","numPointLights","numHemiLights","parseIncludes","include","unrollLoops","snippet","unroll","programIdCount","shadowMapTypeDefine","shadowMapType","envMapTypeDefine","envMapModeDefine","envMapBlendingDefine","prefixVertex","prefixFragment","gammaFactorDefine","customExtensions","customDefines","createProgram","supportsVertexTextures","maxBones","doubleSided","flipSided","shadowMapEnabled","useFog","fogExp","outputEncoding","mapEncoding","envMapEncoding","emissiveMapEncoding","vertexGlsl","fragmentGlsl","glVertexShader","WebGLShader","glFragmentShader","attachShader","bindAttribLocation","linkProgram","programLog","getProgramInfoLog","vertexLog","getShaderInfoLog","fragmentLog","runnable","haveDiagnostics","LINK_STATUS","getError","VALIDATE_STATUS","diagnostics","prefix","deleteShader","cachedUniforms","cachedAttributes","destroy","deleteProgram","usedTimes","allocateBones","nVertexUniforms","nVertexMatrices","getTextureEncodingFromMap","gammaOverrideLinear","shaderIDs","parameterNames","nClipPlanes","envMapMode","pl","addLineNumbers","lines","createShader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","_renderer","getDepthMaterial","isPointLight","lightPositionWorld","materialVariants","_depthMaterials","customMaterial","customDepthMaterial","_distanceMaterials","customDistanceMaterial","useMorphing","useSkinning","variantIndex","_MorphingFlag","_SkinningFlag","keyA","keyB","materialsForVariant","_materialCache","cachedMaterial","shadowCamera","_renderList","_state","_lightShadows","_shadowMapSize","_lookTarget","_lightPositionWorld","_NumberOfMaterialVariants","cubeDirections","cubeUps","cube2DViewPorts","depthMaterialTemplate","distanceShader","distanceUniforms","depthMaterial","distanceMaterial","USE_SHADOWMAP","BLEND","faceCount","vpWidth","vpHeight","pars","shadowMatrix","vpDimensions","clearAlpha","maxVertexAttributes","newAttributes","enabledAttributes","attributeDivisors","compressedTextureFormats","currentBlending","currentBlendEquation","currentBlendSrc","currentBlendDst","currentBlendEquationAlpha","currentBlendSrcAlpha","currentBlendDstAlpha","currentPremultipledAlpha","currentDepthFunc","currentDepthWrite","currentColorWrite","currentStencilWrite","currentStencilFunc","currentStencilRef","currentStencilMask","currentStencilFail","currentStencilZFail","currentStencilZPass","currentFlipSided","currentLineWidth","currentPolygonOffsetFactor","currentPolygonOffsetUnits","currentScissorTest","currentTextureSlot","currentBoundTextures","currentClearColor","currentClearDepth","currentClearStencil","currentScissor","currentViewport","DEPTH_TEST","LEQUAL","blendFunc","enableVertexAttribArray","vertexAttribDivisorANGLE","disableVertexAttribArray","formats","COMPRESSED_TEXTURE_FORMATS","blendEquationSeparate","blendFuncSeparate","NEVER","ALWAYS","LESS","EQUAL","GEQUAL","GREATER","NOTEQUAL","depthMask","colorMask","setStencilFunc","stencilFunc","stencilRef","stencilMask","setStencilOp","stencilFail","stencilZFail","stencilZPass","stencilOp","setStencilTest","stencilTest","STENCIL_TEST","setStencilWrite","stencilWrite","factor","units","POLYGON_OFFSET_FILL","getScissorTest","SCISSOR_TEST","webglSlot","webglType","webglTexture","boundTexture","UniformContainer","arrayCacheF32","arrayCacheI32","flatten","nBlocks","blockSize","firstElem","allocTexUnits","setValue1f","uniform1f","addr","setValue1i","uniform1i","setValue2fv","uniform2fv","uniform2f","setValue3fv","uniform3f","uniform3fv","setValue4fv","uniform4fv","uniform4f","setValue2fm","uniformMatrix2fv","setValue3fm","uniformMatrix3fv","setValue4fm","uniformMatrix4fv","setValueT1","unit","setValueT6","setValue2iv","uniform2iv","setValue3iv","uniform3iv","setValue4iv","uniform4iv","getSingularSetter","setValue1fv","uniform1fv","setValue1iv","uniform1iv","setValueV2a","setValueV3a","setValueV4a","setValueM2a","setValueM3a","setValueM4a","setValueT1a","tex","setValueT6a","getPureArraySetter","SingleUniform","activeInfo","PureArrayUniform","StructuredUniform","RePathPart","addUniform","container","uniformObject","parseUniform","pathLength","matchEnd","idIsIndex","subscript","ACTIVE_UNIFORMS","getActiveUniform","getUniformLocation","flares","vertexBuffer","elementBuffer","tempTexture","occlusionTexture","renderType","occlusionMap","screenPosition","tempPosition","invAspect","halfViewportWidth","halfViewportHeight","screenPositionPixels","validArea","TEXTURE1","copyTexImage2D","sprite","uvOffset","uvScale","fogType","fillStyle","fillRect","spritePosition","spriteRotation","spriteScale","oldFogType","sceneFogType","isIntersectionBox","isIntersectionSphere","multiplyVector3","multiplyVector3Array","extractPosition","multiplyVector4","rotateAxis","crossVector","rotateByAxis","isIntersectionLine","isIntersectionPlane","setEulerFromRotationMatrix","setEulerFromQuaternion","getPositionFromMatrix","getScaleFromMatrix","getColumnFromMatrix","Face4","Vertex","eulerOrder","getChildByName","renderDepth","useQuaternion","ParticleSystem","onlyShadow","shadowCameraFov","shadowCameraLeft","shadowCameraRight","shadowCameraTop","shadowCameraBottom","shadowCameraNear","shadowCameraFar","shadowCameraVisible","shadowDarkness","shadowMapWidth","shadowMapHeight","addIndex","addDrawCall","indexOffset","clearDrawCalls","computeOffsets","wrapAround","wrapRGB","PointCloudMaterial","ParticleBasicMaterial","ParticleSystemMaterial","metal","supportsFloatTextures","supportsHalfFloatTextures","supportsStandardDerivatives","supportsCompressedTextureS3TC","supportsCompressedTexturePVRTC","supportsBlendMinMax","supportsInstancedArrays","enableScissorTest","addPrePlugin","addPostPlugin","updateShadowMap","shadowMapCullFace","audioLoader","GeometryUtils","geometry1","ImageUtils","loadTextureCube","loadCompressedTexture","loadCompressedTextureCube","Projector","projectVector","unprojectVector","pickingRay","CanvasRenderer","MeshFaceMaterial","CurveUtils","tangentQuadraticBezier","tangentCubicBezier","tangentSpline","h00","h10","h01","h11","SceneUtils","createMultiMaterialObject","detach","attach","ShapeUtils","contour","triangulate","snip","verts","py","aX","aY","bX","bY","cX","cY","apx","apy","bpx","bpy","cpx","cpy","cCROSSap","bCROSScp","aCROSSbp","vertIndices","nv","triangulateShape","holes","point_in_segment_2D_colin","inSegPt1","inSegPt2","inOtherPt","intersect_segments_2D","inSeg1Pt1","inSeg1Pt2","inSeg2Pt1","inSeg2Pt2","inExcludeAdjacentSegs","seg1dx","seg1dy","seg2dx","seg2dy","seg1seg2dx","seg1seg2dy","limit","perpSeg1","perpSeg2","factorSeg1","seg1Pt","seg2Pt","seg1min","seg1max","seg1minVal","seg1maxVal","seg2min","seg2max","seg2minVal","seg2maxVal","isPointInsideAngle","inVertex","inLegFromPt","inLegToPt","legFromPtX","legFromPtY","legToPtX","legToPtY","otherPtX","otherPtY","from2toAngle","from2otherAngle","other2toAngle","removeHoles","isCutLineInsideAngles","inShapeIdx","inHoleIdx","lastShapeIdx","shape","prevShapeIdx","nextShapeIdx","insideAngle","hole","lastHoleIdx","prevHoleIdx","nextHoleIdx","intersectsShapeEdge","inShapePt","inHolePt","sIdx","nextIdx","intersectsHoleEdge","ihIdx","chkHole","hIdx","indepHoles","holeIndex","shapeIndex","shapePt","holePt","holeIdx","cutKey","tmpShape1","tmpShape2","tmpHole1","tmpHole2","failedCuts","hl","minShapeIndex","counter","h2","allPointsMap","allpoints","shapeWithoutHoles","triangles","isClockWise","pts","b2p0","b2p1","b2p2","b3","b3p0","b3p1","b3p2","b3p3","Curve","getPointAt","getUtoTmapping","getPoints","divisions","getSpacedPoints","lengths","getLengths","cacheArcLengths","current","sum","updateArcLengths","targetArcLength","arcLengths","comparison","lengthBefore","lengthAfter","segmentLength","segmentFraction","getTangent","pt1","pt2","getTangentAt","getPointFunc","CurvePath","curves","autoClose","curve","closePath","startPoint","endPoint","LineCurve","curveLengths","getCurveLengths","lens","cacheLengths","sums","createPointsGeometry","createGeometry","createSpacedPointsGeometry","generateShapes","createPaths","ret","createPath","glyph","glyphs","cpx0","cpy0","cpx1","cpy1","cpx2","cpy2","laste","Path","o","outline","_cachedOutline","moveTo","lineTo","quadraticCurveTo","bezierCurveTo","ha","shapes","toShapes","fromPoints","args","lastargs","aCPx","aCPy","QuadraticBezierCurve","aCP1x","aCP1y","aCP2x","aCP2y","CubicBezierCurve","splineThru","npts","SplineCurve","aRadius","aStartAngle","aEndAngle","aClockwise","absarc","absellipse","ellipse","xRadius","yRadius","aRotation","EllipseCurve","lastPoint","item","spts","spline","deltaAngle","tdivisions","isCCW","noHoles","extractSubpaths","inActions","subPaths","lastPath","toShapesNoHoles","inSubpaths","tmpPath","tmpShape","Shape","isPointInsidePolygon","inPt","inPolygon","polyLen","inside","edgeLowPt","edgeHighPt","edgeDx","edgeDy","perpEdge","solid","holesFirst","tmpPoints","betterShapeHoles","newShapes","newShapeHoles","mainIdx","ambiguous","toChange","sLen","sho","ho","hole_unassigned","s2Idx","froms","tos","tmpHoles","extrude","ExtrudeGeometry","makeGeometry","ShapeGeometry","getPointsHoles","holesPts","extractAllPoints","extractPoints","tangent","point0","point1","point2","point3","ArcCurve","LineCurve3","QuadraticBezierCurve3","CubicBezierCurve3","SplineCurve3","CatmullRomCurve3","CubicPoly","pz","c0","initNonuniformCatmullRom","x3","dt0","dt1","dt2","initCatmullRom","tension","calc","closed","ClosedSplineCurve3","BoxGeometry","CubeGeometry","calculateVertexCount","buildPlane","udir","vdir","gridX","gridY","segmentWidth","segmentHeight","widthHalf","heightHalf","depthHalf","gridX1","gridY1","vertexCounter","vertexBufferOffset","uvBufferOffset","numberOfVertices","indexBufferOffset","vertexCount","indexCount","CircleGeometry","CircleBufferGeometry","ii","segment","CylinderBufferGeometry","calculateIndexCount","generateTorso","tanTheta","indexRow","halfHeight","indexArray","i3","generateCap","centerIndexStart","centerIndexEnd","CylinderGeometry","EdgesGeometry","thresholdAngle","sortFunction","thresholdDot","edge","vert1","vert2","face1","face2","addShapeList","addShape","scalePt2","pt","getBevelVec","inPrev","inNext","v_trans_x","v_trans_y","shrink_by","v_prev_x","v_prev_y","v_next_x","v_next_y","v_prev_lensq","collinear0","v_prev_len","v_next_len","ptPrevShift_x","ptPrevShift_y","ptNextShift_x","ptNextShift_y","sf","v_trans_lensq","direction_eq","buildLidFaces","bevelEnabled","layer","vlen","flen","f3","steps","bevelSegments","buildSideFaces","layeroffset","sidewalls","ahole","slen1","slen2","f4","shapesOffset","uvgen","generateTopUV","wallContour","stepIndex","stepsLength","contourIndex1","contourIndex2","generateSideWallUV","extrudePts","splineTube","binormal","position2","amount","bevelThickness","bevelSize","curveSegments","extrudePath","extrudeByPath","UVGenerator","WorldUVGenerator","frames","TubeGeometry","FrenetFrames","shapePoints","reverse","bs","vert","contourMovements","oneHoleMovements","holesMovements","verticesMovements","binormals","indexA","indexB","indexC","indexD","LatheBufferGeometry","base","inverseSegments","n1","n2","LatheGeometry","PlaneGeometry","PlaneBufferGeometry","width_half","height_half","segment_width","segment_height","offset2","RingBufferGeometry","radiusStep","thetaSegmentLevel","RingGeometry","SphereGeometry","SphereBufferGeometry","thetaEnd","verticesRow","v4","TextGeometry","font","TorusBufferGeometry","TorusGeometry","TorusKnotBufferGeometry","calculatePositionOnCurve","cu","su","quOverP","cs","P1","P2","N","TorusKnotGeometry","heightScale","taper","NoTaper","ip","jp","uva","uvb","uvc","uvd","grid","numpoints","pos2","tangents","SinusoidalTaper","initialNormal3","smallest","MAX_VALUE","tz","mat","PolyhedronGeometry","prepare","azimuth","inclination","make","centroid","azi","correctUV","subdivide","cols","aj","bj","rows","ParametricGeometry","func","slices","stacks","sliceCount","WireframeGeometry","numEdges","ol","numTris","AxisHelper","ArrowHelper","lineGeometry","coneGeometry","headLength","headWidth","cone","setDirection","setColor","BoxHelper","BoundingBoxHelper","CameraHelper","addLine","addPoint","pointMap","hexFrustum","hexCone","hexUp","hexTarget","hexCross","setPoint","DirectionalLightHelper","lightPlane","targetLine","EdgesHelper","FaceNormalsHelper","nNormals","objGeometry","GridHelper","setColors","colorCenterLine","colorGrid","HemisphereLightHelper","sphereSize","lightSphere","PointLightHelper","SkeletonHelper","getBoneList","boneList","matrixWorldInv","boneMatrix","SpotLightHelper","vector2","coneLength","coneWidth","VertexNormalsHelper","objPos","objNorm","WireframeHelper","renderCallback","MorphBlendMesh","animationsMap","animationsList","numFrames","startFrame","endFrame","createAnimation","setAnimationWeight","lastFrame","currentFrame","active","directionBackwards","mirroredLoop","autoCreateAnimations","firstAnimation","frameRanges","morph","setAnimationDirectionForward","setAnimationDirectionBackward","setAnimationFPS","setAnimationDuration","setAnimationTime","getAnimationTime","getAnimationDuration","playAnimation","stopAnimation","keyframe","_getPrototypeOf","_getPrototypeOf2","_possibleConstructorReturn2","_possibleConstructorReturn3","_inherits2","_inherits3","_refractionF","_refractionF2","bump","_THREE$Mesh","geo","tex_bump","tex_scene","$getPrototypeOf","fails","KEY","exp","_typeof2","_typeof3","ReferenceError","_symbol","_symbol2","_typeof","DESCRIPTORS","META","$fails","wks","wksExt","wksDefine","keyOf","enumKeys","_create","gOPNExt","$GOPD","$DP","gOPD","gOPN","$Symbol","$JSON","_stringify","HIDDEN","TO_PRIMITIVE","isEnum","SymbolRegistry","AllSymbols","OPSymbols","USE_NATIVE","QObject","setter","findChild","setSymbolDesc","D","protoDesc","sym","isSymbol","iterator","$defineProperty","$defineProperties","$create","$propertyIsEnumerable","E","$getOwnPropertyDescriptor","$getOwnPropertyNames","$getOwnPropertySymbols","IS_OP","$set","symbols","for","keyFor","useSetter","useSimple","getOwnPropertyNames","getOwnPropertySymbols","replacer","$replacer","setDesc","isExtensible","FREEZE","preventExtensions","setMeta","fastKey","getWeak","onFreeze","NEED","gOPS","pIE","getSymbols","arg","windowNames","getWindowNames","hiddenKeys","_setPrototypeOf","_setPrototypeOf2","_create2","subClass","superClass","__proto__","setPrototypeOf","check","buggy","Stats","cssText","Panel","addPanel","usedJSHeapSize","jsHeapSizeLimit","devicePixelRatio","textBaseline","fillText","globalAlpha","getAutoRotationAngle","autoRotateSpeed","getZoomScale","zoomSpeed","rotateLeft","sphericalDelta","rotateUp","dollyIn","dollyScale","minZoom","maxZoom","zoomChanged","enableZoom","dollyOut","handleMouseDownRotate","rotateStart","clientX","clientY","handleMouseDownDolly","dollyStart","handleMouseDownPan","panStart","handleMouseMoveRotate","rotateEnd","rotateDelta","element","clientWidth","rotateSpeed","handleMouseMoveDolly","dollyEnd","dollyDelta","handleMouseMovePan","panEnd","panDelta","pan","handleMouseUp","handleMouseWheel","wheelDelta","handleKeyDown","keyCode","UP","keyPanSpeed","BOTTOM","handleTouchStartRotate","touches","pageX","pageY","handleTouchStartDolly","handleTouchStartPan","handleTouchMoveRotate","handleTouchMoveDolly","handleTouchMovePan","handleTouchEnd","onMouseDown","button","mouseButtons","ORBIT","enableRotate","STATE","ROTATE","ZOOM","DOLLY","PAN","enablePan","NONE","onMouseMove","onMouseUp","startEvent","endEvent","onMouseWheel","stopPropagation","onKeyDown","enableKeys","onTouchStart","TOUCH_ROTATE","TOUCH_DOLLY","TOUCH_PAN","onTouchMove","onTouchEnd","onContextMenu","minPolarAngle","maxPolarAngle","minAzimuthAngle","maxAzimuthAngle","enableDamping","dampingFactor","autoRotate","target0","position0","zoom0","getPolarAngle","getAzimuthalAngle","changeEvent","quat","quatInverse","lastPosition","lastQuaternion","spherical","panOffset","panLeft","objectMatrix","panUp","deltaX","deltaY","targetDistance","noZoom","noRotate","noPan","noKeys","staticMoving","constraint","dynamicDampingFactor","utils","controllers","css","rel","href","getElementsByTagName","inject","innerHTML","forEach","BREAK","extend","each","isUndefined","defaults","defer","isNull","isNumber","isString","isBoolean","isFunction","Controller","initialValue","__onFinishChange","__onChange","onFinishChange","updateDisplay","isModified","HTMLEvents","MouseEvents","KeyboardEvents","makeSelectable","onselectstart","MozUserSelect","KhtmlUserSelect","unselectable","makeFullscreen","fakeEvent","createEvent","initMouseEvent","bubbles","cancelable","clickCount","initKeyboardEvent","initKeyEvent","ctrlKey","altKey","shiftKey","metaKey","charCode","initEvent","attachEvent","detachEvent","addClass","className","removeClass","hasClass","RegExp","getWidth","getComputedStyle","getHeight","getOffset","offsetParent","offsetLeft","offsetTop","isActive","activeElement","OptionController","superclass","__select","setAttribute","selectedIndex","NumberController","__min","__max","__step","__impliedStep","LN10","__precision","NumberControllerBox","__input","__truncationSuspended","blur","NumberControllerSlider","__background","__foreground","useDefaultStyles","FunctionController","__button","fire","BooleanController","__prev","__checkbox","checked","interpret","litmus","conversions","THREE_CHAR_HEX","read","space","SIX_CHAR_HEX","CSS_RGB","CSS_RGBA","HEX","conversionName","RGB_ARRAY","RGBA_ARRAY","RGBA_OBJ","RGB_OBJ","HSVA_OBJ","HSV_OBJ","conversion","factoryArgs","before","__li","CLASS_CONTROLLER_ROW","__controllers","__ul","insertBefore","onResize","__gui","nextElementSibling","firstElementChild","listen","H","borderLeftColor","__color","__preset_select","__rememberedObjects","__rememberedObjectIndecesToControllers","remembered","preset","I","__save_row","firstChild","localStorage","getItem","location","useLocalStorage","which","getSaveObject","show","select","save","prompt","saveAs","revert","J","__closeButton","CLASS_DRAG","__resize_handle","marginLeft","cursor","autoPlace","K","A","setItem","__folders","__listening","DEFAULT_WIDTH","resizable","hideable","scrollable","CLASS_CLOSED","TEXT_OPEN","TEXT_CLOSED","CLASS_MAIN","CLASS_CLOSE_BUTTON","createTextNode","CLASS_AUTO_PLACE_CONTAINER","CLASS_AUTO_PLACE","toggleHide","zIndex","CLASS_TOO_TALL","removeChild","folders","childNodes","offsetHeight","remember","factory","StringController","ColorController","background","__state","toOriginal","__saturation_field","scrollLeft","scrollTop","__hue_field","__temp","__selector","__field_knob","__field_knob_border","__hue_knob","__input_textShadow","padding","backgroundColor","boxShadow","border","borderRadius","borderRight","marginRight","textAlign","fontWeight","textShadow","COMPONENTS","marginTop","component_from_hex","hsv_to_rgb","rgb_to_hsv","rgb_to_hex","math","NaN","hex_with_component","webkitRequestAnimationFrame","mozRequestAnimationFrame","oRequestAnimationFrame","msRequestAnimationFrame","CenteredDiv","backgroundElement","WebkitTransition","webkitTransform","layout"],"mappings":"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","file":"js/main-842c7e0d80f94aae4b1e.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"./\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {'use strict';\n\t\n\tvar _getIterator2 = __webpack_require__(1);\n\t\n\tvar _getIterator3 = _interopRequireDefault(_getIterator2);\n\t\n\tvar _classCallCheck2 = __webpack_require__(54);\n\t\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\t\n\tvar _createClass2 = __webpack_require__(55);\n\t\n\tvar _createClass3 = _interopRequireDefault(_createClass2);\n\t\n\tvar _index = __webpack_require__(59);\n\t\n\tvar _index2 = _interopRequireDefault(_index);\n\t\n\tvar _style = __webpack_require__(60);\n\t\n\tvar _style2 = _interopRequireDefault(_style);\n\t\n\tvar _three = __webpack_require__(61);\n\t\n\tvar _three2 = _interopRequireDefault(_three);\n\t\n\tvar _particle = __webpack_require__(62);\n\t\n\tvar _particle2 = _interopRequireDefault(_particle);\n\t\n\tvar _stats = __webpack_require__(98);\n\t\n\tvar _stats2 = _interopRequireDefault(_stats);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar scene = __webpack_require__(99);\n\tglobal.THREE = _three2.default;\n\t\n\t__webpack_require__(100);\n\t\n\tvar dat = __webpack_require__(101);\n\t\n\tvar stats = new _stats2.default();\n\tstats.showPanel(0); // 0: fps, 1: ms, 2: mb, 3+: custom\n\tdocument.body.appendChild(stats.dom);\n\t\n\tvar App = function () {\n\t    function App() {\n\t        var _this = this;\n\t\n\t        (0, _classCallCheck3.default)(this, App);\n\t\n\t        this.scene = new _three2.default.Scene();\n\t\n\t        this.camera = new _three2.default.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 10000);\n\t        this.camera.position.z = 1000;\n\t\n\t        this.stars = [];\n\t\n\t        for (var i = 0, l = 4; i < l; i++) {\n\t            this.stars[i] = this.buildStar();\n\t            this.scene.add(this.stars[i]);\n\t        }\n\t\n\t        var geometry = new _three2.default.BoxBufferGeometry(5000, 5000, 5000);\n\t        this.material = new _three2.default.MeshBasicMaterial({\n\t            side: _three2.default.BackSide,\n\t            map: new _three2.default.TextureLoader().load(scene),\n\t            precision: 'highp'\n\t        });\n\t        var cube = new _three2.default.Mesh(geometry, this.material);\n\t        cube.position.set(0, 0, 0);\n\t        this.scene.add(cube);\n\t\n\t        /*\n\t        const light = new THREE.DirectionalLight(0xffffff);\n\t         light.position.set(0, 100, 60);\n\t        light.castShadow = true;\n\t        light.shadow.camera.left = -60;\n\t        light.shadow.camera.top = -60;\n\t        light.shadow.camera.right = 60;\n\t        light.shadow.camera.bottom = 60;\n\t        light.shadow.camera.near = 1;\n\t        light.shadow.camera.far = 1000;\n\t        light.shadow.bias = -.0001\n\t        light.shadow.mapSize.width = light.shadow.mapSize.height = 1024;\n\t         this.scene.add(light);\n\t        */\n\t\n\t        // this.light = new THREE.DirectionalLight(0xffffff, 1);\n\t        // this.scene.add(this.light);\n\t        // this.light = new THREE.HemisphereLight(0xffffff, 0xffffff, 1.5);\n\t        // this.scene.add(this.light);\n\t\n\t        /*\n\t        const canvas = document.createElement('canvas');\n\t        canvas.width = 512;\n\t        canvas.height = 512;\n\t        const ctx = canvas.getContext('2d');\n\t         const gradient = ctx.createLinearGradient(0, 0, 512, 512);\n\t        gradient.addColorStop(0, '#111166');\n\t        gradient.addColorStop(1, '#333399');\n\t         ctx.fillStyle = gradient;\n\t        ctx.rect(0, 0, 512, 512);\n\t        ctx.fill();\n\t         const shadowTexture = new THREE.Texture(canvas);\n\t        shadowTexture.needsUpdate = true;\n\t         const skyGeo = new THREE.SphereGeometry(5000, 25, 25);\n\t        this.sky = new THREE.Mesh(skyGeo, new THREE.MeshBasicMaterial({\n\t            map: shadowTexture,\n\t            color: 0xFFFFFF,\n\t        }));\n\t        this.sky.material.side = THREE.BackSide;\n\t        this.scene.add(this.sky);\n\t        */\n\t\n\t        this.renderer = new _three2.default.WebGLRenderer({\n\t            canvas: document.getElementById('canvas'),\n\t            antialias: true\n\t        });\n\t        this.renderer.setSize(window.innerWidth, window.innerHeight);\n\t\n\t        var controls = new _three2.default.OrbitControls(this.camera, this.renderer.domElement);\n\t\n\t        this.render = this.render.bind(this);\n\t        this.resize = this.resize.bind(this);\n\t        this.bindEvents = this.bindEvents.bind(this);\n\t        this.update = this.update.bind(this);\n\t\n\t        this.bindEvents();\n\t\n\t        this.render();\n\t\n\t        this.params = {\n\t            color1: 0xFF4400,\n\t            color2: 0xFF4400,\n\t            color3: 0xFF4400,\n\t            color4: 0xFF4400,\n\t            intensity: 0.45,\n\t            scale: 0.03,\n\t            opacity: 0.9,\n\t            fresnel: 1,\n\t            fresnelBias: 0.2,\n\t            fresnelPow: 5\n\t        };\n\t\n\t        var gui = new dat.GUI();\n\t        var color = gui.addColor(this.params, 'color1');\n\t        color.onChange(function (v) {\n\t            var _iteratorNormalCompletion = true;\n\t            var _didIteratorError = false;\n\t            var _iteratorError = undefined;\n\t\n\t            try {\n\t                for (var _iterator = (0, _getIterator3.default)(_this.stars[0].children), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t                    var child = _step.value;\n\t\n\t                    child.material.uniforms.emissive.value = new _three2.default.Color(v);\n\t                }\n\t            } catch (err) {\n\t                _didIteratorError = true;\n\t                _iteratorError = err;\n\t            } finally {\n\t                try {\n\t                    if (!_iteratorNormalCompletion && _iterator.return) {\n\t                        _iterator.return();\n\t                    }\n\t                } finally {\n\t                    if (_didIteratorError) {\n\t                        throw _iteratorError;\n\t                    }\n\t                }\n\t            }\n\t        });\n\t        var color2 = gui.addColor(this.params, 'color2');\n\t        color2.onChange(function (v) {\n\t            var _iteratorNormalCompletion2 = true;\n\t            var _didIteratorError2 = false;\n\t            var _iteratorError2 = undefined;\n\t\n\t            try {\n\t                for (var _iterator2 = (0, _getIterator3.default)(_this.stars[1].children), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n\t                    var child = _step2.value;\n\t\n\t                    child.material.uniforms.emissive.value = new _three2.default.Color(v);\n\t                }\n\t            } catch (err) {\n\t                _didIteratorError2 = true;\n\t                _iteratorError2 = err;\n\t            } finally {\n\t                try {\n\t                    if (!_iteratorNormalCompletion2 && _iterator2.return) {\n\t                        _iterator2.return();\n\t                    }\n\t                } finally {\n\t                    if (_didIteratorError2) {\n\t                        throw _iteratorError2;\n\t                    }\n\t                }\n\t            }\n\t        });\n\t        var color3 = gui.addColor(this.params, 'color3');\n\t        color3.onChange(function (v) {\n\t            var _iteratorNormalCompletion3 = true;\n\t            var _didIteratorError3 = false;\n\t            var _iteratorError3 = undefined;\n\t\n\t            try {\n\t                for (var _iterator3 = (0, _getIterator3.default)(_this.stars[2].children), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n\t                    var child = _step3.value;\n\t\n\t                    child.material.uniforms.emissive.value = new _three2.default.Color(v);\n\t                }\n\t            } catch (err) {\n\t                _didIteratorError3 = true;\n\t                _iteratorError3 = err;\n\t            } finally {\n\t                try {\n\t                    if (!_iteratorNormalCompletion3 && _iterator3.return) {\n\t                        _iterator3.return();\n\t                    }\n\t                } finally {\n\t                    if (_didIteratorError3) {\n\t                        throw _iteratorError3;\n\t                    }\n\t                }\n\t            }\n\t        });\n\t        var color4 = gui.addColor(this.params, 'color4');\n\t        color4.onChange(function (v) {\n\t            var _iteratorNormalCompletion4 = true;\n\t            var _didIteratorError4 = false;\n\t            var _iteratorError4 = undefined;\n\t\n\t            try {\n\t                for (var _iterator4 = (0, _getIterator3.default)(_this.stars[3].children), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n\t                    var child = _step4.value;\n\t\n\t                    child.material.uniforms.emissive.value = new _three2.default.Color(v);\n\t                }\n\t            } catch (err) {\n\t                _didIteratorError4 = true;\n\t                _iteratorError4 = err;\n\t            } finally {\n\t                try {\n\t                    if (!_iteratorNormalCompletion4 && _iterator4.return) {\n\t                        _iterator4.return();\n\t                    }\n\t                } finally {\n\t                    if (_didIteratorError4) {\n\t                        throw _iteratorError4;\n\t                    }\n\t                }\n\t            }\n\t        });\n\t\n\t        var r = gui.addFolder('refraction');\n\t        r.open();\n\t        var refraction = r.add(this.params, 'intensity', 0, 1);\n\t        refraction.onChange(function (v) {\n\t            var _iteratorNormalCompletion5 = true;\n\t            var _didIteratorError5 = false;\n\t            var _iteratorError5 = undefined;\n\t\n\t            try {\n\t                for (var _iterator5 = (0, _getIterator3.default)(_this.stars), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n\t                    var star = _step5.value;\n\t                    var _iteratorNormalCompletion6 = true;\n\t                    var _didIteratorError6 = false;\n\t                    var _iteratorError6 = undefined;\n\t\n\t                    try {\n\t                        for (var _iterator6 = (0, _getIterator3.default)(star.children), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n\t                            var child = _step6.value;\n\t\n\t                            child.material.uniforms.refraction.value = v;\n\t                        }\n\t                    } catch (err) {\n\t                        _didIteratorError6 = true;\n\t                        _iteratorError6 = err;\n\t                    } finally {\n\t                        try {\n\t                            if (!_iteratorNormalCompletion6 && _iterator6.return) {\n\t                                _iterator6.return();\n\t                            }\n\t                        } finally {\n\t                            if (_didIteratorError6) {\n\t                                throw _iteratorError6;\n\t                            }\n\t                        }\n\t                    }\n\t                }\n\t            } catch (err) {\n\t                _didIteratorError5 = true;\n\t                _iteratorError5 = err;\n\t            } finally {\n\t                try {\n\t                    if (!_iteratorNormalCompletion5 && _iterator5.return) {\n\t                        _iterator5.return();\n\t                    }\n\t                } finally {\n\t                    if (_didIteratorError5) {\n\t                        throw _iteratorError5;\n\t                    }\n\t                }\n\t            }\n\t        });\n\t        var opacity = gui.add(this.params, 'opacity', 0, 1);\n\t        opacity.onChange(function (v) {\n\t            var _iteratorNormalCompletion7 = true;\n\t            var _didIteratorError7 = false;\n\t            var _iteratorError7 = undefined;\n\t\n\t            try {\n\t                for (var _iterator7 = (0, _getIterator3.default)(_this.stars), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n\t                    var star = _step7.value;\n\t                    var _iteratorNormalCompletion8 = true;\n\t                    var _didIteratorError8 = false;\n\t                    var _iteratorError8 = undefined;\n\t\n\t                    try {\n\t                        for (var _iterator8 = (0, _getIterator3.default)(star.children), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n\t                            var child = _step8.value;\n\t\n\t                            child.material.uniforms.opacity.value = v;\n\t                        }\n\t                    } catch (err) {\n\t                        _didIteratorError8 = true;\n\t                        _iteratorError8 = err;\n\t                    } finally {\n\t                        try {\n\t                            if (!_iteratorNormalCompletion8 && _iterator8.return) {\n\t                                _iterator8.return();\n\t                            }\n\t                        } finally {\n\t                            if (_didIteratorError8) {\n\t                                throw _iteratorError8;\n\t                            }\n\t                        }\n\t                    }\n\t                }\n\t            } catch (err) {\n\t                _didIteratorError7 = true;\n\t                _iteratorError7 = err;\n\t            } finally {\n\t                try {\n\t                    if (!_iteratorNormalCompletion7 && _iterator7.return) {\n\t                        _iterator7.return();\n\t                    }\n\t                } finally {\n\t                    if (_didIteratorError7) {\n\t                        throw _iteratorError7;\n\t                    }\n\t                }\n\t            }\n\t        });\n\t        var refractionIntensity = r.add(this.params, 'scale', 0, 0.1);\n\t        refractionIntensity.onChange(function (v) {\n\t            var _iteratorNormalCompletion9 = true;\n\t            var _didIteratorError9 = false;\n\t            var _iteratorError9 = undefined;\n\t\n\t            try {\n\t                for (var _iterator9 = (0, _getIterator3.default)(_this.stars), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n\t                    var star = _step9.value;\n\t                    var _iteratorNormalCompletion10 = true;\n\t                    var _didIteratorError10 = false;\n\t                    var _iteratorError10 = undefined;\n\t\n\t                    try {\n\t                        for (var _iterator10 = (0, _getIterator3.default)(star.children), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {\n\t                            var child = _step10.value;\n\t\n\t                            child.material.uniforms.vScale.value = new _three2.default.Vector2(v, v);\n\t                        }\n\t                    } catch (err) {\n\t                        _didIteratorError10 = true;\n\t                        _iteratorError10 = err;\n\t                    } finally {\n\t                        try {\n\t                            if (!_iteratorNormalCompletion10 && _iterator10.return) {\n\t                                _iterator10.return();\n\t                            }\n\t                        } finally {\n\t                            if (_didIteratorError10) {\n\t                                throw _iteratorError10;\n\t                            }\n\t                        }\n\t                    }\n\t                }\n\t            } catch (err) {\n\t                _didIteratorError9 = true;\n\t                _iteratorError9 = err;\n\t            } finally {\n\t                try {\n\t                    if (!_iteratorNormalCompletion9 && _iterator9.return) {\n\t                        _iterator9.return();\n\t                    }\n\t                } finally {\n\t                    if (_didIteratorError9) {\n\t                        throw _iteratorError9;\n\t                    }\n\t                }\n\t            }\n\t        });\n\t        var fresnel = gui.add(this.params, 'fresnel', 0, 1);\n\t        fresnel.onChange(function (v) {\n\t            var _iteratorNormalCompletion11 = true;\n\t            var _didIteratorError11 = false;\n\t            var _iteratorError11 = undefined;\n\t\n\t            try {\n\t                for (var _iterator11 = (0, _getIterator3.default)(_this.stars), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {\n\t                    var star = _step11.value;\n\t                    var _iteratorNormalCompletion12 = true;\n\t                    var _didIteratorError12 = false;\n\t                    var _iteratorError12 = undefined;\n\t\n\t                    try {\n\t                        for (var _iterator12 = (0, _getIterator3.default)(star.children), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {\n\t                            var child = _step12.value;\n\t\n\t                            child.material.uniforms.fresnelMix.value = v;\n\t                        }\n\t                    } catch (err) {\n\t                        _didIteratorError12 = true;\n\t                        _iteratorError12 = err;\n\t                    } finally {\n\t                        try {\n\t                            if (!_iteratorNormalCompletion12 && _iterator12.return) {\n\t                                _iterator12.return();\n\t                            }\n\t                        } finally {\n\t                            if (_didIteratorError12) {\n\t                                throw _iteratorError12;\n\t                            }\n\t                        }\n\t                    }\n\t                }\n\t            } catch (err) {\n\t                _didIteratorError11 = true;\n\t                _iteratorError11 = err;\n\t            } finally {\n\t                try {\n\t                    if (!_iteratorNormalCompletion11 && _iterator11.return) {\n\t                        _iterator11.return();\n\t                    }\n\t                } finally {\n\t                    if (_didIteratorError11) {\n\t                        throw _iteratorError11;\n\t                    }\n\t                }\n\t            }\n\t        });\n\t        var fresnelBias = gui.add(this.params, 'fresnelBias', 0, 1);\n\t        fresnelBias.onChange(function (v) {\n\t            var _iteratorNormalCompletion13 = true;\n\t            var _didIteratorError13 = false;\n\t            var _iteratorError13 = undefined;\n\t\n\t            try {\n\t                for (var _iterator13 = (0, _getIterator3.default)(_this.stars), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {\n\t                    var star = _step13.value;\n\t                    var _iteratorNormalCompletion14 = true;\n\t                    var _didIteratorError14 = false;\n\t                    var _iteratorError14 = undefined;\n\t\n\t                    try {\n\t                        for (var _iterator14 = (0, _getIterator3.default)(star.children), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {\n\t                            var child = _step14.value;\n\t\n\t                            child.material.uniforms.fresnelBias.value = v;\n\t                        }\n\t                    } catch (err) {\n\t                        _didIteratorError14 = true;\n\t                        _iteratorError14 = err;\n\t                    } finally {\n\t                        try {\n\t                            if (!_iteratorNormalCompletion14 && _iterator14.return) {\n\t                                _iterator14.return();\n\t                            }\n\t                        } finally {\n\t                            if (_didIteratorError14) {\n\t                                throw _iteratorError14;\n\t                            }\n\t                        }\n\t                    }\n\t                }\n\t            } catch (err) {\n\t                _didIteratorError13 = true;\n\t                _iteratorError13 = err;\n\t            } finally {\n\t                try {\n\t                    if (!_iteratorNormalCompletion13 && _iterator13.return) {\n\t                        _iterator13.return();\n\t                    }\n\t                } finally {\n\t                    if (_didIteratorError13) {\n\t                        throw _iteratorError13;\n\t                    }\n\t                }\n\t            }\n\t        });\n\t        var fresnelPow = gui.add(this.params, 'fresnelPow', 0, 10);\n\t        fresnelPow.onChange(function (v) {\n\t            var _iteratorNormalCompletion15 = true;\n\t            var _didIteratorError15 = false;\n\t            var _iteratorError15 = undefined;\n\t\n\t            try {\n\t                for (var _iterator15 = (0, _getIterator3.default)(_this.stars), _step15; !(_iteratorNormalCompletion15 = (_step15 = _iterator15.next()).done); _iteratorNormalCompletion15 = true) {\n\t                    var star = _step15.value;\n\t                    var _iteratorNormalCompletion16 = true;\n\t                    var _didIteratorError16 = false;\n\t                    var _iteratorError16 = undefined;\n\t\n\t                    try {\n\t                        for (var _iterator16 = (0, _getIterator3.default)(star.children), _step16; !(_iteratorNormalCompletion16 = (_step16 = _iterator16.next()).done); _iteratorNormalCompletion16 = true) {\n\t                            var child = _step16.value;\n\t\n\t                            child.material.uniforms.fresnelPow.value = v;\n\t                        }\n\t                    } catch (err) {\n\t                        _didIteratorError16 = true;\n\t                        _iteratorError16 = err;\n\t                    } finally {\n\t                        try {\n\t                            if (!_iteratorNormalCompletion16 && _iterator16.return) {\n\t                                _iterator16.return();\n\t                            }\n\t                        } finally {\n\t                            if (_didIteratorError16) {\n\t                                throw _iteratorError16;\n\t                            }\n\t                        }\n\t                    }\n\t                }\n\t            } catch (err) {\n\t                _didIteratorError15 = true;\n\t                _iteratorError15 = err;\n\t            } finally {\n\t                try {\n\t                    if (!_iteratorNormalCompletion15 && _iterator15.return) {\n\t                        _iterator15.return();\n\t                    }\n\t                } finally {\n\t                    if (_didIteratorError15) {\n\t                        throw _iteratorError15;\n\t                    }\n\t                }\n\t            }\n\t        });\n\t    }\n\t\n\t    (0, _createClass3.default)(App, [{\n\t        key: 'bindEvents',\n\t        value: function bindEvents() {\n\t            window.addEventListener('resize', this.resize);\n\t        }\n\t    }, {\n\t        key: 'buildStar',\n\t        value: function buildStar() {\n\t            var obj = new _three2.default.Object3D();\n\t\n\t            obj.position.set(500 - Math.random() * 1000, 500 - Math.random() * 1000, 500 - Math.random() * 1000);\n\t\n\t            for (var i = 0; i < 10; i++) {\n\t                var particle = new _particle2.default();\n\t                particle.rotation.set(Math.PI * Math.random(), Math.PI * Math.random(), Math.PI * Math.random());\n\t                // particle.camera.position.copy(obj.position);\n\t                // this.scene.add(new THREE.CameraHelper(particle.camera));\n\t                obj.add(particle);\n\t            }\n\t\n\t            return obj;\n\t        }\n\t    }, {\n\t        key: 'resize',\n\t        value: function resize() {\n\t            this.renderer.setSize(window.innerWidth, window.innerHeight);\n\t            this.camera.aspect = window.innerWidth / window.innerHeight;\n\t            this.camera.updateProjectionMatrix();\n\t            var _iteratorNormalCompletion17 = true;\n\t            var _didIteratorError17 = false;\n\t            var _iteratorError17 = undefined;\n\t\n\t            try {\n\t                for (var _iterator17 = (0, _getIterator3.default)(this.star.children), _step17; !(_iteratorNormalCompletion17 = (_step17 = _iterator17.next()).done); _iteratorNormalCompletion17 = true) {\n\t                    var child = _step17.value;\n\t\n\t                    child.material.uniforms.resolution.value = new _three2.default.Vector2(window.innerWidth, window.innerHeight);\n\t                }\n\t            } catch (err) {\n\t                _didIteratorError17 = true;\n\t                _iteratorError17 = err;\n\t            } finally {\n\t                try {\n\t                    if (!_iteratorNormalCompletion17 && _iterator17.return) {\n\t                        _iterator17.return();\n\t                    }\n\t                } finally {\n\t                    if (_didIteratorError17) {\n\t                        throw _iteratorError17;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    }, {\n\t        key: 'update',\n\t        value: function update() {\n\t            var _this2 = this;\n\t\n\t            var stars = this.stars.slice();\n\t\n\t            stars.sort(function (a, b) {\n\t                var pb = b.getWorldPosition();\n\t                pb.project(_this2.camera);\n\t                var pa = a.getWorldPosition();\n\t                pa.project(_this2.camera);\n\t                return pb.z - pa.z;\n\t            });\n\t\n\t            var _iteratorNormalCompletion18 = true;\n\t            var _didIteratorError18 = false;\n\t            var _iteratorError18 = undefined;\n\t\n\t            try {\n\t                for (var _iterator18 = (0, _getIterator3.default)(stars), _step18; !(_iteratorNormalCompletion18 = (_step18 = _iterator18.next()).done); _iteratorNormalCompletion18 = true) {\n\t                    var star = _step18.value;\n\t\n\t                    star.visible = false;\n\t                }\n\t            } catch (err) {\n\t                _didIteratorError18 = true;\n\t                _iteratorError18 = err;\n\t            } finally {\n\t                try {\n\t                    if (!_iteratorNormalCompletion18 && _iterator18.return) {\n\t                        _iterator18.return();\n\t                    }\n\t                } finally {\n\t                    if (_didIteratorError18) {\n\t                        throw _iteratorError18;\n\t                    }\n\t                }\n\t            }\n\t\n\t            var _iteratorNormalCompletion19 = true;\n\t            var _didIteratorError19 = false;\n\t            var _iteratorError19 = undefined;\n\t\n\t            try {\n\t                for (var _iterator19 = (0, _getIterator3.default)(stars), _step19; !(_iteratorNormalCompletion19 = (_step19 = _iterator19.next()).done); _iteratorNormalCompletion19 = true) {\n\t                    var _star = _step19.value;\n\t\n\t                    _star.rotation.y += Math.PI / 360;\n\t                    _star.rotation.x += Math.PI / 360;\n\t\n\t                    var children = _star.children.slice();\n\t                    children.sort(function (a, b) {\n\t                        b.translateY(250);\n\t                        var pb = b.getWorldPosition();\n\t                        b.translateY(-250);\n\t                        pb.project(_this2.camera);\n\t                        a.translateY(250);\n\t                        var pa = a.getWorldPosition();\n\t                        a.translateY(-250);\n\t                        pa.project(_this2.camera);\n\t                        return pb.z - pa.z;\n\t                    });\n\t\n\t                    _star.visible = true;\n\t\n\t                    var _iteratorNormalCompletion20 = true;\n\t                    var _didIteratorError20 = false;\n\t                    var _iteratorError20 = undefined;\n\t\n\t                    try {\n\t                        for (var _iterator20 = (0, _getIterator3.default)(children), _step20; !(_iteratorNormalCompletion20 = (_step20 = _iterator20.next()).done); _iteratorNormalCompletion20 = true) {\n\t                            var child = _step20.value;\n\t\n\t                            child.visible = false;\n\t                        }\n\t                    } catch (err) {\n\t                        _didIteratorError20 = true;\n\t                        _iteratorError20 = err;\n\t                    } finally {\n\t                        try {\n\t                            if (!_iteratorNormalCompletion20 && _iterator20.return) {\n\t                                _iterator20.return();\n\t                            }\n\t                        } finally {\n\t                            if (_didIteratorError20) {\n\t                                throw _iteratorError20;\n\t                            }\n\t                        }\n\t                    }\n\t\n\t                    var _iteratorNormalCompletion21 = true;\n\t                    var _didIteratorError21 = false;\n\t                    var _iteratorError21 = undefined;\n\t\n\t                    try {\n\t                        for (var _iterator21 = (0, _getIterator3.default)(children), _step21; !(_iteratorNormalCompletion21 = (_step21 = _iterator21.next()).done); _iteratorNormalCompletion21 = true) {\n\t                            var _child = _step21.value;\n\t\n\t                            this.renderer.render(this.scene, this.camera, _child.renderTarget);\n\t                            _child.visible = true;\n\t                            _child.material.uniforms.offset.value.add(new _three2.default.Vector2(0.001, 0.001));\n\t                        }\n\t                    } catch (err) {\n\t                        _didIteratorError21 = true;\n\t                        _iteratorError21 = err;\n\t                    } finally {\n\t                        try {\n\t                            if (!_iteratorNormalCompletion21 && _iterator21.return) {\n\t                                _iterator21.return();\n\t                            }\n\t                        } finally {\n\t                            if (_didIteratorError21) {\n\t                                throw _iteratorError21;\n\t                            }\n\t                        }\n\t                    }\n\t                }\n\t            } catch (err) {\n\t                _didIteratorError19 = true;\n\t                _iteratorError19 = err;\n\t            } finally {\n\t                try {\n\t                    if (!_iteratorNormalCompletion19 && _iterator19.return) {\n\t                        _iterator19.return();\n\t                    }\n\t                } finally {\n\t                    if (_didIteratorError19) {\n\t                        throw _iteratorError19;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    }, {\n\t        key: 'render',\n\t        value: function render() {\n\t            stats.begin();\n\t\n\t            this.update();\n\t\n\t            this.renderer.render(this.scene, this.camera);\n\t\n\t            stats.end();\n\t\n\t            requestAnimationFrame(this.render);\n\t        }\n\t    }]);\n\t    return App;\n\t}();\n\t\n\tvar app = new App();\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = { \"default\": __webpack_require__(2), __esModule: true };\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(3);\n\t__webpack_require__(49);\n\tmodule.exports = __webpack_require__(51);\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(4);\n\tvar global        = __webpack_require__(15)\n\t  , hide          = __webpack_require__(19)\n\t  , Iterators     = __webpack_require__(7)\n\t  , TO_STRING_TAG = __webpack_require__(46)('toStringTag');\n\t\n\tfor(var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++){\n\t  var NAME       = collections[i]\n\t    , Collection = global[NAME]\n\t    , proto      = Collection && Collection.prototype;\n\t  if(proto && !proto[TO_STRING_TAG])hide(proto, TO_STRING_TAG, NAME);\n\t  Iterators[NAME] = Iterators.Array;\n\t}\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar addToUnscopables = __webpack_require__(5)\n\t  , step             = __webpack_require__(6)\n\t  , Iterators        = __webpack_require__(7)\n\t  , toIObject        = __webpack_require__(8);\n\t\n\t// 22.1.3.4 Array.prototype.entries()\n\t// 22.1.3.13 Array.prototype.keys()\n\t// 22.1.3.29 Array.prototype.values()\n\t// 22.1.3.30 Array.prototype[@@iterator]()\n\tmodule.exports = __webpack_require__(12)(Array, 'Array', function(iterated, kind){\n\t  this._t = toIObject(iterated); // target\n\t  this._i = 0;                   // next index\n\t  this._k = kind;                // kind\n\t// 22.1.5.2.1 %ArrayIteratorPrototype%.next()\n\t}, function(){\n\t  var O     = this._t\n\t    , kind  = this._k\n\t    , index = this._i++;\n\t  if(!O || index >= O.length){\n\t    this._t = undefined;\n\t    return step(1);\n\t  }\n\t  if(kind == 'keys'  )return step(0, index);\n\t  if(kind == 'values')return step(0, O[index]);\n\t  return step(0, [index, O[index]]);\n\t}, 'values');\n\t\n\t// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)\n\tIterators.Arguments = Iterators.Array;\n\t\n\taddToUnscopables('keys');\n\taddToUnscopables('values');\n\taddToUnscopables('entries');\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(){ /* empty */ };\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(done, value){\n\t  return {value: value, done: !!done};\n\t};\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\tmodule.exports = {};\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// to indexed object, toObject with fallback for non-array-like ES3 strings\n\tvar IObject = __webpack_require__(9)\n\t  , defined = __webpack_require__(11);\n\tmodule.exports = function(it){\n\t  return IObject(defined(it));\n\t};\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// fallback for non-array-like ES3 and non-enumerable old V8 strings\n\tvar cof = __webpack_require__(10);\n\tmodule.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){\n\t  return cof(it) == 'String' ? it.split('') : Object(it);\n\t};\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\n\tvar toString = {}.toString;\n\t\n\tmodule.exports = function(it){\n\t  return toString.call(it).slice(8, -1);\n\t};\n\n/***/ },\n/* 11 */\n/***/ function(module, exports) {\n\n\t// 7.2.1 RequireObjectCoercible(argument)\n\tmodule.exports = function(it){\n\t  if(it == undefined)throw TypeError(\"Can't call method on  \" + it);\n\t  return it;\n\t};\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar LIBRARY        = __webpack_require__(13)\n\t  , $export        = __webpack_require__(14)\n\t  , redefine       = __webpack_require__(29)\n\t  , hide           = __webpack_require__(19)\n\t  , has            = __webpack_require__(30)\n\t  , Iterators      = __webpack_require__(7)\n\t  , $iterCreate    = __webpack_require__(31)\n\t  , setToStringTag = __webpack_require__(45)\n\t  , getPrototypeOf = __webpack_require__(47)\n\t  , ITERATOR       = __webpack_require__(46)('iterator')\n\t  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`\n\t  , FF_ITERATOR    = '@@iterator'\n\t  , KEYS           = 'keys'\n\t  , VALUES         = 'values';\n\t\n\tvar returnThis = function(){ return this; };\n\t\n\tmodule.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){\n\t  $iterCreate(Constructor, NAME, next);\n\t  var getMethod = function(kind){\n\t    if(!BUGGY && kind in proto)return proto[kind];\n\t    switch(kind){\n\t      case KEYS: return function keys(){ return new Constructor(this, kind); };\n\t      case VALUES: return function values(){ return new Constructor(this, kind); };\n\t    } return function entries(){ return new Constructor(this, kind); };\n\t  };\n\t  var TAG        = NAME + ' Iterator'\n\t    , DEF_VALUES = DEFAULT == VALUES\n\t    , VALUES_BUG = false\n\t    , proto      = Base.prototype\n\t    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]\n\t    , $default   = $native || getMethod(DEFAULT)\n\t    , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined\n\t    , $anyNative = NAME == 'Array' ? proto.entries || $native : $native\n\t    , methods, key, IteratorPrototype;\n\t  // Fix native\n\t  if($anyNative){\n\t    IteratorPrototype = getPrototypeOf($anyNative.call(new Base));\n\t    if(IteratorPrototype !== Object.prototype){\n\t      // Set @@toStringTag to native iterators\n\t      setToStringTag(IteratorPrototype, TAG, true);\n\t      // fix for some old engines\n\t      if(!LIBRARY && !has(IteratorPrototype, ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);\n\t    }\n\t  }\n\t  // fix Array#{values, @@iterator}.name in V8 / FF\n\t  if(DEF_VALUES && $native && $native.name !== VALUES){\n\t    VALUES_BUG = true;\n\t    $default = function values(){ return $native.call(this); };\n\t  }\n\t  // Define iterator\n\t  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){\n\t    hide(proto, ITERATOR, $default);\n\t  }\n\t  // Plug for library\n\t  Iterators[NAME] = $default;\n\t  Iterators[TAG]  = returnThis;\n\t  if(DEFAULT){\n\t    methods = {\n\t      values:  DEF_VALUES ? $default : getMethod(VALUES),\n\t      keys:    IS_SET     ? $default : getMethod(KEYS),\n\t      entries: $entries\n\t    };\n\t    if(FORCED)for(key in methods){\n\t      if(!(key in proto))redefine(proto, key, methods[key]);\n\t    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);\n\t  }\n\t  return methods;\n\t};\n\n/***/ },\n/* 13 */\n/***/ function(module, exports) {\n\n\tmodule.exports = true;\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar global    = __webpack_require__(15)\n\t  , core      = __webpack_require__(16)\n\t  , ctx       = __webpack_require__(17)\n\t  , hide      = __webpack_require__(19)\n\t  , PROTOTYPE = 'prototype';\n\t\n\tvar $export = function(type, name, source){\n\t  var IS_FORCED = type & $export.F\n\t    , IS_GLOBAL = type & $export.G\n\t    , IS_STATIC = type & $export.S\n\t    , IS_PROTO  = type & $export.P\n\t    , IS_BIND   = type & $export.B\n\t    , IS_WRAP   = type & $export.W\n\t    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})\n\t    , expProto  = exports[PROTOTYPE]\n\t    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]\n\t    , key, own, out;\n\t  if(IS_GLOBAL)source = name;\n\t  for(key in source){\n\t    // contains in native\n\t    own = !IS_FORCED && target && target[key] !== undefined;\n\t    if(own && key in exports)continue;\n\t    // export native or passed\n\t    out = own ? target[key] : source[key];\n\t    // prevent global pollution for namespaces\n\t    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]\n\t    // bind timers to global for call from export context\n\t    : IS_BIND && own ? ctx(out, global)\n\t    // wrap global constructors for prevent change them in library\n\t    : IS_WRAP && target[key] == out ? (function(C){\n\t      var F = function(a, b, c){\n\t        if(this instanceof C){\n\t          switch(arguments.length){\n\t            case 0: return new C;\n\t            case 1: return new C(a);\n\t            case 2: return new C(a, b);\n\t          } return new C(a, b, c);\n\t        } return C.apply(this, arguments);\n\t      };\n\t      F[PROTOTYPE] = C[PROTOTYPE];\n\t      return F;\n\t    // make static versions for prototype methods\n\t    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;\n\t    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%\n\t    if(IS_PROTO){\n\t      (exports.virtual || (exports.virtual = {}))[key] = out;\n\t      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%\n\t      if(type & $export.R && expProto && !expProto[key])hide(expProto, key, out);\n\t    }\n\t  }\n\t};\n\t// type bitmap\n\t$export.F = 1;   // forced\n\t$export.G = 2;   // global\n\t$export.S = 4;   // static\n\t$export.P = 8;   // proto\n\t$export.B = 16;  // bind\n\t$export.W = 32;  // wrap\n\t$export.U = 64;  // safe\n\t$export.R = 128; // real proto method for `library` \n\tmodule.exports = $export;\n\n/***/ },\n/* 15 */\n/***/ function(module, exports) {\n\n\t// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\n\tvar global = module.exports = typeof window != 'undefined' && window.Math == Math\n\t  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();\n\tif(typeof __g == 'number')__g = global; // eslint-disable-line no-undef\n\n/***/ },\n/* 16 */\n/***/ function(module, exports) {\n\n\tvar core = module.exports = {version: '2.4.0'};\n\tif(typeof __e == 'number')__e = core; // eslint-disable-line no-undef\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// optional / simple context binding\n\tvar aFunction = __webpack_require__(18);\n\tmodule.exports = function(fn, that, length){\n\t  aFunction(fn);\n\t  if(that === undefined)return fn;\n\t  switch(length){\n\t    case 1: return function(a){\n\t      return fn.call(that, a);\n\t    };\n\t    case 2: return function(a, b){\n\t      return fn.call(that, a, b);\n\t    };\n\t    case 3: return function(a, b, c){\n\t      return fn.call(that, a, b, c);\n\t    };\n\t  }\n\t  return function(/* ...args */){\n\t    return fn.apply(that, arguments);\n\t  };\n\t};\n\n/***/ },\n/* 18 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(it){\n\t  if(typeof it != 'function')throw TypeError(it + ' is not a function!');\n\t  return it;\n\t};\n\n/***/ },\n/* 19 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar dP         = __webpack_require__(20)\n\t  , createDesc = __webpack_require__(28);\n\tmodule.exports = __webpack_require__(24) ? function(object, key, value){\n\t  return dP.f(object, key, createDesc(1, value));\n\t} : function(object, key, value){\n\t  object[key] = value;\n\t  return object;\n\t};\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar anObject       = __webpack_require__(21)\n\t  , IE8_DOM_DEFINE = __webpack_require__(23)\n\t  , toPrimitive    = __webpack_require__(27)\n\t  , dP             = Object.defineProperty;\n\t\n\texports.f = __webpack_require__(24) ? Object.defineProperty : function defineProperty(O, P, Attributes){\n\t  anObject(O);\n\t  P = toPrimitive(P, true);\n\t  anObject(Attributes);\n\t  if(IE8_DOM_DEFINE)try {\n\t    return dP(O, P, Attributes);\n\t  } catch(e){ /* empty */ }\n\t  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');\n\t  if('value' in Attributes)O[P] = Attributes.value;\n\t  return O;\n\t};\n\n/***/ },\n/* 21 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar isObject = __webpack_require__(22);\n\tmodule.exports = function(it){\n\t  if(!isObject(it))throw TypeError(it + ' is not an object!');\n\t  return it;\n\t};\n\n/***/ },\n/* 22 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(it){\n\t  return typeof it === 'object' ? it !== null : typeof it === 'function';\n\t};\n\n/***/ },\n/* 23 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = !__webpack_require__(24) && !__webpack_require__(25)(function(){\r\n\t  return Object.defineProperty(__webpack_require__(26)('div'), 'a', {get: function(){ return 7; }}).a != 7;\r\n\t});\n\n/***/ },\n/* 24 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// Thank's IE8 for his funny defineProperty\n\tmodule.exports = !__webpack_require__(25)(function(){\n\t  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;\n\t});\n\n/***/ },\n/* 25 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(exec){\n\t  try {\n\t    return !!exec();\n\t  } catch(e){\n\t    return true;\n\t  }\n\t};\n\n/***/ },\n/* 26 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar isObject = __webpack_require__(22)\n\t  , document = __webpack_require__(15).document\n\t  // in old IE typeof document.createElement is 'object'\n\t  , is = isObject(document) && isObject(document.createElement);\n\tmodule.exports = function(it){\n\t  return is ? document.createElement(it) : {};\n\t};\n\n/***/ },\n/* 27 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 7.1.1 ToPrimitive(input [, PreferredType])\n\tvar isObject = __webpack_require__(22);\n\t// instead of the ES6 spec version, we didn't implement @@toPrimitive case\n\t// and the second argument - flag - preferred type is a string\n\tmodule.exports = function(it, S){\n\t  if(!isObject(it))return it;\n\t  var fn, val;\n\t  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;\n\t  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;\n\t  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;\n\t  throw TypeError(\"Can't convert object to primitive value\");\n\t};\n\n/***/ },\n/* 28 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(bitmap, value){\n\t  return {\n\t    enumerable  : !(bitmap & 1),\n\t    configurable: !(bitmap & 2),\n\t    writable    : !(bitmap & 4),\n\t    value       : value\n\t  };\n\t};\n\n/***/ },\n/* 29 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(19);\n\n/***/ },\n/* 30 */\n/***/ function(module, exports) {\n\n\tvar hasOwnProperty = {}.hasOwnProperty;\n\tmodule.exports = function(it, key){\n\t  return hasOwnProperty.call(it, key);\n\t};\n\n/***/ },\n/* 31 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar create         = __webpack_require__(32)\n\t  , descriptor     = __webpack_require__(28)\n\t  , setToStringTag = __webpack_require__(45)\n\t  , IteratorPrototype = {};\n\t\n\t// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\n\t__webpack_require__(19)(IteratorPrototype, __webpack_require__(46)('iterator'), function(){ return this; });\n\t\n\tmodule.exports = function(Constructor, NAME, next){\n\t  Constructor.prototype = create(IteratorPrototype, {next: descriptor(1, next)});\n\t  setToStringTag(Constructor, NAME + ' Iterator');\n\t};\n\n/***/ },\n/* 32 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\r\n\tvar anObject    = __webpack_require__(21)\r\n\t  , dPs         = __webpack_require__(33)\r\n\t  , enumBugKeys = __webpack_require__(43)\r\n\t  , IE_PROTO    = __webpack_require__(40)('IE_PROTO')\r\n\t  , Empty       = function(){ /* empty */ }\r\n\t  , PROTOTYPE   = 'prototype';\r\n\t\r\n\t// Create object with fake `null` prototype: use iframe Object with cleared prototype\r\n\tvar createDict = function(){\r\n\t  // Thrash, waste and sodomy: IE GC bug\r\n\t  var iframe = __webpack_require__(26)('iframe')\r\n\t    , i      = enumBugKeys.length\r\n\t    , gt     = '>'\r\n\t    , iframeDocument;\r\n\t  iframe.style.display = 'none';\r\n\t  __webpack_require__(44).appendChild(iframe);\r\n\t  iframe.src = 'javascript:'; // eslint-disable-line no-script-url\r\n\t  // createDict = iframe.contentWindow.Object;\r\n\t  // html.removeChild(iframe);\r\n\t  iframeDocument = iframe.contentWindow.document;\r\n\t  iframeDocument.open();\r\n\t  iframeDocument.write('<script>document.F=Object</script' + gt);\r\n\t  iframeDocument.close();\r\n\t  createDict = iframeDocument.F;\r\n\t  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];\r\n\t  return createDict();\r\n\t};\r\n\t\r\n\tmodule.exports = Object.create || function create(O, Properties){\r\n\t  var result;\r\n\t  if(O !== null){\r\n\t    Empty[PROTOTYPE] = anObject(O);\r\n\t    result = new Empty;\r\n\t    Empty[PROTOTYPE] = null;\r\n\t    // add \"__proto__\" for Object.getPrototypeOf polyfill\r\n\t    result[IE_PROTO] = O;\r\n\t  } else result = createDict();\r\n\t  return Properties === undefined ? result : dPs(result, Properties);\r\n\t};\n\n/***/ },\n/* 33 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar dP       = __webpack_require__(20)\r\n\t  , anObject = __webpack_require__(21)\r\n\t  , getKeys  = __webpack_require__(34);\r\n\t\r\n\tmodule.exports = __webpack_require__(24) ? Object.defineProperties : function defineProperties(O, Properties){\r\n\t  anObject(O);\r\n\t  var keys   = getKeys(Properties)\r\n\t    , length = keys.length\r\n\t    , i = 0\r\n\t    , P;\r\n\t  while(length > i)dP.f(O, P = keys[i++], Properties[P]);\r\n\t  return O;\r\n\t};\n\n/***/ },\n/* 34 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 19.1.2.14 / 15.2.3.14 Object.keys(O)\r\n\tvar $keys       = __webpack_require__(35)\r\n\t  , enumBugKeys = __webpack_require__(43);\r\n\t\r\n\tmodule.exports = Object.keys || function keys(O){\r\n\t  return $keys(O, enumBugKeys);\r\n\t};\n\n/***/ },\n/* 35 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar has          = __webpack_require__(30)\r\n\t  , toIObject    = __webpack_require__(8)\r\n\t  , arrayIndexOf = __webpack_require__(36)(false)\r\n\t  , IE_PROTO     = __webpack_require__(40)('IE_PROTO');\r\n\t\r\n\tmodule.exports = function(object, names){\r\n\t  var O      = toIObject(object)\r\n\t    , i      = 0\r\n\t    , result = []\r\n\t    , key;\r\n\t  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);\r\n\t  // Don't enum bug & hidden keys\r\n\t  while(names.length > i)if(has(O, key = names[i++])){\r\n\t    ~arrayIndexOf(result, key) || result.push(key);\r\n\t  }\r\n\t  return result;\r\n\t};\n\n/***/ },\n/* 36 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// false -> Array#indexOf\n\t// true  -> Array#includes\n\tvar toIObject = __webpack_require__(8)\n\t  , toLength  = __webpack_require__(37)\n\t  , toIndex   = __webpack_require__(39);\n\tmodule.exports = function(IS_INCLUDES){\n\t  return function($this, el, fromIndex){\n\t    var O      = toIObject($this)\n\t      , length = toLength(O.length)\n\t      , index  = toIndex(fromIndex, length)\n\t      , value;\n\t    // Array#includes uses SameValueZero equality algorithm\n\t    if(IS_INCLUDES && el != el)while(length > index){\n\t      value = O[index++];\n\t      if(value != value)return true;\n\t    // Array#toIndex ignores holes, Array#includes - not\n\t    } else for(;length > index; index++)if(IS_INCLUDES || index in O){\n\t      if(O[index] === el)return IS_INCLUDES || index || 0;\n\t    } return !IS_INCLUDES && -1;\n\t  };\n\t};\n\n/***/ },\n/* 37 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 7.1.15 ToLength\n\tvar toInteger = __webpack_require__(38)\n\t  , min       = Math.min;\n\tmodule.exports = function(it){\n\t  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991\n\t};\n\n/***/ },\n/* 38 */\n/***/ function(module, exports) {\n\n\t// 7.1.4 ToInteger\n\tvar ceil  = Math.ceil\n\t  , floor = Math.floor;\n\tmodule.exports = function(it){\n\t  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);\n\t};\n\n/***/ },\n/* 39 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar toInteger = __webpack_require__(38)\n\t  , max       = Math.max\n\t  , min       = Math.min;\n\tmodule.exports = function(index, length){\n\t  index = toInteger(index);\n\t  return index < 0 ? max(index + length, 0) : min(index, length);\n\t};\n\n/***/ },\n/* 40 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar shared = __webpack_require__(41)('keys')\r\n\t  , uid    = __webpack_require__(42);\r\n\tmodule.exports = function(key){\r\n\t  return shared[key] || (shared[key] = uid(key));\r\n\t};\n\n/***/ },\n/* 41 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar global = __webpack_require__(15)\n\t  , SHARED = '__core-js_shared__'\n\t  , store  = global[SHARED] || (global[SHARED] = {});\n\tmodule.exports = function(key){\n\t  return store[key] || (store[key] = {});\n\t};\n\n/***/ },\n/* 42 */\n/***/ function(module, exports) {\n\n\tvar id = 0\n\t  , px = Math.random();\n\tmodule.exports = function(key){\n\t  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));\n\t};\n\n/***/ },\n/* 43 */\n/***/ function(module, exports) {\n\n\t// IE 8- don't enum bug keys\r\n\tmodule.exports = (\r\n\t  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'\r\n\t).split(',');\n\n/***/ },\n/* 44 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(15).document && document.documentElement;\n\n/***/ },\n/* 45 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar def = __webpack_require__(20).f\n\t  , has = __webpack_require__(30)\n\t  , TAG = __webpack_require__(46)('toStringTag');\n\t\n\tmodule.exports = function(it, tag, stat){\n\t  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});\n\t};\n\n/***/ },\n/* 46 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar store      = __webpack_require__(41)('wks')\n\t  , uid        = __webpack_require__(42)\n\t  , Symbol     = __webpack_require__(15).Symbol\n\t  , USE_SYMBOL = typeof Symbol == 'function';\n\t\n\tvar $exports = module.exports = function(name){\n\t  return store[name] || (store[name] =\n\t    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));\n\t};\n\t\n\t$exports.store = store;\n\n/***/ },\n/* 47 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)\r\n\tvar has         = __webpack_require__(30)\r\n\t  , toObject    = __webpack_require__(48)\r\n\t  , IE_PROTO    = __webpack_require__(40)('IE_PROTO')\r\n\t  , ObjectProto = Object.prototype;\r\n\t\r\n\tmodule.exports = Object.getPrototypeOf || function(O){\r\n\t  O = toObject(O);\r\n\t  if(has(O, IE_PROTO))return O[IE_PROTO];\r\n\t  if(typeof O.constructor == 'function' && O instanceof O.constructor){\r\n\t    return O.constructor.prototype;\r\n\t  } return O instanceof Object ? ObjectProto : null;\r\n\t};\n\n/***/ },\n/* 48 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 7.1.13 ToObject(argument)\n\tvar defined = __webpack_require__(11);\n\tmodule.exports = function(it){\n\t  return Object(defined(it));\n\t};\n\n/***/ },\n/* 49 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar $at  = __webpack_require__(50)(true);\n\t\n\t// 21.1.3.27 String.prototype[@@iterator]()\n\t__webpack_require__(12)(String, 'String', function(iterated){\n\t  this._t = String(iterated); // target\n\t  this._i = 0;                // next index\n\t// 21.1.5.2.1 %StringIteratorPrototype%.next()\n\t}, function(){\n\t  var O     = this._t\n\t    , index = this._i\n\t    , point;\n\t  if(index >= O.length)return {value: undefined, done: true};\n\t  point = $at(O, index);\n\t  this._i += point.length;\n\t  return {value: point, done: false};\n\t});\n\n/***/ },\n/* 50 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar toInteger = __webpack_require__(38)\n\t  , defined   = __webpack_require__(11);\n\t// true  -> String#at\n\t// false -> String#codePointAt\n\tmodule.exports = function(TO_STRING){\n\t  return function(that, pos){\n\t    var s = String(defined(that))\n\t      , i = toInteger(pos)\n\t      , l = s.length\n\t      , a, b;\n\t    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;\n\t    a = s.charCodeAt(i);\n\t    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff\n\t      ? TO_STRING ? s.charAt(i) : a\n\t      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;\n\t  };\n\t};\n\n/***/ },\n/* 51 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar anObject = __webpack_require__(21)\n\t  , get      = __webpack_require__(52);\n\tmodule.exports = __webpack_require__(16).getIterator = function(it){\n\t  var iterFn = get(it);\n\t  if(typeof iterFn != 'function')throw TypeError(it + ' is not iterable!');\n\t  return anObject(iterFn.call(it));\n\t};\n\n/***/ },\n/* 52 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar classof   = __webpack_require__(53)\n\t  , ITERATOR  = __webpack_require__(46)('iterator')\n\t  , Iterators = __webpack_require__(7);\n\tmodule.exports = __webpack_require__(16).getIteratorMethod = function(it){\n\t  if(it != undefined)return it[ITERATOR]\n\t    || it['@@iterator']\n\t    || Iterators[classof(it)];\n\t};\n\n/***/ },\n/* 53 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// getting tag from 19.1.3.6 Object.prototype.toString()\n\tvar cof = __webpack_require__(10)\n\t  , TAG = __webpack_require__(46)('toStringTag')\n\t  // ES3 wrong here\n\t  , ARG = cof(function(){ return arguments; }()) == 'Arguments';\n\t\n\t// fallback for IE11 Script Access Denied error\n\tvar tryGet = function(it, key){\n\t  try {\n\t    return it[key];\n\t  } catch(e){ /* empty */ }\n\t};\n\t\n\tmodule.exports = function(it){\n\t  var O, T, B;\n\t  return it === undefined ? 'Undefined' : it === null ? 'Null'\n\t    // @@toStringTag case\n\t    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T\n\t    // builtinTag case\n\t    : ARG ? cof(O)\n\t    // ES3 arguments fallback\n\t    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;\n\t};\n\n/***/ },\n/* 54 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\texports.__esModule = true;\n\t\n\texports.default = function (instance, Constructor) {\n\t  if (!(instance instanceof Constructor)) {\n\t    throw new TypeError(\"Cannot call a class as a function\");\n\t  }\n\t};\n\n/***/ },\n/* 55 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\texports.__esModule = true;\n\t\n\tvar _defineProperty = __webpack_require__(56);\n\t\n\tvar _defineProperty2 = _interopRequireDefault(_defineProperty);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = function () {\n\t  function defineProperties(target, props) {\n\t    for (var i = 0; i < props.length; i++) {\n\t      var descriptor = props[i];\n\t      descriptor.enumerable = descriptor.enumerable || false;\n\t      descriptor.configurable = true;\n\t      if (\"value\" in descriptor) descriptor.writable = true;\n\t      (0, _defineProperty2.default)(target, descriptor.key, descriptor);\n\t    }\n\t  }\n\t\n\t  return function (Constructor, protoProps, staticProps) {\n\t    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n\t    if (staticProps) defineProperties(Constructor, staticProps);\n\t    return Constructor;\n\t  };\n\t}();\n\n/***/ },\n/* 56 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = { \"default\": __webpack_require__(57), __esModule: true };\n\n/***/ },\n/* 57 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(58);\n\tvar $Object = __webpack_require__(16).Object;\n\tmodule.exports = function defineProperty(it, key, desc){\n\t  return $Object.defineProperty(it, key, desc);\n\t};\n\n/***/ },\n/* 58 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar $export = __webpack_require__(14);\r\n\t// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)\r\n\t$export($export.S + $export.F * !__webpack_require__(24), 'Object', {defineProperty: __webpack_require__(20).f});\n\n/***/ },\n/* 59 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \"<!DOCTYPE html> <html> <head> <meta charset=UTF-8> <title>Particles</title> </head> <body> <canvas id=canvas width=100% height=100%></canvas> </body> </html>\";\n\n/***/ },\n/* 60 */\n/***/ function(module, exports) {\n\n\t// removed by extract-text-webpack-plugin\n\n/***/ },\n/* 61 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;var self = self || {};// File:src/Three.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tvar THREE = { REVISION: '76' };\r\n\t\r\n\t//\r\n\t\r\n\tif ( true ) {\r\n\t\r\n\t\t!(__WEBPACK_AMD_DEFINE_FACTORY__ = (THREE), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\t\r\n\t} else if ( 'undefined' !== typeof exports && 'undefined' !== typeof module ) {\r\n\t\r\n\t\tmodule.exports = THREE;\r\n\t\r\n\t}\r\n\t\r\n\t//\r\n\t\r\n\tif ( Number.EPSILON === undefined ) {\r\n\t\r\n\t\tNumber.EPSILON = Math.pow( 2, - 52 );\r\n\t\r\n\t}\r\n\t\r\n\t//\r\n\t\r\n\tif ( Math.sign === undefined ) {\r\n\t\r\n\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign\r\n\t\r\n\t\tMath.sign = function ( x ) {\r\n\t\r\n\t\t\treturn ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : + x;\r\n\t\r\n\t\t};\r\n\t\r\n\t}\r\n\t\r\n\tif ( Function.prototype.name === undefined && Object.defineProperty !== undefined ) {\r\n\t\r\n\t\t// Missing in IE9-11.\r\n\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name\r\n\t\r\n\t\tObject.defineProperty( Function.prototype, 'name', {\r\n\t\r\n\t\t\tget: function () {\r\n\t\r\n\t\t\t\treturn this.toString().match( /^\\s*function\\s*(\\S*)\\s*\\(/ )[ 1 ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t} );\r\n\t\r\n\t}\r\n\t\r\n\tif ( Object.assign === undefined ) {\r\n\t\r\n\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\r\n\t\r\n\t\tObject.defineProperty( Object, 'assign', {\r\n\t\r\n\t\t\twritable: true,\r\n\t\t\tconfigurable: true,\r\n\t\r\n\t\t\tvalue: function ( target ) {\r\n\t\r\n\t\t\t\t'use strict';\r\n\t\r\n\t\t\t\tif ( target === undefined || target === null ) {\r\n\t\r\n\t\t\t\t\tthrow new TypeError( \"Cannot convert first argument to object\" );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar to = Object( target );\r\n\t\r\n\t\t\t\tfor ( var i = 1, n = arguments.length; i !== n; ++ i ) {\r\n\t\r\n\t\t\t\t\tvar nextSource = arguments[ i ];\r\n\t\r\n\t\t\t\t\tif ( nextSource === undefined || nextSource === null ) continue;\r\n\t\r\n\t\t\t\t\tnextSource = Object( nextSource );\r\n\t\r\n\t\t\t\t\tvar keysArray = Object.keys( nextSource );\r\n\t\r\n\t\t\t\t\tfor ( var nextIndex = 0, len = keysArray.length; nextIndex !== len; ++ nextIndex ) {\r\n\t\r\n\t\t\t\t\t\tvar nextKey = keysArray[ nextIndex ];\r\n\t\t\t\t\t\tvar desc = Object.getOwnPropertyDescriptor( nextSource, nextKey );\r\n\t\r\n\t\t\t\t\t\tif ( desc !== undefined && desc.enumerable ) {\r\n\t\r\n\t\t\t\t\t\t\tto[ nextKey ] = nextSource[ nextKey ];\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn to;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t} );\r\n\t\r\n\t}\r\n\t\r\n\t// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent.button\r\n\t\r\n\tTHREE.MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };\r\n\t\r\n\t// GL STATE CONSTANTS\r\n\t\r\n\tTHREE.CullFaceNone = 0;\r\n\tTHREE.CullFaceBack = 1;\r\n\tTHREE.CullFaceFront = 2;\r\n\tTHREE.CullFaceFrontBack = 3;\r\n\t\r\n\tTHREE.FrontFaceDirectionCW = 0;\r\n\tTHREE.FrontFaceDirectionCCW = 1;\r\n\t\r\n\t// SHADOWING TYPES\r\n\t\r\n\tTHREE.BasicShadowMap = 0;\r\n\tTHREE.PCFShadowMap = 1;\r\n\tTHREE.PCFSoftShadowMap = 2;\r\n\t\r\n\t// MATERIAL CONSTANTS\r\n\t\r\n\t// side\r\n\t\r\n\tTHREE.FrontSide = 0;\r\n\tTHREE.BackSide = 1;\r\n\tTHREE.DoubleSide = 2;\r\n\t\r\n\t// shading\r\n\t\r\n\tTHREE.FlatShading = 1;\r\n\tTHREE.SmoothShading = 2;\r\n\t\r\n\t// colors\r\n\t\r\n\tTHREE.NoColors = 0;\r\n\tTHREE.FaceColors = 1;\r\n\tTHREE.VertexColors = 2;\r\n\t\r\n\t// blending modes\r\n\t\r\n\tTHREE.NoBlending = 0;\r\n\tTHREE.NormalBlending = 1;\r\n\tTHREE.AdditiveBlending = 2;\r\n\tTHREE.SubtractiveBlending = 3;\r\n\tTHREE.MultiplyBlending = 4;\r\n\tTHREE.CustomBlending = 5;\r\n\t\r\n\t// custom blending equations\r\n\t// (numbers start from 100 not to clash with other\r\n\t// mappings to OpenGL constants defined in Texture.js)\r\n\t\r\n\tTHREE.AddEquation = 100;\r\n\tTHREE.SubtractEquation = 101;\r\n\tTHREE.ReverseSubtractEquation = 102;\r\n\tTHREE.MinEquation = 103;\r\n\tTHREE.MaxEquation = 104;\r\n\t\r\n\t// custom blending destination factors\r\n\t\r\n\tTHREE.ZeroFactor = 200;\r\n\tTHREE.OneFactor = 201;\r\n\tTHREE.SrcColorFactor = 202;\r\n\tTHREE.OneMinusSrcColorFactor = 203;\r\n\tTHREE.SrcAlphaFactor = 204;\r\n\tTHREE.OneMinusSrcAlphaFactor = 205;\r\n\tTHREE.DstAlphaFactor = 206;\r\n\tTHREE.OneMinusDstAlphaFactor = 207;\r\n\t\r\n\t// custom blending source factors\r\n\t\r\n\t//THREE.ZeroFactor = 200;\r\n\t//THREE.OneFactor = 201;\r\n\t//THREE.SrcAlphaFactor = 204;\r\n\t//THREE.OneMinusSrcAlphaFactor = 205;\r\n\t//THREE.DstAlphaFactor = 206;\r\n\t//THREE.OneMinusDstAlphaFactor = 207;\r\n\tTHREE.DstColorFactor = 208;\r\n\tTHREE.OneMinusDstColorFactor = 209;\r\n\tTHREE.SrcAlphaSaturateFactor = 210;\r\n\t\r\n\t// depth modes\r\n\t\r\n\tTHREE.NeverDepth = 0;\r\n\tTHREE.AlwaysDepth = 1;\r\n\tTHREE.LessDepth = 2;\r\n\tTHREE.LessEqualDepth = 3;\r\n\tTHREE.EqualDepth = 4;\r\n\tTHREE.GreaterEqualDepth = 5;\r\n\tTHREE.GreaterDepth = 6;\r\n\tTHREE.NotEqualDepth = 7;\r\n\t\r\n\t\r\n\t// TEXTURE CONSTANTS\r\n\t\r\n\tTHREE.MultiplyOperation = 0;\r\n\tTHREE.MixOperation = 1;\r\n\tTHREE.AddOperation = 2;\r\n\t\r\n\t// Tone Mapping modes\r\n\t\r\n\tTHREE.NoToneMapping = 0; // do not do any tone mapping, not even exposure (required for special purpose passes.)\r\n\tTHREE.LinearToneMapping = 1; // only apply exposure.\r\n\tTHREE.ReinhardToneMapping = 2;\r\n\tTHREE.Uncharted2ToneMapping = 3; // John Hable\r\n\tTHREE.CineonToneMapping = 4;  // optimized filmic operator by Jim Hejl and Richard Burgess-Dawson\r\n\t\r\n\t// Mapping modes\r\n\t\r\n\tTHREE.UVMapping = 300;\r\n\t\r\n\tTHREE.CubeReflectionMapping = 301;\r\n\tTHREE.CubeRefractionMapping = 302;\r\n\t\r\n\tTHREE.EquirectangularReflectionMapping = 303;\r\n\tTHREE.EquirectangularRefractionMapping = 304;\r\n\t\r\n\tTHREE.SphericalReflectionMapping = 305;\r\n\tTHREE.CubeUVReflectionMapping = 306;\r\n\tTHREE.CubeUVRefractionMapping = 307;\r\n\t\r\n\t// Wrapping modes\r\n\t\r\n\tTHREE.RepeatWrapping = 1000;\r\n\tTHREE.ClampToEdgeWrapping = 1001;\r\n\tTHREE.MirroredRepeatWrapping = 1002;\r\n\t\r\n\t// Filters\r\n\t\r\n\tTHREE.NearestFilter = 1003;\r\n\tTHREE.NearestMipMapNearestFilter = 1004;\r\n\tTHREE.NearestMipMapLinearFilter = 1005;\r\n\tTHREE.LinearFilter = 1006;\r\n\tTHREE.LinearMipMapNearestFilter = 1007;\r\n\tTHREE.LinearMipMapLinearFilter = 1008;\r\n\t\r\n\t// Data types\r\n\t\r\n\tTHREE.UnsignedByteType = 1009;\r\n\tTHREE.ByteType = 1010;\r\n\tTHREE.ShortType = 1011;\r\n\tTHREE.UnsignedShortType = 1012;\r\n\tTHREE.IntType = 1013;\r\n\tTHREE.UnsignedIntType = 1014;\r\n\tTHREE.FloatType = 1015;\r\n\tTHREE.HalfFloatType = 1025;\r\n\t\r\n\t// Pixel types\r\n\t\r\n\t//THREE.UnsignedByteType = 1009;\r\n\tTHREE.UnsignedShort4444Type = 1016;\r\n\tTHREE.UnsignedShort5551Type = 1017;\r\n\tTHREE.UnsignedShort565Type = 1018;\r\n\t\r\n\t// Pixel formats\r\n\t\r\n\tTHREE.AlphaFormat = 1019;\r\n\tTHREE.RGBFormat = 1020;\r\n\tTHREE.RGBAFormat = 1021;\r\n\tTHREE.LuminanceFormat = 1022;\r\n\tTHREE.LuminanceAlphaFormat = 1023;\r\n\t// THREE.RGBEFormat handled as THREE.RGBAFormat in shaders\r\n\tTHREE.RGBEFormat = THREE.RGBAFormat; //1024;\r\n\tTHREE.DepthFormat = 1026;\r\n\t\r\n\t// DDS / ST3C Compressed texture formats\r\n\t\r\n\tTHREE.RGB_S3TC_DXT1_Format = 2001;\r\n\tTHREE.RGBA_S3TC_DXT1_Format = 2002;\r\n\tTHREE.RGBA_S3TC_DXT3_Format = 2003;\r\n\tTHREE.RGBA_S3TC_DXT5_Format = 2004;\r\n\t\r\n\t\r\n\t// PVRTC compressed texture formats\r\n\t\r\n\tTHREE.RGB_PVRTC_4BPPV1_Format = 2100;\r\n\tTHREE.RGB_PVRTC_2BPPV1_Format = 2101;\r\n\tTHREE.RGBA_PVRTC_4BPPV1_Format = 2102;\r\n\tTHREE.RGBA_PVRTC_2BPPV1_Format = 2103;\r\n\t\r\n\t// ETC compressed texture formats\r\n\t\r\n\tTHREE.RGB_ETC1_Format = 2151;\r\n\t\r\n\t// Loop styles for AnimationAction\r\n\t\r\n\tTHREE.LoopOnce = 2200;\r\n\tTHREE.LoopRepeat = 2201;\r\n\tTHREE.LoopPingPong = 2202;\r\n\t\r\n\t// Interpolation\r\n\t\r\n\tTHREE.InterpolateDiscrete = 2300;\r\n\tTHREE.InterpolateLinear = 2301;\r\n\tTHREE.InterpolateSmooth = 2302;\r\n\t\r\n\t// Interpolant ending modes\r\n\t\r\n\tTHREE.ZeroCurvatureEnding = 2400;\r\n\tTHREE.ZeroSlopeEnding = 2401;\r\n\tTHREE.WrapAroundEnding = 2402;\r\n\t\r\n\t// Triangle Draw modes\r\n\t\r\n\tTHREE.TrianglesDrawMode = 0;\r\n\tTHREE.TriangleStripDrawMode = 1;\r\n\tTHREE.TriangleFanDrawMode = 2;\r\n\t\r\n\t// Texture Encodings\r\n\t\r\n\tTHREE.LinearEncoding = 3000; // No encoding at all.\r\n\tTHREE.sRGBEncoding = 3001;\r\n\tTHREE.GammaEncoding = 3007; // uses GAMMA_FACTOR, for backwards compatibility with WebGLRenderer.gammaInput/gammaOutput\r\n\t\r\n\t// The following Texture Encodings are for RGB-only (no alpha) HDR light emission sources.\r\n\t// These encodings should not specified as output encodings except in rare situations.\r\n\tTHREE.RGBEEncoding = 3002; // AKA Radiance.\r\n\tTHREE.LogLuvEncoding = 3003;\r\n\tTHREE.RGBM7Encoding = 3004;\r\n\tTHREE.RGBM16Encoding = 3005;\r\n\tTHREE.RGBDEncoding = 3006; // MaxRange is 256.\r\n\t\r\n\t// Depth packing strategies\r\n\t\r\n\tTHREE.BasicDepthPacking = 3200;  // for writing to float textures for high precision or for visualizing results in RGB buffers\r\n\tTHREE.RGBADepthPacking = 3201; // for packing into RGBA buffers.\r\n\t\r\n\t// File:src/math/Color.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.Color = function ( color ) {\r\n\t\r\n\t\tif ( arguments.length === 3 ) {\r\n\t\r\n\t\t\treturn this.fromArray( arguments );\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn this.set( color );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Color.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Color,\r\n\t\r\n\t\tr: 1, g: 1, b: 1,\r\n\t\r\n\t\tset: function ( value ) {\r\n\t\r\n\t\t\tif ( value instanceof THREE.Color ) {\r\n\t\r\n\t\t\t\tthis.copy( value );\r\n\t\r\n\t\t\t} else if ( typeof value === 'number' ) {\r\n\t\r\n\t\t\t\tthis.setHex( value );\r\n\t\r\n\t\t\t} else if ( typeof value === 'string' ) {\r\n\t\r\n\t\t\t\tthis.setStyle( value );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetScalar: function ( scalar ) {\r\n\t\r\n\t\t\tthis.r = scalar;\r\n\t\t\tthis.g = scalar;\r\n\t\t\tthis.b = scalar;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetHex: function ( hex ) {\r\n\t\r\n\t\t\thex = Math.floor( hex );\r\n\t\r\n\t\t\tthis.r = ( hex >> 16 & 255 ) / 255;\r\n\t\t\tthis.g = ( hex >> 8 & 255 ) / 255;\r\n\t\t\tthis.b = ( hex & 255 ) / 255;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetRGB: function ( r, g, b ) {\r\n\t\r\n\t\t\tthis.r = r;\r\n\t\t\tthis.g = g;\r\n\t\t\tthis.b = b;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetHSL: function () {\r\n\t\r\n\t\t\tfunction hue2rgb( p, q, t ) {\r\n\t\r\n\t\t\t\tif ( t < 0 ) t += 1;\r\n\t\t\t\tif ( t > 1 ) t -= 1;\r\n\t\t\t\tif ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;\r\n\t\t\t\tif ( t < 1 / 2 ) return q;\r\n\t\t\t\tif ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );\r\n\t\t\t\treturn p;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn function ( h, s, l ) {\r\n\t\r\n\t\t\t\t// h,s,l ranges are in 0.0 - 1.0\r\n\t\t\t\th = THREE.Math.euclideanModulo( h, 1 );\r\n\t\t\t\ts = THREE.Math.clamp( s, 0, 1 );\r\n\t\t\t\tl = THREE.Math.clamp( l, 0, 1 );\r\n\t\r\n\t\t\t\tif ( s === 0 ) {\r\n\t\r\n\t\t\t\t\tthis.r = this.g = this.b = l;\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tvar p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );\r\n\t\t\t\t\tvar q = ( 2 * l ) - p;\r\n\t\r\n\t\t\t\t\tthis.r = hue2rgb( q, p, h + 1 / 3 );\r\n\t\t\t\t\tthis.g = hue2rgb( q, p, h );\r\n\t\t\t\t\tthis.b = hue2rgb( q, p, h - 1 / 3 );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tsetStyle: function ( style ) {\r\n\t\r\n\t\t\tfunction handleAlpha( string ) {\r\n\t\r\n\t\t\t\tif ( string === undefined ) return;\r\n\t\r\n\t\t\t\tif ( parseFloat( string ) < 1 ) {\r\n\t\r\n\t\t\t\t\tconsole.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\r\n\t\t\tvar m;\r\n\t\r\n\t\t\tif ( m = /^((?:rgb|hsl)a?)\\(\\s*([^\\)]*)\\)/.exec( style ) ) {\r\n\t\r\n\t\t\t\t// rgb / hsl\r\n\t\r\n\t\t\t\tvar color;\r\n\t\t\t\tvar name = m[ 1 ];\r\n\t\t\t\tvar components = m[ 2 ];\r\n\t\r\n\t\t\t\tswitch ( name ) {\r\n\t\r\n\t\t\t\t\tcase 'rgb':\r\n\t\t\t\t\tcase 'rgba':\r\n\t\r\n\t\t\t\t\t\tif ( color = /^(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\r\n\t\r\n\t\t\t\t\t\t\t// rgb(255,0,0) rgba(255,0,0,0.5)\r\n\t\t\t\t\t\t\tthis.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;\r\n\t\t\t\t\t\t\tthis.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;\r\n\t\t\t\t\t\t\tthis.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;\r\n\t\r\n\t\t\t\t\t\t\thandleAlpha( color[ 5 ] );\r\n\t\r\n\t\t\t\t\t\t\treturn this;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tif ( color = /^(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\r\n\t\r\n\t\t\t\t\t\t\t// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)\r\n\t\t\t\t\t\t\tthis.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;\r\n\t\t\t\t\t\t\tthis.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;\r\n\t\t\t\t\t\t\tthis.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;\r\n\t\r\n\t\t\t\t\t\t\thandleAlpha( color[ 5 ] );\r\n\t\r\n\t\t\t\t\t\t\treturn this;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'hsl':\r\n\t\t\t\t\tcase 'hsla':\r\n\t\r\n\t\t\t\t\t\tif ( color = /^([0-9]*\\.?[0-9]+)\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\r\n\t\r\n\t\t\t\t\t\t\t// hsl(120,50%,50%) hsla(120,50%,50%,0.5)\r\n\t\t\t\t\t\t\tvar h = parseFloat( color[ 1 ] ) / 360;\r\n\t\t\t\t\t\t\tvar s = parseInt( color[ 2 ], 10 ) / 100;\r\n\t\t\t\t\t\t\tvar l = parseInt( color[ 3 ], 10 ) / 100;\r\n\t\r\n\t\t\t\t\t\t\thandleAlpha( color[ 5 ] );\r\n\t\r\n\t\t\t\t\t\t\treturn this.setHSL( h, s, l );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else if ( m = /^\\#([A-Fa-f0-9]+)$/.exec( style ) ) {\r\n\t\r\n\t\t\t\t// hex color\r\n\t\r\n\t\t\t\tvar hex = m[ 1 ];\r\n\t\t\t\tvar size = hex.length;\r\n\t\r\n\t\t\t\tif ( size === 3 ) {\r\n\t\r\n\t\t\t\t\t// #ff0\r\n\t\t\t\t\tthis.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;\r\n\t\t\t\t\tthis.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;\r\n\t\t\t\t\tthis.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;\r\n\t\r\n\t\t\t\t\treturn this;\r\n\t\r\n\t\t\t\t} else if ( size === 6 ) {\r\n\t\r\n\t\t\t\t\t// #ff0000\r\n\t\t\t\t\tthis.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;\r\n\t\t\t\t\tthis.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;\r\n\t\t\t\t\tthis.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;\r\n\t\r\n\t\t\t\t\treturn this;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( style && style.length > 0 ) {\r\n\t\r\n\t\t\t\t// color keywords\r\n\t\t\t\tvar hex = THREE.ColorKeywords[ style ];\r\n\t\r\n\t\t\t\tif ( hex !== undefined ) {\r\n\t\r\n\t\t\t\t\t// red\r\n\t\t\t\t\tthis.setHex( hex );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t// unknown color\r\n\t\t\t\t\tconsole.warn( 'THREE.Color: Unknown color ' + style );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new this.constructor( this.r, this.g, this.b );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( color ) {\r\n\t\r\n\t\t\tthis.r = color.r;\r\n\t\t\tthis.g = color.g;\r\n\t\t\tthis.b = color.b;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopyGammaToLinear: function ( color, gammaFactor ) {\r\n\t\r\n\t\t\tif ( gammaFactor === undefined ) gammaFactor = 2.0;\r\n\t\r\n\t\t\tthis.r = Math.pow( color.r, gammaFactor );\r\n\t\t\tthis.g = Math.pow( color.g, gammaFactor );\r\n\t\t\tthis.b = Math.pow( color.b, gammaFactor );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopyLinearToGamma: function ( color, gammaFactor ) {\r\n\t\r\n\t\t\tif ( gammaFactor === undefined ) gammaFactor = 2.0;\r\n\t\r\n\t\t\tvar safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;\r\n\t\r\n\t\t\tthis.r = Math.pow( color.r, safeInverse );\r\n\t\t\tthis.g = Math.pow( color.g, safeInverse );\r\n\t\t\tthis.b = Math.pow( color.b, safeInverse );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tconvertGammaToLinear: function () {\r\n\t\r\n\t\t\tvar r = this.r, g = this.g, b = this.b;\r\n\t\r\n\t\t\tthis.r = r * r;\r\n\t\t\tthis.g = g * g;\r\n\t\t\tthis.b = b * b;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tconvertLinearToGamma: function () {\r\n\t\r\n\t\t\tthis.r = Math.sqrt( this.r );\r\n\t\t\tthis.g = Math.sqrt( this.g );\r\n\t\t\tthis.b = Math.sqrt( this.b );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetHex: function () {\r\n\t\r\n\t\t\treturn ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetHexString: function () {\r\n\t\r\n\t\t\treturn ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetHSL: function ( optionalTarget ) {\r\n\t\r\n\t\t\t// h,s,l ranges are in 0.0 - 1.0\r\n\t\r\n\t\t\tvar hsl = optionalTarget || { h: 0, s: 0, l: 0 };\r\n\t\r\n\t\t\tvar r = this.r, g = this.g, b = this.b;\r\n\t\r\n\t\t\tvar max = Math.max( r, g, b );\r\n\t\t\tvar min = Math.min( r, g, b );\r\n\t\r\n\t\t\tvar hue, saturation;\r\n\t\t\tvar lightness = ( min + max ) / 2.0;\r\n\t\r\n\t\t\tif ( min === max ) {\r\n\t\r\n\t\t\t\thue = 0;\r\n\t\t\t\tsaturation = 0;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tvar delta = max - min;\r\n\t\r\n\t\t\t\tsaturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );\r\n\t\r\n\t\t\t\tswitch ( max ) {\r\n\t\r\n\t\t\t\t\tcase r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;\r\n\t\t\t\t\tcase g: hue = ( b - r ) / delta + 2; break;\r\n\t\t\t\t\tcase b: hue = ( r - g ) / delta + 4; break;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\thue /= 6;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\thsl.h = hue;\r\n\t\t\thsl.s = saturation;\r\n\t\t\thsl.l = lightness;\r\n\t\r\n\t\t\treturn hsl;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetStyle: function () {\r\n\t\r\n\t\t\treturn 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';\r\n\t\r\n\t\t},\r\n\t\r\n\t\toffsetHSL: function ( h, s, l ) {\r\n\t\r\n\t\t\tvar hsl = this.getHSL();\r\n\t\r\n\t\t\thsl.h += h; hsl.s += s; hsl.l += l;\r\n\t\r\n\t\t\tthis.setHSL( hsl.h, hsl.s, hsl.l );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tadd: function ( color ) {\r\n\t\r\n\t\t\tthis.r += color.r;\r\n\t\t\tthis.g += color.g;\r\n\t\t\tthis.b += color.b;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\taddColors: function ( color1, color2 ) {\r\n\t\r\n\t\t\tthis.r = color1.r + color2.r;\r\n\t\t\tthis.g = color1.g + color2.g;\r\n\t\t\tthis.b = color1.b + color2.b;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\taddScalar: function ( s ) {\r\n\t\r\n\t\t\tthis.r += s;\r\n\t\t\tthis.g += s;\r\n\t\t\tthis.b += s;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmultiply: function ( color ) {\r\n\t\r\n\t\t\tthis.r *= color.r;\r\n\t\t\tthis.g *= color.g;\r\n\t\t\tthis.b *= color.b;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmultiplyScalar: function ( s ) {\r\n\t\r\n\t\t\tthis.r *= s;\r\n\t\t\tthis.g *= s;\r\n\t\t\tthis.b *= s;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlerp: function ( color, alpha ) {\r\n\t\r\n\t\t\tthis.r += ( color.r - this.r ) * alpha;\r\n\t\t\tthis.g += ( color.g - this.g ) * alpha;\r\n\t\t\tthis.b += ( color.b - this.b ) * alpha;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tequals: function ( c ) {\r\n\t\r\n\t\t\treturn ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfromArray: function ( array, offset ) {\r\n\t\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\r\n\t\t\tthis.r = array[ offset ];\r\n\t\t\tthis.g = array[ offset + 1 ];\r\n\t\t\tthis.b = array[ offset + 2 ];\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttoArray: function ( array, offset ) {\r\n\t\r\n\t\t\tif ( array === undefined ) array = [];\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\r\n\t\t\tarray[ offset ] = this.r;\r\n\t\t\tarray[ offset + 1 ] = this.g;\r\n\t\t\tarray[ offset + 2 ] = this.b;\r\n\t\r\n\t\t\treturn array;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,\r\n\t'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,\r\n\t'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,\r\n\t'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,\r\n\t'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,\r\n\t'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,\r\n\t'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,\r\n\t'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,\r\n\t'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,\r\n\t'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,\r\n\t'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,\r\n\t'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,\r\n\t'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,\r\n\t'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,\r\n\t'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,\r\n\t'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,\r\n\t'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,\r\n\t'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,\r\n\t'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,\r\n\t'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,\r\n\t'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,\r\n\t'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,\r\n\t'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,\r\n\t'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };\r\n\t\r\n\t// File:src/math/Quaternion.js\r\n\t\r\n\t/**\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t * @author bhouston / http://clara.io\r\n\t */\r\n\t\r\n\tTHREE.Quaternion = function ( x, y, z, w ) {\r\n\t\r\n\t\tthis._x = x || 0;\r\n\t\tthis._y = y || 0;\r\n\t\tthis._z = z || 0;\r\n\t\tthis._w = ( w !== undefined ) ? w : 1;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Quaternion.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Quaternion,\r\n\t\r\n\t\tget x () {\r\n\t\r\n\t\t\treturn this._x;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tset x ( value ) {\r\n\t\r\n\t\t\tthis._x = value;\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t},\r\n\t\r\n\t\tget y () {\r\n\t\r\n\t\t\treturn this._y;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tset y ( value ) {\r\n\t\r\n\t\t\tthis._y = value;\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t},\r\n\t\r\n\t\tget z () {\r\n\t\r\n\t\t\treturn this._z;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tset z ( value ) {\r\n\t\r\n\t\t\tthis._z = value;\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t},\r\n\t\r\n\t\tget w () {\r\n\t\r\n\t\t\treturn this._w;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tset w ( value ) {\r\n\t\r\n\t\t\tthis._w = value;\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t},\r\n\t\r\n\t\tset: function ( x, y, z, w ) {\r\n\t\r\n\t\t\tthis._x = x;\r\n\t\t\tthis._y = y;\r\n\t\t\tthis._z = z;\r\n\t\t\tthis._w = w;\r\n\t\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new this.constructor( this._x, this._y, this._z, this._w );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( quaternion ) {\r\n\t\r\n\t\t\tthis._x = quaternion.x;\r\n\t\t\tthis._y = quaternion.y;\r\n\t\t\tthis._z = quaternion.z;\r\n\t\t\tthis._w = quaternion.w;\r\n\t\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromEuler: function ( euler, update ) {\r\n\t\r\n\t\t\tif ( euler instanceof THREE.Euler === false ) {\r\n\t\r\n\t\t\t\tthrow new Error( 'THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// http://www.mathworks.com/matlabcentral/fileexchange/\r\n\t\t\t// \t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\r\n\t\t\t//\tcontent/SpinCalc.m\r\n\t\r\n\t\t\tvar c1 = Math.cos( euler._x / 2 );\r\n\t\t\tvar c2 = Math.cos( euler._y / 2 );\r\n\t\t\tvar c3 = Math.cos( euler._z / 2 );\r\n\t\t\tvar s1 = Math.sin( euler._x / 2 );\r\n\t\t\tvar s2 = Math.sin( euler._y / 2 );\r\n\t\t\tvar s3 = Math.sin( euler._z / 2 );\r\n\t\r\n\t\t\tvar order = euler.order;\r\n\t\r\n\t\t\tif ( order === 'XYZ' ) {\r\n\t\r\n\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\r\n\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\r\n\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\r\n\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\r\n\t\r\n\t\t\t} else if ( order === 'YXZ' ) {\r\n\t\r\n\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\r\n\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\r\n\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\r\n\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\r\n\t\r\n\t\t\t} else if ( order === 'ZXY' ) {\r\n\t\r\n\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\r\n\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\r\n\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\r\n\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\r\n\t\r\n\t\t\t} else if ( order === 'ZYX' ) {\r\n\t\r\n\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\r\n\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\r\n\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\r\n\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\r\n\t\r\n\t\t\t} else if ( order === 'YZX' ) {\r\n\t\r\n\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\r\n\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\r\n\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\r\n\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\r\n\t\r\n\t\t\t} else if ( order === 'XZY' ) {\r\n\t\r\n\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\r\n\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\r\n\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\r\n\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( update !== false ) this.onChangeCallback();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromAxisAngle: function ( axis, angle ) {\r\n\t\r\n\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\r\n\t\r\n\t\t\t// assumes axis is normalized\r\n\t\r\n\t\t\tvar halfAngle = angle / 2, s = Math.sin( halfAngle );\r\n\t\r\n\t\t\tthis._x = axis.x * s;\r\n\t\t\tthis._y = axis.y * s;\r\n\t\t\tthis._z = axis.z * s;\r\n\t\t\tthis._w = Math.cos( halfAngle );\r\n\t\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromRotationMatrix: function ( m ) {\r\n\t\r\n\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\r\n\t\r\n\t\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\r\n\t\r\n\t\t\tvar te = m.elements,\r\n\t\r\n\t\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\r\n\t\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\r\n\t\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],\r\n\t\r\n\t\t\t\ttrace = m11 + m22 + m33,\r\n\t\t\t\ts;\r\n\t\r\n\t\t\tif ( trace > 0 ) {\r\n\t\r\n\t\t\t\ts = 0.5 / Math.sqrt( trace + 1.0 );\r\n\t\r\n\t\t\t\tthis._w = 0.25 / s;\r\n\t\t\t\tthis._x = ( m32 - m23 ) * s;\r\n\t\t\t\tthis._y = ( m13 - m31 ) * s;\r\n\t\t\t\tthis._z = ( m21 - m12 ) * s;\r\n\t\r\n\t\t\t} else if ( m11 > m22 && m11 > m33 ) {\r\n\t\r\n\t\t\t\ts = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );\r\n\t\r\n\t\t\t\tthis._w = ( m32 - m23 ) / s;\r\n\t\t\t\tthis._x = 0.25 * s;\r\n\t\t\t\tthis._y = ( m12 + m21 ) / s;\r\n\t\t\t\tthis._z = ( m13 + m31 ) / s;\r\n\t\r\n\t\t\t} else if ( m22 > m33 ) {\r\n\t\r\n\t\t\t\ts = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );\r\n\t\r\n\t\t\t\tthis._w = ( m13 - m31 ) / s;\r\n\t\t\t\tthis._x = ( m12 + m21 ) / s;\r\n\t\t\t\tthis._y = 0.25 * s;\r\n\t\t\t\tthis._z = ( m23 + m32 ) / s;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\ts = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );\r\n\t\r\n\t\t\t\tthis._w = ( m21 - m12 ) / s;\r\n\t\t\t\tthis._x = ( m13 + m31 ) / s;\r\n\t\t\t\tthis._y = ( m23 + m32 ) / s;\r\n\t\t\t\tthis._z = 0.25 * s;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromUnitVectors: function () {\r\n\t\r\n\t\t\t// http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final\r\n\t\r\n\t\t\t// assumes direction vectors vFrom and vTo are normalized\r\n\t\r\n\t\t\tvar v1, r;\r\n\t\r\n\t\t\tvar EPS = 0.000001;\r\n\t\r\n\t\t\treturn function ( vFrom, vTo ) {\r\n\t\r\n\t\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\t\r\n\t\t\t\tr = vFrom.dot( vTo ) + 1;\r\n\t\r\n\t\t\t\tif ( r < EPS ) {\r\n\t\r\n\t\t\t\t\tr = 0;\r\n\t\r\n\t\t\t\t\tif ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {\r\n\t\r\n\t\t\t\t\t\tv1.set( - vFrom.y, vFrom.x, 0 );\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tv1.set( 0, - vFrom.z, vFrom.y );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tv1.crossVectors( vFrom, vTo );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tthis._x = v1.x;\r\n\t\t\t\tthis._y = v1.y;\r\n\t\t\t\tthis._z = v1.z;\r\n\t\t\t\tthis._w = r;\r\n\t\r\n\t\t\t\tthis.normalize();\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tinverse: function () {\r\n\t\r\n\t\t\tthis.conjugate().normalize();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tconjugate: function () {\r\n\t\r\n\t\t\tthis._x *= - 1;\r\n\t\t\tthis._y *= - 1;\r\n\t\t\tthis._z *= - 1;\r\n\t\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdot: function ( v ) {\r\n\t\r\n\t\t\treturn this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlengthSq: function () {\r\n\t\r\n\t\t\treturn this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlength: function () {\r\n\t\r\n\t\t\treturn Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tnormalize: function () {\r\n\t\r\n\t\t\tvar l = this.length();\r\n\t\r\n\t\t\tif ( l === 0 ) {\r\n\t\r\n\t\t\t\tthis._x = 0;\r\n\t\t\t\tthis._y = 0;\r\n\t\t\t\tthis._z = 0;\r\n\t\t\t\tthis._w = 1;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tl = 1 / l;\r\n\t\r\n\t\t\t\tthis._x = this._x * l;\r\n\t\t\t\tthis._y = this._y * l;\r\n\t\t\t\tthis._z = this._z * l;\r\n\t\t\t\tthis._w = this._w * l;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmultiply: function ( q, p ) {\r\n\t\r\n\t\t\tif ( p !== undefined ) {\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );\r\n\t\t\t\treturn this.multiplyQuaternions( q, p );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this.multiplyQuaternions( this, q );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmultiplyQuaternions: function ( a, b ) {\r\n\t\r\n\t\t\t// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\r\n\t\r\n\t\t\tvar qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;\r\n\t\t\tvar qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;\r\n\t\r\n\t\t\tthis._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\r\n\t\t\tthis._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\r\n\t\t\tthis._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\r\n\t\t\tthis._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\r\n\t\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tslerp: function ( qb, t ) {\r\n\t\r\n\t\t\tif ( t === 0 ) return this;\r\n\t\t\tif ( t === 1 ) return this.copy( qb );\r\n\t\r\n\t\t\tvar x = this._x, y = this._y, z = this._z, w = this._w;\r\n\t\r\n\t\t\t// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\r\n\t\r\n\t\t\tvar cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;\r\n\t\r\n\t\t\tif ( cosHalfTheta < 0 ) {\r\n\t\r\n\t\t\t\tthis._w = - qb._w;\r\n\t\t\t\tthis._x = - qb._x;\r\n\t\t\t\tthis._y = - qb._y;\r\n\t\t\t\tthis._z = - qb._z;\r\n\t\r\n\t\t\t\tcosHalfTheta = - cosHalfTheta;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tthis.copy( qb );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( cosHalfTheta >= 1.0 ) {\r\n\t\r\n\t\t\t\tthis._w = w;\r\n\t\t\t\tthis._x = x;\r\n\t\t\t\tthis._y = y;\r\n\t\t\t\tthis._z = z;\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );\r\n\t\r\n\t\t\tif ( Math.abs( sinHalfTheta ) < 0.001 ) {\r\n\t\r\n\t\t\t\tthis._w = 0.5 * ( w + this._w );\r\n\t\t\t\tthis._x = 0.5 * ( x + this._x );\r\n\t\t\t\tthis._y = 0.5 * ( y + this._y );\r\n\t\t\t\tthis._z = 0.5 * ( z + this._z );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );\r\n\t\t\tvar ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,\r\n\t\t\tratioB = Math.sin( t * halfTheta ) / sinHalfTheta;\r\n\t\r\n\t\t\tthis._w = ( w * ratioA + this._w * ratioB );\r\n\t\t\tthis._x = ( x * ratioA + this._x * ratioB );\r\n\t\t\tthis._y = ( y * ratioA + this._y * ratioB );\r\n\t\t\tthis._z = ( z * ratioA + this._z * ratioB );\r\n\t\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tequals: function ( quaternion ) {\r\n\t\r\n\t\t\treturn ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfromArray: function ( array, offset ) {\r\n\t\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\r\n\t\t\tthis._x = array[ offset ];\r\n\t\t\tthis._y = array[ offset + 1 ];\r\n\t\t\tthis._z = array[ offset + 2 ];\r\n\t\t\tthis._w = array[ offset + 3 ];\r\n\t\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttoArray: function ( array, offset ) {\r\n\t\r\n\t\t\tif ( array === undefined ) array = [];\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\r\n\t\t\tarray[ offset ] = this._x;\r\n\t\t\tarray[ offset + 1 ] = this._y;\r\n\t\t\tarray[ offset + 2 ] = this._z;\r\n\t\t\tarray[ offset + 3 ] = this._w;\r\n\t\r\n\t\t\treturn array;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tonChange: function ( callback ) {\r\n\t\r\n\t\t\tthis.onChangeCallback = callback;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tonChangeCallback: function () {}\r\n\t\r\n\t};\r\n\t\r\n\tObject.assign( THREE.Quaternion, {\r\n\t\r\n\t\tslerp: function( qa, qb, qm, t ) {\r\n\t\r\n\t\t\treturn qm.copy( qa ).slerp( qb, t );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tslerpFlat: function(\r\n\t\t\t\tdst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {\r\n\t\r\n\t\t\t// fuzz-free, array-based Quaternion SLERP operation\r\n\t\r\n\t\t\tvar x0 = src0[ srcOffset0 + 0 ],\r\n\t\t\t\ty0 = src0[ srcOffset0 + 1 ],\r\n\t\t\t\tz0 = src0[ srcOffset0 + 2 ],\r\n\t\t\t\tw0 = src0[ srcOffset0 + 3 ],\r\n\t\r\n\t\t\t\tx1 = src1[ srcOffset1 + 0 ],\r\n\t\t\t\ty1 = src1[ srcOffset1 + 1 ],\r\n\t\t\t\tz1 = src1[ srcOffset1 + 2 ],\r\n\t\t\t\tw1 = src1[ srcOffset1 + 3 ];\r\n\t\r\n\t\t\tif ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {\r\n\t\r\n\t\t\t\tvar s = 1 - t,\r\n\t\r\n\t\t\t\t\tcos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,\r\n\t\r\n\t\t\t\t\tdir = ( cos >= 0 ? 1 : - 1 ),\r\n\t\t\t\t\tsqrSin = 1 - cos * cos;\r\n\t\r\n\t\t\t\t// Skip the Slerp for tiny steps to avoid numeric problems:\r\n\t\t\t\tif ( sqrSin > Number.EPSILON ) {\r\n\t\r\n\t\t\t\t\tvar sin = Math.sqrt( sqrSin ),\r\n\t\t\t\t\t\tlen = Math.atan2( sin, cos * dir );\r\n\t\r\n\t\t\t\t\ts = Math.sin( s * len ) / sin;\r\n\t\t\t\t\tt = Math.sin( t * len ) / sin;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar tDir = t * dir;\r\n\t\r\n\t\t\t\tx0 = x0 * s + x1 * tDir;\r\n\t\t\t\ty0 = y0 * s + y1 * tDir;\r\n\t\t\t\tz0 = z0 * s + z1 * tDir;\r\n\t\t\t\tw0 = w0 * s + w1 * tDir;\r\n\t\r\n\t\t\t\t// Normalize in case we just did a lerp:\r\n\t\t\t\tif ( s === 1 - t ) {\r\n\t\r\n\t\t\t\t\tvar f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );\r\n\t\r\n\t\t\t\t\tx0 *= f;\r\n\t\t\t\t\ty0 *= f;\r\n\t\t\t\t\tz0 *= f;\r\n\t\t\t\t\tw0 *= f;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tdst[ dstOffset ] = x0;\r\n\t\t\tdst[ dstOffset + 1 ] = y0;\r\n\t\t\tdst[ dstOffset + 2 ] = z0;\r\n\t\t\tdst[ dstOffset + 3 ] = w0;\r\n\t\r\n\t\t}\r\n\t\r\n\t} );\r\n\t\r\n\t// File:src/math/Vector2.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author philogb / http://blog.thejit.org/\r\n\t * @author egraether / http://egraether.com/\r\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\r\n\t */\r\n\t\r\n\tTHREE.Vector2 = function ( x, y ) {\r\n\t\r\n\t\tthis.x = x || 0;\r\n\t\tthis.y = y || 0;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Vector2.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Vector2,\r\n\t\r\n\t\tget width() {\r\n\t\r\n\t\t\treturn this.x;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tset width( value ) {\r\n\t\r\n\t\t\tthis.x = value;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tget height() {\r\n\t\r\n\t\t\treturn this.y;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tset height( value ) {\r\n\t\r\n\t\t\tthis.y = value;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t//\r\n\t\r\n\t\tset: function ( x, y ) {\r\n\t\r\n\t\t\tthis.x = x;\r\n\t\t\tthis.y = y;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetScalar: function ( scalar ) {\r\n\t\r\n\t\t\tthis.x = scalar;\r\n\t\t\tthis.y = scalar;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetX: function ( x ) {\r\n\t\r\n\t\t\tthis.x = x;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetY: function ( y ) {\r\n\t\r\n\t\t\tthis.y = y;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetComponent: function ( index, value ) {\r\n\t\r\n\t\t\tswitch ( index ) {\r\n\t\r\n\t\t\t\tcase 0: this.x = value; break;\r\n\t\t\t\tcase 1: this.y = value; break;\r\n\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetComponent: function ( index ) {\r\n\t\r\n\t\t\tswitch ( index ) {\r\n\t\r\n\t\t\t\tcase 0: return this.x;\r\n\t\t\t\tcase 1: return this.y;\r\n\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new this.constructor( this.x, this.y );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( v ) {\r\n\t\r\n\t\t\tthis.x = v.x;\r\n\t\t\tthis.y = v.y;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tadd: function ( v, w ) {\r\n\t\r\n\t\t\tif ( w !== undefined ) {\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\r\n\t\t\t\treturn this.addVectors( v, w );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.x += v.x;\r\n\t\t\tthis.y += v.y;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\taddScalar: function ( s ) {\r\n\t\r\n\t\t\tthis.x += s;\r\n\t\t\tthis.y += s;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\taddVectors: function ( a, b ) {\r\n\t\r\n\t\t\tthis.x = a.x + b.x;\r\n\t\t\tthis.y = a.y + b.y;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\taddScaledVector: function ( v, s ) {\r\n\t\r\n\t\t\tthis.x += v.x * s;\r\n\t\t\tthis.y += v.y * s;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsub: function ( v, w ) {\r\n\t\r\n\t\t\tif ( w !== undefined ) {\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\r\n\t\t\t\treturn this.subVectors( v, w );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.x -= v.x;\r\n\t\t\tthis.y -= v.y;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsubScalar: function ( s ) {\r\n\t\r\n\t\t\tthis.x -= s;\r\n\t\t\tthis.y -= s;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsubVectors: function ( a, b ) {\r\n\t\r\n\t\t\tthis.x = a.x - b.x;\r\n\t\t\tthis.y = a.y - b.y;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmultiply: function ( v ) {\r\n\t\r\n\t\t\tthis.x *= v.x;\r\n\t\t\tthis.y *= v.y;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmultiplyScalar: function ( scalar ) {\r\n\t\r\n\t\t\tif ( isFinite( scalar ) ) {\r\n\t\r\n\t\t\t\tthis.x *= scalar;\r\n\t\t\t\tthis.y *= scalar;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tthis.x = 0;\r\n\t\t\t\tthis.y = 0;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdivide: function ( v ) {\r\n\t\r\n\t\t\tthis.x /= v.x;\r\n\t\t\tthis.y /= v.y;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdivideScalar: function ( scalar ) {\r\n\t\r\n\t\t\treturn this.multiplyScalar( 1 / scalar );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmin: function ( v ) {\r\n\t\r\n\t\t\tthis.x = Math.min( this.x, v.x );\r\n\t\t\tthis.y = Math.min( this.y, v.y );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmax: function ( v ) {\r\n\t\r\n\t\t\tthis.x = Math.max( this.x, v.x );\r\n\t\t\tthis.y = Math.max( this.y, v.y );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclamp: function ( min, max ) {\r\n\t\r\n\t\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\r\n\t\r\n\t\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\r\n\t\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclampScalar: function () {\r\n\t\r\n\t\t\tvar min, max;\r\n\t\r\n\t\t\treturn function clampScalar( minVal, maxVal ) {\r\n\t\r\n\t\t\t\tif ( min === undefined ) {\r\n\t\r\n\t\t\t\t\tmin = new THREE.Vector2();\r\n\t\t\t\t\tmax = new THREE.Vector2();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tmin.set( minVal, minVal );\r\n\t\t\t\tmax.set( maxVal, maxVal );\r\n\t\r\n\t\t\t\treturn this.clamp( min, max );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tclampLength: function ( min, max ) {\r\n\t\r\n\t\t\tvar length = this.length();\r\n\t\r\n\t\t\tthis.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfloor: function () {\r\n\t\r\n\t\t\tthis.x = Math.floor( this.x );\r\n\t\t\tthis.y = Math.floor( this.y );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tceil: function () {\r\n\t\r\n\t\t\tthis.x = Math.ceil( this.x );\r\n\t\t\tthis.y = Math.ceil( this.y );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tround: function () {\r\n\t\r\n\t\t\tthis.x = Math.round( this.x );\r\n\t\t\tthis.y = Math.round( this.y );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\troundToZero: function () {\r\n\t\r\n\t\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\r\n\t\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tnegate: function () {\r\n\t\r\n\t\t\tthis.x = - this.x;\r\n\t\t\tthis.y = - this.y;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdot: function ( v ) {\r\n\t\r\n\t\t\treturn this.x * v.x + this.y * v.y;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlengthSq: function () {\r\n\t\r\n\t\t\treturn this.x * this.x + this.y * this.y;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlength: function () {\r\n\t\r\n\t\t\treturn Math.sqrt( this.x * this.x + this.y * this.y );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlengthManhattan: function() {\r\n\t\r\n\t\t\treturn Math.abs( this.x ) + Math.abs( this.y );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tnormalize: function () {\r\n\t\r\n\t\t\treturn this.divideScalar( this.length() );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tangle: function () {\r\n\t\r\n\t\t\t// computes the angle in radians with respect to the positive x-axis\r\n\t\r\n\t\t\tvar angle = Math.atan2( this.y, this.x );\r\n\t\r\n\t\t\tif ( angle < 0 ) angle += 2 * Math.PI;\r\n\t\r\n\t\t\treturn angle;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdistanceTo: function ( v ) {\r\n\t\r\n\t\t\treturn Math.sqrt( this.distanceToSquared( v ) );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdistanceToSquared: function ( v ) {\r\n\t\r\n\t\t\tvar dx = this.x - v.x, dy = this.y - v.y;\r\n\t\t\treturn dx * dx + dy * dy;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetLength: function ( length ) {\r\n\t\r\n\t\t\treturn this.multiplyScalar( length / this.length() );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlerp: function ( v, alpha ) {\r\n\t\r\n\t\t\tthis.x += ( v.x - this.x ) * alpha;\r\n\t\t\tthis.y += ( v.y - this.y ) * alpha;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlerpVectors: function ( v1, v2, alpha ) {\r\n\t\r\n\t\t\tthis.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tequals: function ( v ) {\r\n\t\r\n\t\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfromArray: function ( array, offset ) {\r\n\t\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\r\n\t\t\tthis.x = array[ offset ];\r\n\t\t\tthis.y = array[ offset + 1 ];\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttoArray: function ( array, offset ) {\r\n\t\r\n\t\t\tif ( array === undefined ) array = [];\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\r\n\t\t\tarray[ offset ] = this.x;\r\n\t\t\tarray[ offset + 1 ] = this.y;\r\n\t\r\n\t\t\treturn array;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfromAttribute: function ( attribute, index, offset ) {\r\n\t\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\r\n\t\t\tindex = index * attribute.itemSize + offset;\r\n\t\r\n\t\t\tthis.x = attribute.array[ index ];\r\n\t\t\tthis.y = attribute.array[ index + 1 ];\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\trotateAround: function ( center, angle ) {\r\n\t\r\n\t\t\tvar c = Math.cos( angle ), s = Math.sin( angle );\r\n\t\r\n\t\t\tvar x = this.x - center.x;\r\n\t\t\tvar y = this.y - center.y;\r\n\t\r\n\t\t\tthis.x = x * c - y * s + center.x;\r\n\t\t\tthis.y = x * s + y * c + center.y;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/math/Vector3.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author *kile / http://kile.stravaganza.org/\r\n\t * @author philogb / http://blog.thejit.org/\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t * @author egraether / http://egraether.com/\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t */\r\n\t\r\n\tTHREE.Vector3 = function ( x, y, z ) {\r\n\t\r\n\t\tthis.x = x || 0;\r\n\t\tthis.y = y || 0;\r\n\t\tthis.z = z || 0;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Vector3.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Vector3,\r\n\t\r\n\t\tset: function ( x, y, z ) {\r\n\t\r\n\t\t\tthis.x = x;\r\n\t\t\tthis.y = y;\r\n\t\t\tthis.z = z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetScalar: function ( scalar ) {\r\n\t\r\n\t\t\tthis.x = scalar;\r\n\t\t\tthis.y = scalar;\r\n\t\t\tthis.z = scalar;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetX: function ( x ) {\r\n\t\r\n\t\t\tthis.x = x;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetY: function ( y ) {\r\n\t\r\n\t\t\tthis.y = y;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetZ: function ( z ) {\r\n\t\r\n\t\t\tthis.z = z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetComponent: function ( index, value ) {\r\n\t\r\n\t\t\tswitch ( index ) {\r\n\t\r\n\t\t\t\tcase 0: this.x = value; break;\r\n\t\t\t\tcase 1: this.y = value; break;\r\n\t\t\t\tcase 2: this.z = value; break;\r\n\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetComponent: function ( index ) {\r\n\t\r\n\t\t\tswitch ( index ) {\r\n\t\r\n\t\t\t\tcase 0: return this.x;\r\n\t\t\t\tcase 1: return this.y;\r\n\t\t\t\tcase 2: return this.z;\r\n\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new this.constructor( this.x, this.y, this.z );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( v ) {\r\n\t\r\n\t\t\tthis.x = v.x;\r\n\t\t\tthis.y = v.y;\r\n\t\t\tthis.z = v.z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tadd: function ( v, w ) {\r\n\t\r\n\t\t\tif ( w !== undefined ) {\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\r\n\t\t\t\treturn this.addVectors( v, w );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.x += v.x;\r\n\t\t\tthis.y += v.y;\r\n\t\t\tthis.z += v.z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\taddScalar: function ( s ) {\r\n\t\r\n\t\t\tthis.x += s;\r\n\t\t\tthis.y += s;\r\n\t\t\tthis.z += s;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\taddVectors: function ( a, b ) {\r\n\t\r\n\t\t\tthis.x = a.x + b.x;\r\n\t\t\tthis.y = a.y + b.y;\r\n\t\t\tthis.z = a.z + b.z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\taddScaledVector: function ( v, s ) {\r\n\t\r\n\t\t\tthis.x += v.x * s;\r\n\t\t\tthis.y += v.y * s;\r\n\t\t\tthis.z += v.z * s;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsub: function ( v, w ) {\r\n\t\r\n\t\t\tif ( w !== undefined ) {\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\r\n\t\t\t\treturn this.subVectors( v, w );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.x -= v.x;\r\n\t\t\tthis.y -= v.y;\r\n\t\t\tthis.z -= v.z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsubScalar: function ( s ) {\r\n\t\r\n\t\t\tthis.x -= s;\r\n\t\t\tthis.y -= s;\r\n\t\t\tthis.z -= s;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsubVectors: function ( a, b ) {\r\n\t\r\n\t\t\tthis.x = a.x - b.x;\r\n\t\t\tthis.y = a.y - b.y;\r\n\t\t\tthis.z = a.z - b.z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmultiply: function ( v, w ) {\r\n\t\r\n\t\t\tif ( w !== undefined ) {\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );\r\n\t\t\t\treturn this.multiplyVectors( v, w );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.x *= v.x;\r\n\t\t\tthis.y *= v.y;\r\n\t\t\tthis.z *= v.z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmultiplyScalar: function ( scalar ) {\r\n\t\r\n\t\t\tif ( isFinite( scalar ) ) {\r\n\t\r\n\t\t\t\tthis.x *= scalar;\r\n\t\t\t\tthis.y *= scalar;\r\n\t\t\t\tthis.z *= scalar;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tthis.x = 0;\r\n\t\t\t\tthis.y = 0;\r\n\t\t\t\tthis.z = 0;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmultiplyVectors: function ( a, b ) {\r\n\t\r\n\t\t\tthis.x = a.x * b.x;\r\n\t\t\tthis.y = a.y * b.y;\r\n\t\t\tthis.z = a.z * b.z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tapplyEuler: function () {\r\n\t\r\n\t\t\tvar quaternion;\r\n\t\r\n\t\t\treturn function applyEuler( euler ) {\r\n\t\r\n\t\t\t\tif ( euler instanceof THREE.Euler === false ) {\r\n\t\r\n\t\t\t\t\tconsole.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( quaternion === undefined ) quaternion = new THREE.Quaternion();\r\n\t\r\n\t\t\t\tthis.applyQuaternion( quaternion.setFromEuler( euler ) );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tapplyAxisAngle: function () {\r\n\t\r\n\t\t\tvar quaternion;\r\n\t\r\n\t\t\treturn function applyAxisAngle( axis, angle ) {\r\n\t\r\n\t\t\t\tif ( quaternion === undefined ) quaternion = new THREE.Quaternion();\r\n\t\r\n\t\t\t\tthis.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tapplyMatrix3: function ( m ) {\r\n\t\r\n\t\t\tvar x = this.x;\r\n\t\t\tvar y = this.y;\r\n\t\t\tvar z = this.z;\r\n\t\r\n\t\t\tvar e = m.elements;\r\n\t\r\n\t\t\tthis.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;\r\n\t\t\tthis.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;\r\n\t\t\tthis.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tapplyMatrix4: function ( m ) {\r\n\t\r\n\t\t\t// input: THREE.Matrix4 affine matrix\r\n\t\r\n\t\t\tvar x = this.x, y = this.y, z = this.z;\r\n\t\r\n\t\t\tvar e = m.elements;\r\n\t\r\n\t\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ];\r\n\t\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ];\r\n\t\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ];\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tapplyProjection: function ( m ) {\r\n\t\r\n\t\t\t// input: THREE.Matrix4 projection matrix\r\n\t\r\n\t\t\tvar x = this.x, y = this.y, z = this.z;\r\n\t\r\n\t\t\tvar e = m.elements;\r\n\t\t\tvar d = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] ); // perspective divide\r\n\t\r\n\t\t\tthis.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ] ) * d;\r\n\t\t\tthis.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ] ) * d;\r\n\t\t\tthis.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * d;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tapplyQuaternion: function ( q ) {\r\n\t\r\n\t\t\tvar x = this.x;\r\n\t\t\tvar y = this.y;\r\n\t\t\tvar z = this.z;\r\n\t\r\n\t\t\tvar qx = q.x;\r\n\t\t\tvar qy = q.y;\r\n\t\t\tvar qz = q.z;\r\n\t\t\tvar qw = q.w;\r\n\t\r\n\t\t\t// calculate quat * vector\r\n\t\r\n\t\t\tvar ix =  qw * x + qy * z - qz * y;\r\n\t\t\tvar iy =  qw * y + qz * x - qx * z;\r\n\t\t\tvar iz =  qw * z + qx * y - qy * x;\r\n\t\t\tvar iw = - qx * x - qy * y - qz * z;\r\n\t\r\n\t\t\t// calculate result * inverse quat\r\n\t\r\n\t\t\tthis.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;\r\n\t\t\tthis.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;\r\n\t\t\tthis.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tproject: function () {\r\n\t\r\n\t\t\tvar matrix;\r\n\t\r\n\t\t\treturn function project( camera ) {\r\n\t\r\n\t\t\t\tif ( matrix === undefined ) matrix = new THREE.Matrix4();\r\n\t\r\n\t\t\t\tmatrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );\r\n\t\t\t\treturn this.applyProjection( matrix );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tunproject: function () {\r\n\t\r\n\t\t\tvar matrix;\r\n\t\r\n\t\t\treturn function unproject( camera ) {\r\n\t\r\n\t\t\t\tif ( matrix === undefined ) matrix = new THREE.Matrix4();\r\n\t\r\n\t\t\t\tmatrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );\r\n\t\t\t\treturn this.applyProjection( matrix );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\ttransformDirection: function ( m ) {\r\n\t\r\n\t\t\t// input: THREE.Matrix4 affine matrix\r\n\t\t\t// vector interpreted as a direction\r\n\t\r\n\t\t\tvar x = this.x, y = this.y, z = this.z;\r\n\t\r\n\t\t\tvar e = m.elements;\r\n\t\r\n\t\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z;\r\n\t\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z;\r\n\t\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;\r\n\t\r\n\t\t\tthis.normalize();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdivide: function ( v ) {\r\n\t\r\n\t\t\tthis.x /= v.x;\r\n\t\t\tthis.y /= v.y;\r\n\t\t\tthis.z /= v.z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdivideScalar: function ( scalar ) {\r\n\t\r\n\t\t\treturn this.multiplyScalar( 1 / scalar );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmin: function ( v ) {\r\n\t\r\n\t\t\tthis.x = Math.min( this.x, v.x );\r\n\t\t\tthis.y = Math.min( this.y, v.y );\r\n\t\t\tthis.z = Math.min( this.z, v.z );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmax: function ( v ) {\r\n\t\r\n\t\t\tthis.x = Math.max( this.x, v.x );\r\n\t\t\tthis.y = Math.max( this.y, v.y );\r\n\t\t\tthis.z = Math.max( this.z, v.z );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclamp: function ( min, max ) {\r\n\t\r\n\t\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\r\n\t\r\n\t\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\r\n\t\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\r\n\t\t\tthis.z = Math.max( min.z, Math.min( max.z, this.z ) );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclampScalar: function () {\r\n\t\r\n\t\t\tvar min, max;\r\n\t\r\n\t\t\treturn function clampScalar( minVal, maxVal ) {\r\n\t\r\n\t\t\t\tif ( min === undefined ) {\r\n\t\r\n\t\t\t\t\tmin = new THREE.Vector3();\r\n\t\t\t\t\tmax = new THREE.Vector3();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tmin.set( minVal, minVal, minVal );\r\n\t\t\t\tmax.set( maxVal, maxVal, maxVal );\r\n\t\r\n\t\t\t\treturn this.clamp( min, max );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tclampLength: function ( min, max ) {\r\n\t\r\n\t\t\tvar length = this.length();\r\n\t\r\n\t\t\tthis.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfloor: function () {\r\n\t\r\n\t\t\tthis.x = Math.floor( this.x );\r\n\t\t\tthis.y = Math.floor( this.y );\r\n\t\t\tthis.z = Math.floor( this.z );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tceil: function () {\r\n\t\r\n\t\t\tthis.x = Math.ceil( this.x );\r\n\t\t\tthis.y = Math.ceil( this.y );\r\n\t\t\tthis.z = Math.ceil( this.z );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tround: function () {\r\n\t\r\n\t\t\tthis.x = Math.round( this.x );\r\n\t\t\tthis.y = Math.round( this.y );\r\n\t\t\tthis.z = Math.round( this.z );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\troundToZero: function () {\r\n\t\r\n\t\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\r\n\t\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\r\n\t\t\tthis.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tnegate: function () {\r\n\t\r\n\t\t\tthis.x = - this.x;\r\n\t\t\tthis.y = - this.y;\r\n\t\t\tthis.z = - this.z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdot: function ( v ) {\r\n\t\r\n\t\t\treturn this.x * v.x + this.y * v.y + this.z * v.z;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlengthSq: function () {\r\n\t\r\n\t\t\treturn this.x * this.x + this.y * this.y + this.z * this.z;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlength: function () {\r\n\t\r\n\t\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlengthManhattan: function () {\r\n\t\r\n\t\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tnormalize: function () {\r\n\t\r\n\t\t\treturn this.divideScalar( this.length() );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetLength: function ( length ) {\r\n\t\r\n\t\t\treturn this.multiplyScalar( length / this.length() );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlerp: function ( v, alpha ) {\r\n\t\r\n\t\t\tthis.x += ( v.x - this.x ) * alpha;\r\n\t\t\tthis.y += ( v.y - this.y ) * alpha;\r\n\t\t\tthis.z += ( v.z - this.z ) * alpha;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlerpVectors: function ( v1, v2, alpha ) {\r\n\t\r\n\t\t\tthis.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcross: function ( v, w ) {\r\n\t\r\n\t\t\tif ( w !== undefined ) {\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );\r\n\t\t\t\treturn this.crossVectors( v, w );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar x = this.x, y = this.y, z = this.z;\r\n\t\r\n\t\t\tthis.x = y * v.z - z * v.y;\r\n\t\t\tthis.y = z * v.x - x * v.z;\r\n\t\t\tthis.z = x * v.y - y * v.x;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcrossVectors: function ( a, b ) {\r\n\t\r\n\t\t\tvar ax = a.x, ay = a.y, az = a.z;\r\n\t\t\tvar bx = b.x, by = b.y, bz = b.z;\r\n\t\r\n\t\t\tthis.x = ay * bz - az * by;\r\n\t\t\tthis.y = az * bx - ax * bz;\r\n\t\t\tthis.z = ax * by - ay * bx;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tprojectOnVector: function () {\r\n\t\r\n\t\t\tvar v1, dot;\r\n\t\r\n\t\t\treturn function projectOnVector( vector ) {\r\n\t\r\n\t\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\t\r\n\t\t\t\tv1.copy( vector ).normalize();\r\n\t\r\n\t\t\t\tdot = this.dot( v1 );\r\n\t\r\n\t\t\t\treturn this.copy( v1 ).multiplyScalar( dot );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tprojectOnPlane: function () {\r\n\t\r\n\t\t\tvar v1;\r\n\t\r\n\t\t\treturn function projectOnPlane( planeNormal ) {\r\n\t\r\n\t\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\t\r\n\t\t\t\tv1.copy( this ).projectOnVector( planeNormal );\r\n\t\r\n\t\t\t\treturn this.sub( v1 );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\treflect: function () {\r\n\t\r\n\t\t\t// reflect incident vector off plane orthogonal to normal\r\n\t\t\t// normal is assumed to have unit length\r\n\t\r\n\t\t\tvar v1;\r\n\t\r\n\t\t\treturn function reflect( normal ) {\r\n\t\r\n\t\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\t\r\n\t\t\t\treturn this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tangleTo: function ( v ) {\r\n\t\r\n\t\t\tvar theta = this.dot( v ) / ( Math.sqrt( this.lengthSq() * v.lengthSq() ) );\r\n\t\r\n\t\t\t// clamp, to handle numerical problems\r\n\t\r\n\t\t\treturn Math.acos( THREE.Math.clamp( theta, - 1, 1 ) );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdistanceTo: function ( v ) {\r\n\t\r\n\t\t\treturn Math.sqrt( this.distanceToSquared( v ) );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdistanceToSquared: function ( v ) {\r\n\t\r\n\t\t\tvar dx = this.x - v.x;\r\n\t\t\tvar dy = this.y - v.y;\r\n\t\t\tvar dz = this.z - v.z;\r\n\t\r\n\t\t\treturn dx * dx + dy * dy + dz * dz;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromSpherical: function( s ) {\r\n\t\r\n\t\t\tvar sinPhiRadius = Math.sin( s.phi ) * s.radius;\r\n\t\r\n\t\t\tthis.x = sinPhiRadius * Math.sin( s.theta );\r\n\t\t\tthis.y = Math.cos( s.phi ) * s.radius;\r\n\t\t\tthis.z = sinPhiRadius * Math.cos( s.theta );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromMatrixPosition: function ( m ) {\r\n\t\r\n\t\t\treturn this.setFromMatrixColumn( m, 3 );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromMatrixScale: function ( m ) {\r\n\t\r\n\t\t\tvar sx = this.setFromMatrixColumn( m, 0 ).length();\r\n\t\t\tvar sy = this.setFromMatrixColumn( m, 1 ).length();\r\n\t\t\tvar sz = this.setFromMatrixColumn( m, 2 ).length();\r\n\t\r\n\t\t\tthis.x = sx;\r\n\t\t\tthis.y = sy;\r\n\t\t\tthis.z = sz;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromMatrixColumn: function ( m, index ) {\r\n\t\r\n\t\t\tif ( typeof m === 'number' ) {\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.Vector3: setFromMatrixColumn now expects ( matrix, index ).' );\r\n\t\r\n\t\t\t\tm = arguments[ 1 ];\r\n\t\t\t\tindex = arguments[ 0 ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this.fromArray( m.elements, index * 4 );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tequals: function ( v ) {\r\n\t\r\n\t\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfromArray: function ( array, offset ) {\r\n\t\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\r\n\t\t\tthis.x = array[ offset ];\r\n\t\t\tthis.y = array[ offset + 1 ];\r\n\t\t\tthis.z = array[ offset + 2 ];\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttoArray: function ( array, offset ) {\r\n\t\r\n\t\t\tif ( array === undefined ) array = [];\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\r\n\t\t\tarray[ offset ] = this.x;\r\n\t\t\tarray[ offset + 1 ] = this.y;\r\n\t\t\tarray[ offset + 2 ] = this.z;\r\n\t\r\n\t\t\treturn array;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfromAttribute: function ( attribute, index, offset ) {\r\n\t\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\r\n\t\t\tindex = index * attribute.itemSize + offset;\r\n\t\r\n\t\t\tthis.x = attribute.array[ index ];\r\n\t\t\tthis.y = attribute.array[ index + 1 ];\r\n\t\t\tthis.z = attribute.array[ index + 2 ];\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/math/Vector4.js\r\n\t\r\n\t/**\r\n\t * @author supereggbert / http://www.paulbrunt.co.uk/\r\n\t * @author philogb / http://blog.thejit.org/\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t * @author egraether / http://egraether.com/\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t */\r\n\t\r\n\tTHREE.Vector4 = function ( x, y, z, w ) {\r\n\t\r\n\t\tthis.x = x || 0;\r\n\t\tthis.y = y || 0;\r\n\t\tthis.z = z || 0;\r\n\t\tthis.w = ( w !== undefined ) ? w : 1;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Vector4.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Vector4,\r\n\t\r\n\t\tset: function ( x, y, z, w ) {\r\n\t\r\n\t\t\tthis.x = x;\r\n\t\t\tthis.y = y;\r\n\t\t\tthis.z = z;\r\n\t\t\tthis.w = w;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetScalar: function ( scalar ) {\r\n\t\r\n\t\t\tthis.x = scalar;\r\n\t\t\tthis.y = scalar;\r\n\t\t\tthis.z = scalar;\r\n\t\t\tthis.w = scalar;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetX: function ( x ) {\r\n\t\r\n\t\t\tthis.x = x;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetY: function ( y ) {\r\n\t\r\n\t\t\tthis.y = y;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetZ: function ( z ) {\r\n\t\r\n\t\t\tthis.z = z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetW: function ( w ) {\r\n\t\r\n\t\t\tthis.w = w;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetComponent: function ( index, value ) {\r\n\t\r\n\t\t\tswitch ( index ) {\r\n\t\r\n\t\t\t\tcase 0: this.x = value; break;\r\n\t\t\t\tcase 1: this.y = value; break;\r\n\t\t\t\tcase 2: this.z = value; break;\r\n\t\t\t\tcase 3: this.w = value; break;\r\n\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetComponent: function ( index ) {\r\n\t\r\n\t\t\tswitch ( index ) {\r\n\t\r\n\t\t\t\tcase 0: return this.x;\r\n\t\t\t\tcase 1: return this.y;\r\n\t\t\t\tcase 2: return this.z;\r\n\t\t\t\tcase 3: return this.w;\r\n\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new this.constructor( this.x, this.y, this.z, this.w );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( v ) {\r\n\t\r\n\t\t\tthis.x = v.x;\r\n\t\t\tthis.y = v.y;\r\n\t\t\tthis.z = v.z;\r\n\t\t\tthis.w = ( v.w !== undefined ) ? v.w : 1;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tadd: function ( v, w ) {\r\n\t\r\n\t\t\tif ( w !== undefined ) {\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\r\n\t\t\t\treturn this.addVectors( v, w );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.x += v.x;\r\n\t\t\tthis.y += v.y;\r\n\t\t\tthis.z += v.z;\r\n\t\t\tthis.w += v.w;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\taddScalar: function ( s ) {\r\n\t\r\n\t\t\tthis.x += s;\r\n\t\t\tthis.y += s;\r\n\t\t\tthis.z += s;\r\n\t\t\tthis.w += s;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\taddVectors: function ( a, b ) {\r\n\t\r\n\t\t\tthis.x = a.x + b.x;\r\n\t\t\tthis.y = a.y + b.y;\r\n\t\t\tthis.z = a.z + b.z;\r\n\t\t\tthis.w = a.w + b.w;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\taddScaledVector: function ( v, s ) {\r\n\t\r\n\t\t\tthis.x += v.x * s;\r\n\t\t\tthis.y += v.y * s;\r\n\t\t\tthis.z += v.z * s;\r\n\t\t\tthis.w += v.w * s;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsub: function ( v, w ) {\r\n\t\r\n\t\t\tif ( w !== undefined ) {\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\r\n\t\t\t\treturn this.subVectors( v, w );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.x -= v.x;\r\n\t\t\tthis.y -= v.y;\r\n\t\t\tthis.z -= v.z;\r\n\t\t\tthis.w -= v.w;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsubScalar: function ( s ) {\r\n\t\r\n\t\t\tthis.x -= s;\r\n\t\t\tthis.y -= s;\r\n\t\t\tthis.z -= s;\r\n\t\t\tthis.w -= s;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsubVectors: function ( a, b ) {\r\n\t\r\n\t\t\tthis.x = a.x - b.x;\r\n\t\t\tthis.y = a.y - b.y;\r\n\t\t\tthis.z = a.z - b.z;\r\n\t\t\tthis.w = a.w - b.w;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmultiplyScalar: function ( scalar ) {\r\n\t\r\n\t\t\tif ( isFinite( scalar ) ) {\r\n\t\r\n\t\t\t\tthis.x *= scalar;\r\n\t\t\t\tthis.y *= scalar;\r\n\t\t\t\tthis.z *= scalar;\r\n\t\t\t\tthis.w *= scalar;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tthis.x = 0;\r\n\t\t\t\tthis.y = 0;\r\n\t\t\t\tthis.z = 0;\r\n\t\t\t\tthis.w = 0;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tapplyMatrix4: function ( m ) {\r\n\t\r\n\t\t\tvar x = this.x;\r\n\t\t\tvar y = this.y;\r\n\t\t\tvar z = this.z;\r\n\t\t\tvar w = this.w;\r\n\t\r\n\t\t\tvar e = m.elements;\r\n\t\r\n\t\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;\r\n\t\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;\r\n\t\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;\r\n\t\t\tthis.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdivideScalar: function ( scalar ) {\r\n\t\r\n\t\t\treturn this.multiplyScalar( 1 / scalar );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetAxisAngleFromQuaternion: function ( q ) {\r\n\t\r\n\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm\r\n\t\r\n\t\t\t// q is assumed to be normalized\r\n\t\r\n\t\t\tthis.w = 2 * Math.acos( q.w );\r\n\t\r\n\t\t\tvar s = Math.sqrt( 1 - q.w * q.w );\r\n\t\r\n\t\t\tif ( s < 0.0001 ) {\r\n\t\r\n\t\t\t\t this.x = 1;\r\n\t\t\t\t this.y = 0;\r\n\t\t\t\t this.z = 0;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\t this.x = q.x / s;\r\n\t\t\t\t this.y = q.y / s;\r\n\t\t\t\t this.z = q.z / s;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetAxisAngleFromRotationMatrix: function ( m ) {\r\n\t\r\n\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm\r\n\t\r\n\t\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\r\n\t\r\n\t\t\tvar angle, x, y, z,\t\t// variables for result\r\n\t\t\t\tepsilon = 0.01,\t\t// margin to allow for rounding errors\r\n\t\t\t\tepsilon2 = 0.1,\t\t// margin to distinguish between 0 and 180 degrees\r\n\t\r\n\t\t\t\tte = m.elements,\r\n\t\r\n\t\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\r\n\t\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\r\n\t\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\r\n\t\r\n\t\t\tif ( ( Math.abs( m12 - m21 ) < epsilon ) &&\r\n\t\t\t     ( Math.abs( m13 - m31 ) < epsilon ) &&\r\n\t\t\t     ( Math.abs( m23 - m32 ) < epsilon ) ) {\r\n\t\r\n\t\t\t\t// singularity found\r\n\t\t\t\t// first check for identity matrix which must have +1 for all terms\r\n\t\t\t\t// in leading diagonal and zero in other terms\r\n\t\r\n\t\t\t\tif ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&\r\n\t\t\t\t     ( Math.abs( m13 + m31 ) < epsilon2 ) &&\r\n\t\t\t\t     ( Math.abs( m23 + m32 ) < epsilon2 ) &&\r\n\t\t\t\t     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {\r\n\t\r\n\t\t\t\t\t// this singularity is identity matrix so angle = 0\r\n\t\r\n\t\t\t\t\tthis.set( 1, 0, 0, 0 );\r\n\t\r\n\t\t\t\t\treturn this; // zero angle, arbitrary axis\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// otherwise this singularity is angle = 180\r\n\t\r\n\t\t\t\tangle = Math.PI;\r\n\t\r\n\t\t\t\tvar xx = ( m11 + 1 ) / 2;\r\n\t\t\t\tvar yy = ( m22 + 1 ) / 2;\r\n\t\t\t\tvar zz = ( m33 + 1 ) / 2;\r\n\t\t\t\tvar xy = ( m12 + m21 ) / 4;\r\n\t\t\t\tvar xz = ( m13 + m31 ) / 4;\r\n\t\t\t\tvar yz = ( m23 + m32 ) / 4;\r\n\t\r\n\t\t\t\tif ( ( xx > yy ) && ( xx > zz ) ) {\r\n\t\r\n\t\t\t\t\t// m11 is the largest diagonal term\r\n\t\r\n\t\t\t\t\tif ( xx < epsilon ) {\r\n\t\r\n\t\t\t\t\t\tx = 0;\r\n\t\t\t\t\t\ty = 0.707106781;\r\n\t\t\t\t\t\tz = 0.707106781;\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tx = Math.sqrt( xx );\r\n\t\t\t\t\t\ty = xy / x;\r\n\t\t\t\t\t\tz = xz / x;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else if ( yy > zz ) {\r\n\t\r\n\t\t\t\t\t// m22 is the largest diagonal term\r\n\t\r\n\t\t\t\t\tif ( yy < epsilon ) {\r\n\t\r\n\t\t\t\t\t\tx = 0.707106781;\r\n\t\t\t\t\t\ty = 0;\r\n\t\t\t\t\t\tz = 0.707106781;\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\ty = Math.sqrt( yy );\r\n\t\t\t\t\t\tx = xy / y;\r\n\t\t\t\t\t\tz = yz / y;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t// m33 is the largest diagonal term so base result on this\r\n\t\r\n\t\t\t\t\tif ( zz < epsilon ) {\r\n\t\r\n\t\t\t\t\t\tx = 0.707106781;\r\n\t\t\t\t\t\ty = 0.707106781;\r\n\t\t\t\t\t\tz = 0;\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tz = Math.sqrt( zz );\r\n\t\t\t\t\t\tx = xz / z;\r\n\t\t\t\t\t\ty = yz / z;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tthis.set( x, y, z, angle );\r\n\t\r\n\t\t\t\treturn this; // return 180 deg rotation\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// as we have reached here there are no singularities so we can handle normally\r\n\t\r\n\t\t\tvar s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +\r\n\t\t\t                   ( m13 - m31 ) * ( m13 - m31 ) +\r\n\t\t\t                   ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize\r\n\t\r\n\t\t\tif ( Math.abs( s ) < 0.001 ) s = 1;\r\n\t\r\n\t\t\t// prevent divide by zero, should not happen if matrix is orthogonal and should be\r\n\t\t\t// caught by singularity test above, but I've left it in just in case\r\n\t\r\n\t\t\tthis.x = ( m32 - m23 ) / s;\r\n\t\t\tthis.y = ( m13 - m31 ) / s;\r\n\t\t\tthis.z = ( m21 - m12 ) / s;\r\n\t\t\tthis.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmin: function ( v ) {\r\n\t\r\n\t\t\tthis.x = Math.min( this.x, v.x );\r\n\t\t\tthis.y = Math.min( this.y, v.y );\r\n\t\t\tthis.z = Math.min( this.z, v.z );\r\n\t\t\tthis.w = Math.min( this.w, v.w );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmax: function ( v ) {\r\n\t\r\n\t\t\tthis.x = Math.max( this.x, v.x );\r\n\t\t\tthis.y = Math.max( this.y, v.y );\r\n\t\t\tthis.z = Math.max( this.z, v.z );\r\n\t\t\tthis.w = Math.max( this.w, v.w );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclamp: function ( min, max ) {\r\n\t\r\n\t\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\r\n\t\r\n\t\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\r\n\t\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\r\n\t\t\tthis.z = Math.max( min.z, Math.min( max.z, this.z ) );\r\n\t\t\tthis.w = Math.max( min.w, Math.min( max.w, this.w ) );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclampScalar: function () {\r\n\t\r\n\t\t\tvar min, max;\r\n\t\r\n\t\t\treturn function clampScalar( minVal, maxVal ) {\r\n\t\r\n\t\t\t\tif ( min === undefined ) {\r\n\t\r\n\t\t\t\t\tmin = new THREE.Vector4();\r\n\t\t\t\t\tmax = new THREE.Vector4();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tmin.set( minVal, minVal, minVal, minVal );\r\n\t\t\t\tmax.set( maxVal, maxVal, maxVal, maxVal );\r\n\t\r\n\t\t\t\treturn this.clamp( min, max );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tfloor: function () {\r\n\t\r\n\t\t\tthis.x = Math.floor( this.x );\r\n\t\t\tthis.y = Math.floor( this.y );\r\n\t\t\tthis.z = Math.floor( this.z );\r\n\t\t\tthis.w = Math.floor( this.w );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tceil: function () {\r\n\t\r\n\t\t\tthis.x = Math.ceil( this.x );\r\n\t\t\tthis.y = Math.ceil( this.y );\r\n\t\t\tthis.z = Math.ceil( this.z );\r\n\t\t\tthis.w = Math.ceil( this.w );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tround: function () {\r\n\t\r\n\t\t\tthis.x = Math.round( this.x );\r\n\t\t\tthis.y = Math.round( this.y );\r\n\t\t\tthis.z = Math.round( this.z );\r\n\t\t\tthis.w = Math.round( this.w );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\troundToZero: function () {\r\n\t\r\n\t\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\r\n\t\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\r\n\t\t\tthis.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\r\n\t\t\tthis.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tnegate: function () {\r\n\t\r\n\t\t\tthis.x = - this.x;\r\n\t\t\tthis.y = - this.y;\r\n\t\t\tthis.z = - this.z;\r\n\t\t\tthis.w = - this.w;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdot: function ( v ) {\r\n\t\r\n\t\t\treturn this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlengthSq: function () {\r\n\t\r\n\t\t\treturn this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlength: function () {\r\n\t\r\n\t\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlengthManhattan: function () {\r\n\t\r\n\t\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tnormalize: function () {\r\n\t\r\n\t\t\treturn this.divideScalar( this.length() );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetLength: function ( length ) {\r\n\t\r\n\t\t\treturn this.multiplyScalar( length / this.length() );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlerp: function ( v, alpha ) {\r\n\t\r\n\t\t\tthis.x += ( v.x - this.x ) * alpha;\r\n\t\t\tthis.y += ( v.y - this.y ) * alpha;\r\n\t\t\tthis.z += ( v.z - this.z ) * alpha;\r\n\t\t\tthis.w += ( v.w - this.w ) * alpha;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlerpVectors: function ( v1, v2, alpha ) {\r\n\t\r\n\t\t\tthis.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tequals: function ( v ) {\r\n\t\r\n\t\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfromArray: function ( array, offset ) {\r\n\t\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\r\n\t\t\tthis.x = array[ offset ];\r\n\t\t\tthis.y = array[ offset + 1 ];\r\n\t\t\tthis.z = array[ offset + 2 ];\r\n\t\t\tthis.w = array[ offset + 3 ];\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttoArray: function ( array, offset ) {\r\n\t\r\n\t\t\tif ( array === undefined ) array = [];\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\r\n\t\t\tarray[ offset ] = this.x;\r\n\t\t\tarray[ offset + 1 ] = this.y;\r\n\t\t\tarray[ offset + 2 ] = this.z;\r\n\t\t\tarray[ offset + 3 ] = this.w;\r\n\t\r\n\t\t\treturn array;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfromAttribute: function ( attribute, index, offset ) {\r\n\t\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\r\n\t\t\tindex = index * attribute.itemSize + offset;\r\n\t\r\n\t\t\tthis.x = attribute.array[ index ];\r\n\t\t\tthis.y = attribute.array[ index + 1 ];\r\n\t\t\tthis.z = attribute.array[ index + 2 ];\r\n\t\t\tthis.w = attribute.array[ index + 3 ];\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/math/Euler.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t * @author bhouston / http://clara.io\r\n\t */\r\n\t\r\n\tTHREE.Euler = function ( x, y, z, order ) {\r\n\t\r\n\t\tthis._x = x || 0;\r\n\t\tthis._y = y || 0;\r\n\t\tthis._z = z || 0;\r\n\t\tthis._order = order || THREE.Euler.DefaultOrder;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];\r\n\t\r\n\tTHREE.Euler.DefaultOrder = 'XYZ';\r\n\t\r\n\tTHREE.Euler.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Euler,\r\n\t\r\n\t\tget x () {\r\n\t\r\n\t\t\treturn this._x;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tset x ( value ) {\r\n\t\r\n\t\t\tthis._x = value;\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t},\r\n\t\r\n\t\tget y () {\r\n\t\r\n\t\t\treturn this._y;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tset y ( value ) {\r\n\t\r\n\t\t\tthis._y = value;\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t},\r\n\t\r\n\t\tget z () {\r\n\t\r\n\t\t\treturn this._z;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tset z ( value ) {\r\n\t\r\n\t\t\tthis._z = value;\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t},\r\n\t\r\n\t\tget order () {\r\n\t\r\n\t\t\treturn this._order;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tset order ( value ) {\r\n\t\r\n\t\t\tthis._order = value;\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t},\r\n\t\r\n\t\tset: function ( x, y, z, order ) {\r\n\t\r\n\t\t\tthis._x = x;\r\n\t\t\tthis._y = y;\r\n\t\t\tthis._z = z;\r\n\t\t\tthis._order = order || this._order;\r\n\t\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new this.constructor( this._x, this._y, this._z, this._order );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( euler ) {\r\n\t\r\n\t\t\tthis._x = euler._x;\r\n\t\t\tthis._y = euler._y;\r\n\t\t\tthis._z = euler._z;\r\n\t\t\tthis._order = euler._order;\r\n\t\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromRotationMatrix: function ( m, order, update ) {\r\n\t\r\n\t\t\tvar clamp = THREE.Math.clamp;\r\n\t\r\n\t\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\r\n\t\r\n\t\t\tvar te = m.elements;\r\n\t\t\tvar m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];\r\n\t\t\tvar m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];\r\n\t\t\tvar m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\r\n\t\r\n\t\t\torder = order || this._order;\r\n\t\r\n\t\t\tif ( order === 'XYZ' ) {\r\n\t\r\n\t\t\t\tthis._y = Math.asin( clamp( m13, - 1, 1 ) );\r\n\t\r\n\t\t\t\tif ( Math.abs( m13 ) < 0.99999 ) {\r\n\t\r\n\t\t\t\t\tthis._x = Math.atan2( - m23, m33 );\r\n\t\t\t\t\tthis._z = Math.atan2( - m12, m11 );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tthis._x = Math.atan2( m32, m22 );\r\n\t\t\t\t\tthis._z = 0;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else if ( order === 'YXZ' ) {\r\n\t\r\n\t\t\t\tthis._x = Math.asin( - clamp( m23, - 1, 1 ) );\r\n\t\r\n\t\t\t\tif ( Math.abs( m23 ) < 0.99999 ) {\r\n\t\r\n\t\t\t\t\tthis._y = Math.atan2( m13, m33 );\r\n\t\t\t\t\tthis._z = Math.atan2( m21, m22 );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tthis._y = Math.atan2( - m31, m11 );\r\n\t\t\t\t\tthis._z = 0;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else if ( order === 'ZXY' ) {\r\n\t\r\n\t\t\t\tthis._x = Math.asin( clamp( m32, - 1, 1 ) );\r\n\t\r\n\t\t\t\tif ( Math.abs( m32 ) < 0.99999 ) {\r\n\t\r\n\t\t\t\t\tthis._y = Math.atan2( - m31, m33 );\r\n\t\t\t\t\tthis._z = Math.atan2( - m12, m22 );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tthis._y = 0;\r\n\t\t\t\t\tthis._z = Math.atan2( m21, m11 );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else if ( order === 'ZYX' ) {\r\n\t\r\n\t\t\t\tthis._y = Math.asin( - clamp( m31, - 1, 1 ) );\r\n\t\r\n\t\t\t\tif ( Math.abs( m31 ) < 0.99999 ) {\r\n\t\r\n\t\t\t\t\tthis._x = Math.atan2( m32, m33 );\r\n\t\t\t\t\tthis._z = Math.atan2( m21, m11 );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tthis._x = 0;\r\n\t\t\t\t\tthis._z = Math.atan2( - m12, m22 );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else if ( order === 'YZX' ) {\r\n\t\r\n\t\t\t\tthis._z = Math.asin( clamp( m21, - 1, 1 ) );\r\n\t\r\n\t\t\t\tif ( Math.abs( m21 ) < 0.99999 ) {\r\n\t\r\n\t\t\t\t\tthis._x = Math.atan2( - m23, m22 );\r\n\t\t\t\t\tthis._y = Math.atan2( - m31, m11 );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tthis._x = 0;\r\n\t\t\t\t\tthis._y = Math.atan2( m13, m33 );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else if ( order === 'XZY' ) {\r\n\t\r\n\t\t\t\tthis._z = Math.asin( - clamp( m12, - 1, 1 ) );\r\n\t\r\n\t\t\t\tif ( Math.abs( m12 ) < 0.99999 ) {\r\n\t\r\n\t\t\t\t\tthis._x = Math.atan2( m32, m22 );\r\n\t\t\t\t\tthis._y = Math.atan2( m13, m11 );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tthis._x = Math.atan2( - m23, m33 );\r\n\t\t\t\t\tthis._y = 0;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis._order = order;\r\n\t\r\n\t\t\tif ( update !== false ) this.onChangeCallback();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromQuaternion: function () {\r\n\t\r\n\t\t\tvar matrix;\r\n\t\r\n\t\t\treturn function ( q, order, update ) {\r\n\t\r\n\t\t\t\tif ( matrix === undefined ) matrix = new THREE.Matrix4();\r\n\t\t\t\tmatrix.makeRotationFromQuaternion( q );\r\n\t\t\t\tthis.setFromRotationMatrix( matrix, order, update );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tsetFromVector3: function ( v, order ) {\r\n\t\r\n\t\t\treturn this.set( v.x, v.y, v.z, order || this._order );\r\n\t\r\n\t\t},\r\n\t\r\n\t\treorder: function () {\r\n\t\r\n\t\t\t// WARNING: this discards revolution information -bhouston\r\n\t\r\n\t\t\tvar q = new THREE.Quaternion();\r\n\t\r\n\t\t\treturn function ( newOrder ) {\r\n\t\r\n\t\t\t\tq.setFromEuler( this );\r\n\t\t\t\tthis.setFromQuaternion( q, newOrder );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tequals: function ( euler ) {\r\n\t\r\n\t\t\treturn ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfromArray: function ( array ) {\r\n\t\r\n\t\t\tthis._x = array[ 0 ];\r\n\t\t\tthis._y = array[ 1 ];\r\n\t\t\tthis._z = array[ 2 ];\r\n\t\t\tif ( array[ 3 ] !== undefined ) this._order = array[ 3 ];\r\n\t\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttoArray: function ( array, offset ) {\r\n\t\r\n\t\t\tif ( array === undefined ) array = [];\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\r\n\t\t\tarray[ offset ] = this._x;\r\n\t\t\tarray[ offset + 1 ] = this._y;\r\n\t\t\tarray[ offset + 2 ] = this._z;\r\n\t\t\tarray[ offset + 3 ] = this._order;\r\n\t\r\n\t\t\treturn array;\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttoVector3: function ( optionalResult ) {\r\n\t\r\n\t\t\tif ( optionalResult ) {\r\n\t\r\n\t\t\t\treturn optionalResult.set( this._x, this._y, this._z );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\treturn new THREE.Vector3( this._x, this._y, this._z );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tonChange: function ( callback ) {\r\n\t\r\n\t\t\tthis.onChangeCallback = callback;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tonChangeCallback: function () {}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/math/Line3.js\r\n\t\r\n\t/**\r\n\t * @author bhouston / http://clara.io\r\n\t */\r\n\t\r\n\tTHREE.Line3 = function ( start, end ) {\r\n\t\r\n\t\tthis.start = ( start !== undefined ) ? start : new THREE.Vector3();\r\n\t\tthis.end = ( end !== undefined ) ? end : new THREE.Vector3();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Line3.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Line3,\r\n\t\r\n\t\tset: function ( start, end ) {\r\n\t\r\n\t\t\tthis.start.copy( start );\r\n\t\t\tthis.end.copy( end );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new this.constructor().copy( this );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( line ) {\r\n\t\r\n\t\t\tthis.start.copy( line.start );\r\n\t\t\tthis.end.copy( line.end );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcenter: function ( optionalTarget ) {\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\t\treturn result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdelta: function ( optionalTarget ) {\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\t\treturn result.subVectors( this.end, this.start );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdistanceSq: function () {\r\n\t\r\n\t\t\treturn this.start.distanceToSquared( this.end );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdistance: function () {\r\n\t\r\n\t\t\treturn this.start.distanceTo( this.end );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tat: function ( t, optionalTarget ) {\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\r\n\t\t\treturn this.delta( result ).multiplyScalar( t ).add( this.start );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclosestPointToPointParameter: function () {\r\n\t\r\n\t\t\tvar startP = new THREE.Vector3();\r\n\t\t\tvar startEnd = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function ( point, clampToLine ) {\r\n\t\r\n\t\t\t\tstartP.subVectors( point, this.start );\r\n\t\t\t\tstartEnd.subVectors( this.end, this.start );\r\n\t\r\n\t\t\t\tvar startEnd2 = startEnd.dot( startEnd );\r\n\t\t\t\tvar startEnd_startP = startEnd.dot( startP );\r\n\t\r\n\t\t\t\tvar t = startEnd_startP / startEnd2;\r\n\t\r\n\t\t\t\tif ( clampToLine ) {\r\n\t\r\n\t\t\t\t\tt = THREE.Math.clamp( t, 0, 1 );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn t;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tclosestPointToPoint: function ( point, clampToLine, optionalTarget ) {\r\n\t\r\n\t\t\tvar t = this.closestPointToPointParameter( point, clampToLine );\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\r\n\t\t\treturn this.delta( result ).multiplyScalar( t ).add( this.start );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tapplyMatrix4: function ( matrix ) {\r\n\t\r\n\t\t\tthis.start.applyMatrix4( matrix );\r\n\t\t\tthis.end.applyMatrix4( matrix );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tequals: function ( line ) {\r\n\t\r\n\t\t\treturn line.start.equals( this.start ) && line.end.equals( this.end );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/math/Box2.js\r\n\t\r\n\t/**\r\n\t * @author bhouston / http://clara.io\r\n\t */\r\n\t\r\n\tTHREE.Box2 = function ( min, max ) {\r\n\t\r\n\t\tthis.min = ( min !== undefined ) ? min : new THREE.Vector2( + Infinity, + Infinity );\r\n\t\tthis.max = ( max !== undefined ) ? max : new THREE.Vector2( - Infinity, - Infinity );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Box2.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Box2,\r\n\t\r\n\t\tset: function ( min, max ) {\r\n\t\r\n\t\t\tthis.min.copy( min );\r\n\t\t\tthis.max.copy( max );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromPoints: function ( points ) {\r\n\t\r\n\t\t\tthis.makeEmpty();\r\n\t\r\n\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tthis.expandByPoint( points[ i ] );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromCenterAndSize: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector2();\r\n\t\r\n\t\t\treturn function ( center, size ) {\r\n\t\r\n\t\t\t\tvar halfSize = v1.copy( size ).multiplyScalar( 0.5 );\r\n\t\t\t\tthis.min.copy( center ).sub( halfSize );\r\n\t\t\t\tthis.max.copy( center ).add( halfSize );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new this.constructor().copy( this );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( box ) {\r\n\t\r\n\t\t\tthis.min.copy( box.min );\r\n\t\t\tthis.max.copy( box.max );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmakeEmpty: function () {\r\n\t\r\n\t\t\tthis.min.x = this.min.y = + Infinity;\r\n\t\t\tthis.max.x = this.max.y = - Infinity;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tisEmpty: function () {\r\n\t\r\n\t\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\r\n\t\r\n\t\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcenter: function ( optionalTarget ) {\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector2();\r\n\t\t\treturn result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsize: function ( optionalTarget ) {\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector2();\r\n\t\t\treturn result.subVectors( this.max, this.min );\r\n\t\r\n\t\t},\r\n\t\r\n\t\texpandByPoint: function ( point ) {\r\n\t\r\n\t\t\tthis.min.min( point );\r\n\t\t\tthis.max.max( point );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\texpandByVector: function ( vector ) {\r\n\t\r\n\t\t\tthis.min.sub( vector );\r\n\t\t\tthis.max.add( vector );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\texpandByScalar: function ( scalar ) {\r\n\t\r\n\t\t\tthis.min.addScalar( - scalar );\r\n\t\t\tthis.max.addScalar( scalar );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcontainsPoint: function ( point ) {\r\n\t\r\n\t\t\tif ( point.x < this.min.x || point.x > this.max.x ||\r\n\t\t\t     point.y < this.min.y || point.y > this.max.y ) {\r\n\t\r\n\t\t\t\treturn false;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn true;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcontainsBox: function ( box ) {\r\n\t\r\n\t\t\tif ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&\r\n\t\t\t     ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) ) {\r\n\t\r\n\t\t\t\treturn true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn false;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetParameter: function ( point, optionalTarget ) {\r\n\t\r\n\t\t\t// This can potentially have a divide by zero if the box\r\n\t\t\t// has a size dimension of 0.\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector2();\r\n\t\r\n\t\t\treturn result.set(\r\n\t\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\r\n\t\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y )\r\n\t\t\t);\r\n\t\r\n\t\t},\r\n\t\r\n\t\tintersectsBox: function ( box ) {\r\n\t\r\n\t\t\t// using 6 splitting planes to rule out intersections.\r\n\t\r\n\t\t\tif ( box.max.x < this.min.x || box.min.x > this.max.x ||\r\n\t\t\t     box.max.y < this.min.y || box.min.y > this.max.y ) {\r\n\t\r\n\t\t\t\treturn false;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn true;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclampPoint: function ( point, optionalTarget ) {\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector2();\r\n\t\t\treturn result.copy( point ).clamp( this.min, this.max );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdistanceToPoint: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector2();\r\n\t\r\n\t\t\treturn function ( point ) {\r\n\t\r\n\t\t\t\tvar clampedPoint = v1.copy( point ).clamp( this.min, this.max );\r\n\t\t\t\treturn clampedPoint.sub( point ).length();\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tintersect: function ( box ) {\r\n\t\r\n\t\t\tthis.min.max( box.min );\r\n\t\t\tthis.max.min( box.max );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tunion: function ( box ) {\r\n\t\r\n\t\t\tthis.min.min( box.min );\r\n\t\t\tthis.max.max( box.max );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttranslate: function ( offset ) {\r\n\t\r\n\t\t\tthis.min.add( offset );\r\n\t\t\tthis.max.add( offset );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tequals: function ( box ) {\r\n\t\r\n\t\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/math/Box3.js\r\n\t\r\n\t/**\r\n\t * @author bhouston / http://clara.io\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t */\r\n\t\r\n\tTHREE.Box3 = function ( min, max ) {\r\n\t\r\n\t\tthis.min = ( min !== undefined ) ? min : new THREE.Vector3( + Infinity, + Infinity, + Infinity );\r\n\t\tthis.max = ( max !== undefined ) ? max : new THREE.Vector3( - Infinity, - Infinity, - Infinity );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Box3.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Box3,\r\n\t\r\n\t\tset: function ( min, max ) {\r\n\t\r\n\t\t\tthis.min.copy( min );\r\n\t\t\tthis.max.copy( max );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromArray: function ( array ) {\r\n\t\r\n\t\t\tvar minX = + Infinity;\r\n\t\t\tvar minY = + Infinity;\r\n\t\t\tvar minZ = + Infinity;\r\n\t\r\n\t\t\tvar maxX = - Infinity;\r\n\t\t\tvar maxY = - Infinity;\r\n\t\t\tvar maxZ = - Infinity;\r\n\t\r\n\t\t\tfor ( var i = 0, l = array.length; i < l; i += 3 ) {\r\n\t\r\n\t\t\t\tvar x = array[ i ];\r\n\t\t\t\tvar y = array[ i + 1 ];\r\n\t\t\t\tvar z = array[ i + 2 ];\r\n\t\r\n\t\t\t\tif ( x < minX ) minX = x;\r\n\t\t\t\tif ( y < minY ) minY = y;\r\n\t\t\t\tif ( z < minZ ) minZ = z;\r\n\t\r\n\t\t\t\tif ( x > maxX ) maxX = x;\r\n\t\t\t\tif ( y > maxY ) maxY = y;\r\n\t\t\t\tif ( z > maxZ ) maxZ = z;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.min.set( minX, minY, minZ );\r\n\t\t\tthis.max.set( maxX, maxY, maxZ );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromPoints: function ( points ) {\r\n\t\r\n\t\t\tthis.makeEmpty();\r\n\t\r\n\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tthis.expandByPoint( points[ i ] );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromCenterAndSize: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function ( center, size ) {\r\n\t\r\n\t\t\t\tvar halfSize = v1.copy( size ).multiplyScalar( 0.5 );\r\n\t\r\n\t\t\t\tthis.min.copy( center ).sub( halfSize );\r\n\t\t\t\tthis.max.copy( center ).add( halfSize );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tsetFromObject: function () {\r\n\t\r\n\t\t\t// Computes the world-axis-aligned bounding box of an object (including its children),\r\n\t\t\t// accounting for both the object's, and children's, world transforms\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function ( object ) {\r\n\t\r\n\t\t\t\tvar scope = this;\r\n\t\r\n\t\t\t\tobject.updateMatrixWorld( true );\r\n\t\r\n\t\t\t\tthis.makeEmpty();\r\n\t\r\n\t\t\t\tobject.traverse( function ( node ) {\r\n\t\r\n\t\t\t\t\tvar geometry = node.geometry;\r\n\t\r\n\t\t\t\t\tif ( geometry !== undefined ) {\r\n\t\r\n\t\t\t\t\t\tif ( geometry instanceof THREE.Geometry ) {\r\n\t\r\n\t\t\t\t\t\t\tvar vertices = geometry.vertices;\r\n\t\r\n\t\t\t\t\t\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\tv1.copy( vertices[ i ] );\r\n\t\t\t\t\t\t\t\tv1.applyMatrix4( node.matrixWorld );\r\n\t\r\n\t\t\t\t\t\t\t\tscope.expandByPoint( v1 );\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t} else if ( geometry instanceof THREE.BufferGeometry && geometry.attributes[ 'position' ] !== undefined ) {\r\n\t\r\n\t\t\t\t\t\t\tvar positions = geometry.attributes[ 'position' ].array;\r\n\t\r\n\t\t\t\t\t\t\tfor ( var i = 0, il = positions.length; i < il; i += 3 ) {\r\n\t\r\n\t\t\t\t\t\t\t\tv1.fromArray( positions, i );\r\n\t\t\t\t\t\t\t\tv1.applyMatrix4( node.matrixWorld );\r\n\t\r\n\t\t\t\t\t\t\t\tscope.expandByPoint( v1 );\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new this.constructor().copy( this );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( box ) {\r\n\t\r\n\t\t\tthis.min.copy( box.min );\r\n\t\t\tthis.max.copy( box.max );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmakeEmpty: function () {\r\n\t\r\n\t\t\tthis.min.x = this.min.y = this.min.z = + Infinity;\r\n\t\t\tthis.max.x = this.max.y = this.max.z = - Infinity;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tisEmpty: function () {\r\n\t\r\n\t\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\r\n\t\r\n\t\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcenter: function ( optionalTarget ) {\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\t\treturn result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsize: function ( optionalTarget ) {\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\t\treturn result.subVectors( this.max, this.min );\r\n\t\r\n\t\t},\r\n\t\r\n\t\texpandByPoint: function ( point ) {\r\n\t\r\n\t\t\tthis.min.min( point );\r\n\t\t\tthis.max.max( point );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\texpandByVector: function ( vector ) {\r\n\t\r\n\t\t\tthis.min.sub( vector );\r\n\t\t\tthis.max.add( vector );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\texpandByScalar: function ( scalar ) {\r\n\t\r\n\t\t\tthis.min.addScalar( - scalar );\r\n\t\t\tthis.max.addScalar( scalar );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcontainsPoint: function ( point ) {\r\n\t\r\n\t\t\tif ( point.x < this.min.x || point.x > this.max.x ||\r\n\t\t\t\t\t point.y < this.min.y || point.y > this.max.y ||\r\n\t\t\t\t\t point.z < this.min.z || point.z > this.max.z ) {\r\n\t\r\n\t\t\t\treturn false;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn true;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcontainsBox: function ( box ) {\r\n\t\r\n\t\t\tif ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&\r\n\t\t\t\t ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) &&\r\n\t\t\t\t ( this.min.z <= box.min.z ) && ( box.max.z <= this.max.z ) ) {\r\n\t\r\n\t\t\t\treturn true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn false;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetParameter: function ( point, optionalTarget ) {\r\n\t\r\n\t\t\t// This can potentially have a divide by zero if the box\r\n\t\t\t// has a size dimension of 0.\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\r\n\t\t\treturn result.set(\r\n\t\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\r\n\t\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y ),\r\n\t\t\t\t( point.z - this.min.z ) / ( this.max.z - this.min.z )\r\n\t\t\t);\r\n\t\r\n\t\t},\r\n\t\r\n\t\tintersectsBox: function ( box ) {\r\n\t\r\n\t\t\t// using 6 splitting planes to rule out intersections.\r\n\t\r\n\t\t\tif ( box.max.x < this.min.x || box.min.x > this.max.x ||\r\n\t\t\t\t\t box.max.y < this.min.y || box.min.y > this.max.y ||\r\n\t\t\t\t\t box.max.z < this.min.z || box.min.z > this.max.z ) {\r\n\t\r\n\t\t\t\treturn false;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn true;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tintersectsSphere: ( function () {\r\n\t\r\n\t\t\tvar closestPoint;\r\n\t\r\n\t\t\treturn function intersectsSphere( sphere ) {\r\n\t\r\n\t\t\t\tif ( closestPoint === undefined ) closestPoint = new THREE.Vector3();\r\n\t\r\n\t\t\t\t// Find the point on the AABB closest to the sphere center.\r\n\t\t\t\tthis.clampPoint( sphere.center, closestPoint );\r\n\t\r\n\t\t\t\t// If that point is inside the sphere, the AABB and sphere intersect.\r\n\t\t\t\treturn closestPoint.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t} )(),\r\n\t\r\n\t\tintersectsPlane: function ( plane ) {\r\n\t\r\n\t\t\t// We compute the minimum and maximum dot product values. If those values\r\n\t\t\t// are on the same side (back or front) of the plane, then there is no intersection.\r\n\t\r\n\t\t\tvar min, max;\r\n\t\r\n\t\t\tif ( plane.normal.x > 0 ) {\r\n\t\r\n\t\t\t\tmin = plane.normal.x * this.min.x;\r\n\t\t\t\tmax = plane.normal.x * this.max.x;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tmin = plane.normal.x * this.max.x;\r\n\t\t\t\tmax = plane.normal.x * this.min.x;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( plane.normal.y > 0 ) {\r\n\t\r\n\t\t\t\tmin += plane.normal.y * this.min.y;\r\n\t\t\t\tmax += plane.normal.y * this.max.y;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tmin += plane.normal.y * this.max.y;\r\n\t\t\t\tmax += plane.normal.y * this.min.y;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( plane.normal.z > 0 ) {\r\n\t\r\n\t\t\t\tmin += plane.normal.z * this.min.z;\r\n\t\t\t\tmax += plane.normal.z * this.max.z;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tmin += plane.normal.z * this.max.z;\r\n\t\t\t\tmax += plane.normal.z * this.min.z;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn ( min <= plane.constant && max >= plane.constant );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclampPoint: function ( point, optionalTarget ) {\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\t\treturn result.copy( point ).clamp( this.min, this.max );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdistanceToPoint: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function ( point ) {\r\n\t\r\n\t\t\t\tvar clampedPoint = v1.copy( point ).clamp( this.min, this.max );\r\n\t\t\t\treturn clampedPoint.sub( point ).length();\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tgetBoundingSphere: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function ( optionalTarget ) {\r\n\t\r\n\t\t\t\tvar result = optionalTarget || new THREE.Sphere();\r\n\t\r\n\t\t\t\tresult.center = this.center();\r\n\t\t\t\tresult.radius = this.size( v1 ).length() * 0.5;\r\n\t\r\n\t\t\t\treturn result;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tintersect: function ( box ) {\r\n\t\r\n\t\t\tthis.min.max( box.min );\r\n\t\t\tthis.max.min( box.max );\r\n\t\r\n\t\t\t// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.\r\n\t\t\tif( this.isEmpty() ) this.makeEmpty();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tunion: function ( box ) {\r\n\t\r\n\t\t\tthis.min.min( box.min );\r\n\t\t\tthis.max.max( box.max );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tapplyMatrix4: function () {\r\n\t\r\n\t\t\tvar points = [\r\n\t\t\t\tnew THREE.Vector3(),\r\n\t\t\t\tnew THREE.Vector3(),\r\n\t\t\t\tnew THREE.Vector3(),\r\n\t\t\t\tnew THREE.Vector3(),\r\n\t\t\t\tnew THREE.Vector3(),\r\n\t\t\t\tnew THREE.Vector3(),\r\n\t\t\t\tnew THREE.Vector3(),\r\n\t\t\t\tnew THREE.Vector3()\r\n\t\t\t];\r\n\t\r\n\t\t\treturn function ( matrix ) {\r\n\t\r\n\t\t\t\t// transform of empty box is an empty box.\r\n\t\t\t\tif( this.isEmpty() ) return this;\r\n\t\r\n\t\t\t\t// NOTE: I am using a binary pattern to specify all 2^3 combinations below\r\n\t\t\t\tpoints[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000\r\n\t\t\t\tpoints[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001\r\n\t\t\t\tpoints[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010\r\n\t\t\t\tpoints[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011\r\n\t\t\t\tpoints[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100\r\n\t\t\t\tpoints[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101\r\n\t\t\t\tpoints[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110\r\n\t\t\t\tpoints[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );\t// 111\r\n\t\r\n\t\t\t\tthis.setFromPoints( points );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\ttranslate: function ( offset ) {\r\n\t\r\n\t\t\tthis.min.add( offset );\r\n\t\t\tthis.max.add( offset );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tequals: function ( box ) {\r\n\t\r\n\t\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/math/Matrix3.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t * @author bhouston / http://clara.io\r\n\t * @author tschw\r\n\t */\r\n\t\r\n\tTHREE.Matrix3 = function () {\r\n\t\r\n\t\tthis.elements = new Float32Array( [\r\n\t\r\n\t\t\t1, 0, 0,\r\n\t\t\t0, 1, 0,\r\n\t\t\t0, 0, 1\r\n\t\r\n\t\t] );\r\n\t\r\n\t\tif ( arguments.length > 0 ) {\r\n\t\r\n\t\t\tconsole.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Matrix3.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Matrix3,\r\n\t\r\n\t\tset: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\r\n\t\t\tte[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;\r\n\t\t\tte[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;\r\n\t\t\tte[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tidentity: function () {\r\n\t\r\n\t\t\tthis.set(\r\n\t\r\n\t\t\t\t1, 0, 0,\r\n\t\t\t\t0, 1, 0,\r\n\t\t\t\t0, 0, 1\r\n\t\r\n\t\t\t);\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new this.constructor().fromArray( this.elements );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( m ) {\r\n\t\r\n\t\t\tvar me = m.elements;\r\n\t\r\n\t\t\tthis.set(\r\n\t\r\n\t\t\t\tme[ 0 ], me[ 3 ], me[ 6 ],\r\n\t\t\t\tme[ 1 ], me[ 4 ], me[ 7 ],\r\n\t\t\t\tme[ 2 ], me[ 5 ], me[ 8 ]\r\n\t\r\n\t\t\t);\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromMatrix4: function( m ) {\r\n\t\r\n\t\t\tvar me = m.elements;\r\n\t\r\n\t\t\tthis.set(\r\n\t\r\n\t\t\t\tme[ 0 ], me[ 4 ], me[  8 ],\r\n\t\t\t\tme[ 1 ], me[ 5 ], me[  9 ],\r\n\t\t\t\tme[ 2 ], me[ 6 ], me[ 10 ]\r\n\t\r\n\t\t\t);\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tapplyToVector3Array: function () {\r\n\t\r\n\t\t\tvar v1;\r\n\t\r\n\t\t\treturn function ( array, offset, length ) {\r\n\t\r\n\t\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\t\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\t\t\tif ( length === undefined ) length = array.length;\r\n\t\r\n\t\t\t\tfor ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {\r\n\t\r\n\t\t\t\t\tv1.fromArray( array, j );\r\n\t\t\t\t\tv1.applyMatrix3( this );\r\n\t\t\t\t\tv1.toArray( array, j );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn array;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tapplyToBuffer: function () {\r\n\t\r\n\t\t\tvar v1;\r\n\t\r\n\t\t\treturn function applyToBuffer( buffer, offset, length ) {\r\n\t\r\n\t\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\t\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\t\t\tif ( length === undefined ) length = buffer.length / buffer.itemSize;\r\n\t\r\n\t\t\t\tfor ( var i = 0, j = offset; i < length; i ++, j ++ ) {\r\n\t\r\n\t\t\t\t\tv1.x = buffer.getX( j );\r\n\t\t\t\t\tv1.y = buffer.getY( j );\r\n\t\t\t\t\tv1.z = buffer.getZ( j );\r\n\t\r\n\t\t\t\t\tv1.applyMatrix3( this );\r\n\t\r\n\t\t\t\t\tbuffer.setXYZ( v1.x, v1.y, v1.z );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn buffer;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tmultiplyScalar: function ( s ) {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\r\n\t\t\tte[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;\r\n\t\t\tte[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;\r\n\t\t\tte[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdeterminant: function () {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\r\n\t\t\tvar a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],\r\n\t\t\t\td = te[ 3 ], e = te[ 4 ], f = te[ 5 ],\r\n\t\t\t\tg = te[ 6 ], h = te[ 7 ], i = te[ 8 ];\r\n\t\r\n\t\t\treturn a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetInverse: function ( matrix, throwOnDegenerate ) {\r\n\t\r\n\t\t\tif ( matrix instanceof THREE.Matrix4 ) {\r\n\t\r\n\t\t\t\tconsole.error( \"THREE.Matrix3.getInverse no longer takes a Matrix4 argument.\" );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar me = matrix.elements,\r\n\t\t\t\tte = this.elements,\r\n\t\r\n\t\t\t\tn11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ],\r\n\t\t\t\tn12 = me[ 3 ], n22 = me[ 4 ], n32 = me[ 5 ],\r\n\t\t\t\tn13 = me[ 6 ], n23 = me[ 7 ], n33 = me[ 8 ],\r\n\t\r\n\t\t\t\tt11 = n33 * n22 - n32 * n23,\r\n\t\t\t\tt12 = n32 * n13 - n33 * n12,\r\n\t\t\t\tt13 = n23 * n12 - n22 * n13,\r\n\t\r\n\t\t\t\tdet = n11 * t11 + n21 * t12 + n31 * t13;\r\n\t\r\n\t\t\tif ( det === 0 ) {\r\n\t\r\n\t\t\t\tvar msg = \"THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0\";\r\n\t\r\n\t\t\t\tif ( throwOnDegenerate || false ) {\r\n\t\r\n\t\t\t\t\tthrow new Error( msg );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tconsole.warn( msg );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn this.identity();\r\n\t\t\t}\r\n\t\r\n\t\t\tte[ 0 ] = t11;\r\n\t\t\tte[ 1 ] = n31 * n23 - n33 * n21;\r\n\t\t\tte[ 2 ] = n32 * n21 - n31 * n22;\r\n\t\r\n\t\t\tte[ 3 ] = t12;\r\n\t\t\tte[ 4 ] = n33 * n11 - n31 * n13;\r\n\t\t\tte[ 5 ] = n31 * n12 - n32 * n11;\r\n\t\r\n\t\t\tte[ 6 ] = t13;\r\n\t\t\tte[ 7 ] = n21 * n13 - n23 * n11;\r\n\t\t\tte[ 8 ] = n22 * n11 - n21 * n12;\r\n\t\r\n\t\t\treturn this.multiplyScalar( 1 / det );\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttranspose: function () {\r\n\t\r\n\t\t\tvar tmp, m = this.elements;\r\n\t\r\n\t\t\ttmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;\r\n\t\t\ttmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;\r\n\t\t\ttmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tflattenToArrayOffset: function ( array, offset ) {\r\n\t\r\n\t\t\tconsole.warn( \"THREE.Matrix3: .flattenToArrayOffset is deprecated \" +\r\n\t\t\t\t\t\"- just use .toArray instead.\" );\r\n\t\r\n\t\t\treturn this.toArray( array, offset );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetNormalMatrix: function ( matrix4 ) {\r\n\t\r\n\t\t\treturn this.setFromMatrix4( matrix4 ).getInverse( this ).transpose();\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttransposeIntoArray: function ( r ) {\r\n\t\r\n\t\t\tvar m = this.elements;\r\n\t\r\n\t\t\tr[ 0 ] = m[ 0 ];\r\n\t\t\tr[ 1 ] = m[ 3 ];\r\n\t\t\tr[ 2 ] = m[ 6 ];\r\n\t\t\tr[ 3 ] = m[ 1 ];\r\n\t\t\tr[ 4 ] = m[ 4 ];\r\n\t\t\tr[ 5 ] = m[ 7 ];\r\n\t\t\tr[ 6 ] = m[ 2 ];\r\n\t\t\tr[ 7 ] = m[ 5 ];\r\n\t\t\tr[ 8 ] = m[ 8 ];\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfromArray: function ( array ) {\r\n\t\r\n\t\t\tthis.elements.set( array );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttoArray: function ( array, offset ) {\r\n\t\r\n\t\t\tif ( array === undefined ) array = [];\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\r\n\t\t\tarray[ offset ] = te[ 0 ];\r\n\t\t\tarray[ offset + 1 ] = te[ 1 ];\r\n\t\t\tarray[ offset + 2 ] = te[ 2 ];\r\n\t\r\n\t\t\tarray[ offset + 3 ] = te[ 3 ];\r\n\t\t\tarray[ offset + 4 ] = te[ 4 ];\r\n\t\t\tarray[ offset + 5 ] = te[ 5 ];\r\n\t\r\n\t\t\tarray[ offset + 6 ] = te[ 6 ];\r\n\t\t\tarray[ offset + 7 ] = te[ 7 ];\r\n\t\t\tarray[ offset + 8 ]  = te[ 8 ];\r\n\t\r\n\t\t\treturn array;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/math/Matrix4.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author supereggbert / http://www.paulbrunt.co.uk/\r\n\t * @author philogb / http://blog.thejit.org/\r\n\t * @author jordi_ros / http://plattsoft.com\r\n\t * @author D1plo1d / http://github.com/D1plo1d\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t * @author timknip / http://www.floorplanner.com/\r\n\t * @author bhouston / http://clara.io\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t */\r\n\t\r\n\tTHREE.Matrix4 = function () {\r\n\t\r\n\t\tthis.elements = new Float32Array( [\r\n\t\r\n\t\t\t1, 0, 0, 0,\r\n\t\t\t0, 1, 0, 0,\r\n\t\t\t0, 0, 1, 0,\r\n\t\t\t0, 0, 0, 1\r\n\t\r\n\t\t] );\r\n\t\r\n\t\tif ( arguments.length > 0 ) {\r\n\t\r\n\t\t\tconsole.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Matrix4.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Matrix4,\r\n\t\r\n\t\tset: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\r\n\t\t\tte[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;\r\n\t\t\tte[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;\r\n\t\t\tte[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;\r\n\t\t\tte[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tidentity: function () {\r\n\t\r\n\t\t\tthis.set(\r\n\t\r\n\t\t\t\t1, 0, 0, 0,\r\n\t\t\t\t0, 1, 0, 0,\r\n\t\t\t\t0, 0, 1, 0,\r\n\t\t\t\t0, 0, 0, 1\r\n\t\r\n\t\t\t);\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new THREE.Matrix4().fromArray( this.elements );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( m ) {\r\n\t\r\n\t\t\tthis.elements.set( m.elements );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopyPosition: function ( m ) {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\t\tvar me = m.elements;\r\n\t\r\n\t\t\tte[ 12 ] = me[ 12 ];\r\n\t\t\tte[ 13 ] = me[ 13 ];\r\n\t\t\tte[ 14 ] = me[ 14 ];\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\textractBasis: function ( xAxis, yAxis, zAxis ) {\r\n\t\r\n\t\t\txAxis.setFromMatrixColumn( this, 0 );\r\n\t\t\tyAxis.setFromMatrixColumn( this, 1 );\r\n\t\t\tzAxis.setFromMatrixColumn( this, 2 );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmakeBasis: function ( xAxis, yAxis, zAxis ) {\r\n\t\r\n\t\t\tthis.set(\r\n\t\t\t\txAxis.x, yAxis.x, zAxis.x, 0,\r\n\t\t\t\txAxis.y, yAxis.y, zAxis.y, 0,\r\n\t\t\t\txAxis.z, yAxis.z, zAxis.z, 0,\r\n\t\t\t\t0,       0,       0,       1\r\n\t\t\t);\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\textractRotation: function () {\r\n\t\r\n\t\t\tvar v1;\r\n\t\r\n\t\t\treturn function ( m ) {\r\n\t\r\n\t\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\t\r\n\t\t\t\tvar te = this.elements;\r\n\t\t\t\tvar me = m.elements;\r\n\t\r\n\t\t\t\tvar scaleX = 1 / v1.setFromMatrixColumn( m, 0 ).length();\r\n\t\t\t\tvar scaleY = 1 / v1.setFromMatrixColumn( m, 1 ).length();\r\n\t\t\t\tvar scaleZ = 1 / v1.setFromMatrixColumn( m, 2 ).length();\r\n\t\r\n\t\t\t\tte[ 0 ] = me[ 0 ] * scaleX;\r\n\t\t\t\tte[ 1 ] = me[ 1 ] * scaleX;\r\n\t\t\t\tte[ 2 ] = me[ 2 ] * scaleX;\r\n\t\r\n\t\t\t\tte[ 4 ] = me[ 4 ] * scaleY;\r\n\t\t\t\tte[ 5 ] = me[ 5 ] * scaleY;\r\n\t\t\t\tte[ 6 ] = me[ 6 ] * scaleY;\r\n\t\r\n\t\t\t\tte[ 8 ] = me[ 8 ] * scaleZ;\r\n\t\t\t\tte[ 9 ] = me[ 9 ] * scaleZ;\r\n\t\t\t\tte[ 10 ] = me[ 10 ] * scaleZ;\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tmakeRotationFromEuler: function ( euler ) {\r\n\t\r\n\t\t\tif ( euler instanceof THREE.Euler === false ) {\r\n\t\r\n\t\t\t\tconsole.error( 'THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\r\n\t\t\tvar x = euler.x, y = euler.y, z = euler.z;\r\n\t\t\tvar a = Math.cos( x ), b = Math.sin( x );\r\n\t\t\tvar c = Math.cos( y ), d = Math.sin( y );\r\n\t\t\tvar e = Math.cos( z ), f = Math.sin( z );\r\n\t\r\n\t\t\tif ( euler.order === 'XYZ' ) {\r\n\t\r\n\t\t\t\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\r\n\t\r\n\t\t\t\tte[ 0 ] = c * e;\r\n\t\t\t\tte[ 4 ] = - c * f;\r\n\t\t\t\tte[ 8 ] = d;\r\n\t\r\n\t\t\t\tte[ 1 ] = af + be * d;\r\n\t\t\t\tte[ 5 ] = ae - bf * d;\r\n\t\t\t\tte[ 9 ] = - b * c;\r\n\t\r\n\t\t\t\tte[ 2 ] = bf - ae * d;\r\n\t\t\t\tte[ 6 ] = be + af * d;\r\n\t\t\t\tte[ 10 ] = a * c;\r\n\t\r\n\t\t\t} else if ( euler.order === 'YXZ' ) {\r\n\t\r\n\t\t\t\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\r\n\t\r\n\t\t\t\tte[ 0 ] = ce + df * b;\r\n\t\t\t\tte[ 4 ] = de * b - cf;\r\n\t\t\t\tte[ 8 ] = a * d;\r\n\t\r\n\t\t\t\tte[ 1 ] = a * f;\r\n\t\t\t\tte[ 5 ] = a * e;\r\n\t\t\t\tte[ 9 ] = - b;\r\n\t\r\n\t\t\t\tte[ 2 ] = cf * b - de;\r\n\t\t\t\tte[ 6 ] = df + ce * b;\r\n\t\t\t\tte[ 10 ] = a * c;\r\n\t\r\n\t\t\t} else if ( euler.order === 'ZXY' ) {\r\n\t\r\n\t\t\t\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\r\n\t\r\n\t\t\t\tte[ 0 ] = ce - df * b;\r\n\t\t\t\tte[ 4 ] = - a * f;\r\n\t\t\t\tte[ 8 ] = de + cf * b;\r\n\t\r\n\t\t\t\tte[ 1 ] = cf + de * b;\r\n\t\t\t\tte[ 5 ] = a * e;\r\n\t\t\t\tte[ 9 ] = df - ce * b;\r\n\t\r\n\t\t\t\tte[ 2 ] = - a * d;\r\n\t\t\t\tte[ 6 ] = b;\r\n\t\t\t\tte[ 10 ] = a * c;\r\n\t\r\n\t\t\t} else if ( euler.order === 'ZYX' ) {\r\n\t\r\n\t\t\t\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\r\n\t\r\n\t\t\t\tte[ 0 ] = c * e;\r\n\t\t\t\tte[ 4 ] = be * d - af;\r\n\t\t\t\tte[ 8 ] = ae * d + bf;\r\n\t\r\n\t\t\t\tte[ 1 ] = c * f;\r\n\t\t\t\tte[ 5 ] = bf * d + ae;\r\n\t\t\t\tte[ 9 ] = af * d - be;\r\n\t\r\n\t\t\t\tte[ 2 ] = - d;\r\n\t\t\t\tte[ 6 ] = b * c;\r\n\t\t\t\tte[ 10 ] = a * c;\r\n\t\r\n\t\t\t} else if ( euler.order === 'YZX' ) {\r\n\t\r\n\t\t\t\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\r\n\t\r\n\t\t\t\tte[ 0 ] = c * e;\r\n\t\t\t\tte[ 4 ] = bd - ac * f;\r\n\t\t\t\tte[ 8 ] = bc * f + ad;\r\n\t\r\n\t\t\t\tte[ 1 ] = f;\r\n\t\t\t\tte[ 5 ] = a * e;\r\n\t\t\t\tte[ 9 ] = - b * e;\r\n\t\r\n\t\t\t\tte[ 2 ] = - d * e;\r\n\t\t\t\tte[ 6 ] = ad * f + bc;\r\n\t\t\t\tte[ 10 ] = ac - bd * f;\r\n\t\r\n\t\t\t} else if ( euler.order === 'XZY' ) {\r\n\t\r\n\t\t\t\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\r\n\t\r\n\t\t\t\tte[ 0 ] = c * e;\r\n\t\t\t\tte[ 4 ] = - f;\r\n\t\t\t\tte[ 8 ] = d * e;\r\n\t\r\n\t\t\t\tte[ 1 ] = ac * f + bd;\r\n\t\t\t\tte[ 5 ] = a * e;\r\n\t\t\t\tte[ 9 ] = ad * f - bc;\r\n\t\r\n\t\t\t\tte[ 2 ] = bc * f - ad;\r\n\t\t\t\tte[ 6 ] = b * e;\r\n\t\t\t\tte[ 10 ] = bd * f + ac;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// last column\r\n\t\t\tte[ 3 ] = 0;\r\n\t\t\tte[ 7 ] = 0;\r\n\t\t\tte[ 11 ] = 0;\r\n\t\r\n\t\t\t// bottom row\r\n\t\t\tte[ 12 ] = 0;\r\n\t\t\tte[ 13 ] = 0;\r\n\t\t\tte[ 14 ] = 0;\r\n\t\t\tte[ 15 ] = 1;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmakeRotationFromQuaternion: function ( q ) {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\r\n\t\t\tvar x = q.x, y = q.y, z = q.z, w = q.w;\r\n\t\t\tvar x2 = x + x, y2 = y + y, z2 = z + z;\r\n\t\t\tvar xx = x * x2, xy = x * y2, xz = x * z2;\r\n\t\t\tvar yy = y * y2, yz = y * z2, zz = z * z2;\r\n\t\t\tvar wx = w * x2, wy = w * y2, wz = w * z2;\r\n\t\r\n\t\t\tte[ 0 ] = 1 - ( yy + zz );\r\n\t\t\tte[ 4 ] = xy - wz;\r\n\t\t\tte[ 8 ] = xz + wy;\r\n\t\r\n\t\t\tte[ 1 ] = xy + wz;\r\n\t\t\tte[ 5 ] = 1 - ( xx + zz );\r\n\t\t\tte[ 9 ] = yz - wx;\r\n\t\r\n\t\t\tte[ 2 ] = xz - wy;\r\n\t\t\tte[ 6 ] = yz + wx;\r\n\t\t\tte[ 10 ] = 1 - ( xx + yy );\r\n\t\r\n\t\t\t// last column\r\n\t\t\tte[ 3 ] = 0;\r\n\t\t\tte[ 7 ] = 0;\r\n\t\t\tte[ 11 ] = 0;\r\n\t\r\n\t\t\t// bottom row\r\n\t\t\tte[ 12 ] = 0;\r\n\t\t\tte[ 13 ] = 0;\r\n\t\t\tte[ 14 ] = 0;\r\n\t\t\tte[ 15 ] = 1;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlookAt: function () {\r\n\t\r\n\t\t\tvar x, y, z;\r\n\t\r\n\t\t\treturn function ( eye, target, up ) {\r\n\t\r\n\t\t\t\tif ( x === undefined ) x = new THREE.Vector3();\r\n\t\t\t\tif ( y === undefined ) y = new THREE.Vector3();\r\n\t\t\t\tif ( z === undefined ) z = new THREE.Vector3();\r\n\t\r\n\t\t\t\tvar te = this.elements;\r\n\t\r\n\t\t\t\tz.subVectors( eye, target ).normalize();\r\n\t\r\n\t\t\t\tif ( z.lengthSq() === 0 ) {\r\n\t\r\n\t\t\t\t\tz.z = 1;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tx.crossVectors( up, z ).normalize();\r\n\t\r\n\t\t\t\tif ( x.lengthSq() === 0 ) {\r\n\t\r\n\t\t\t\t\tz.x += 0.0001;\r\n\t\t\t\t\tx.crossVectors( up, z ).normalize();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\ty.crossVectors( z, x );\r\n\t\r\n\t\r\n\t\t\t\tte[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;\r\n\t\t\t\tte[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;\r\n\t\t\t\tte[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tmultiply: function ( m, n ) {\r\n\t\r\n\t\t\tif ( n !== undefined ) {\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );\r\n\t\t\t\treturn this.multiplyMatrices( m, n );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this.multiplyMatrices( this, m );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tpremultiply: function ( m ) {\r\n\t\r\n\t\t\treturn this.multiplyMatrices( m, this );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmultiplyMatrices: function ( a, b ) {\r\n\t\r\n\t\t\tvar ae = a.elements;\r\n\t\t\tvar be = b.elements;\r\n\t\t\tvar te = this.elements;\r\n\t\r\n\t\t\tvar a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];\r\n\t\t\tvar a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];\r\n\t\t\tvar a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];\r\n\t\t\tvar a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];\r\n\t\r\n\t\t\tvar b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];\r\n\t\t\tvar b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];\r\n\t\t\tvar b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];\r\n\t\t\tvar b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];\r\n\t\r\n\t\t\tte[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\r\n\t\t\tte[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\r\n\t\t\tte[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\r\n\t\t\tte[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\r\n\t\r\n\t\t\tte[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\r\n\t\t\tte[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\r\n\t\t\tte[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\r\n\t\t\tte[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\r\n\t\r\n\t\t\tte[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\r\n\t\t\tte[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\r\n\t\t\tte[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\r\n\t\t\tte[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\r\n\t\r\n\t\t\tte[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\r\n\t\t\tte[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\r\n\t\t\tte[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\r\n\t\t\tte[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmultiplyToArray: function ( a, b, r ) {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\r\n\t\t\tthis.multiplyMatrices( a, b );\r\n\t\r\n\t\t\tr[ 0 ] = te[ 0 ]; r[ 1 ] = te[ 1 ]; r[ 2 ] = te[ 2 ]; r[ 3 ] = te[ 3 ];\r\n\t\t\tr[ 4 ] = te[ 4 ]; r[ 5 ] = te[ 5 ]; r[ 6 ] = te[ 6 ]; r[ 7 ] = te[ 7 ];\r\n\t\t\tr[ 8 ]  = te[ 8 ]; r[ 9 ]  = te[ 9 ]; r[ 10 ] = te[ 10 ]; r[ 11 ] = te[ 11 ];\r\n\t\t\tr[ 12 ] = te[ 12 ]; r[ 13 ] = te[ 13 ]; r[ 14 ] = te[ 14 ]; r[ 15 ] = te[ 15 ];\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmultiplyScalar: function ( s ) {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\r\n\t\t\tte[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;\r\n\t\t\tte[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;\r\n\t\t\tte[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;\r\n\t\t\tte[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tapplyToVector3Array: function () {\r\n\t\r\n\t\t\tvar v1;\r\n\t\r\n\t\t\treturn function ( array, offset, length ) {\r\n\t\r\n\t\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\t\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\t\t\tif ( length === undefined ) length = array.length;\r\n\t\r\n\t\t\t\tfor ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {\r\n\t\r\n\t\t\t\t\tv1.fromArray( array, j );\r\n\t\t\t\t\tv1.applyMatrix4( this );\r\n\t\t\t\t\tv1.toArray( array, j );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn array;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tapplyToBuffer: function () {\r\n\t\r\n\t\t\tvar v1;\r\n\t\r\n\t\t\treturn function applyToBuffer( buffer, offset, length ) {\r\n\t\r\n\t\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\t\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\t\t\tif ( length === undefined ) length = buffer.length / buffer.itemSize;\r\n\t\r\n\t\t\t\tfor ( var i = 0, j = offset; i < length; i ++, j ++ ) {\r\n\t\r\n\t\t\t\t\tv1.x = buffer.getX( j );\r\n\t\t\t\t\tv1.y = buffer.getY( j );\r\n\t\t\t\t\tv1.z = buffer.getZ( j );\r\n\t\r\n\t\t\t\t\tv1.applyMatrix4( this );\r\n\t\r\n\t\t\t\t\tbuffer.setXYZ( v1.x, v1.y, v1.z );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn buffer;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tdeterminant: function () {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\r\n\t\t\tvar n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];\r\n\t\t\tvar n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];\r\n\t\t\tvar n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];\r\n\t\t\tvar n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];\r\n\t\r\n\t\t\t//TODO: make this more efficient\r\n\t\t\t//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )\r\n\t\r\n\t\t\treturn (\r\n\t\t\t\tn41 * (\r\n\t\t\t\t\t+ n14 * n23 * n32\r\n\t\t\t\t\t - n13 * n24 * n32\r\n\t\t\t\t\t - n14 * n22 * n33\r\n\t\t\t\t\t + n12 * n24 * n33\r\n\t\t\t\t\t + n13 * n22 * n34\r\n\t\t\t\t\t - n12 * n23 * n34\r\n\t\t\t\t) +\r\n\t\t\t\tn42 * (\r\n\t\t\t\t\t+ n11 * n23 * n34\r\n\t\t\t\t\t - n11 * n24 * n33\r\n\t\t\t\t\t + n14 * n21 * n33\r\n\t\t\t\t\t - n13 * n21 * n34\r\n\t\t\t\t\t + n13 * n24 * n31\r\n\t\t\t\t\t - n14 * n23 * n31\r\n\t\t\t\t) +\r\n\t\t\t\tn43 * (\r\n\t\t\t\t\t+ n11 * n24 * n32\r\n\t\t\t\t\t - n11 * n22 * n34\r\n\t\t\t\t\t - n14 * n21 * n32\r\n\t\t\t\t\t + n12 * n21 * n34\r\n\t\t\t\t\t + n14 * n22 * n31\r\n\t\t\t\t\t - n12 * n24 * n31\r\n\t\t\t\t) +\r\n\t\t\t\tn44 * (\r\n\t\t\t\t\t- n13 * n22 * n31\r\n\t\t\t\t\t - n11 * n23 * n32\r\n\t\t\t\t\t + n11 * n22 * n33\r\n\t\t\t\t\t + n13 * n21 * n32\r\n\t\t\t\t\t - n12 * n21 * n33\r\n\t\t\t\t\t + n12 * n23 * n31\r\n\t\t\t\t)\r\n\t\r\n\t\t\t);\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttranspose: function () {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\t\tvar tmp;\r\n\t\r\n\t\t\ttmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;\r\n\t\t\ttmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;\r\n\t\t\ttmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;\r\n\t\r\n\t\t\ttmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;\r\n\t\t\ttmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;\r\n\t\t\ttmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tflattenToArrayOffset: function ( array, offset ) {\r\n\t\r\n\t\t\tconsole.warn( \"THREE.Matrix3: .flattenToArrayOffset is deprecated \" +\r\n\t\t\t\t\t\"- just use .toArray instead.\" );\r\n\t\r\n\t\t\treturn this.toArray( array, offset );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetPosition: function () {\r\n\t\r\n\t\t\tvar v1;\r\n\t\r\n\t\t\treturn function () {\r\n\t\r\n\t\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\t\t\t\tconsole.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );\r\n\t\r\n\t\t\t\treturn v1.setFromMatrixColumn( this, 3 );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tsetPosition: function ( v ) {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\r\n\t\t\tte[ 12 ] = v.x;\r\n\t\t\tte[ 13 ] = v.y;\r\n\t\t\tte[ 14 ] = v.z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetInverse: function ( m, throwOnDegenerate ) {\r\n\t\r\n\t\t\t// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\r\n\t\t\tvar te = this.elements,\r\n\t\t\t\tme = m.elements,\r\n\t\r\n\t\t\t\tn11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ], n41 = me[ 3 ],\r\n\t\t\t\tn12 = me[ 4 ], n22 = me[ 5 ], n32 = me[ 6 ], n42 = me[ 7 ],\r\n\t\t\t\tn13 = me[ 8 ], n23 = me[ 9 ], n33 = me[ 10 ], n43 = me[ 11 ],\r\n\t\t\t\tn14 = me[ 12 ], n24 = me[ 13 ], n34 = me[ 14 ], n44 = me[ 15 ],\r\n\t\r\n\t\t\t\tt11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,\r\n\t\t\t\tt12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,\r\n\t\t\t\tt13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,\r\n\t\t\t\tt14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\r\n\t\r\n\t\t\tvar det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;\r\n\t\r\n\t\t\tif ( det === 0 ) {\r\n\t\r\n\t\t\t\tvar msg = \"THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0\";\r\n\t\r\n\t\t\t\tif ( throwOnDegenerate || false ) {\r\n\t\r\n\t\t\t\t\tthrow new Error( msg );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tconsole.warn( msg );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn this.identity();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tte[ 0 ] = t11;\r\n\t\t\tte[ 1 ] = n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44;\r\n\t\t\tte[ 2 ] = n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44;\r\n\t\t\tte[ 3 ] = n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43;\r\n\t\r\n\t\t\tte[ 4 ] = t12;\r\n\t\t\tte[ 5 ] = n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44;\r\n\t\t\tte[ 6 ] = n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44;\r\n\t\t\tte[ 7 ] = n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43;\r\n\t\r\n\t\t\tte[ 8 ] = t13;\r\n\t\t\tte[ 9 ] = n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44;\r\n\t\t\tte[ 10 ] = n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44;\r\n\t\t\tte[ 11 ] = n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43;\r\n\t\r\n\t\t\tte[ 12 ] = t14;\r\n\t\t\tte[ 13 ] = n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34;\r\n\t\t\tte[ 14 ] = n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34;\r\n\t\t\tte[ 15 ] = n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33;\r\n\t\r\n\t\t\treturn this.multiplyScalar( 1 / det );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tscale: function ( v ) {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\t\tvar x = v.x, y = v.y, z = v.z;\r\n\t\r\n\t\t\tte[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;\r\n\t\t\tte[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;\r\n\t\t\tte[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;\r\n\t\t\tte[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetMaxScaleOnAxis: function () {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\r\n\t\t\tvar scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];\r\n\t\t\tvar scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];\r\n\t\t\tvar scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];\r\n\t\r\n\t\t\treturn Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmakeTranslation: function ( x, y, z ) {\r\n\t\r\n\t\t\tthis.set(\r\n\t\r\n\t\t\t\t1, 0, 0, x,\r\n\t\t\t\t0, 1, 0, y,\r\n\t\t\t\t0, 0, 1, z,\r\n\t\t\t\t0, 0, 0, 1\r\n\t\r\n\t\t\t);\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmakeRotationX: function ( theta ) {\r\n\t\r\n\t\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\r\n\t\r\n\t\t\tthis.set(\r\n\t\r\n\t\t\t\t1, 0,  0, 0,\r\n\t\t\t\t0, c, - s, 0,\r\n\t\t\t\t0, s,  c, 0,\r\n\t\t\t\t0, 0,  0, 1\r\n\t\r\n\t\t\t);\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmakeRotationY: function ( theta ) {\r\n\t\r\n\t\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\r\n\t\r\n\t\t\tthis.set(\r\n\t\r\n\t\t\t\t c, 0, s, 0,\r\n\t\t\t\t 0, 1, 0, 0,\r\n\t\t\t\t- s, 0, c, 0,\r\n\t\t\t\t 0, 0, 0, 1\r\n\t\r\n\t\t\t);\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmakeRotationZ: function ( theta ) {\r\n\t\r\n\t\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\r\n\t\r\n\t\t\tthis.set(\r\n\t\r\n\t\t\t\tc, - s, 0, 0,\r\n\t\t\t\ts,  c, 0, 0,\r\n\t\t\t\t0,  0, 1, 0,\r\n\t\t\t\t0,  0, 0, 1\r\n\t\r\n\t\t\t);\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmakeRotationAxis: function ( axis, angle ) {\r\n\t\r\n\t\t\t// Based on http://www.gamedev.net/reference/articles/article1199.asp\r\n\t\r\n\t\t\tvar c = Math.cos( angle );\r\n\t\t\tvar s = Math.sin( angle );\r\n\t\t\tvar t = 1 - c;\r\n\t\t\tvar x = axis.x, y = axis.y, z = axis.z;\r\n\t\t\tvar tx = t * x, ty = t * y;\r\n\t\r\n\t\t\tthis.set(\r\n\t\r\n\t\t\t\ttx * x + c, tx * y - s * z, tx * z + s * y, 0,\r\n\t\t\t\ttx * y + s * z, ty * y + c, ty * z - s * x, 0,\r\n\t\t\t\ttx * z - s * y, ty * z + s * x, t * z * z + c, 0,\r\n\t\t\t\t0, 0, 0, 1\r\n\t\r\n\t\t\t);\r\n\t\r\n\t\t\t return this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmakeScale: function ( x, y, z ) {\r\n\t\r\n\t\t\tthis.set(\r\n\t\r\n\t\t\t\tx, 0, 0, 0,\r\n\t\t\t\t0, y, 0, 0,\r\n\t\t\t\t0, 0, z, 0,\r\n\t\t\t\t0, 0, 0, 1\r\n\t\r\n\t\t\t);\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcompose: function ( position, quaternion, scale ) {\r\n\t\r\n\t\t\tthis.makeRotationFromQuaternion( quaternion );\r\n\t\t\tthis.scale( scale );\r\n\t\t\tthis.setPosition( position );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdecompose: function () {\r\n\t\r\n\t\t\tvar vector, matrix;\r\n\t\r\n\t\t\treturn function ( position, quaternion, scale ) {\r\n\t\r\n\t\t\t\tif ( vector === undefined ) vector = new THREE.Vector3();\r\n\t\t\t\tif ( matrix === undefined ) matrix = new THREE.Matrix4();\r\n\t\r\n\t\t\t\tvar te = this.elements;\r\n\t\r\n\t\t\t\tvar sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();\r\n\t\t\t\tvar sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();\r\n\t\t\t\tvar sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();\r\n\t\r\n\t\t\t\t// if determine is negative, we need to invert one scale\r\n\t\t\t\tvar det = this.determinant();\r\n\t\t\t\tif ( det < 0 ) {\r\n\t\r\n\t\t\t\t\tsx = - sx;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tposition.x = te[ 12 ];\r\n\t\t\t\tposition.y = te[ 13 ];\r\n\t\t\t\tposition.z = te[ 14 ];\r\n\t\r\n\t\t\t\t// scale the rotation part\r\n\t\r\n\t\t\t\tmatrix.elements.set( this.elements ); // at this point matrix is incomplete so we can't use .copy()\r\n\t\r\n\t\t\t\tvar invSX = 1 / sx;\r\n\t\t\t\tvar invSY = 1 / sy;\r\n\t\t\t\tvar invSZ = 1 / sz;\r\n\t\r\n\t\t\t\tmatrix.elements[ 0 ] *= invSX;\r\n\t\t\t\tmatrix.elements[ 1 ] *= invSX;\r\n\t\t\t\tmatrix.elements[ 2 ] *= invSX;\r\n\t\r\n\t\t\t\tmatrix.elements[ 4 ] *= invSY;\r\n\t\t\t\tmatrix.elements[ 5 ] *= invSY;\r\n\t\t\t\tmatrix.elements[ 6 ] *= invSY;\r\n\t\r\n\t\t\t\tmatrix.elements[ 8 ] *= invSZ;\r\n\t\t\t\tmatrix.elements[ 9 ] *= invSZ;\r\n\t\t\t\tmatrix.elements[ 10 ] *= invSZ;\r\n\t\r\n\t\t\t\tquaternion.setFromRotationMatrix( matrix );\r\n\t\r\n\t\t\t\tscale.x = sx;\r\n\t\t\t\tscale.y = sy;\r\n\t\t\t\tscale.z = sz;\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tmakeFrustum: function ( left, right, bottom, top, near, far ) {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\t\tvar x = 2 * near / ( right - left );\r\n\t\t\tvar y = 2 * near / ( top - bottom );\r\n\t\r\n\t\t\tvar a = ( right + left ) / ( right - left );\r\n\t\t\tvar b = ( top + bottom ) / ( top - bottom );\r\n\t\t\tvar c = - ( far + near ) / ( far - near );\r\n\t\t\tvar d = - 2 * far * near / ( far - near );\r\n\t\r\n\t\t\tte[ 0 ] = x;\tte[ 4 ] = 0;\tte[ 8 ] = a;\tte[ 12 ] = 0;\r\n\t\t\tte[ 1 ] = 0;\tte[ 5 ] = y;\tte[ 9 ] = b;\tte[ 13 ] = 0;\r\n\t\t\tte[ 2 ] = 0;\tte[ 6 ] = 0;\tte[ 10 ] = c;\tte[ 14 ] = d;\r\n\t\t\tte[ 3 ] = 0;\tte[ 7 ] = 0;\tte[ 11 ] = - 1;\tte[ 15 ] = 0;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmakePerspective: function ( fov, aspect, near, far ) {\r\n\t\r\n\t\t\tvar ymax = near * Math.tan( THREE.Math.DEG2RAD * fov * 0.5 );\r\n\t\t\tvar ymin = - ymax;\r\n\t\t\tvar xmin = ymin * aspect;\r\n\t\t\tvar xmax = ymax * aspect;\r\n\t\r\n\t\t\treturn this.makeFrustum( xmin, xmax, ymin, ymax, near, far );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmakeOrthographic: function ( left, right, top, bottom, near, far ) {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\t\tvar w = 1.0 / ( right - left );\r\n\t\t\tvar h = 1.0 / ( top - bottom );\r\n\t\t\tvar p = 1.0 / ( far - near );\r\n\t\r\n\t\t\tvar x = ( right + left ) * w;\r\n\t\t\tvar y = ( top + bottom ) * h;\r\n\t\t\tvar z = ( far + near ) * p;\r\n\t\r\n\t\t\tte[ 0 ] = 2 * w;\tte[ 4 ] = 0;\tte[ 8 ] = 0;\tte[ 12 ] = - x;\r\n\t\t\tte[ 1 ] = 0;\tte[ 5 ] = 2 * h;\tte[ 9 ] = 0;\tte[ 13 ] = - y;\r\n\t\t\tte[ 2 ] = 0;\tte[ 6 ] = 0;\tte[ 10 ] = - 2 * p;\tte[ 14 ] = - z;\r\n\t\t\tte[ 3 ] = 0;\tte[ 7 ] = 0;\tte[ 11 ] = 0;\tte[ 15 ] = 1;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tequals: function ( matrix ) {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\t\tvar me = matrix.elements;\r\n\t\r\n\t\t\tfor ( var i = 0; i < 16; i ++ ) {\r\n\t\r\n\t\t\t\tif ( te[ i ] !== me[ i ] ) return false;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn true;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfromArray: function ( array ) {\r\n\t\r\n\t\t\tthis.elements.set( array );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttoArray: function ( array, offset ) {\r\n\t\r\n\t\t\tif ( array === undefined ) array = [];\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\r\n\t\t\tarray[ offset ] = te[ 0 ];\r\n\t\t\tarray[ offset + 1 ] = te[ 1 ];\r\n\t\t\tarray[ offset + 2 ] = te[ 2 ];\r\n\t\t\tarray[ offset + 3 ] = te[ 3 ];\r\n\t\r\n\t\t\tarray[ offset + 4 ] = te[ 4 ];\r\n\t\t\tarray[ offset + 5 ] = te[ 5 ];\r\n\t\t\tarray[ offset + 6 ] = te[ 6 ];\r\n\t\t\tarray[ offset + 7 ] = te[ 7 ];\r\n\t\r\n\t\t\tarray[ offset + 8 ]  = te[ 8 ];\r\n\t\t\tarray[ offset + 9 ]  = te[ 9 ];\r\n\t\t\tarray[ offset + 10 ] = te[ 10 ];\r\n\t\t\tarray[ offset + 11 ] = te[ 11 ];\r\n\t\r\n\t\t\tarray[ offset + 12 ] = te[ 12 ];\r\n\t\t\tarray[ offset + 13 ] = te[ 13 ];\r\n\t\t\tarray[ offset + 14 ] = te[ 14 ];\r\n\t\t\tarray[ offset + 15 ] = te[ 15 ];\r\n\t\r\n\t\t\treturn array;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/math/Ray.js\r\n\t\r\n\t/**\r\n\t * @author bhouston / http://clara.io\r\n\t */\r\n\t\r\n\tTHREE.Ray = function ( origin, direction ) {\r\n\t\r\n\t\tthis.origin = ( origin !== undefined ) ? origin : new THREE.Vector3();\r\n\t\tthis.direction = ( direction !== undefined ) ? direction : new THREE.Vector3();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Ray.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Ray,\r\n\t\r\n\t\tset: function ( origin, direction ) {\r\n\t\r\n\t\t\tthis.origin.copy( origin );\r\n\t\t\tthis.direction.copy( direction );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new this.constructor().copy( this );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( ray ) {\r\n\t\r\n\t\t\tthis.origin.copy( ray.origin );\r\n\t\t\tthis.direction.copy( ray.direction );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tat: function ( t, optionalTarget ) {\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\r\n\t\t\treturn result.copy( this.direction ).multiplyScalar( t ).add( this.origin );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlookAt: function ( v ) {\r\n\t\r\n\t\t\tthis.direction.copy( v ).sub( this.origin ).normalize();\r\n\t\r\n\t\t},\r\n\t\r\n\t\trecast: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function ( t ) {\r\n\t\r\n\t\t\t\tthis.origin.copy( this.at( t, v1 ) );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tclosestPointToPoint: function ( point, optionalTarget ) {\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\t\tresult.subVectors( point, this.origin );\r\n\t\t\tvar directionDistance = result.dot( this.direction );\r\n\t\r\n\t\t\tif ( directionDistance < 0 ) {\r\n\t\r\n\t\t\t\treturn result.copy( this.origin );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdistanceToPoint: function ( point ) {\r\n\t\r\n\t\t\treturn Math.sqrt( this.distanceSqToPoint( point ) );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdistanceSqToPoint: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function ( point ) {\r\n\t\r\n\t\t\t\tvar directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );\r\n\t\r\n\t\t\t\t// point behind the ray\r\n\t\r\n\t\t\t\tif ( directionDistance < 0 ) {\r\n\t\r\n\t\t\t\t\treturn this.origin.distanceToSquared( point );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tv1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\r\n\t\r\n\t\t\t\treturn v1.distanceToSquared( point );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tdistanceSqToSegment: function () {\r\n\t\r\n\t\t\tvar segCenter = new THREE.Vector3();\r\n\t\t\tvar segDir = new THREE.Vector3();\r\n\t\t\tvar diff = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function ( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {\r\n\t\r\n\t\t\t\t// from http://www.geometrictools.com/LibMathematics/Distance/Wm5DistRay3Segment3.cpp\r\n\t\t\t\t// It returns the min distance between the ray and the segment\r\n\t\t\t\t// defined by v0 and v1\r\n\t\t\t\t// It can also set two optional targets :\r\n\t\t\t\t// - The closest point on the ray\r\n\t\t\t\t// - The closest point on the segment\r\n\t\r\n\t\t\t\tsegCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );\r\n\t\t\t\tsegDir.copy( v1 ).sub( v0 ).normalize();\r\n\t\t\t\tdiff.copy( this.origin ).sub( segCenter );\r\n\t\r\n\t\t\t\tvar segExtent = v0.distanceTo( v1 ) * 0.5;\r\n\t\t\t\tvar a01 = - this.direction.dot( segDir );\r\n\t\t\t\tvar b0 = diff.dot( this.direction );\r\n\t\t\t\tvar b1 = - diff.dot( segDir );\r\n\t\t\t\tvar c = diff.lengthSq();\r\n\t\t\t\tvar det = Math.abs( 1 - a01 * a01 );\r\n\t\t\t\tvar s0, s1, sqrDist, extDet;\r\n\t\r\n\t\t\t\tif ( det > 0 ) {\r\n\t\r\n\t\t\t\t\t// The ray and segment are not parallel.\r\n\t\r\n\t\t\t\t\ts0 = a01 * b1 - b0;\r\n\t\t\t\t\ts1 = a01 * b0 - b1;\r\n\t\t\t\t\textDet = segExtent * det;\r\n\t\r\n\t\t\t\t\tif ( s0 >= 0 ) {\r\n\t\r\n\t\t\t\t\t\tif ( s1 >= - extDet ) {\r\n\t\r\n\t\t\t\t\t\t\tif ( s1 <= extDet ) {\r\n\t\r\n\t\t\t\t\t\t\t\t// region 0\r\n\t\t\t\t\t\t\t\t// Minimum at interior points of ray and segment.\r\n\t\r\n\t\t\t\t\t\t\t\tvar invDet = 1 / det;\r\n\t\t\t\t\t\t\t\ts0 *= invDet;\r\n\t\t\t\t\t\t\t\ts1 *= invDet;\r\n\t\t\t\t\t\t\t\tsqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;\r\n\t\r\n\t\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\t\t// region 1\r\n\t\r\n\t\t\t\t\t\t\t\ts1 = segExtent;\r\n\t\t\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\r\n\t\t\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\t// region 5\r\n\t\r\n\t\t\t\t\t\t\ts1 = - segExtent;\r\n\t\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\r\n\t\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tif ( s1 <= - extDet ) {\r\n\t\r\n\t\t\t\t\t\t\t// region 4\r\n\t\r\n\t\t\t\t\t\t\ts0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );\r\n\t\t\t\t\t\t\ts1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\r\n\t\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\t\r\n\t\t\t\t\t\t} else if ( s1 <= extDet ) {\r\n\t\r\n\t\t\t\t\t\t\t// region 3\r\n\t\r\n\t\t\t\t\t\t\ts0 = 0;\r\n\t\t\t\t\t\t\ts1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );\r\n\t\t\t\t\t\t\tsqrDist = s1 * ( s1 + 2 * b1 ) + c;\r\n\t\r\n\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\t// region 2\r\n\t\r\n\t\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * segExtent + b0 ) );\r\n\t\t\t\t\t\t\ts1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\r\n\t\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t// Ray and segment are parallel.\r\n\t\r\n\t\t\t\t\ts1 = ( a01 > 0 ) ? - segExtent : segExtent;\r\n\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\r\n\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( optionalPointOnRay ) {\r\n\t\r\n\t\t\t\t\toptionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( optionalPointOnSegment ) {\r\n\t\r\n\t\t\t\t\toptionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn sqrDist;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tintersectSphere: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function ( sphere, optionalTarget ) {\r\n\t\r\n\t\t\t\tv1.subVectors( sphere.center, this.origin );\r\n\t\t\t\tvar tca = v1.dot( this.direction );\r\n\t\t\t\tvar d2 = v1.dot( v1 ) - tca * tca;\r\n\t\t\t\tvar radius2 = sphere.radius * sphere.radius;\r\n\t\r\n\t\t\t\tif ( d2 > radius2 ) return null;\r\n\t\r\n\t\t\t\tvar thc = Math.sqrt( radius2 - d2 );\r\n\t\r\n\t\t\t\t// t0 = first intersect point - entrance on front of sphere\r\n\t\t\t\tvar t0 = tca - thc;\r\n\t\r\n\t\t\t\t// t1 = second intersect point - exit point on back of sphere\r\n\t\t\t\tvar t1 = tca + thc;\r\n\t\r\n\t\t\t\t// test to see if both t0 and t1 are behind the ray - if so, return null\r\n\t\t\t\tif ( t0 < 0 && t1 < 0 ) return null;\r\n\t\r\n\t\t\t\t// test to see if t0 is behind the ray:\r\n\t\t\t\t// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,\r\n\t\t\t\t// in order to always return an intersect point that is in front of the ray.\r\n\t\t\t\tif ( t0 < 0 ) return this.at( t1, optionalTarget );\r\n\t\r\n\t\t\t\t// else t0 is in front of the ray, so return the first collision point scaled by t0\r\n\t\t\t\treturn this.at( t0, optionalTarget );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tintersectsSphere: function ( sphere ) {\r\n\t\r\n\t\t\treturn this.distanceToPoint( sphere.center ) <= sphere.radius;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdistanceToPlane: function ( plane ) {\r\n\t\r\n\t\t\tvar denominator = plane.normal.dot( this.direction );\r\n\t\r\n\t\t\tif ( denominator === 0 ) {\r\n\t\r\n\t\t\t\t// line is coplanar, return origin\r\n\t\t\t\tif ( plane.distanceToPoint( this.origin ) === 0 ) {\r\n\t\r\n\t\t\t\t\treturn 0;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// Null is preferable to undefined since undefined means.... it is undefined\r\n\t\r\n\t\t\t\treturn null;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;\r\n\t\r\n\t\t\t// Return if the ray never intersects the plane\r\n\t\r\n\t\t\treturn t >= 0 ? t :  null;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tintersectPlane: function ( plane, optionalTarget ) {\r\n\t\r\n\t\t\tvar t = this.distanceToPlane( plane );\r\n\t\r\n\t\t\tif ( t === null ) {\r\n\t\r\n\t\t\t\treturn null;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this.at( t, optionalTarget );\r\n\t\r\n\t\t},\r\n\t\r\n\t\r\n\t\r\n\t\tintersectsPlane: function ( plane ) {\r\n\t\r\n\t\t\t// check if the ray lies on the plane first\r\n\t\r\n\t\t\tvar distToPoint = plane.distanceToPoint( this.origin );\r\n\t\r\n\t\t\tif ( distToPoint === 0 ) {\r\n\t\r\n\t\t\t\treturn true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar denominator = plane.normal.dot( this.direction );\r\n\t\r\n\t\t\tif ( denominator * distToPoint < 0 ) {\r\n\t\r\n\t\t\t\treturn true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// ray origin is behind the plane (and is pointing behind it)\r\n\t\r\n\t\t\treturn false;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tintersectBox: function ( box, optionalTarget ) {\r\n\t\r\n\t\t\tvar tmin, tmax, tymin, tymax, tzmin, tzmax;\r\n\t\r\n\t\t\tvar invdirx = 1 / this.direction.x,\r\n\t\t\t\tinvdiry = 1 / this.direction.y,\r\n\t\t\t\tinvdirz = 1 / this.direction.z;\r\n\t\r\n\t\t\tvar origin = this.origin;\r\n\t\r\n\t\t\tif ( invdirx >= 0 ) {\r\n\t\r\n\t\t\t\ttmin = ( box.min.x - origin.x ) * invdirx;\r\n\t\t\t\ttmax = ( box.max.x - origin.x ) * invdirx;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\ttmin = ( box.max.x - origin.x ) * invdirx;\r\n\t\t\t\ttmax = ( box.min.x - origin.x ) * invdirx;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( invdiry >= 0 ) {\r\n\t\r\n\t\t\t\ttymin = ( box.min.y - origin.y ) * invdiry;\r\n\t\t\t\ttymax = ( box.max.y - origin.y ) * invdiry;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\ttymin = ( box.max.y - origin.y ) * invdiry;\r\n\t\t\t\ttymax = ( box.min.y - origin.y ) * invdiry;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;\r\n\t\r\n\t\t\t// These lines also handle the case where tmin or tmax is NaN\r\n\t\t\t// (result of 0 * Infinity). x !== x returns true if x is NaN\r\n\t\r\n\t\t\tif ( tymin > tmin || tmin !== tmin ) tmin = tymin;\r\n\t\r\n\t\t\tif ( tymax < tmax || tmax !== tmax ) tmax = tymax;\r\n\t\r\n\t\t\tif ( invdirz >= 0 ) {\r\n\t\r\n\t\t\t\ttzmin = ( box.min.z - origin.z ) * invdirz;\r\n\t\t\t\ttzmax = ( box.max.z - origin.z ) * invdirz;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\ttzmin = ( box.max.z - origin.z ) * invdirz;\r\n\t\t\t\ttzmax = ( box.min.z - origin.z ) * invdirz;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;\r\n\t\r\n\t\t\tif ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;\r\n\t\r\n\t\t\tif ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;\r\n\t\r\n\t\t\t//return point closest to the ray (positive side)\r\n\t\r\n\t\t\tif ( tmax < 0 ) return null;\r\n\t\r\n\t\t\treturn this.at( tmin >= 0 ? tmin : tmax, optionalTarget );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tintersectsBox: ( function () {\r\n\t\r\n\t\t\tvar v = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function ( box ) {\r\n\t\r\n\t\t\t\treturn this.intersectBox( box, v ) !== null;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t} )(),\r\n\t\r\n\t\tintersectTriangle: function () {\r\n\t\r\n\t\t\t// Compute the offset origin, edges, and normal.\r\n\t\t\tvar diff = new THREE.Vector3();\r\n\t\t\tvar edge1 = new THREE.Vector3();\r\n\t\t\tvar edge2 = new THREE.Vector3();\r\n\t\t\tvar normal = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function ( a, b, c, backfaceCulling, optionalTarget ) {\r\n\t\r\n\t\t\t\t// from http://www.geometrictools.com/LibMathematics/Intersection/Wm5IntrRay3Triangle3.cpp\r\n\t\r\n\t\t\t\tedge1.subVectors( b, a );\r\n\t\t\t\tedge2.subVectors( c, a );\r\n\t\t\t\tnormal.crossVectors( edge1, edge2 );\r\n\t\r\n\t\t\t\t// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,\r\n\t\t\t\t// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by\r\n\t\t\t\t//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))\r\n\t\t\t\t//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))\r\n\t\t\t\t//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)\r\n\t\t\t\tvar DdN = this.direction.dot( normal );\r\n\t\t\t\tvar sign;\r\n\t\r\n\t\t\t\tif ( DdN > 0 ) {\r\n\t\r\n\t\t\t\t\tif ( backfaceCulling ) return null;\r\n\t\t\t\t\tsign = 1;\r\n\t\r\n\t\t\t\t} else if ( DdN < 0 ) {\r\n\t\r\n\t\t\t\t\tsign = - 1;\r\n\t\t\t\t\tDdN = - DdN;\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\treturn null;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tdiff.subVectors( this.origin, a );\r\n\t\t\t\tvar DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );\r\n\t\r\n\t\t\t\t// b1 < 0, no intersection\r\n\t\t\t\tif ( DdQxE2 < 0 ) {\r\n\t\r\n\t\t\t\t\treturn null;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );\r\n\t\r\n\t\t\t\t// b2 < 0, no intersection\r\n\t\t\t\tif ( DdE1xQ < 0 ) {\r\n\t\r\n\t\t\t\t\treturn null;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// b1+b2 > 1, no intersection\r\n\t\t\t\tif ( DdQxE2 + DdE1xQ > DdN ) {\r\n\t\r\n\t\t\t\t\treturn null;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// Line intersects triangle, check if ray does.\r\n\t\t\t\tvar QdN = - sign * diff.dot( normal );\r\n\t\r\n\t\t\t\t// t < 0, no intersection\r\n\t\t\t\tif ( QdN < 0 ) {\r\n\t\r\n\t\t\t\t\treturn null;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// Ray intersects triangle.\r\n\t\t\t\treturn this.at( QdN / DdN, optionalTarget );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tapplyMatrix4: function ( matrix4 ) {\r\n\t\r\n\t\t\tthis.direction.add( this.origin ).applyMatrix4( matrix4 );\r\n\t\t\tthis.origin.applyMatrix4( matrix4 );\r\n\t\t\tthis.direction.sub( this.origin );\r\n\t\t\tthis.direction.normalize();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tequals: function ( ray ) {\r\n\t\r\n\t\t\treturn ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/math/Sphere.js\r\n\t\r\n\t/**\r\n\t * @author bhouston / http://clara.io\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.Sphere = function ( center, radius ) {\r\n\t\r\n\t\tthis.center = ( center !== undefined ) ? center : new THREE.Vector3();\r\n\t\tthis.radius = ( radius !== undefined ) ? radius : 0;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Sphere.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Sphere,\r\n\t\r\n\t\tset: function ( center, radius ) {\r\n\t\r\n\t\t\tthis.center.copy( center );\r\n\t\t\tthis.radius = radius;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromPoints: function () {\r\n\t\r\n\t\t\tvar box = new THREE.Box3();\r\n\t\r\n\t\t\treturn function ( points, optionalCenter ) {\r\n\t\r\n\t\t\t\tvar center = this.center;\r\n\t\r\n\t\t\t\tif ( optionalCenter !== undefined ) {\r\n\t\r\n\t\t\t\t\tcenter.copy( optionalCenter );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tbox.setFromPoints( points ).center( center );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar maxRadiusSq = 0;\r\n\t\r\n\t\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tthis.radius = Math.sqrt( maxRadiusSq );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new this.constructor().copy( this );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( sphere ) {\r\n\t\r\n\t\t\tthis.center.copy( sphere.center );\r\n\t\t\tthis.radius = sphere.radius;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tempty: function () {\r\n\t\r\n\t\t\treturn ( this.radius <= 0 );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcontainsPoint: function ( point ) {\r\n\t\r\n\t\t\treturn ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdistanceToPoint: function ( point ) {\r\n\t\r\n\t\t\treturn ( point.distanceTo( this.center ) - this.radius );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tintersectsSphere: function ( sphere ) {\r\n\t\r\n\t\t\tvar radiusSum = this.radius + sphere.radius;\r\n\t\r\n\t\t\treturn sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tintersectsBox: function ( box ) {\r\n\t\r\n\t\t\treturn box.intersectsSphere( this );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tintersectsPlane: function ( plane ) {\r\n\t\r\n\t\t\t// We use the following equation to compute the signed distance from\r\n\t\t\t// the center of the sphere to the plane.\r\n\t\t\t//\r\n\t\t\t// distance = q * n - d\r\n\t\t\t//\r\n\t\t\t// If this distance is greater than the radius of the sphere,\r\n\t\t\t// then there is no intersection.\r\n\t\r\n\t\t\treturn Math.abs( this.center.dot( plane.normal ) - plane.constant ) <= this.radius;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclampPoint: function ( point, optionalTarget ) {\r\n\t\r\n\t\t\tvar deltaLengthSq = this.center.distanceToSquared( point );\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\r\n\t\t\tresult.copy( point );\r\n\t\r\n\t\t\tif ( deltaLengthSq > ( this.radius * this.radius ) ) {\r\n\t\r\n\t\t\t\tresult.sub( this.center ).normalize();\r\n\t\t\t\tresult.multiplyScalar( this.radius ).add( this.center );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn result;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetBoundingBox: function ( optionalTarget ) {\r\n\t\r\n\t\t\tvar box = optionalTarget || new THREE.Box3();\r\n\t\r\n\t\t\tbox.set( this.center, this.center );\r\n\t\t\tbox.expandByScalar( this.radius );\r\n\t\r\n\t\t\treturn box;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tapplyMatrix4: function ( matrix ) {\r\n\t\r\n\t\t\tthis.center.applyMatrix4( matrix );\r\n\t\t\tthis.radius = this.radius * matrix.getMaxScaleOnAxis();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttranslate: function ( offset ) {\r\n\t\r\n\t\t\tthis.center.add( offset );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tequals: function ( sphere ) {\r\n\t\r\n\t\t\treturn sphere.center.equals( this.center ) && ( sphere.radius === this.radius );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/math/Frustum.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author bhouston / http://clara.io\r\n\t */\r\n\t\r\n\tTHREE.Frustum = function ( p0, p1, p2, p3, p4, p5 ) {\r\n\t\r\n\t\tthis.planes = [\r\n\t\r\n\t\t\t( p0 !== undefined ) ? p0 : new THREE.Plane(),\r\n\t\t\t( p1 !== undefined ) ? p1 : new THREE.Plane(),\r\n\t\t\t( p2 !== undefined ) ? p2 : new THREE.Plane(),\r\n\t\t\t( p3 !== undefined ) ? p3 : new THREE.Plane(),\r\n\t\t\t( p4 !== undefined ) ? p4 : new THREE.Plane(),\r\n\t\t\t( p5 !== undefined ) ? p5 : new THREE.Plane()\r\n\t\r\n\t\t];\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Frustum.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Frustum,\r\n\t\r\n\t\tset: function ( p0, p1, p2, p3, p4, p5 ) {\r\n\t\r\n\t\t\tvar planes = this.planes;\r\n\t\r\n\t\t\tplanes[ 0 ].copy( p0 );\r\n\t\t\tplanes[ 1 ].copy( p1 );\r\n\t\t\tplanes[ 2 ].copy( p2 );\r\n\t\t\tplanes[ 3 ].copy( p3 );\r\n\t\t\tplanes[ 4 ].copy( p4 );\r\n\t\t\tplanes[ 5 ].copy( p5 );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new this.constructor().copy( this );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( frustum ) {\r\n\t\r\n\t\t\tvar planes = this.planes;\r\n\t\r\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\t\r\n\t\t\t\tplanes[ i ].copy( frustum.planes[ i ] );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromMatrix: function ( m ) {\r\n\t\r\n\t\t\tvar planes = this.planes;\r\n\t\t\tvar me = m.elements;\r\n\t\t\tvar me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];\r\n\t\t\tvar me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];\r\n\t\t\tvar me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];\r\n\t\t\tvar me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];\r\n\t\r\n\t\t\tplanes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();\r\n\t\t\tplanes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();\r\n\t\t\tplanes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();\r\n\t\t\tplanes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();\r\n\t\t\tplanes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();\r\n\t\t\tplanes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tintersectsObject: function () {\r\n\t\r\n\t\t\tvar sphere = new THREE.Sphere();\r\n\t\r\n\t\t\treturn function ( object ) {\r\n\t\r\n\t\t\t\tvar geometry = object.geometry;\r\n\t\r\n\t\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\r\n\t\r\n\t\t\t\tsphere.copy( geometry.boundingSphere );\r\n\t\t\t\tsphere.applyMatrix4( object.matrixWorld );\r\n\t\r\n\t\t\t\treturn this.intersectsSphere( sphere );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tintersectsSphere: function ( sphere ) {\r\n\t\r\n\t\t\tvar planes = this.planes;\r\n\t\t\tvar center = sphere.center;\r\n\t\t\tvar negRadius = - sphere.radius;\r\n\t\r\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\t\r\n\t\t\t\tvar distance = planes[ i ].distanceToPoint( center );\r\n\t\r\n\t\t\t\tif ( distance < negRadius ) {\r\n\t\r\n\t\t\t\t\treturn false;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn true;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tintersectsBox: function () {\r\n\t\r\n\t\t\tvar p1 = new THREE.Vector3(),\r\n\t\t\t\tp2 = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function ( box ) {\r\n\t\r\n\t\t\t\tvar planes = this.planes;\r\n\t\r\n\t\t\t\tfor ( var i = 0; i < 6 ; i ++ ) {\r\n\t\r\n\t\t\t\t\tvar plane = planes[ i ];\r\n\t\r\n\t\t\t\t\tp1.x = plane.normal.x > 0 ? box.min.x : box.max.x;\r\n\t\t\t\t\tp2.x = plane.normal.x > 0 ? box.max.x : box.min.x;\r\n\t\t\t\t\tp1.y = plane.normal.y > 0 ? box.min.y : box.max.y;\r\n\t\t\t\t\tp2.y = plane.normal.y > 0 ? box.max.y : box.min.y;\r\n\t\t\t\t\tp1.z = plane.normal.z > 0 ? box.min.z : box.max.z;\r\n\t\t\t\t\tp2.z = plane.normal.z > 0 ? box.max.z : box.min.z;\r\n\t\r\n\t\t\t\t\tvar d1 = plane.distanceToPoint( p1 );\r\n\t\t\t\t\tvar d2 = plane.distanceToPoint( p2 );\r\n\t\r\n\t\t\t\t\t// if both outside plane, no intersection\r\n\t\r\n\t\t\t\t\tif ( d1 < 0 && d2 < 0 ) {\r\n\t\r\n\t\t\t\t\t\treturn false;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn true;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\r\n\t\tcontainsPoint: function ( point ) {\r\n\t\r\n\t\t\tvar planes = this.planes;\r\n\t\r\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\t\r\n\t\t\t\tif ( planes[ i ].distanceToPoint( point ) < 0 ) {\r\n\t\r\n\t\t\t\t\treturn false;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn true;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/math/Plane.js\r\n\t\r\n\t/**\r\n\t * @author bhouston / http://clara.io\r\n\t */\r\n\t\r\n\tTHREE.Plane = function ( normal, constant ) {\r\n\t\r\n\t\tthis.normal = ( normal !== undefined ) ? normal : new THREE.Vector3( 1, 0, 0 );\r\n\t\tthis.constant = ( constant !== undefined ) ? constant : 0;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Plane.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Plane,\r\n\t\r\n\t\tset: function ( normal, constant ) {\r\n\t\r\n\t\t\tthis.normal.copy( normal );\r\n\t\t\tthis.constant = constant;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetComponents: function ( x, y, z, w ) {\r\n\t\r\n\t\t\tthis.normal.set( x, y, z );\r\n\t\t\tthis.constant = w;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromNormalAndCoplanarPoint: function ( normal, point ) {\r\n\t\r\n\t\t\tthis.normal.copy( normal );\r\n\t\t\tthis.constant = - point.dot( this.normal );\t// must be this.normal, not normal, as this.normal is normalized\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromCoplanarPoints: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3();\r\n\t\t\tvar v2 = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function ( a, b, c ) {\r\n\t\r\n\t\t\t\tvar normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();\r\n\t\r\n\t\t\t\t// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?\r\n\t\r\n\t\t\t\tthis.setFromNormalAndCoplanarPoint( normal, a );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new this.constructor().copy( this );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( plane ) {\r\n\t\r\n\t\t\tthis.normal.copy( plane.normal );\r\n\t\t\tthis.constant = plane.constant;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tnormalize: function () {\r\n\t\r\n\t\t\t// Note: will lead to a divide by zero if the plane is invalid.\r\n\t\r\n\t\t\tvar inverseNormalLength = 1.0 / this.normal.length();\r\n\t\t\tthis.normal.multiplyScalar( inverseNormalLength );\r\n\t\t\tthis.constant *= inverseNormalLength;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tnegate: function () {\r\n\t\r\n\t\t\tthis.constant *= - 1;\r\n\t\t\tthis.normal.negate();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdistanceToPoint: function ( point ) {\r\n\t\r\n\t\t\treturn this.normal.dot( point ) + this.constant;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdistanceToSphere: function ( sphere ) {\r\n\t\r\n\t\t\treturn this.distanceToPoint( sphere.center ) - sphere.radius;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tprojectPoint: function ( point, optionalTarget ) {\r\n\t\r\n\t\t\treturn this.orthoPoint( point, optionalTarget ).sub( point ).negate();\r\n\t\r\n\t\t},\r\n\t\r\n\t\torthoPoint: function ( point, optionalTarget ) {\r\n\t\r\n\t\t\tvar perpendicularMagnitude = this.distanceToPoint( point );\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\t\treturn result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tintersectLine: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function ( line, optionalTarget ) {\r\n\t\r\n\t\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\r\n\t\t\t\tvar direction = line.delta( v1 );\r\n\t\r\n\t\t\t\tvar denominator = this.normal.dot( direction );\r\n\t\r\n\t\t\t\tif ( denominator === 0 ) {\r\n\t\r\n\t\t\t\t\t// line is coplanar, return origin\r\n\t\t\t\t\tif ( this.distanceToPoint( line.start ) === 0 ) {\r\n\t\r\n\t\t\t\t\t\treturn result.copy( line.start );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t// Unsure if this is the correct method to handle this case.\r\n\t\t\t\t\treturn undefined;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;\r\n\t\r\n\t\t\t\tif ( t < 0 || t > 1 ) {\r\n\t\r\n\t\t\t\t\treturn undefined;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn result.copy( direction ).multiplyScalar( t ).add( line.start );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tintersectsLine: function ( line ) {\r\n\t\r\n\t\t\t// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.\r\n\t\r\n\t\t\tvar startSign = this.distanceToPoint( line.start );\r\n\t\t\tvar endSign = this.distanceToPoint( line.end );\r\n\t\r\n\t\t\treturn ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tintersectsBox: function ( box ) {\r\n\t\r\n\t\t\treturn box.intersectsPlane( this );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tintersectsSphere: function ( sphere ) {\r\n\t\r\n\t\t\treturn sphere.intersectsPlane( this );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcoplanarPoint: function ( optionalTarget ) {\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\t\treturn result.copy( this.normal ).multiplyScalar( - this.constant );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tapplyMatrix4: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3();\r\n\t\t\tvar m1 = new THREE.Matrix3();\r\n\t\r\n\t\t\treturn function ( matrix, optionalNormalMatrix ) {\r\n\t\r\n\t\t\t\tvar referencePoint = this.coplanarPoint( v1 ).applyMatrix4( matrix );\r\n\t\r\n\t\t\t\t// transform normal based on theory here:\r\n\t\t\t\t// http://www.songho.ca/opengl/gl_normaltransform.html\r\n\t\t\t\tvar normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );\r\n\t\t\t\tvar normal = this.normal.applyMatrix3( normalMatrix ).normalize();\r\n\t\r\n\t\t\t\t// recalculate constant (like in setFromNormalAndCoplanarPoint)\r\n\t\t\t\tthis.constant = - referencePoint.dot( normal );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\ttranslate: function ( offset ) {\r\n\t\r\n\t\t\tthis.constant = this.constant - offset.dot( this.normal );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tequals: function ( plane ) {\r\n\t\r\n\t\t\treturn plane.normal.equals( this.normal ) && ( plane.constant === this.constant );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/math/Spherical.js\r\n\t\r\n\t/**\r\n\t * @author bhouston / http://clara.io\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t *\r\n\t * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system\r\n\t *\r\n\t * The poles (phi) are at the positive and negative y axis.\r\n\t * The equator starts at positive z.\r\n\t */\r\n\t\r\n\tTHREE.Spherical = function ( radius, phi, theta ) {\r\n\t\r\n\t\tthis.radius = ( radius !== undefined ) ? radius : 1.0;\r\n\t\tthis.phi = ( phi !== undefined ) ? phi : 0; // up / down towards top and bottom pole\r\n\t\tthis.theta = ( theta !== undefined ) ? theta : 0; // around the equator of the sphere\r\n\t\r\n\t\treturn this;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Spherical.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Spherical,\r\n\t\r\n\t\tset: function ( radius, phi, theta ) {\r\n\t\r\n\t\t\tthis.radius = radius;\r\n\t\t\tthis.phi = phi;\r\n\t\t\tthis.theta = theta;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new this.constructor().copy( this );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( other ) {\r\n\t\r\n\t\t\tthis.radius.copy( other.radius );\r\n\t\t\tthis.phi.copy( other.phi );\r\n\t\t\tthis.theta.copy( other.theta );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// restrict phi to be betwee EPS and PI-EPS\r\n\t\tmakeSafe: function() {\r\n\t\r\n\t\t\tvar EPS = 0.000001;\r\n\t\t\tthis.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromVector3: function( vec3 ) {\r\n\t\r\n\t\t\tthis.radius = vec3.length();\r\n\t\r\n\t\t\tif ( this.radius === 0 ) {\r\n\t\r\n\t\t\t\tthis.theta = 0;\r\n\t\t\t\tthis.phi = 0;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tthis.theta = Math.atan2( vec3.x, vec3.z ); // equator angle around y-up axis\r\n\t\t\t\tthis.phi = Math.acos( THREE.Math.clamp( vec3.y / this.radius, - 1, 1 ) ); // polar angle\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/math/Math.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.Math = {\r\n\t\r\n\t\tDEG2RAD: Math.PI / 180,\r\n\t\tRAD2DEG: 180 / Math.PI,\r\n\t\r\n\t\tgenerateUUID: function () {\r\n\t\r\n\t\t\t// http://www.broofa.com/Tools/Math.uuid.htm\r\n\t\r\n\t\t\tvar chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split( '' );\r\n\t\t\tvar uuid = new Array( 36 );\r\n\t\t\tvar rnd = 0, r;\r\n\t\r\n\t\t\treturn function () {\r\n\t\r\n\t\t\t\tfor ( var i = 0; i < 36; i ++ ) {\r\n\t\r\n\t\t\t\t\tif ( i === 8 || i === 13 || i === 18 || i === 23 ) {\r\n\t\r\n\t\t\t\t\t\tuuid[ i ] = '-';\r\n\t\r\n\t\t\t\t\t} else if ( i === 14 ) {\r\n\t\r\n\t\t\t\t\t\tuuid[ i ] = '4';\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tif ( rnd <= 0x02 ) rnd = 0x2000000 + ( Math.random() * 0x1000000 ) | 0;\r\n\t\t\t\t\t\tr = rnd & 0xf;\r\n\t\t\t\t\t\trnd = rnd >> 4;\r\n\t\t\t\t\t\tuuid[ i ] = chars[ ( i === 19 ) ? ( r & 0x3 ) | 0x8 : r ];\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn uuid.join( '' );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tclamp: function ( value, min, max ) {\r\n\t\r\n\t\t\treturn Math.max( min, Math.min( max, value ) );\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// compute euclidian modulo of m % n\r\n\t\t// https://en.wikipedia.org/wiki/Modulo_operation\r\n\t\r\n\t\teuclideanModulo: function ( n, m ) {\r\n\t\r\n\t\t\treturn ( ( n % m ) + m ) % m;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Linear mapping from range <a1, a2> to range <b1, b2>\r\n\t\r\n\t\tmapLinear: function ( x, a1, a2, b1, b2 ) {\r\n\t\r\n\t\t\treturn b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// http://en.wikipedia.org/wiki/Smoothstep\r\n\t\r\n\t\tsmoothstep: function ( x, min, max ) {\r\n\t\r\n\t\t\tif ( x <= min ) return 0;\r\n\t\t\tif ( x >= max ) return 1;\r\n\t\r\n\t\t\tx = ( x - min ) / ( max - min );\r\n\t\r\n\t\t\treturn x * x * ( 3 - 2 * x );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsmootherstep: function ( x, min, max ) {\r\n\t\r\n\t\t\tif ( x <= min ) return 0;\r\n\t\t\tif ( x >= max ) return 1;\r\n\t\r\n\t\t\tx = ( x - min ) / ( max - min );\r\n\t\r\n\t\t\treturn x * x * x * ( x * ( x * 6 - 15 ) + 10 );\r\n\t\r\n\t\t},\r\n\t\r\n\t\trandom16: function () {\r\n\t\r\n\t\t\tconsole.warn( 'THREE.Math.random16() has been deprecated. Use Math.random() instead.' );\r\n\t\t\treturn Math.random();\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Random integer from <low, high> interval\r\n\t\r\n\t\trandInt: function ( low, high ) {\r\n\t\r\n\t\t\treturn low + Math.floor( Math.random() * ( high - low + 1 ) );\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Random float from <low, high> interval\r\n\t\r\n\t\trandFloat: function ( low, high ) {\r\n\t\r\n\t\t\treturn low + Math.random() * ( high - low );\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Random float from <-range/2, range/2> interval\r\n\t\r\n\t\trandFloatSpread: function ( range ) {\r\n\t\r\n\t\t\treturn range * ( 0.5 - Math.random() );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdegToRad: function ( degrees ) {\r\n\t\r\n\t\t\treturn degrees * THREE.Math.DEG2RAD;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tradToDeg: function ( radians ) {\r\n\t\r\n\t\t\treturn radians * THREE.Math.RAD2DEG;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tisPowerOfTwo: function ( value ) {\r\n\t\r\n\t\t\treturn ( value & ( value - 1 ) ) === 0 && value !== 0;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tnearestPowerOfTwo: function ( value ) {\r\n\t\r\n\t\t\treturn Math.pow( 2, Math.round( Math.log( value ) / Math.LN2 ) );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tnextPowerOfTwo: function ( value ) {\r\n\t\r\n\t\t\tvalue --;\r\n\t\t\tvalue |= value >> 1;\r\n\t\t\tvalue |= value >> 2;\r\n\t\t\tvalue |= value >> 4;\r\n\t\t\tvalue |= value >> 8;\r\n\t\t\tvalue |= value >> 16;\r\n\t\t\tvalue ++;\r\n\t\r\n\t\t\treturn value;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/math/Spline.js\r\n\t\r\n\t/**\r\n\t * Spline from Tween.js, slightly optimized (and trashed)\r\n\t * http://sole.github.com/tween.js/examples/05_spline.html\r\n\t *\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.Spline = function ( points ) {\r\n\t\r\n\t\tthis.points = points;\r\n\t\r\n\t\tvar c = [], v3 = { x: 0, y: 0, z: 0 },\r\n\t\tpoint, intPoint, weight, w2, w3,\r\n\t\tpa, pb, pc, pd;\r\n\t\r\n\t\tthis.initFromArray = function ( a ) {\r\n\t\r\n\t\t\tthis.points = [];\r\n\t\r\n\t\t\tfor ( var i = 0; i < a.length; i ++ ) {\r\n\t\r\n\t\t\t\tthis.points[ i ] = { x: a[ i ][ 0 ], y: a[ i ][ 1 ], z: a[ i ][ 2 ] };\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.getPoint = function ( k ) {\r\n\t\r\n\t\t\tpoint = ( this.points.length - 1 ) * k;\r\n\t\t\tintPoint = Math.floor( point );\r\n\t\t\tweight = point - intPoint;\r\n\t\r\n\t\t\tc[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;\r\n\t\t\tc[ 1 ] = intPoint;\r\n\t\t\tc[ 2 ] = intPoint  > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;\r\n\t\t\tc[ 3 ] = intPoint  > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;\r\n\t\r\n\t\t\tpa = this.points[ c[ 0 ] ];\r\n\t\t\tpb = this.points[ c[ 1 ] ];\r\n\t\t\tpc = this.points[ c[ 2 ] ];\r\n\t\t\tpd = this.points[ c[ 3 ] ];\r\n\t\r\n\t\t\tw2 = weight * weight;\r\n\t\t\tw3 = weight * w2;\r\n\t\r\n\t\t\tv3.x = interpolate( pa.x, pb.x, pc.x, pd.x, weight, w2, w3 );\r\n\t\t\tv3.y = interpolate( pa.y, pb.y, pc.y, pd.y, weight, w2, w3 );\r\n\t\t\tv3.z = interpolate( pa.z, pb.z, pc.z, pd.z, weight, w2, w3 );\r\n\t\r\n\t\t\treturn v3;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.getControlPointsArray = function () {\r\n\t\r\n\t\t\tvar i, p, l = this.points.length,\r\n\t\t\t\tcoords = [];\r\n\t\r\n\t\t\tfor ( i = 0; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tp = this.points[ i ];\r\n\t\t\t\tcoords[ i ] = [ p.x, p.y, p.z ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn coords;\r\n\t\r\n\t\t};\r\n\t\r\n\t\t// approximate length by summing linear segments\r\n\t\r\n\t\tthis.getLength = function ( nSubDivisions ) {\r\n\t\r\n\t\t\tvar i, index, nSamples, position,\r\n\t\t\t\tpoint = 0, intPoint = 0, oldIntPoint = 0,\r\n\t\t\t\toldPosition = new THREE.Vector3(),\r\n\t\t\t\ttmpVec = new THREE.Vector3(),\r\n\t\t\t\tchunkLengths = [],\r\n\t\t\t\ttotalLength = 0;\r\n\t\r\n\t\t\t// first point has 0 length\r\n\t\r\n\t\t\tchunkLengths[ 0 ] = 0;\r\n\t\r\n\t\t\tif ( ! nSubDivisions ) nSubDivisions = 100;\r\n\t\r\n\t\t\tnSamples = this.points.length * nSubDivisions;\r\n\t\r\n\t\t\toldPosition.copy( this.points[ 0 ] );\r\n\t\r\n\t\t\tfor ( i = 1; i < nSamples; i ++ ) {\r\n\t\r\n\t\t\t\tindex = i / nSamples;\r\n\t\r\n\t\t\t\tposition = this.getPoint( index );\r\n\t\t\t\ttmpVec.copy( position );\r\n\t\r\n\t\t\t\ttotalLength += tmpVec.distanceTo( oldPosition );\r\n\t\r\n\t\t\t\toldPosition.copy( position );\r\n\t\r\n\t\t\t\tpoint = ( this.points.length - 1 ) * index;\r\n\t\t\t\tintPoint = Math.floor( point );\r\n\t\r\n\t\t\t\tif ( intPoint !== oldIntPoint ) {\r\n\t\r\n\t\t\t\t\tchunkLengths[ intPoint ] = totalLength;\r\n\t\t\t\t\toldIntPoint = intPoint;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// last point ends with total length\r\n\t\r\n\t\t\tchunkLengths[ chunkLengths.length ] = totalLength;\r\n\t\r\n\t\t\treturn { chunks: chunkLengths, total: totalLength };\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.reparametrizeByArcLength = function ( samplingCoef ) {\r\n\t\r\n\t\t\tvar i, j,\r\n\t\t\t\tindex, indexCurrent, indexNext,\r\n\t\t\t\trealDistance,\r\n\t\t\t\tsampling, position,\r\n\t\t\t\tnewpoints = [],\r\n\t\t\t\ttmpVec = new THREE.Vector3(),\r\n\t\t\t\tsl = this.getLength();\r\n\t\r\n\t\t\tnewpoints.push( tmpVec.copy( this.points[ 0 ] ).clone() );\r\n\t\r\n\t\t\tfor ( i = 1; i < this.points.length; i ++ ) {\r\n\t\r\n\t\t\t\t//tmpVec.copy( this.points[ i - 1 ] );\r\n\t\t\t\t//linearDistance = tmpVec.distanceTo( this.points[ i ] );\r\n\t\r\n\t\t\t\trealDistance = sl.chunks[ i ] - sl.chunks[ i - 1 ];\r\n\t\r\n\t\t\t\tsampling = Math.ceil( samplingCoef * realDistance / sl.total );\r\n\t\r\n\t\t\t\tindexCurrent = ( i - 1 ) / ( this.points.length - 1 );\r\n\t\t\t\tindexNext = i / ( this.points.length - 1 );\r\n\t\r\n\t\t\t\tfor ( j = 1; j < sampling - 1; j ++ ) {\r\n\t\r\n\t\t\t\t\tindex = indexCurrent + j * ( 1 / sampling ) * ( indexNext - indexCurrent );\r\n\t\r\n\t\t\t\t\tposition = this.getPoint( index );\r\n\t\t\t\t\tnewpoints.push( tmpVec.copy( position ).clone() );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tnewpoints.push( tmpVec.copy( this.points[ i ] ).clone() );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.points = newpoints;\r\n\t\r\n\t\t};\r\n\t\r\n\t\t// Catmull-Rom\r\n\t\r\n\t\tfunction interpolate( p0, p1, p2, p3, t, t2, t3 ) {\r\n\t\r\n\t\t\tvar v0 = ( p2 - p0 ) * 0.5,\r\n\t\t\t\tv1 = ( p3 - p1 ) * 0.5;\r\n\t\r\n\t\t\treturn ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/math/Triangle.js\r\n\t\r\n\t/**\r\n\t * @author bhouston / http://clara.io\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.Triangle = function ( a, b, c ) {\r\n\t\r\n\t\tthis.a = ( a !== undefined ) ? a : new THREE.Vector3();\r\n\t\tthis.b = ( b !== undefined ) ? b : new THREE.Vector3();\r\n\t\tthis.c = ( c !== undefined ) ? c : new THREE.Vector3();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Triangle.normal = function () {\r\n\t\r\n\t\tvar v0 = new THREE.Vector3();\r\n\t\r\n\t\treturn function ( a, b, c, optionalTarget ) {\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\r\n\t\t\tresult.subVectors( c, b );\r\n\t\t\tv0.subVectors( a, b );\r\n\t\t\tresult.cross( v0 );\r\n\t\r\n\t\t\tvar resultLengthSq = result.lengthSq();\r\n\t\t\tif ( resultLengthSq > 0 ) {\r\n\t\r\n\t\t\t\treturn result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn result.set( 0, 0, 0 );\r\n\t\r\n\t\t};\r\n\t\r\n\t}();\r\n\t\r\n\t// static/instance method to calculate barycentric coordinates\r\n\t// based on: http://www.blackpawn.com/texts/pointinpoly/default.html\r\n\tTHREE.Triangle.barycoordFromPoint = function () {\r\n\t\r\n\t\tvar v0 = new THREE.Vector3();\r\n\t\tvar v1 = new THREE.Vector3();\r\n\t\tvar v2 = new THREE.Vector3();\r\n\t\r\n\t\treturn function ( point, a, b, c, optionalTarget ) {\r\n\t\r\n\t\t\tv0.subVectors( c, a );\r\n\t\t\tv1.subVectors( b, a );\r\n\t\t\tv2.subVectors( point, a );\r\n\t\r\n\t\t\tvar dot00 = v0.dot( v0 );\r\n\t\t\tvar dot01 = v0.dot( v1 );\r\n\t\t\tvar dot02 = v0.dot( v2 );\r\n\t\t\tvar dot11 = v1.dot( v1 );\r\n\t\t\tvar dot12 = v1.dot( v2 );\r\n\t\r\n\t\t\tvar denom = ( dot00 * dot11 - dot01 * dot01 );\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\r\n\t\t\t// collinear or singular triangle\r\n\t\t\tif ( denom === 0 ) {\r\n\t\r\n\t\t\t\t// arbitrary location outside of triangle?\r\n\t\t\t\t// not sure if this is the best idea, maybe should be returning undefined\r\n\t\t\t\treturn result.set( - 2, - 1, - 1 );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar invDenom = 1 / denom;\r\n\t\t\tvar u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;\r\n\t\t\tvar v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;\r\n\t\r\n\t\t\t// barycentric coordinates must always sum to 1\r\n\t\t\treturn result.set( 1 - u - v, v, u );\r\n\t\r\n\t\t};\r\n\t\r\n\t}();\r\n\t\r\n\tTHREE.Triangle.containsPoint = function () {\r\n\t\r\n\t\tvar v1 = new THREE.Vector3();\r\n\t\r\n\t\treturn function ( point, a, b, c ) {\r\n\t\r\n\t\t\tvar result = THREE.Triangle.barycoordFromPoint( point, a, b, c, v1 );\r\n\t\r\n\t\t\treturn ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );\r\n\t\r\n\t\t};\r\n\t\r\n\t}();\r\n\t\r\n\tTHREE.Triangle.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Triangle,\r\n\t\r\n\t\tset: function ( a, b, c ) {\r\n\t\r\n\t\t\tthis.a.copy( a );\r\n\t\t\tthis.b.copy( b );\r\n\t\t\tthis.c.copy( c );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromPointsAndIndices: function ( points, i0, i1, i2 ) {\r\n\t\r\n\t\t\tthis.a.copy( points[ i0 ] );\r\n\t\t\tthis.b.copy( points[ i1 ] );\r\n\t\t\tthis.c.copy( points[ i2 ] );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new this.constructor().copy( this );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( triangle ) {\r\n\t\r\n\t\t\tthis.a.copy( triangle.a );\r\n\t\t\tthis.b.copy( triangle.b );\r\n\t\t\tthis.c.copy( triangle.c );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tarea: function () {\r\n\t\r\n\t\t\tvar v0 = new THREE.Vector3();\r\n\t\t\tvar v1 = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function () {\r\n\t\r\n\t\t\t\tv0.subVectors( this.c, this.b );\r\n\t\t\t\tv1.subVectors( this.a, this.b );\r\n\t\r\n\t\t\t\treturn v0.cross( v1 ).length() * 0.5;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tmidpoint: function ( optionalTarget ) {\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\t\treturn result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tnormal: function ( optionalTarget ) {\r\n\t\r\n\t\t\treturn THREE.Triangle.normal( this.a, this.b, this.c, optionalTarget );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tplane: function ( optionalTarget ) {\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Plane();\r\n\t\r\n\t\t\treturn result.setFromCoplanarPoints( this.a, this.b, this.c );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tbarycoordFromPoint: function ( point, optionalTarget ) {\r\n\t\r\n\t\t\treturn THREE.Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcontainsPoint: function ( point ) {\r\n\t\r\n\t\t\treturn THREE.Triangle.containsPoint( point, this.a, this.b, this.c );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclosestPointToPoint: function () {\r\n\t\r\n\t\t\tvar plane, edgeList, projectedPoint, closestPoint;\r\n\t\r\n\t\t\treturn function closestPointToPoint( point, optionalTarget ) {\r\n\t\r\n\t\t\t\tif ( plane === undefined ) {\r\n\t\r\n\t\t\t\t\tplane = new THREE.Plane();\r\n\t\t\t\t\tedgeList = [ new THREE.Line3(), new THREE.Line3(), new THREE.Line3() ];\r\n\t\t\t\t\tprojectedPoint = new THREE.Vector3();\r\n\t\t\t\t\tclosestPoint = new THREE.Vector3();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\t\t\tvar minDistance = Infinity;\r\n\t\r\n\t\t\t\t// project the point onto the plane of the triangle\r\n\t\r\n\t\t\t\tplane.setFromCoplanarPoints( this.a, this.b, this.c );\r\n\t\t\t\tplane.projectPoint( point, projectedPoint );\r\n\t\r\n\t\t\t\t// check if the projection lies within the triangle\r\n\t\r\n\t\t\t\tif( this.containsPoint( projectedPoint ) === true ) {\r\n\t\r\n\t\t\t\t\t// if so, this is the closest point\r\n\t\r\n\t\t\t\t\tresult.copy( projectedPoint );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t// if not, the point falls outside the triangle. the result is the closest point to the triangle's edges or vertices\r\n\t\r\n\t\t\t\t\tedgeList[ 0 ].set( this.a, this.b );\r\n\t\t\t\t\tedgeList[ 1 ].set( this.b, this.c );\r\n\t\t\t\t\tedgeList[ 2 ].set( this.c, this.a );\r\n\t\r\n\t\t\t\t\tfor( var i = 0; i < edgeList.length; i ++ ) {\r\n\t\r\n\t\t\t\t\t\tedgeList[ i ].closestPointToPoint( projectedPoint, true, closestPoint );\r\n\t\r\n\t\t\t\t\t\tvar distance = projectedPoint.distanceToSquared( closestPoint );\r\n\t\r\n\t\t\t\t\t\tif( distance < minDistance ) {\r\n\t\r\n\t\t\t\t\t\t\tminDistance = distance;\r\n\t\r\n\t\t\t\t\t\t\tresult.copy( closestPoint );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn result;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tequals: function ( triangle ) {\r\n\t\r\n\t\t\treturn triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/math/Interpolant.js\r\n\t\r\n\t/**\r\n\t * Abstract base class of interpolants over parametric samples.\r\n\t *\r\n\t * The parameter domain is one dimensional, typically the time or a path\r\n\t * along a curve defined by the data.\r\n\t *\r\n\t * The sample values can have any dimensionality and derived classes may\r\n\t * apply special interpretations to the data.\r\n\t *\r\n\t * This class provides the interval seek in a Template Method, deferring\r\n\t * the actual interpolation to derived classes.\r\n\t *\r\n\t * Time complexity is O(1) for linear access crossing at most two points\r\n\t * and O(log N) for random access, where N is the number of positions.\r\n\t *\r\n\t * References:\r\n\t *\r\n\t * \t\thttp://www.oodesign.com/template-method-pattern.html\r\n\t *\r\n\t * @author tschw\r\n\t */\r\n\t\r\n\tTHREE.Interpolant = function(\r\n\t\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\r\n\t\r\n\t\tthis.parameterPositions = parameterPositions;\r\n\t\tthis._cachedIndex = 0;\r\n\t\r\n\t\tthis.resultBuffer = resultBuffer !== undefined ?\r\n\t\t\t\tresultBuffer : new sampleValues.constructor( sampleSize );\r\n\t\tthis.sampleValues = sampleValues;\r\n\t\tthis.valueSize = sampleSize;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Interpolant.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Interpolant,\r\n\t\r\n\t\tevaluate: function( t ) {\r\n\t\r\n\t\t\tvar pp = this.parameterPositions,\r\n\t\t\t\ti1 = this._cachedIndex,\r\n\t\r\n\t\t\t\tt1 = pp[   i1   ],\r\n\t\t\t\tt0 = pp[ i1 - 1 ];\r\n\t\r\n\t\t\tvalidate_interval: {\r\n\t\r\n\t\t\t\tseek: {\r\n\t\r\n\t\t\t\t\tvar right;\r\n\t\r\n\t\t\t\t\tlinear_scan: {\r\n\t//- See http://jsperf.com/comparison-to-undefined/3\r\n\t//- slower code:\r\n\t//-\r\n\t//- \t\t\t\tif ( t >= t1 || t1 === undefined ) {\r\n\t\t\t\t\t\tforward_scan: if ( ! ( t < t1 ) ) {\r\n\t\r\n\t\t\t\t\t\t\tfor ( var giveUpAt = i1 + 2; ;) {\r\n\t\r\n\t\t\t\t\t\t\t\tif ( t1 === undefined ) {\r\n\t\r\n\t\t\t\t\t\t\t\t\tif ( t < t0 ) break forward_scan;\r\n\t\r\n\t\t\t\t\t\t\t\t\t// after end\r\n\t\r\n\t\t\t\t\t\t\t\t\ti1 = pp.length;\r\n\t\t\t\t\t\t\t\t\tthis._cachedIndex = i1;\r\n\t\t\t\t\t\t\t\t\treturn this.afterEnd_( i1 - 1, t, t0 );\r\n\t\r\n\t\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t\tif ( i1 === giveUpAt ) break; // this loop\r\n\t\r\n\t\t\t\t\t\t\t\tt0 = t1;\r\n\t\t\t\t\t\t\t\tt1 = pp[ ++ i1 ];\r\n\t\r\n\t\t\t\t\t\t\t\tif ( t < t1 ) {\r\n\t\r\n\t\t\t\t\t\t\t\t\t// we have arrived at the sought interval\r\n\t\t\t\t\t\t\t\t\tbreak seek;\r\n\t\r\n\t\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t// prepare binary search on the right side of the index\r\n\t\t\t\t\t\t\tright = pp.length;\r\n\t\t\t\t\t\t\tbreak linear_scan;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t//- slower code:\r\n\t//-\t\t\t\t\tif ( t < t0 || t0 === undefined ) {\r\n\t\t\t\t\t\tif ( ! ( t >= t0 ) ) {\r\n\t\r\n\t\t\t\t\t\t\t// looping?\r\n\t\r\n\t\t\t\t\t\t\tvar t1global = pp[ 1 ];\r\n\t\r\n\t\t\t\t\t\t\tif ( t < t1global ) {\r\n\t\r\n\t\t\t\t\t\t\t\ti1 = 2; // + 1, using the scan for the details\r\n\t\t\t\t\t\t\t\tt0 = t1global;\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t// linear reverse scan\r\n\t\r\n\t\t\t\t\t\t\tfor ( var giveUpAt = i1 - 2; ;) {\r\n\t\r\n\t\t\t\t\t\t\t\tif ( t0 === undefined ) {\r\n\t\r\n\t\t\t\t\t\t\t\t\t// before start\r\n\t\r\n\t\t\t\t\t\t\t\t\tthis._cachedIndex = 0;\r\n\t\t\t\t\t\t\t\t\treturn this.beforeStart_( 0, t, t1 );\r\n\t\r\n\t\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t\tif ( i1 === giveUpAt ) break; // this loop\r\n\t\r\n\t\t\t\t\t\t\t\tt1 = t0;\r\n\t\t\t\t\t\t\t\tt0 = pp[ -- i1 - 1 ];\r\n\t\r\n\t\t\t\t\t\t\t\tif ( t >= t0 ) {\r\n\t\r\n\t\t\t\t\t\t\t\t\t// we have arrived at the sought interval\r\n\t\t\t\t\t\t\t\t\tbreak seek;\r\n\t\r\n\t\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t// prepare binary search on the left side of the index\r\n\t\t\t\t\t\t\tright = i1;\r\n\t\t\t\t\t\t\ti1 = 0;\r\n\t\t\t\t\t\t\tbreak linear_scan;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t// the interval is valid\r\n\t\r\n\t\t\t\t\t\tbreak validate_interval;\r\n\t\r\n\t\t\t\t\t} // linear scan\r\n\t\r\n\t\t\t\t\t// binary search\r\n\t\r\n\t\t\t\t\twhile ( i1 < right ) {\r\n\t\r\n\t\t\t\t\t\tvar mid = ( i1 + right ) >>> 1;\r\n\t\r\n\t\t\t\t\t\tif ( t < pp[ mid ] ) {\r\n\t\r\n\t\t\t\t\t\t\tright = mid;\r\n\t\r\n\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\ti1 = mid + 1;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tt1 = pp[   i1   ];\r\n\t\t\t\t\tt0 = pp[ i1 - 1 ];\r\n\t\r\n\t\t\t\t\t// check boundary cases, again\r\n\t\r\n\t\t\t\t\tif ( t0 === undefined ) {\r\n\t\r\n\t\t\t\t\t\tthis._cachedIndex = 0;\r\n\t\t\t\t\t\treturn this.beforeStart_( 0, t, t1 );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( t1 === undefined ) {\r\n\t\r\n\t\t\t\t\t\ti1 = pp.length;\r\n\t\t\t\t\t\tthis._cachedIndex = i1;\r\n\t\t\t\t\t\treturn this.afterEnd_( i1 - 1, t0, t );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} // seek\r\n\t\r\n\t\t\t\tthis._cachedIndex = i1;\r\n\t\r\n\t\t\t\tthis.intervalChanged_( i1, t0, t1 );\r\n\t\r\n\t\t\t} // validate_interval\r\n\t\r\n\t\t\treturn this.interpolate_( i1, t0, t, t1 );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsettings: null, // optional, subclass-specific settings structure\r\n\t\t// Note: The indirection allows central control of many interpolants.\r\n\t\r\n\t\t// --- Protected interface\r\n\t\r\n\t\tDefaultSettings_: {},\r\n\t\r\n\t\tgetSettings_: function() {\r\n\t\r\n\t\t\treturn this.settings || this.DefaultSettings_;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopySampleValue_: function( index ) {\r\n\t\r\n\t\t\t// copies a sample value to the result buffer\r\n\t\r\n\t\t\tvar result = this.resultBuffer,\r\n\t\t\t\tvalues = this.sampleValues,\r\n\t\t\t\tstride = this.valueSize,\r\n\t\t\t\toffset = index * stride;\r\n\t\r\n\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\r\n\t\r\n\t\t\t\tresult[ i ] = values[ offset + i ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn result;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Template methods for derived classes:\r\n\t\r\n\t\tinterpolate_: function( i1, t0, t, t1 ) {\r\n\t\r\n\t\t\tthrow new Error( \"call to abstract method\" );\r\n\t\t\t// implementations shall return this.resultBuffer\r\n\t\r\n\t\t},\r\n\t\r\n\t\tintervalChanged_: function( i1, t0, t1 ) {\r\n\t\r\n\t\t\t// empty\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tObject.assign( THREE.Interpolant.prototype, {\r\n\t\r\n\t\tbeforeStart_: //( 0, t, t0 ), returns this.resultBuffer\r\n\t\t\tTHREE.Interpolant.prototype.copySampleValue_,\r\n\t\r\n\t\tafterEnd_: //( N-1, tN-1, t ), returns this.resultBuffer\r\n\t\t\tTHREE.Interpolant.prototype.copySampleValue_\r\n\t\r\n\t} );\r\n\t\r\n\t// File:src/math/interpolants/CubicInterpolant.js\r\n\t\r\n\t/**\r\n\t * Fast and simple cubic spline interpolant.\r\n\t *\r\n\t * It was derived from a Hermitian construction setting the first derivative\r\n\t * at each sample position to the linear slope between neighboring positions\r\n\t * over their parameter interval.\r\n\t *\r\n\t * @author tschw\r\n\t */\r\n\t\r\n\tTHREE.CubicInterpolant = function(\r\n\t\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\r\n\t\r\n\t\tTHREE.Interpolant.call(\r\n\t\t\t\tthis, parameterPositions, sampleValues, sampleSize, resultBuffer );\r\n\t\r\n\t\tthis._weightPrev = -0;\r\n\t\tthis._offsetPrev = -0;\r\n\t\tthis._weightNext = -0;\r\n\t\tthis._offsetNext = -0;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.CubicInterpolant.prototype =\r\n\t\t\tObject.assign( Object.create( THREE.Interpolant.prototype ), {\r\n\t\r\n\t\tconstructor: THREE.CubicInterpolant,\r\n\t\r\n\t\tDefaultSettings_: {\r\n\t\r\n\t\t\tendingStart: \tTHREE.ZeroCurvatureEnding,\r\n\t\t\tendingEnd:\t\tTHREE.ZeroCurvatureEnding\r\n\t\r\n\t\t},\r\n\t\r\n\t\tintervalChanged_: function( i1, t0, t1 ) {\r\n\t\r\n\t\t\tvar pp = this.parameterPositions,\r\n\t\t\t\tiPrev = i1 - 2,\r\n\t\t\t\tiNext = i1 + 1,\r\n\t\r\n\t\t\t\ttPrev = pp[ iPrev ],\r\n\t\t\t\ttNext = pp[ iNext ];\r\n\t\r\n\t\t\tif ( tPrev === undefined ) {\r\n\t\r\n\t\t\t\tswitch ( this.getSettings_().endingStart ) {\r\n\t\r\n\t\t\t\t\tcase THREE.ZeroSlopeEnding:\r\n\t\r\n\t\t\t\t\t\t// f'(t0) = 0\r\n\t\t\t\t\t\tiPrev = i1;\r\n\t\t\t\t\t\ttPrev = 2 * t0 - t1;\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase THREE.WrapAroundEnding:\r\n\t\r\n\t\t\t\t\t\t// use the other end of the curve\r\n\t\t\t\t\t\tiPrev = pp.length - 2;\r\n\t\t\t\t\t\ttPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tdefault: // ZeroCurvatureEnding\r\n\t\r\n\t\t\t\t\t\t// f''(t0) = 0 a.k.a. Natural Spline\r\n\t\t\t\t\t\tiPrev = i1;\r\n\t\t\t\t\t\ttPrev = t1;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( tNext === undefined ) {\r\n\t\r\n\t\t\t\tswitch ( this.getSettings_().endingEnd ) {\r\n\t\r\n\t\t\t\t\tcase THREE.ZeroSlopeEnding:\r\n\t\r\n\t\t\t\t\t\t// f'(tN) = 0\r\n\t\t\t\t\t\tiNext = i1;\r\n\t\t\t\t\t\ttNext = 2 * t1 - t0;\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase THREE.WrapAroundEnding:\r\n\t\r\n\t\t\t\t\t\t// use the other end of the curve\r\n\t\t\t\t\t\tiNext = 1;\r\n\t\t\t\t\t\ttNext = t1 + pp[ 1 ] - pp[ 0 ];\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tdefault: // ZeroCurvatureEnding\r\n\t\r\n\t\t\t\t\t\t// f''(tN) = 0, a.k.a. Natural Spline\r\n\t\t\t\t\t\tiNext = i1 - 1;\r\n\t\t\t\t\t\ttNext = t0;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar halfDt = ( t1 - t0 ) * 0.5,\r\n\t\t\t\tstride = this.valueSize;\r\n\t\r\n\t\t\tthis._weightPrev = halfDt / ( t0 - tPrev );\r\n\t\t\tthis._weightNext = halfDt / ( tNext - t1 );\r\n\t\t\tthis._offsetPrev = iPrev * stride;\r\n\t\t\tthis._offsetNext = iNext * stride;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tinterpolate_: function( i1, t0, t, t1 ) {\r\n\t\r\n\t\t\tvar result = this.resultBuffer,\r\n\t\t\t\tvalues = this.sampleValues,\r\n\t\t\t\tstride = this.valueSize,\r\n\t\r\n\t\t\t\to1 = i1 * stride,\t\to0 = o1 - stride,\r\n\t\t\t\toP = this._offsetPrev, \toN = this._offsetNext,\r\n\t\t\t\twP = this._weightPrev,\twN = this._weightNext,\r\n\t\r\n\t\t\t\tp = ( t - t0 ) / ( t1 - t0 ),\r\n\t\t\t\tpp = p * p,\r\n\t\t\t\tppp = pp * p;\r\n\t\r\n\t\t\t// evaluate polynomials\r\n\t\r\n\t\t\tvar sP =     - wP   * ppp   +         2 * wP    * pp    -          wP   * p;\r\n\t\t\tvar s0 = ( 1 + wP ) * ppp   + (-1.5 - 2 * wP )  * pp    + ( -0.5 + wP ) * p     + 1;\r\n\t\t\tvar s1 = (-1 - wN ) * ppp   + ( 1.5 +   wN   )  * pp    +    0.5        * p;\r\n\t\t\tvar sN =       wN   * ppp   -           wN      * pp;\r\n\t\r\n\t\t\t// combine data linearly\r\n\t\r\n\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\r\n\t\r\n\t\t\t\tresult[ i ] =\r\n\t\t\t\t\t\tsP * values[ oP + i ] +\r\n\t\t\t\t\t\ts0 * values[ o0 + i ] +\r\n\t\t\t\t\t\ts1 * values[ o1 + i ] +\r\n\t\t\t\t\t\tsN * values[ oN + i ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn result;\r\n\t\r\n\t\t}\r\n\t\r\n\t} );\r\n\t\r\n\t// File:src/math/interpolants/DiscreteInterpolant.js\r\n\t\r\n\t/**\r\n\t *\r\n\t * Interpolant that evaluates to the sample value at the position preceeding\r\n\t * the parameter.\r\n\t *\r\n\t * @author tschw\r\n\t */\r\n\t\r\n\tTHREE.DiscreteInterpolant = function(\r\n\t\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\r\n\t\r\n\t\tTHREE.Interpolant.call(\r\n\t\t\t\tthis, parameterPositions, sampleValues, sampleSize, resultBuffer );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.DiscreteInterpolant.prototype =\r\n\t\t\tObject.assign( Object.create( THREE.Interpolant.prototype ), {\r\n\t\r\n\t\tconstructor: THREE.DiscreteInterpolant,\r\n\t\r\n\t\tinterpolate_: function( i1, t0, t, t1 ) {\r\n\t\r\n\t\t\treturn this.copySampleValue_( i1 - 1 );\r\n\t\r\n\t\t}\r\n\t\r\n\t} );\r\n\t\r\n\t// File:src/math/interpolants/LinearInterpolant.js\r\n\t\r\n\t/**\r\n\t * @author tschw\r\n\t */\r\n\t\r\n\tTHREE.LinearInterpolant = function(\r\n\t\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\r\n\t\r\n\t\tTHREE.Interpolant.call(\r\n\t\t\t\tthis, parameterPositions, sampleValues, sampleSize, resultBuffer );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.LinearInterpolant.prototype =\r\n\t\t\tObject.assign( Object.create( THREE.Interpolant.prototype ), {\r\n\t\r\n\t\tconstructor: THREE.LinearInterpolant,\r\n\t\r\n\t\tinterpolate_: function( i1, t0, t, t1 ) {\r\n\t\r\n\t\t\tvar result = this.resultBuffer,\r\n\t\t\t\tvalues = this.sampleValues,\r\n\t\t\t\tstride = this.valueSize,\r\n\t\r\n\t\t\t\toffset1 = i1 * stride,\r\n\t\t\t\toffset0 = offset1 - stride,\r\n\t\r\n\t\t\t\tweight1 = ( t - t0 ) / ( t1 - t0 ),\r\n\t\t\t\tweight0 = 1 - weight1;\r\n\t\r\n\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\r\n\t\r\n\t\t\t\tresult[ i ] =\r\n\t\t\t\t\t\tvalues[ offset0 + i ] * weight0 +\r\n\t\t\t\t\t\tvalues[ offset1 + i ] * weight1;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn result;\r\n\t\r\n\t\t}\r\n\t\r\n\t} );\r\n\t\r\n\t// File:src/math/interpolants/QuaternionLinearInterpolant.js\r\n\t\r\n\t/**\r\n\t * Spherical linear unit quaternion interpolant.\r\n\t *\r\n\t * @author tschw\r\n\t */\r\n\t\r\n\tTHREE.QuaternionLinearInterpolant = function(\r\n\t\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\r\n\t\r\n\t\tTHREE.Interpolant.call(\r\n\t\t\t\tthis, parameterPositions, sampleValues, sampleSize, resultBuffer );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.QuaternionLinearInterpolant.prototype =\r\n\t\t\tObject.assign( Object.create( THREE.Interpolant.prototype ), {\r\n\t\r\n\t\tconstructor: THREE.QuaternionLinearInterpolant,\r\n\t\r\n\t\tinterpolate_: function( i1, t0, t, t1 ) {\r\n\t\r\n\t\t\tvar result = this.resultBuffer,\r\n\t\t\t\tvalues = this.sampleValues,\r\n\t\t\t\tstride = this.valueSize,\r\n\t\r\n\t\t\t\toffset = i1 * stride,\r\n\t\r\n\t\t\t\talpha = ( t - t0 ) / ( t1 - t0 );\r\n\t\r\n\t\t\tfor ( var end = offset + stride; offset !== end; offset += 4 ) {\r\n\t\r\n\t\t\t\tTHREE.Quaternion.slerpFlat( result, 0,\r\n\t\t\t\t\t\tvalues, offset - stride, values, offset, alpha );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn result;\r\n\t\r\n\t\t}\r\n\t\r\n\t} );\r\n\t\r\n\t// File:src/core/Clock.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.Clock = function ( autoStart ) {\r\n\t\r\n\t\tthis.autoStart = ( autoStart !== undefined ) ? autoStart : true;\r\n\t\r\n\t\tthis.startTime = 0;\r\n\t\tthis.oldTime = 0;\r\n\t\tthis.elapsedTime = 0;\r\n\t\r\n\t\tthis.running = false;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Clock.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Clock,\r\n\t\r\n\t\tstart: function () {\r\n\t\r\n\t\t\tthis.startTime = ( performance || Date ).now();\r\n\t\r\n\t\t\tthis.oldTime = this.startTime;\r\n\t\t\tthis.running = true;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tstop: function () {\r\n\t\r\n\t\t\tthis.getElapsedTime();\r\n\t\t\tthis.running = false;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetElapsedTime: function () {\r\n\t\r\n\t\t\tthis.getDelta();\r\n\t\t\treturn this.elapsedTime;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetDelta: function () {\r\n\t\r\n\t\t\tvar diff = 0;\r\n\t\r\n\t\t\tif ( this.autoStart && ! this.running ) {\r\n\t\r\n\t\t\t\tthis.start();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( this.running ) {\r\n\t\r\n\t\t\t\tvar newTime = ( performance || Date ).now();\r\n\t\r\n\t\t\t\tdiff = ( newTime - this.oldTime ) / 1000;\r\n\t\t\t\tthis.oldTime = newTime;\r\n\t\r\n\t\t\t\tthis.elapsedTime += diff;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn diff;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/core/EventDispatcher.js\r\n\t\r\n\t/**\r\n\t * https://github.com/mrdoob/eventdispatcher.js/\r\n\t */\r\n\t\r\n\tTHREE.EventDispatcher = function () {};\r\n\t\r\n\tTHREE.EventDispatcher.prototype = {\r\n\t\r\n\t\tconstructor: THREE.EventDispatcher,\r\n\t\r\n\t\tapply: function ( object ) {\r\n\t\r\n\t\t\tobject.addEventListener = THREE.EventDispatcher.prototype.addEventListener;\r\n\t\t\tobject.hasEventListener = THREE.EventDispatcher.prototype.hasEventListener;\r\n\t\t\tobject.removeEventListener = THREE.EventDispatcher.prototype.removeEventListener;\r\n\t\t\tobject.dispatchEvent = THREE.EventDispatcher.prototype.dispatchEvent;\r\n\t\r\n\t\t},\r\n\t\r\n\t\taddEventListener: function ( type, listener ) {\r\n\t\r\n\t\t\tif ( this._listeners === undefined ) this._listeners = {};\r\n\t\r\n\t\t\tvar listeners = this._listeners;\r\n\t\r\n\t\t\tif ( listeners[ type ] === undefined ) {\r\n\t\r\n\t\t\t\tlisteners[ type ] = [];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( listeners[ type ].indexOf( listener ) === - 1 ) {\r\n\t\r\n\t\t\t\tlisteners[ type ].push( listener );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\thasEventListener: function ( type, listener ) {\r\n\t\r\n\t\t\tif ( this._listeners === undefined ) return false;\r\n\t\r\n\t\t\tvar listeners = this._listeners;\r\n\t\r\n\t\t\tif ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {\r\n\t\r\n\t\t\t\treturn true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn false;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tremoveEventListener: function ( type, listener ) {\r\n\t\r\n\t\t\tif ( this._listeners === undefined ) return;\r\n\t\r\n\t\t\tvar listeners = this._listeners;\r\n\t\t\tvar listenerArray = listeners[ type ];\r\n\t\r\n\t\t\tif ( listenerArray !== undefined ) {\r\n\t\r\n\t\t\t\tvar index = listenerArray.indexOf( listener );\r\n\t\r\n\t\t\t\tif ( index !== - 1 ) {\r\n\t\r\n\t\t\t\t\tlistenerArray.splice( index, 1 );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdispatchEvent: function ( event ) {\r\n\t\r\n\t\t\tif ( this._listeners === undefined ) return;\r\n\t\r\n\t\t\tvar listeners = this._listeners;\r\n\t\t\tvar listenerArray = listeners[ event.type ];\r\n\t\r\n\t\t\tif ( listenerArray !== undefined ) {\r\n\t\r\n\t\t\t\tevent.target = this;\r\n\t\r\n\t\t\t\tvar array = [];\r\n\t\t\t\tvar length = listenerArray.length;\r\n\t\r\n\t\t\t\tfor ( var i = 0; i < length; i ++ ) {\r\n\t\r\n\t\t\t\t\tarray[ i ] = listenerArray[ i ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tfor ( var i = 0; i < length; i ++ ) {\r\n\t\r\n\t\t\t\t\tarray[ i ].call( this, event );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/core/Layers.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.Layers = function () {\r\n\t\r\n\t\tthis.mask = 1;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Layers.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Layers,\r\n\t\r\n\t\tset: function ( channel ) {\r\n\t\r\n\t\t\tthis.mask = 1 << channel;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tenable: function ( channel ) {\r\n\t\r\n\t\t\tthis.mask |= 1 << channel;\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttoggle: function ( channel ) {\r\n\t\r\n\t\t\tthis.mask ^= 1 << channel;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdisable: function ( channel ) {\r\n\t\r\n\t\t\tthis.mask &= ~ ( 1 << channel );\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttest: function ( layers ) {\r\n\t\r\n\t\t\treturn ( this.mask & layers.mask ) !== 0;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/core/Raycaster.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author bhouston / http://clara.io/\r\n\t * @author stephomi / http://stephaneginier.com/\r\n\t */\r\n\t\r\n\t( function ( THREE ) {\r\n\t\r\n\t\tTHREE.Raycaster = function ( origin, direction, near, far ) {\r\n\t\r\n\t\t\tthis.ray = new THREE.Ray( origin, direction );\r\n\t\t\t// direction is assumed to be normalized (for accurate distance calculations)\r\n\t\r\n\t\t\tthis.near = near || 0;\r\n\t\t\tthis.far = far || Infinity;\r\n\t\r\n\t\t\tthis.params = {\r\n\t\t\t\tMesh: {},\r\n\t\t\t\tLine: {},\r\n\t\t\t\tLOD: {},\r\n\t\t\t\tPoints: { threshold: 1 },\r\n\t\t\t\tSprite: {}\r\n\t\t\t};\r\n\t\r\n\t\t\tObject.defineProperties( this.params, {\r\n\t\t\t\tPointCloud: {\r\n\t\t\t\t\tget: function () {\r\n\t\t\t\t\t\tconsole.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );\r\n\t\t\t\t\t\treturn this.Points;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tfunction ascSort( a, b ) {\r\n\t\r\n\t\t\treturn a.distance - b.distance;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction intersectObject( object, raycaster, intersects, recursive ) {\r\n\t\r\n\t\t\tif ( object.visible === false ) return;\r\n\t\r\n\t\t\tobject.raycast( raycaster, intersects );\r\n\t\r\n\t\t\tif ( recursive === true ) {\r\n\t\r\n\t\t\t\tvar children = object.children;\r\n\t\r\n\t\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\tintersectObject( children[ i ], raycaster, intersects, true );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\t//\r\n\t\r\n\t\tTHREE.Raycaster.prototype = {\r\n\t\r\n\t\t\tconstructor: THREE.Raycaster,\r\n\t\r\n\t\t\tlinePrecision: 1,\r\n\t\r\n\t\t\tset: function ( origin, direction ) {\r\n\t\r\n\t\t\t\t// direction is assumed to be normalized (for accurate distance calculations)\r\n\t\r\n\t\t\t\tthis.ray.set( origin, direction );\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t\tsetFromCamera: function ( coords, camera ) {\r\n\t\r\n\t\t\t\tif ( camera instanceof THREE.PerspectiveCamera ) {\r\n\t\r\n\t\t\t\t\tthis.ray.origin.setFromMatrixPosition( camera.matrixWorld );\r\n\t\t\t\t\tthis.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();\r\n\t\r\n\t\t\t\t} else if ( camera instanceof THREE.OrthographicCamera ) {\r\n\t\r\n\t\t\t\t\tthis.ray.origin.set( coords.x, coords.y, - 1 ).unproject( camera );\r\n\t\t\t\t\tthis.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tconsole.error( 'THREE.Raycaster: Unsupported camera type.' );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t\tintersectObject: function ( object, recursive ) {\r\n\t\r\n\t\t\t\tvar intersects = [];\r\n\t\r\n\t\t\t\tintersectObject( object, this, intersects, recursive );\r\n\t\r\n\t\t\t\tintersects.sort( ascSort );\r\n\t\r\n\t\t\t\treturn intersects;\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t\tintersectObjects: function ( objects, recursive ) {\r\n\t\r\n\t\t\t\tvar intersects = [];\r\n\t\r\n\t\t\t\tif ( Array.isArray( objects ) === false ) {\r\n\t\r\n\t\t\t\t\tconsole.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );\r\n\t\t\t\t\treturn intersects;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tfor ( var i = 0, l = objects.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\tintersectObject( objects[ i ], this, intersects, recursive );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tintersects.sort( ascSort );\r\n\t\r\n\t\t\t\treturn intersects;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t}( THREE ) );\r\n\t\r\n\t// File:src/core/Object3D.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t * @author elephantatwork / www.elephantatwork.ch\r\n\t */\r\n\t\r\n\tTHREE.Object3D = function () {\r\n\t\r\n\t\tObject.defineProperty( this, 'id', { value: THREE.Object3DIdCount ++ } );\r\n\t\r\n\t\tthis.uuid = THREE.Math.generateUUID();\r\n\t\r\n\t\tthis.name = '';\r\n\t\tthis.type = 'Object3D';\r\n\t\r\n\t\tthis.parent = null;\r\n\t\tthis.children = [];\r\n\t\r\n\t\tthis.up = THREE.Object3D.DefaultUp.clone();\r\n\t\r\n\t\tvar position = new THREE.Vector3();\r\n\t\tvar rotation = new THREE.Euler();\r\n\t\tvar quaternion = new THREE.Quaternion();\r\n\t\tvar scale = new THREE.Vector3( 1, 1, 1 );\r\n\t\r\n\t\tfunction onRotationChange() {\r\n\t\r\n\t\t\tquaternion.setFromEuler( rotation, false );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction onQuaternionChange() {\r\n\t\r\n\t\t\trotation.setFromQuaternion( quaternion, undefined, false );\r\n\t\r\n\t\t}\r\n\t\r\n\t\trotation.onChange( onRotationChange );\r\n\t\tquaternion.onChange( onQuaternionChange );\r\n\t\r\n\t\tObject.defineProperties( this, {\r\n\t\t\tposition: {\r\n\t\t\t\tenumerable: true,\r\n\t\t\t\tvalue: position\r\n\t\t\t},\r\n\t\t\trotation: {\r\n\t\t\t\tenumerable: true,\r\n\t\t\t\tvalue: rotation\r\n\t\t\t},\r\n\t\t\tquaternion: {\r\n\t\t\t\tenumerable: true,\r\n\t\t\t\tvalue: quaternion\r\n\t\t\t},\r\n\t\t\tscale: {\r\n\t\t\t\tenumerable: true,\r\n\t\t\t\tvalue: scale\r\n\t\t\t},\r\n\t\t\tmodelViewMatrix: {\r\n\t\t\t\tvalue: new THREE.Matrix4()\r\n\t\t\t},\r\n\t\t\tnormalMatrix: {\r\n\t\t\t\tvalue: new THREE.Matrix3()\r\n\t\t\t}\r\n\t\t} );\r\n\t\r\n\t\tthis.rotationAutoUpdate = true;\r\n\t\r\n\t\tthis.matrix = new THREE.Matrix4();\r\n\t\tthis.matrixWorld = new THREE.Matrix4();\r\n\t\r\n\t\tthis.matrixAutoUpdate = THREE.Object3D.DefaultMatrixAutoUpdate;\r\n\t\tthis.matrixWorldNeedsUpdate = false;\r\n\t\r\n\t\tthis.layers = new THREE.Layers();\r\n\t\tthis.visible = true;\r\n\t\r\n\t\tthis.castShadow = false;\r\n\t\tthis.receiveShadow = false;\r\n\t\r\n\t\tthis.frustumCulled = true;\r\n\t\tthis.renderOrder = 0;\r\n\t\r\n\t\tthis.userData = {};\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Object3D.DefaultUp = new THREE.Vector3( 0, 1, 0 );\r\n\tTHREE.Object3D.DefaultMatrixAutoUpdate = true;\r\n\t\r\n\tTHREE.Object3D.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Object3D,\r\n\t\r\n\t\tapplyMatrix: function ( matrix ) {\r\n\t\r\n\t\t\tthis.matrix.multiplyMatrices( matrix, this.matrix );\r\n\t\r\n\t\t\tthis.matrix.decompose( this.position, this.quaternion, this.scale );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetRotationFromAxisAngle: function ( axis, angle ) {\r\n\t\r\n\t\t\t// assumes axis is normalized\r\n\t\r\n\t\t\tthis.quaternion.setFromAxisAngle( axis, angle );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetRotationFromEuler: function ( euler ) {\r\n\t\r\n\t\t\tthis.quaternion.setFromEuler( euler, true );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetRotationFromMatrix: function ( m ) {\r\n\t\r\n\t\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\r\n\t\r\n\t\t\tthis.quaternion.setFromRotationMatrix( m );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetRotationFromQuaternion: function ( q ) {\r\n\t\r\n\t\t\t// assumes q is normalized\r\n\t\r\n\t\t\tthis.quaternion.copy( q );\r\n\t\r\n\t\t},\r\n\t\r\n\t\trotateOnAxis: function () {\r\n\t\r\n\t\t\t// rotate object on axis in object space\r\n\t\t\t// axis is assumed to be normalized\r\n\t\r\n\t\t\tvar q1 = new THREE.Quaternion();\r\n\t\r\n\t\t\treturn function ( axis, angle ) {\r\n\t\r\n\t\t\t\tq1.setFromAxisAngle( axis, angle );\r\n\t\r\n\t\t\t\tthis.quaternion.multiply( q1 );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\trotateX: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3( 1, 0, 0 );\r\n\t\r\n\t\t\treturn function ( angle ) {\r\n\t\r\n\t\t\t\treturn this.rotateOnAxis( v1, angle );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\trotateY: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3( 0, 1, 0 );\r\n\t\r\n\t\t\treturn function ( angle ) {\r\n\t\r\n\t\t\t\treturn this.rotateOnAxis( v1, angle );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\trotateZ: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3( 0, 0, 1 );\r\n\t\r\n\t\t\treturn function ( angle ) {\r\n\t\r\n\t\t\t\treturn this.rotateOnAxis( v1, angle );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\ttranslateOnAxis: function () {\r\n\t\r\n\t\t\t// translate object by distance along axis in object space\r\n\t\t\t// axis is assumed to be normalized\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function ( axis, distance ) {\r\n\t\r\n\t\t\t\tv1.copy( axis ).applyQuaternion( this.quaternion );\r\n\t\r\n\t\t\t\tthis.position.add( v1.multiplyScalar( distance ) );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\ttranslateX: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3( 1, 0, 0 );\r\n\t\r\n\t\t\treturn function ( distance ) {\r\n\t\r\n\t\t\t\treturn this.translateOnAxis( v1, distance );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\ttranslateY: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3( 0, 1, 0 );\r\n\t\r\n\t\t\treturn function ( distance ) {\r\n\t\r\n\t\t\t\treturn this.translateOnAxis( v1, distance );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\ttranslateZ: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3( 0, 0, 1 );\r\n\t\r\n\t\t\treturn function ( distance ) {\r\n\t\r\n\t\t\t\treturn this.translateOnAxis( v1, distance );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tlocalToWorld: function ( vector ) {\r\n\t\r\n\t\t\treturn vector.applyMatrix4( this.matrixWorld );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tworldToLocal: function () {\r\n\t\r\n\t\t\tvar m1 = new THREE.Matrix4();\r\n\t\r\n\t\t\treturn function ( vector ) {\r\n\t\r\n\t\t\t\treturn vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tlookAt: function () {\r\n\t\r\n\t\t\t// This routine does not support objects with rotated and/or translated parent(s)\r\n\t\r\n\t\t\tvar m1 = new THREE.Matrix4();\r\n\t\r\n\t\t\treturn function ( vector ) {\r\n\t\r\n\t\t\t\tm1.lookAt( vector, this.position, this.up );\r\n\t\r\n\t\t\t\tthis.quaternion.setFromRotationMatrix( m1 );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tadd: function ( object ) {\r\n\t\r\n\t\t\tif ( arguments.length > 1 ) {\r\n\t\r\n\t\t\t\tfor ( var i = 0; i < arguments.length; i ++ ) {\r\n\t\r\n\t\t\t\t\tthis.add( arguments[ i ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( object === this ) {\r\n\t\r\n\t\t\t\tconsole.error( \"THREE.Object3D.add: object can't be added as a child of itself.\", object );\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( object instanceof THREE.Object3D ) {\r\n\t\r\n\t\t\t\tif ( object.parent !== null ) {\r\n\t\r\n\t\t\t\t\tobject.parent.remove( object );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tobject.parent = this;\r\n\t\t\t\tobject.dispatchEvent( { type: 'added' } );\r\n\t\r\n\t\t\t\tthis.children.push( object );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tconsole.error( \"THREE.Object3D.add: object not an instance of THREE.Object3D.\", object );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tremove: function ( object ) {\r\n\t\r\n\t\t\tif ( arguments.length > 1 ) {\r\n\t\r\n\t\t\t\tfor ( var i = 0; i < arguments.length; i ++ ) {\r\n\t\r\n\t\t\t\t\tthis.remove( arguments[ i ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar index = this.children.indexOf( object );\r\n\t\r\n\t\t\tif ( index !== - 1 ) {\r\n\t\r\n\t\t\t\tobject.parent = null;\r\n\t\r\n\t\t\t\tobject.dispatchEvent( { type: 'removed' } );\r\n\t\r\n\t\t\t\tthis.children.splice( index, 1 );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetObjectById: function ( id ) {\r\n\t\r\n\t\t\treturn this.getObjectByProperty( 'id', id );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetObjectByName: function ( name ) {\r\n\t\r\n\t\t\treturn this.getObjectByProperty( 'name', name );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetObjectByProperty: function ( name, value ) {\r\n\t\r\n\t\t\tif ( this[ name ] === value ) return this;\r\n\t\r\n\t\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tvar child = this.children[ i ];\r\n\t\t\t\tvar object = child.getObjectByProperty( name, value );\r\n\t\r\n\t\t\t\tif ( object !== undefined ) {\r\n\t\r\n\t\t\t\t\treturn object;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn undefined;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetWorldPosition: function ( optionalTarget ) {\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\r\n\t\t\tthis.updateMatrixWorld( true );\r\n\t\r\n\t\t\treturn result.setFromMatrixPosition( this.matrixWorld );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetWorldQuaternion: function () {\r\n\t\r\n\t\t\tvar position = new THREE.Vector3();\r\n\t\t\tvar scale = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function ( optionalTarget ) {\r\n\t\r\n\t\t\t\tvar result = optionalTarget || new THREE.Quaternion();\r\n\t\r\n\t\t\t\tthis.updateMatrixWorld( true );\r\n\t\r\n\t\t\t\tthis.matrixWorld.decompose( position, result, scale );\r\n\t\r\n\t\t\t\treturn result;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tgetWorldRotation: function () {\r\n\t\r\n\t\t\tvar quaternion = new THREE.Quaternion();\r\n\t\r\n\t\t\treturn function ( optionalTarget ) {\r\n\t\r\n\t\t\t\tvar result = optionalTarget || new THREE.Euler();\r\n\t\r\n\t\t\t\tthis.getWorldQuaternion( quaternion );\r\n\t\r\n\t\t\t\treturn result.setFromQuaternion( quaternion, this.rotation.order, false );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tgetWorldScale: function () {\r\n\t\r\n\t\t\tvar position = new THREE.Vector3();\r\n\t\t\tvar quaternion = new THREE.Quaternion();\r\n\t\r\n\t\t\treturn function ( optionalTarget ) {\r\n\t\r\n\t\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\r\n\t\t\t\tthis.updateMatrixWorld( true );\r\n\t\r\n\t\t\t\tthis.matrixWorld.decompose( position, quaternion, result );\r\n\t\r\n\t\t\t\treturn result;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tgetWorldDirection: function () {\r\n\t\r\n\t\t\tvar quaternion = new THREE.Quaternion();\r\n\t\r\n\t\t\treturn function ( optionalTarget ) {\r\n\t\r\n\t\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\r\n\t\t\t\tthis.getWorldQuaternion( quaternion );\r\n\t\r\n\t\t\t\treturn result.set( 0, 0, 1 ).applyQuaternion( quaternion );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\traycast: function () {},\r\n\t\r\n\t\ttraverse: function ( callback ) {\r\n\t\r\n\t\t\tcallback( this );\r\n\t\r\n\t\t\tvar children = this.children;\r\n\t\r\n\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tchildren[ i ].traverse( callback );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttraverseVisible: function ( callback ) {\r\n\t\r\n\t\t\tif ( this.visible === false ) return;\r\n\t\r\n\t\t\tcallback( this );\r\n\t\r\n\t\t\tvar children = this.children;\r\n\t\r\n\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tchildren[ i ].traverseVisible( callback );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttraverseAncestors: function ( callback ) {\r\n\t\r\n\t\t\tvar parent = this.parent;\r\n\t\r\n\t\t\tif ( parent !== null ) {\r\n\t\r\n\t\t\t\tcallback( parent );\r\n\t\r\n\t\t\t\tparent.traverseAncestors( callback );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tupdateMatrix: function () {\r\n\t\r\n\t\t\tthis.matrix.compose( this.position, this.quaternion, this.scale );\r\n\t\r\n\t\t\tthis.matrixWorldNeedsUpdate = true;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tupdateMatrixWorld: function ( force ) {\r\n\t\r\n\t\t\tif ( this.matrixAutoUpdate === true ) this.updateMatrix();\r\n\t\r\n\t\t\tif ( this.matrixWorldNeedsUpdate === true || force === true ) {\r\n\t\r\n\t\t\t\tif ( this.parent === null ) {\r\n\t\r\n\t\t\t\t\tthis.matrixWorld.copy( this.matrix );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tthis.matrixWorldNeedsUpdate = false;\r\n\t\r\n\t\t\t\tforce = true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// update children\r\n\t\r\n\t\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tthis.children[ i ].updateMatrixWorld( force );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttoJSON: function ( meta ) {\r\n\t\r\n\t\t\t// meta is '' when called from JSON.stringify\r\n\t\t\tvar isRootObject = ( meta === undefined || meta === '' );\r\n\t\r\n\t\t\tvar output = {};\r\n\t\r\n\t\t\t// meta is a hash used to collect geometries, materials.\r\n\t\t\t// not providing it implies that this is the root object\r\n\t\t\t// being serialized.\r\n\t\t\tif ( isRootObject ) {\r\n\t\r\n\t\t\t\t// initialize meta obj\r\n\t\t\t\tmeta = {\r\n\t\t\t\t\tgeometries: {},\r\n\t\t\t\t\tmaterials: {},\r\n\t\t\t\t\ttextures: {},\r\n\t\t\t\t\timages: {}\r\n\t\t\t\t};\r\n\t\r\n\t\t\t\toutput.metadata = {\r\n\t\t\t\t\tversion: 4.4,\r\n\t\t\t\t\ttype: 'Object',\r\n\t\t\t\t\tgenerator: 'Object3D.toJSON'\r\n\t\t\t\t};\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// standard Object3D serialization\r\n\t\r\n\t\t\tvar object = {};\r\n\t\r\n\t\t\tobject.uuid = this.uuid;\r\n\t\t\tobject.type = this.type;\r\n\t\r\n\t\t\tif ( this.name !== '' ) object.name = this.name;\r\n\t\t\tif ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;\r\n\t\t\tif ( this.castShadow === true ) object.castShadow = true;\r\n\t\t\tif ( this.receiveShadow === true ) object.receiveShadow = true;\r\n\t\t\tif ( this.visible === false ) object.visible = false;\r\n\t\r\n\t\t\tobject.matrix = this.matrix.toArray();\r\n\t\r\n\t\t\t//\r\n\t\r\n\t\t\tif ( this.geometry !== undefined ) {\r\n\t\r\n\t\t\t\tif ( meta.geometries[ this.geometry.uuid ] === undefined ) {\r\n\t\r\n\t\t\t\t\tmeta.geometries[ this.geometry.uuid ] = this.geometry.toJSON( meta );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tobject.geometry = this.geometry.uuid;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( this.material !== undefined ) {\r\n\t\r\n\t\t\t\tif ( meta.materials[ this.material.uuid ] === undefined ) {\r\n\t\r\n\t\t\t\t\tmeta.materials[ this.material.uuid ] = this.material.toJSON( meta );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tobject.material = this.material.uuid;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t//\r\n\t\r\n\t\t\tif ( this.children.length > 0 ) {\r\n\t\r\n\t\t\t\tobject.children = [];\r\n\t\r\n\t\t\t\tfor ( var i = 0; i < this.children.length; i ++ ) {\r\n\t\r\n\t\t\t\t\tobject.children.push( this.children[ i ].toJSON( meta ).object );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( isRootObject ) {\r\n\t\r\n\t\t\t\tvar geometries = extractFromCache( meta.geometries );\r\n\t\t\t\tvar materials = extractFromCache( meta.materials );\r\n\t\t\t\tvar textures = extractFromCache( meta.textures );\r\n\t\t\t\tvar images = extractFromCache( meta.images );\r\n\t\r\n\t\t\t\tif ( geometries.length > 0 ) output.geometries = geometries;\r\n\t\t\t\tif ( materials.length > 0 ) output.materials = materials;\r\n\t\t\t\tif ( textures.length > 0 ) output.textures = textures;\r\n\t\t\t\tif ( images.length > 0 ) output.images = images;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\toutput.object = object;\r\n\t\r\n\t\t\treturn output;\r\n\t\r\n\t\t\t// extract data from the cache hash\r\n\t\t\t// remove metadata on each item\r\n\t\t\t// and return as array\r\n\t\t\tfunction extractFromCache ( cache ) {\r\n\t\r\n\t\t\t\tvar values = [];\r\n\t\t\t\tfor ( var key in cache ) {\r\n\t\r\n\t\t\t\t\tvar data = cache[ key ];\r\n\t\t\t\t\tdelete data.metadata;\r\n\t\t\t\t\tvalues.push( data );\r\n\t\r\n\t\t\t\t}\r\n\t\t\t\treturn values;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function ( recursive ) {\r\n\t\r\n\t\t\treturn new this.constructor().copy( this, recursive );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( source, recursive ) {\r\n\t\r\n\t\t\tif ( recursive === undefined ) recursive = true;\r\n\t\r\n\t\t\tthis.name = source.name;\r\n\t\r\n\t\t\tthis.up.copy( source.up );\r\n\t\r\n\t\t\tthis.position.copy( source.position );\r\n\t\t\tthis.quaternion.copy( source.quaternion );\r\n\t\t\tthis.scale.copy( source.scale );\r\n\t\r\n\t\t\tthis.rotationAutoUpdate = source.rotationAutoUpdate;\r\n\t\r\n\t\t\tthis.matrix.copy( source.matrix );\r\n\t\t\tthis.matrixWorld.copy( source.matrixWorld );\r\n\t\r\n\t\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\r\n\t\t\tthis.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;\r\n\t\r\n\t\t\tthis.visible = source.visible;\r\n\t\r\n\t\t\tthis.castShadow = source.castShadow;\r\n\t\t\tthis.receiveShadow = source.receiveShadow;\r\n\t\r\n\t\t\tthis.frustumCulled = source.frustumCulled;\r\n\t\t\tthis.renderOrder = source.renderOrder;\r\n\t\r\n\t\t\tthis.userData = JSON.parse( JSON.stringify( source.userData ) );\r\n\t\r\n\t\t\tif ( recursive === true ) {\r\n\t\r\n\t\t\t\tfor ( var i = 0; i < source.children.length; i ++ ) {\r\n\t\r\n\t\t\t\t\tvar child = source.children[ i ];\r\n\t\t\t\t\tthis.add( child.clone() );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.EventDispatcher.prototype.apply( THREE.Object3D.prototype );\r\n\t\r\n\tTHREE.Object3DIdCount = 0;\r\n\t\r\n\t// File:src/core/Face3.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.Face3 = function ( a, b, c, normal, color, materialIndex ) {\r\n\t\r\n\t\tthis.a = a;\r\n\t\tthis.b = b;\r\n\t\tthis.c = c;\r\n\t\r\n\t\tthis.normal = normal instanceof THREE.Vector3 ? normal : new THREE.Vector3();\r\n\t\tthis.vertexNormals = Array.isArray( normal ) ? normal : [];\r\n\t\r\n\t\tthis.color = color instanceof THREE.Color ? color : new THREE.Color();\r\n\t\tthis.vertexColors = Array.isArray( color ) ? color : [];\r\n\t\r\n\t\tthis.materialIndex = materialIndex !== undefined ? materialIndex : 0;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Face3.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Face3,\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new this.constructor().copy( this );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( source ) {\r\n\t\r\n\t\t\tthis.a = source.a;\r\n\t\t\tthis.b = source.b;\r\n\t\t\tthis.c = source.c;\r\n\t\r\n\t\t\tthis.normal.copy( source.normal );\r\n\t\t\tthis.color.copy( source.color );\r\n\t\r\n\t\t\tthis.materialIndex = source.materialIndex;\r\n\t\r\n\t\t\tfor ( var i = 0, il = source.vertexNormals.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tthis.vertexNormals[ i ] = source.vertexNormals[ i ].clone();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( var i = 0, il = source.vertexColors.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tthis.vertexColors[ i ] = source.vertexColors[ i ].clone();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/core/BufferAttribute.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.BufferAttribute = function ( array, itemSize, normalized ) {\r\n\t\r\n\t\tthis.uuid = THREE.Math.generateUUID();\r\n\t\r\n\t\tthis.array = array;\r\n\t\tthis.itemSize = itemSize;\r\n\t\r\n\t\tthis.dynamic = false;\r\n\t\tthis.updateRange = { offset: 0, count: - 1 };\r\n\t\r\n\t\tthis.version = 0;\r\n\t\tthis.normalized = normalized === true;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.BufferAttribute.prototype = {\r\n\t\r\n\t\tconstructor: THREE.BufferAttribute,\r\n\t\r\n\t\tget count() {\r\n\t\r\n\t\t\treturn this.array.length / this.itemSize;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tset needsUpdate( value ) {\r\n\t\r\n\t\t\tif ( value === true ) this.version ++;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetDynamic: function ( value ) {\r\n\t\r\n\t\t\tthis.dynamic = value;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( source ) {\r\n\t\r\n\t\t\tthis.array = new source.array.constructor( source.array );\r\n\t\t\tthis.itemSize = source.itemSize;\r\n\t\r\n\t\t\tthis.dynamic = source.dynamic;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopyAt: function ( index1, attribute, index2 ) {\r\n\t\r\n\t\t\tindex1 *= this.itemSize;\r\n\t\t\tindex2 *= attribute.itemSize;\r\n\t\r\n\t\t\tfor ( var i = 0, l = this.itemSize; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tthis.array[ index1 + i ] = attribute.array[ index2 + i ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopyArray: function ( array ) {\r\n\t\r\n\t\t\tthis.array.set( array );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopyColorsArray: function ( colors ) {\r\n\t\r\n\t\t\tvar array = this.array, offset = 0;\r\n\t\r\n\t\t\tfor ( var i = 0, l = colors.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tvar color = colors[ i ];\r\n\t\r\n\t\t\t\tif ( color === undefined ) {\r\n\t\r\n\t\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );\r\n\t\t\t\t\tcolor = new THREE.Color();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tarray[ offset ++ ] = color.r;\r\n\t\t\t\tarray[ offset ++ ] = color.g;\r\n\t\t\t\tarray[ offset ++ ] = color.b;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopyIndicesArray: function ( indices ) {\r\n\t\r\n\t\t\tvar array = this.array, offset = 0;\r\n\t\r\n\t\t\tfor ( var i = 0, l = indices.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tvar index = indices[ i ];\r\n\t\r\n\t\t\t\tarray[ offset ++ ] = index.a;\r\n\t\t\t\tarray[ offset ++ ] = index.b;\r\n\t\t\t\tarray[ offset ++ ] = index.c;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopyVector2sArray: function ( vectors ) {\r\n\t\r\n\t\t\tvar array = this.array, offset = 0;\r\n\t\r\n\t\t\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tvar vector = vectors[ i ];\r\n\t\r\n\t\t\t\tif ( vector === undefined ) {\r\n\t\r\n\t\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );\r\n\t\t\t\t\tvector = new THREE.Vector2();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tarray[ offset ++ ] = vector.x;\r\n\t\t\t\tarray[ offset ++ ] = vector.y;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopyVector3sArray: function ( vectors ) {\r\n\t\r\n\t\t\tvar array = this.array, offset = 0;\r\n\t\r\n\t\t\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tvar vector = vectors[ i ];\r\n\t\r\n\t\t\t\tif ( vector === undefined ) {\r\n\t\r\n\t\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );\r\n\t\t\t\t\tvector = new THREE.Vector3();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tarray[ offset ++ ] = vector.x;\r\n\t\t\t\tarray[ offset ++ ] = vector.y;\r\n\t\t\t\tarray[ offset ++ ] = vector.z;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopyVector4sArray: function ( vectors ) {\r\n\t\r\n\t\t\tvar array = this.array, offset = 0;\r\n\t\r\n\t\t\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tvar vector = vectors[ i ];\r\n\t\r\n\t\t\t\tif ( vector === undefined ) {\r\n\t\r\n\t\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );\r\n\t\t\t\t\tvector = new THREE.Vector4();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tarray[ offset ++ ] = vector.x;\r\n\t\t\t\tarray[ offset ++ ] = vector.y;\r\n\t\t\t\tarray[ offset ++ ] = vector.z;\r\n\t\t\t\tarray[ offset ++ ] = vector.w;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tset: function ( value, offset ) {\r\n\t\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\r\n\t\t\tthis.array.set( value, offset );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetX: function ( index ) {\r\n\t\r\n\t\t\treturn this.array[ index * this.itemSize ];\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetX: function ( index, x ) {\r\n\t\r\n\t\t\tthis.array[ index * this.itemSize ] = x;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetY: function ( index ) {\r\n\t\r\n\t\t\treturn this.array[ index * this.itemSize + 1 ];\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetY: function ( index, y ) {\r\n\t\r\n\t\t\tthis.array[ index * this.itemSize + 1 ] = y;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetZ: function ( index ) {\r\n\t\r\n\t\t\treturn this.array[ index * this.itemSize + 2 ];\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetZ: function ( index, z ) {\r\n\t\r\n\t\t\tthis.array[ index * this.itemSize + 2 ] = z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetW: function ( index ) {\r\n\t\r\n\t\t\treturn this.array[ index * this.itemSize + 3 ];\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetW: function ( index, w ) {\r\n\t\r\n\t\t\tthis.array[ index * this.itemSize + 3 ] = w;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetXY: function ( index, x, y ) {\r\n\t\r\n\t\t\tindex *= this.itemSize;\r\n\t\r\n\t\t\tthis.array[ index + 0 ] = x;\r\n\t\t\tthis.array[ index + 1 ] = y;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetXYZ: function ( index, x, y, z ) {\r\n\t\r\n\t\t\tindex *= this.itemSize;\r\n\t\r\n\t\t\tthis.array[ index + 0 ] = x;\r\n\t\t\tthis.array[ index + 1 ] = y;\r\n\t\t\tthis.array[ index + 2 ] = z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetXYZW: function ( index, x, y, z, w ) {\r\n\t\r\n\t\t\tindex *= this.itemSize;\r\n\t\r\n\t\t\tthis.array[ index + 0 ] = x;\r\n\t\t\tthis.array[ index + 1 ] = y;\r\n\t\t\tthis.array[ index + 2 ] = z;\r\n\t\t\tthis.array[ index + 3 ] = w;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new this.constructor().copy( this );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t//\r\n\t\r\n\tTHREE.Int8Attribute = function ( array, itemSize ) {\r\n\t\r\n\t\treturn new THREE.BufferAttribute( new Int8Array( array ), itemSize );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Uint8Attribute = function ( array, itemSize ) {\r\n\t\r\n\t\treturn new THREE.BufferAttribute( new Uint8Array( array ), itemSize );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Uint8ClampedAttribute = function ( array, itemSize ) {\r\n\t\r\n\t\treturn new THREE.BufferAttribute( new Uint8ClampedArray( array ), itemSize );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Int16Attribute = function ( array, itemSize ) {\r\n\t\r\n\t\treturn new THREE.BufferAttribute( new Int16Array( array ), itemSize );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Uint16Attribute = function ( array, itemSize ) {\r\n\t\r\n\t\treturn new THREE.BufferAttribute( new Uint16Array( array ), itemSize );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Int32Attribute = function ( array, itemSize ) {\r\n\t\r\n\t\treturn new THREE.BufferAttribute( new Int32Array( array ), itemSize );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Uint32Attribute = function ( array, itemSize ) {\r\n\t\r\n\t\treturn new THREE.BufferAttribute( new Uint32Array( array ), itemSize );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Float32Attribute = function ( array, itemSize ) {\r\n\t\r\n\t\treturn new THREE.BufferAttribute( new Float32Array( array ), itemSize );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Float64Attribute = function ( array, itemSize ) {\r\n\t\r\n\t\treturn new THREE.BufferAttribute( new Float64Array( array ), itemSize );\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\t// Deprecated\r\n\t\r\n\tTHREE.DynamicBufferAttribute = function ( array, itemSize ) {\r\n\t\r\n\t\tconsole.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.' );\r\n\t\treturn new THREE.BufferAttribute( array, itemSize ).setDynamic( true );\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/core/InstancedBufferAttribute.js\r\n\t\r\n\t/**\r\n\t * @author benaadams / https://twitter.com/ben_a_adams\r\n\t */\r\n\t\r\n\tTHREE.InstancedBufferAttribute = function ( array, itemSize, meshPerAttribute ) {\r\n\t\r\n\t\tTHREE.BufferAttribute.call( this, array, itemSize );\r\n\t\r\n\t\tthis.meshPerAttribute = meshPerAttribute || 1;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.InstancedBufferAttribute.prototype = Object.create( THREE.BufferAttribute.prototype );\r\n\tTHREE.InstancedBufferAttribute.prototype.constructor = THREE.InstancedBufferAttribute;\r\n\t\r\n\tTHREE.InstancedBufferAttribute.prototype.copy = function ( source ) {\r\n\t\r\n\t\tTHREE.BufferAttribute.prototype.copy.call( this, source );\r\n\t\r\n\t\tthis.meshPerAttribute = source.meshPerAttribute;\r\n\t\r\n\t\treturn this;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/core/InterleavedBuffer.js\r\n\t\r\n\t/**\r\n\t * @author benaadams / https://twitter.com/ben_a_adams\r\n\t */\r\n\t\r\n\tTHREE.InterleavedBuffer = function ( array, stride ) {\r\n\t\r\n\t\tthis.uuid = THREE.Math.generateUUID();\r\n\t\r\n\t\tthis.array = array;\r\n\t\tthis.stride = stride;\r\n\t\r\n\t\tthis.dynamic = false;\r\n\t\tthis.updateRange = { offset: 0, count: - 1 };\r\n\t\r\n\t\tthis.version = 0;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.InterleavedBuffer.prototype = {\r\n\t\r\n\t\tconstructor: THREE.InterleavedBuffer,\r\n\t\r\n\t\tget length () {\r\n\t\r\n\t\t\treturn this.array.length;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tget count () {\r\n\t\r\n\t\t\treturn this.array.length / this.stride;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tset needsUpdate( value ) {\r\n\t\r\n\t\t\tif ( value === true ) this.version ++;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetDynamic: function ( value ) {\r\n\t\r\n\t\t\tthis.dynamic = value;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( source ) {\r\n\t\r\n\t\t\tthis.array = new source.array.constructor( source.array );\r\n\t\t\tthis.stride = source.stride;\r\n\t\t\tthis.dynamic = source.dynamic;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopyAt: function ( index1, attribute, index2 ) {\r\n\t\r\n\t\t\tindex1 *= this.stride;\r\n\t\t\tindex2 *= attribute.stride;\r\n\t\r\n\t\t\tfor ( var i = 0, l = this.stride; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tthis.array[ index1 + i ] = attribute.array[ index2 + i ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tset: function ( value, offset ) {\r\n\t\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\r\n\t\t\tthis.array.set( value, offset );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new this.constructor().copy( this );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/core/InstancedInterleavedBuffer.js\r\n\t\r\n\t/**\r\n\t * @author benaadams / https://twitter.com/ben_a_adams\r\n\t */\r\n\t\r\n\tTHREE.InstancedInterleavedBuffer = function ( array, stride, meshPerAttribute ) {\r\n\t\r\n\t\tTHREE.InterleavedBuffer.call( this, array, stride );\r\n\t\r\n\t\tthis.meshPerAttribute = meshPerAttribute || 1;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.InstancedInterleavedBuffer.prototype = Object.create( THREE.InterleavedBuffer.prototype );\r\n\tTHREE.InstancedInterleavedBuffer.prototype.constructor = THREE.InstancedInterleavedBuffer;\r\n\t\r\n\tTHREE.InstancedInterleavedBuffer.prototype.copy = function ( source ) {\r\n\t\r\n\t\tTHREE.InterleavedBuffer.prototype.copy.call( this, source );\r\n\t\r\n\t\tthis.meshPerAttribute = source.meshPerAttribute;\r\n\t\r\n\t\treturn this;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/core/InterleavedBufferAttribute.js\r\n\t\r\n\t/**\r\n\t * @author benaadams / https://twitter.com/ben_a_adams\r\n\t */\r\n\t\r\n\tTHREE.InterleavedBufferAttribute = function ( interleavedBuffer, itemSize, offset ) {\r\n\t\r\n\t\tthis.uuid = THREE.Math.generateUUID();\r\n\t\r\n\t\tthis.data = interleavedBuffer;\r\n\t\tthis.itemSize = itemSize;\r\n\t\tthis.offset = offset;\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\tTHREE.InterleavedBufferAttribute.prototype = {\r\n\t\r\n\t\tconstructor: THREE.InterleavedBufferAttribute,\r\n\t\r\n\t\tget length() {\r\n\t\r\n\t\t\tconsole.warn( 'THREE.BufferAttribute: .length has been deprecated. Please use .count.' );\r\n\t\t\treturn this.array.length;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tget count() {\r\n\t\r\n\t\t\treturn this.data.count;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetX: function ( index, x ) {\r\n\t\r\n\t\t\tthis.data.array[ index * this.data.stride + this.offset ] = x;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetY: function ( index, y ) {\r\n\t\r\n\t\t\tthis.data.array[ index * this.data.stride + this.offset + 1 ] = y;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetZ: function ( index, z ) {\r\n\t\r\n\t\t\tthis.data.array[ index * this.data.stride + this.offset + 2 ] = z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetW: function ( index, w ) {\r\n\t\r\n\t\t\tthis.data.array[ index * this.data.stride + this.offset + 3 ] = w;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetX: function ( index ) {\r\n\t\r\n\t\t\treturn this.data.array[ index * this.data.stride + this.offset ];\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetY: function ( index ) {\r\n\t\r\n\t\t\treturn this.data.array[ index * this.data.stride + this.offset + 1 ];\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetZ: function ( index ) {\r\n\t\r\n\t\t\treturn this.data.array[ index * this.data.stride + this.offset + 2 ];\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetW: function ( index ) {\r\n\t\r\n\t\t\treturn this.data.array[ index * this.data.stride + this.offset + 3 ];\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetXY: function ( index, x, y ) {\r\n\t\r\n\t\t\tindex = index * this.data.stride + this.offset;\r\n\t\r\n\t\t\tthis.data.array[ index + 0 ] = x;\r\n\t\t\tthis.data.array[ index + 1 ] = y;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetXYZ: function ( index, x, y, z ) {\r\n\t\r\n\t\t\tindex = index * this.data.stride + this.offset;\r\n\t\r\n\t\t\tthis.data.array[ index + 0 ] = x;\r\n\t\t\tthis.data.array[ index + 1 ] = y;\r\n\t\t\tthis.data.array[ index + 2 ] = z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetXYZW: function ( index, x, y, z, w ) {\r\n\t\r\n\t\t\tindex = index * this.data.stride + this.offset;\r\n\t\r\n\t\t\tthis.data.array[ index + 0 ] = x;\r\n\t\t\tthis.data.array[ index + 1 ] = y;\r\n\t\t\tthis.data.array[ index + 2 ] = z;\r\n\t\t\tthis.data.array[ index + 3 ] = w;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/core/Geometry.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author kile / http://kile.stravaganza.org/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\r\n\t * @author bhouston / http://clara.io\r\n\t */\r\n\t\r\n\tTHREE.Geometry = function () {\r\n\t\r\n\t\tObject.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );\r\n\t\r\n\t\tthis.uuid = THREE.Math.generateUUID();\r\n\t\r\n\t\tthis.name = '';\r\n\t\tthis.type = 'Geometry';\r\n\t\r\n\t\tthis.vertices = [];\r\n\t\tthis.colors = [];\r\n\t\tthis.faces = [];\r\n\t\tthis.faceVertexUvs = [ [] ];\r\n\t\r\n\t\tthis.morphTargets = [];\r\n\t\tthis.morphNormals = [];\r\n\t\r\n\t\tthis.skinWeights = [];\r\n\t\tthis.skinIndices = [];\r\n\t\r\n\t\tthis.lineDistances = [];\r\n\t\r\n\t\tthis.boundingBox = null;\r\n\t\tthis.boundingSphere = null;\r\n\t\r\n\t\t// update flags\r\n\t\r\n\t\tthis.verticesNeedUpdate = false;\r\n\t\tthis.elementsNeedUpdate = false;\r\n\t\tthis.uvsNeedUpdate = false;\r\n\t\tthis.normalsNeedUpdate = false;\r\n\t\tthis.colorsNeedUpdate = false;\r\n\t\tthis.lineDistancesNeedUpdate = false;\r\n\t\tthis.groupsNeedUpdate = false;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Geometry.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Geometry,\r\n\t\r\n\t\tapplyMatrix: function ( matrix ) {\r\n\t\r\n\t\t\tvar normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );\r\n\t\r\n\t\t\tfor ( var i = 0, il = this.vertices.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tvar vertex = this.vertices[ i ];\r\n\t\t\t\tvertex.applyMatrix4( matrix );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( var i = 0, il = this.faces.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tvar face = this.faces[ i ];\r\n\t\t\t\tface.normal.applyMatrix3( normalMatrix ).normalize();\r\n\t\r\n\t\t\t\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\r\n\t\r\n\t\t\t\t\tface.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( this.boundingBox !== null ) {\r\n\t\r\n\t\t\t\tthis.computeBoundingBox();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( this.boundingSphere !== null ) {\r\n\t\r\n\t\t\t\tthis.computeBoundingSphere();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.verticesNeedUpdate = true;\r\n\t\t\tthis.normalsNeedUpdate = true;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\trotateX: function () {\r\n\t\r\n\t\t\t// rotate geometry around world x-axis\r\n\t\r\n\t\t\tvar m1;\r\n\t\r\n\t\t\treturn function rotateX( angle ) {\r\n\t\r\n\t\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\r\n\t\r\n\t\t\t\tm1.makeRotationX( angle );\r\n\t\r\n\t\t\t\tthis.applyMatrix( m1 );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\trotateY: function () {\r\n\t\r\n\t\t\t// rotate geometry around world y-axis\r\n\t\r\n\t\t\tvar m1;\r\n\t\r\n\t\t\treturn function rotateY( angle ) {\r\n\t\r\n\t\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\r\n\t\r\n\t\t\t\tm1.makeRotationY( angle );\r\n\t\r\n\t\t\t\tthis.applyMatrix( m1 );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\trotateZ: function () {\r\n\t\r\n\t\t\t// rotate geometry around world z-axis\r\n\t\r\n\t\t\tvar m1;\r\n\t\r\n\t\t\treturn function rotateZ( angle ) {\r\n\t\r\n\t\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\r\n\t\r\n\t\t\t\tm1.makeRotationZ( angle );\r\n\t\r\n\t\t\t\tthis.applyMatrix( m1 );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\ttranslate: function () {\r\n\t\r\n\t\t\t// translate geometry\r\n\t\r\n\t\t\tvar m1;\r\n\t\r\n\t\t\treturn function translate( x, y, z ) {\r\n\t\r\n\t\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\r\n\t\r\n\t\t\t\tm1.makeTranslation( x, y, z );\r\n\t\r\n\t\t\t\tthis.applyMatrix( m1 );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tscale: function () {\r\n\t\r\n\t\t\t// scale geometry\r\n\t\r\n\t\t\tvar m1;\r\n\t\r\n\t\t\treturn function scale( x, y, z ) {\r\n\t\r\n\t\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\r\n\t\r\n\t\t\t\tm1.makeScale( x, y, z );\r\n\t\r\n\t\t\t\tthis.applyMatrix( m1 );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tlookAt: function () {\r\n\t\r\n\t\t\tvar obj;\r\n\t\r\n\t\t\treturn function lookAt( vector ) {\r\n\t\r\n\t\t\t\tif ( obj === undefined ) obj = new THREE.Object3D();\r\n\t\r\n\t\t\t\tobj.lookAt( vector );\r\n\t\r\n\t\t\t\tobj.updateMatrix();\r\n\t\r\n\t\t\t\tthis.applyMatrix( obj.matrix );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tfromBufferGeometry: function ( geometry ) {\r\n\t\r\n\t\t\tvar scope = this;\r\n\t\r\n\t\t\tvar indices = geometry.index !== null ? geometry.index.array : undefined;\r\n\t\t\tvar attributes = geometry.attributes;\r\n\t\r\n\t\t\tvar positions = attributes.position.array;\r\n\t\t\tvar normals = attributes.normal !== undefined ? attributes.normal.array : undefined;\r\n\t\t\tvar colors = attributes.color !== undefined ? attributes.color.array : undefined;\r\n\t\t\tvar uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;\r\n\t\t\tvar uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;\r\n\t\r\n\t\t\tif ( uvs2 !== undefined ) this.faceVertexUvs[ 1 ] = [];\r\n\t\r\n\t\t\tvar tempNormals = [];\r\n\t\t\tvar tempUVs = [];\r\n\t\t\tvar tempUVs2 = [];\r\n\t\r\n\t\t\tfor ( var i = 0, j = 0; i < positions.length; i += 3, j += 2 ) {\r\n\t\r\n\t\t\t\tscope.vertices.push( new THREE.Vector3( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] ) );\r\n\t\r\n\t\t\t\tif ( normals !== undefined ) {\r\n\t\r\n\t\t\t\t\ttempNormals.push( new THREE.Vector3( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( colors !== undefined ) {\r\n\t\r\n\t\t\t\t\tscope.colors.push( new THREE.Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( uvs !== undefined ) {\r\n\t\r\n\t\t\t\t\ttempUVs.push( new THREE.Vector2( uvs[ j ], uvs[ j + 1 ] ) );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( uvs2 !== undefined ) {\r\n\t\r\n\t\t\t\t\ttempUVs2.push( new THREE.Vector2( uvs2[ j ], uvs2[ j + 1 ] ) );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfunction addFace( a, b, c, materialIndex ) {\r\n\t\r\n\t\t\t\tvar vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];\r\n\t\t\t\tvar vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];\r\n\t\r\n\t\t\t\tvar face = new THREE.Face3( a, b, c, vertexNormals, vertexColors, materialIndex );\r\n\t\r\n\t\t\t\tscope.faces.push( face );\r\n\t\r\n\t\t\t\tif ( uvs !== undefined ) {\r\n\t\r\n\t\t\t\t\tscope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ].clone(), tempUVs[ b ].clone(), tempUVs[ c ].clone() ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( uvs2 !== undefined ) {\r\n\t\r\n\t\t\t\t\tscope.faceVertexUvs[ 1 ].push( [ tempUVs2[ a ].clone(), tempUVs2[ b ].clone(), tempUVs2[ c ].clone() ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( indices !== undefined ) {\r\n\t\r\n\t\t\t\tvar groups = geometry.groups;\r\n\t\r\n\t\t\t\tif ( groups.length > 0 ) {\r\n\t\r\n\t\t\t\t\tfor ( var i = 0; i < groups.length; i ++ ) {\r\n\t\r\n\t\t\t\t\t\tvar group = groups[ i ];\r\n\t\r\n\t\t\t\t\t\tvar start = group.start;\r\n\t\t\t\t\t\tvar count = group.count;\r\n\t\r\n\t\t\t\t\t\tfor ( var j = start, jl = start + count; j < jl; j += 3 ) {\r\n\t\r\n\t\t\t\t\t\t\taddFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ], group.materialIndex  );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tfor ( var i = 0; i < indices.length; i += 3 ) {\r\n\t\r\n\t\t\t\t\t\taddFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tfor ( var i = 0; i < positions.length / 3; i += 3 ) {\r\n\t\r\n\t\t\t\t\taddFace( i, i + 1, i + 2 );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.computeFaceNormals();\r\n\t\r\n\t\t\tif ( geometry.boundingBox !== null ) {\r\n\t\r\n\t\t\t\tthis.boundingBox = geometry.boundingBox.clone();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( geometry.boundingSphere !== null ) {\r\n\t\r\n\t\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcenter: function () {\r\n\t\r\n\t\t\tthis.computeBoundingBox();\r\n\t\r\n\t\t\tvar offset = this.boundingBox.center().negate();\r\n\t\r\n\t\t\tthis.translate( offset.x, offset.y, offset.z );\r\n\t\r\n\t\t\treturn offset;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tnormalize: function () {\r\n\t\r\n\t\t\tthis.computeBoundingSphere();\r\n\t\r\n\t\t\tvar center = this.boundingSphere.center;\r\n\t\t\tvar radius = this.boundingSphere.radius;\r\n\t\r\n\t\t\tvar s = radius === 0 ? 1 : 1.0 / radius;\r\n\t\r\n\t\t\tvar matrix = new THREE.Matrix4();\r\n\t\t\tmatrix.set(\r\n\t\t\t\ts, 0, 0, - s * center.x,\r\n\t\t\t\t0, s, 0, - s * center.y,\r\n\t\t\t\t0, 0, s, - s * center.z,\r\n\t\t\t\t0, 0, 0, 1\r\n\t\t\t);\r\n\t\r\n\t\t\tthis.applyMatrix( matrix );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcomputeFaceNormals: function () {\r\n\t\r\n\t\t\tvar cb = new THREE.Vector3(), ab = new THREE.Vector3();\r\n\t\r\n\t\t\tfor ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\tvar face = this.faces[ f ];\r\n\t\r\n\t\t\t\tvar vA = this.vertices[ face.a ];\r\n\t\t\t\tvar vB = this.vertices[ face.b ];\r\n\t\t\t\tvar vC = this.vertices[ face.c ];\r\n\t\r\n\t\t\t\tcb.subVectors( vC, vB );\r\n\t\t\t\tab.subVectors( vA, vB );\r\n\t\t\t\tcb.cross( ab );\r\n\t\r\n\t\t\t\tcb.normalize();\r\n\t\r\n\t\t\t\tface.normal.copy( cb );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcomputeVertexNormals: function ( areaWeighted ) {\r\n\t\r\n\t\t\tif ( areaWeighted === undefined ) areaWeighted = true;\r\n\t\r\n\t\t\tvar v, vl, f, fl, face, vertices;\r\n\t\r\n\t\t\tvertices = new Array( this.vertices.length );\r\n\t\r\n\t\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\r\n\t\r\n\t\t\t\tvertices[ v ] = new THREE.Vector3();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( areaWeighted ) {\r\n\t\r\n\t\t\t\t// vertex normals weighted by triangle areas\r\n\t\t\t\t// http://www.iquilezles.org/www/articles/normals/normals.htm\r\n\t\r\n\t\t\t\tvar vA, vB, vC;\r\n\t\t\t\tvar cb = new THREE.Vector3(), ab = new THREE.Vector3();\r\n\t\r\n\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\t\tface = this.faces[ f ];\r\n\t\r\n\t\t\t\t\tvA = this.vertices[ face.a ];\r\n\t\t\t\t\tvB = this.vertices[ face.b ];\r\n\t\t\t\t\tvC = this.vertices[ face.c ];\r\n\t\r\n\t\t\t\t\tcb.subVectors( vC, vB );\r\n\t\t\t\t\tab.subVectors( vA, vB );\r\n\t\t\t\t\tcb.cross( ab );\r\n\t\r\n\t\t\t\t\tvertices[ face.a ].add( cb );\r\n\t\t\t\t\tvertices[ face.b ].add( cb );\r\n\t\t\t\t\tvertices[ face.c ].add( cb );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\t\tface = this.faces[ f ];\r\n\t\r\n\t\t\t\t\tvertices[ face.a ].add( face.normal );\r\n\t\t\t\t\tvertices[ face.b ].add( face.normal );\r\n\t\t\t\t\tvertices[ face.c ].add( face.normal );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\r\n\t\r\n\t\t\t\tvertices[ v ].normalize();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\tface = this.faces[ f ];\r\n\t\r\n\t\t\t\tvar vertexNormals = face.vertexNormals;\r\n\t\r\n\t\t\t\tif ( vertexNormals.length === 3 ) {\r\n\t\r\n\t\t\t\t\tvertexNormals[ 0 ].copy( vertices[ face.a ] );\r\n\t\t\t\t\tvertexNormals[ 1 ].copy( vertices[ face.b ] );\r\n\t\t\t\t\tvertexNormals[ 2 ].copy( vertices[ face.c ] );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tvertexNormals[ 0 ] = vertices[ face.a ].clone();\r\n\t\t\t\t\tvertexNormals[ 1 ] = vertices[ face.b ].clone();\r\n\t\t\t\t\tvertexNormals[ 2 ] = vertices[ face.c ].clone();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( this.faces.length > 0 ) {\r\n\t\r\n\t\t\t\tthis.normalsNeedUpdate = true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcomputeMorphNormals: function () {\r\n\t\r\n\t\t\tvar i, il, f, fl, face;\r\n\t\r\n\t\t\t// save original normals\r\n\t\t\t// - create temp variables on first access\r\n\t\t\t//   otherwise just copy (for faster repeated calls)\r\n\t\r\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\tface = this.faces[ f ];\r\n\t\r\n\t\t\t\tif ( ! face.__originalFaceNormal ) {\r\n\t\r\n\t\t\t\t\tface.__originalFaceNormal = face.normal.clone();\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tface.__originalFaceNormal.copy( face.normal );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];\r\n\t\r\n\t\t\t\tfor ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\tif ( ! face.__originalVertexNormals[ i ] ) {\r\n\t\r\n\t\t\t\t\t\tface.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tface.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// use temp geometry to compute face and vertex normals for each morph\r\n\t\r\n\t\t\tvar tmpGeo = new THREE.Geometry();\r\n\t\t\ttmpGeo.faces = this.faces;\r\n\t\r\n\t\t\tfor ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t// create on first access\r\n\t\r\n\t\t\t\tif ( ! this.morphNormals[ i ] ) {\r\n\t\r\n\t\t\t\t\tthis.morphNormals[ i ] = {};\r\n\t\t\t\t\tthis.morphNormals[ i ].faceNormals = [];\r\n\t\t\t\t\tthis.morphNormals[ i ].vertexNormals = [];\r\n\t\r\n\t\t\t\t\tvar dstNormalsFace = this.morphNormals[ i ].faceNormals;\r\n\t\t\t\t\tvar dstNormalsVertex = this.morphNormals[ i ].vertexNormals;\r\n\t\r\n\t\t\t\t\tvar faceNormal, vertexNormals;\r\n\t\r\n\t\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\t\t\tfaceNormal = new THREE.Vector3();\r\n\t\t\t\t\t\tvertexNormals = { a: new THREE.Vector3(), b: new THREE.Vector3(), c: new THREE.Vector3() };\r\n\t\r\n\t\t\t\t\t\tdstNormalsFace.push( faceNormal );\r\n\t\t\t\t\t\tdstNormalsVertex.push( vertexNormals );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar morphNormals = this.morphNormals[ i ];\r\n\t\r\n\t\t\t\t// set vertices to morph target\r\n\t\r\n\t\t\t\ttmpGeo.vertices = this.morphTargets[ i ].vertices;\r\n\t\r\n\t\t\t\t// compute morph normals\r\n\t\r\n\t\t\t\ttmpGeo.computeFaceNormals();\r\n\t\t\t\ttmpGeo.computeVertexNormals();\r\n\t\r\n\t\t\t\t// store morph normals\r\n\t\r\n\t\t\t\tvar faceNormal, vertexNormals;\r\n\t\r\n\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\t\tface = this.faces[ f ];\r\n\t\r\n\t\t\t\t\tfaceNormal = morphNormals.faceNormals[ f ];\r\n\t\t\t\t\tvertexNormals = morphNormals.vertexNormals[ f ];\r\n\t\r\n\t\t\t\t\tfaceNormal.copy( face.normal );\r\n\t\r\n\t\t\t\t\tvertexNormals.a.copy( face.vertexNormals[ 0 ] );\r\n\t\t\t\t\tvertexNormals.b.copy( face.vertexNormals[ 1 ] );\r\n\t\t\t\t\tvertexNormals.c.copy( face.vertexNormals[ 2 ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// restore original normals\r\n\t\r\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\tface = this.faces[ f ];\r\n\t\r\n\t\t\t\tface.normal = face.__originalFaceNormal;\r\n\t\t\t\tface.vertexNormals = face.__originalVertexNormals;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcomputeTangents: function () {\r\n\t\r\n\t\t\tconsole.warn( 'THREE.Geometry: .computeTangents() has been removed.' );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcomputeLineDistances: function () {\r\n\t\r\n\t\t\tvar d = 0;\r\n\t\t\tvar vertices = this.vertices;\r\n\t\r\n\t\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tif ( i > 0 ) {\r\n\t\r\n\t\t\t\t\td += vertices[ i ].distanceTo( vertices[ i - 1 ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tthis.lineDistances[ i ] = d;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcomputeBoundingBox: function () {\r\n\t\r\n\t\t\tif ( this.boundingBox === null ) {\r\n\t\r\n\t\t\t\tthis.boundingBox = new THREE.Box3();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.boundingBox.setFromPoints( this.vertices );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcomputeBoundingSphere: function () {\r\n\t\r\n\t\t\tif ( this.boundingSphere === null ) {\r\n\t\r\n\t\t\t\tthis.boundingSphere = new THREE.Sphere();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.boundingSphere.setFromPoints( this.vertices );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmerge: function ( geometry, matrix, materialIndexOffset ) {\r\n\t\r\n\t\t\tif ( geometry instanceof THREE.Geometry === false ) {\r\n\t\r\n\t\t\t\tconsole.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );\r\n\t\t\t\treturn;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar normalMatrix,\r\n\t\t\tvertexOffset = this.vertices.length,\r\n\t\t\tvertices1 = this.vertices,\r\n\t\t\tvertices2 = geometry.vertices,\r\n\t\t\tfaces1 = this.faces,\r\n\t\t\tfaces2 = geometry.faces,\r\n\t\t\tuvs1 = this.faceVertexUvs[ 0 ],\r\n\t\t\tuvs2 = geometry.faceVertexUvs[ 0 ];\r\n\t\r\n\t\t\tif ( materialIndexOffset === undefined ) materialIndexOffset = 0;\r\n\t\r\n\t\t\tif ( matrix !== undefined ) {\r\n\t\r\n\t\t\t\tnormalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// vertices\r\n\t\r\n\t\t\tfor ( var i = 0, il = vertices2.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tvar vertex = vertices2[ i ];\r\n\t\r\n\t\t\t\tvar vertexCopy = vertex.clone();\r\n\t\r\n\t\t\t\tif ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );\r\n\t\r\n\t\t\t\tvertices1.push( vertexCopy );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// faces\r\n\t\r\n\t\t\tfor ( i = 0, il = faces2.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tvar face = faces2[ i ], faceCopy, normal, color,\r\n\t\t\t\tfaceVertexNormals = face.vertexNormals,\r\n\t\t\t\tfaceVertexColors = face.vertexColors;\r\n\t\r\n\t\t\t\tfaceCopy = new THREE.Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );\r\n\t\t\t\tfaceCopy.normal.copy( face.normal );\r\n\t\r\n\t\t\t\tif ( normalMatrix !== undefined ) {\r\n\t\r\n\t\t\t\t\tfaceCopy.normal.applyMatrix3( normalMatrix ).normalize();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tfor ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {\r\n\t\r\n\t\t\t\t\tnormal = faceVertexNormals[ j ].clone();\r\n\t\r\n\t\t\t\t\tif ( normalMatrix !== undefined ) {\r\n\t\r\n\t\t\t\t\t\tnormal.applyMatrix3( normalMatrix ).normalize();\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tfaceCopy.vertexNormals.push( normal );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tfaceCopy.color.copy( face.color );\r\n\t\r\n\t\t\t\tfor ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {\r\n\t\r\n\t\t\t\t\tcolor = faceVertexColors[ j ];\r\n\t\t\t\t\tfaceCopy.vertexColors.push( color.clone() );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tfaceCopy.materialIndex = face.materialIndex + materialIndexOffset;\r\n\t\r\n\t\t\t\tfaces1.push( faceCopy );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// uvs\r\n\t\r\n\t\t\tfor ( i = 0, il = uvs2.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tvar uv = uvs2[ i ], uvCopy = [];\r\n\t\r\n\t\t\t\tif ( uv === undefined ) {\r\n\t\r\n\t\t\t\t\tcontinue;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tfor ( var j = 0, jl = uv.length; j < jl; j ++ ) {\r\n\t\r\n\t\t\t\t\tuvCopy.push( uv[ j ].clone() );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tuvs1.push( uvCopy );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmergeMesh: function ( mesh ) {\r\n\t\r\n\t\t\tif ( mesh instanceof THREE.Mesh === false ) {\r\n\t\r\n\t\t\t\tconsole.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );\r\n\t\t\t\treturn;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tmesh.matrixAutoUpdate && mesh.updateMatrix();\r\n\t\r\n\t\t\tthis.merge( mesh.geometry, mesh.matrix );\r\n\t\r\n\t\t},\r\n\t\r\n\t\t/*\r\n\t\t * Checks for duplicate vertices with hashmap.\r\n\t\t * Duplicated vertices are removed\r\n\t\t * and faces' vertices are updated.\r\n\t\t */\r\n\t\r\n\t\tmergeVertices: function () {\r\n\t\r\n\t\t\tvar verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)\r\n\t\t\tvar unique = [], changes = [];\r\n\t\r\n\t\t\tvar v, key;\r\n\t\t\tvar precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001\r\n\t\t\tvar precision = Math.pow( 10, precisionPoints );\r\n\t\t\tvar i, il, face;\r\n\t\t\tvar indices, j, jl;\r\n\t\r\n\t\t\tfor ( i = 0, il = this.vertices.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tv = this.vertices[ i ];\r\n\t\t\t\tkey = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );\r\n\t\r\n\t\t\t\tif ( verticesMap[ key ] === undefined ) {\r\n\t\r\n\t\t\t\t\tverticesMap[ key ] = i;\r\n\t\t\t\t\tunique.push( this.vertices[ i ] );\r\n\t\t\t\t\tchanges[ i ] = unique.length - 1;\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);\r\n\t\t\t\t\tchanges[ i ] = changes[ verticesMap[ key ] ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\r\n\t\t\t// if faces are completely degenerate after merging vertices, we\r\n\t\t\t// have to remove them from the geometry.\r\n\t\t\tvar faceIndicesToRemove = [];\r\n\t\r\n\t\t\tfor ( i = 0, il = this.faces.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tface = this.faces[ i ];\r\n\t\r\n\t\t\t\tface.a = changes[ face.a ];\r\n\t\t\t\tface.b = changes[ face.b ];\r\n\t\t\t\tface.c = changes[ face.c ];\r\n\t\r\n\t\t\t\tindices = [ face.a, face.b, face.c ];\r\n\t\r\n\t\t\t\tvar dupIndex = - 1;\r\n\t\r\n\t\t\t\t// if any duplicate vertices are found in a Face3\r\n\t\t\t\t// we have to remove the face as nothing can be saved\r\n\t\t\t\tfor ( var n = 0; n < 3; n ++ ) {\r\n\t\r\n\t\t\t\t\tif ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {\r\n\t\r\n\t\t\t\t\t\tdupIndex = n;\r\n\t\t\t\t\t\tfaceIndicesToRemove.push( i );\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {\r\n\t\r\n\t\t\t\tvar idx = faceIndicesToRemove[ i ];\r\n\t\r\n\t\t\t\tthis.faces.splice( idx, 1 );\r\n\t\r\n\t\t\t\tfor ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {\r\n\t\r\n\t\t\t\t\tthis.faceVertexUvs[ j ].splice( idx, 1 );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// Use unique set of vertices\r\n\t\r\n\t\t\tvar diff = this.vertices.length - unique.length;\r\n\t\t\tthis.vertices = unique;\r\n\t\t\treturn diff;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsortFacesByMaterialIndex: function () {\r\n\t\r\n\t\t\tvar faces = this.faces;\r\n\t\t\tvar length = faces.length;\r\n\t\r\n\t\t\t// tag faces\r\n\t\r\n\t\t\tfor ( var i = 0; i < length; i ++ ) {\r\n\t\r\n\t\t\t\tfaces[ i ]._id = i;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// sort faces\r\n\t\r\n\t\t\tfunction materialIndexSort( a, b ) {\r\n\t\r\n\t\t\t\treturn a.materialIndex - b.materialIndex;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfaces.sort( materialIndexSort );\r\n\t\r\n\t\t\t// sort uvs\r\n\t\r\n\t\t\tvar uvs1 = this.faceVertexUvs[ 0 ];\r\n\t\t\tvar uvs2 = this.faceVertexUvs[ 1 ];\r\n\t\r\n\t\t\tvar newUvs1, newUvs2;\r\n\t\r\n\t\t\tif ( uvs1 && uvs1.length === length ) newUvs1 = [];\r\n\t\t\tif ( uvs2 && uvs2.length === length ) newUvs2 = [];\r\n\t\r\n\t\t\tfor ( var i = 0; i < length; i ++ ) {\r\n\t\r\n\t\t\t\tvar id = faces[ i ]._id;\r\n\t\r\n\t\t\t\tif ( newUvs1 ) newUvs1.push( uvs1[ id ] );\r\n\t\t\t\tif ( newUvs2 ) newUvs2.push( uvs2[ id ] );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( newUvs1 ) this.faceVertexUvs[ 0 ] = newUvs1;\r\n\t\t\tif ( newUvs2 ) this.faceVertexUvs[ 1 ] = newUvs2;\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttoJSON: function () {\r\n\t\r\n\t\t\tvar data = {\r\n\t\t\t\tmetadata: {\r\n\t\t\t\t\tversion: 4.4,\r\n\t\t\t\t\ttype: 'Geometry',\r\n\t\t\t\t\tgenerator: 'Geometry.toJSON'\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\r\n\t\t\t// standard Geometry serialization\r\n\t\r\n\t\t\tdata.uuid = this.uuid;\r\n\t\t\tdata.type = this.type;\r\n\t\t\tif ( this.name !== '' ) data.name = this.name;\r\n\t\r\n\t\t\tif ( this.parameters !== undefined ) {\r\n\t\r\n\t\t\t\tvar parameters = this.parameters;\r\n\t\r\n\t\t\t\tfor ( var key in parameters ) {\r\n\t\r\n\t\t\t\t\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn data;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar vertices = [];\r\n\t\r\n\t\t\tfor ( var i = 0; i < this.vertices.length; i ++ ) {\r\n\t\r\n\t\t\t\tvar vertex = this.vertices[ i ];\r\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar faces = [];\r\n\t\t\tvar normals = [];\r\n\t\t\tvar normalsHash = {};\r\n\t\t\tvar colors = [];\r\n\t\t\tvar colorsHash = {};\r\n\t\t\tvar uvs = [];\r\n\t\t\tvar uvsHash = {};\r\n\t\r\n\t\t\tfor ( var i = 0; i < this.faces.length; i ++ ) {\r\n\t\r\n\t\t\t\tvar face = this.faces[ i ];\r\n\t\r\n\t\t\t\tvar hasMaterial = true;\r\n\t\t\t\tvar hasFaceUv = false; // deprecated\r\n\t\t\t\tvar hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;\r\n\t\t\t\tvar hasFaceNormal = face.normal.length() > 0;\r\n\t\t\t\tvar hasFaceVertexNormal = face.vertexNormals.length > 0;\r\n\t\t\t\tvar hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;\r\n\t\t\t\tvar hasFaceVertexColor = face.vertexColors.length > 0;\r\n\t\r\n\t\t\t\tvar faceType = 0;\r\n\t\r\n\t\t\t\tfaceType = setBit( faceType, 0, 0 ); // isQuad\r\n\t\t\t\tfaceType = setBit( faceType, 1, hasMaterial );\r\n\t\t\t\tfaceType = setBit( faceType, 2, hasFaceUv );\r\n\t\t\t\tfaceType = setBit( faceType, 3, hasFaceVertexUv );\r\n\t\t\t\tfaceType = setBit( faceType, 4, hasFaceNormal );\r\n\t\t\t\tfaceType = setBit( faceType, 5, hasFaceVertexNormal );\r\n\t\t\t\tfaceType = setBit( faceType, 6, hasFaceColor );\r\n\t\t\t\tfaceType = setBit( faceType, 7, hasFaceVertexColor );\r\n\t\r\n\t\t\t\tfaces.push( faceType );\r\n\t\t\t\tfaces.push( face.a, face.b, face.c );\r\n\t\t\t\tfaces.push( face.materialIndex );\r\n\t\r\n\t\t\t\tif ( hasFaceVertexUv ) {\r\n\t\r\n\t\t\t\t\tvar faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];\r\n\t\r\n\t\t\t\t\tfaces.push(\r\n\t\t\t\t\t\tgetUvIndex( faceVertexUvs[ 0 ] ),\r\n\t\t\t\t\t\tgetUvIndex( faceVertexUvs[ 1 ] ),\r\n\t\t\t\t\t\tgetUvIndex( faceVertexUvs[ 2 ] )\r\n\t\t\t\t\t);\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( hasFaceNormal ) {\r\n\t\r\n\t\t\t\t\tfaces.push( getNormalIndex( face.normal ) );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( hasFaceVertexNormal ) {\r\n\t\r\n\t\t\t\t\tvar vertexNormals = face.vertexNormals;\r\n\t\r\n\t\t\t\t\tfaces.push(\r\n\t\t\t\t\t\tgetNormalIndex( vertexNormals[ 0 ] ),\r\n\t\t\t\t\t\tgetNormalIndex( vertexNormals[ 1 ] ),\r\n\t\t\t\t\t\tgetNormalIndex( vertexNormals[ 2 ] )\r\n\t\t\t\t\t);\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( hasFaceColor ) {\r\n\t\r\n\t\t\t\t\tfaces.push( getColorIndex( face.color ) );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( hasFaceVertexColor ) {\r\n\t\r\n\t\t\t\t\tvar vertexColors = face.vertexColors;\r\n\t\r\n\t\t\t\t\tfaces.push(\r\n\t\t\t\t\t\tgetColorIndex( vertexColors[ 0 ] ),\r\n\t\t\t\t\t\tgetColorIndex( vertexColors[ 1 ] ),\r\n\t\t\t\t\t\tgetColorIndex( vertexColors[ 2 ] )\r\n\t\t\t\t\t);\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfunction setBit( value, position, enabled ) {\r\n\t\r\n\t\t\t\treturn enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfunction getNormalIndex( normal ) {\r\n\t\r\n\t\t\t\tvar hash = normal.x.toString() + normal.y.toString() + normal.z.toString();\r\n\t\r\n\t\t\t\tif ( normalsHash[ hash ] !== undefined ) {\r\n\t\r\n\t\t\t\t\treturn normalsHash[ hash ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tnormalsHash[ hash ] = normals.length / 3;\r\n\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\r\n\t\r\n\t\t\t\treturn normalsHash[ hash ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfunction getColorIndex( color ) {\r\n\t\r\n\t\t\t\tvar hash = color.r.toString() + color.g.toString() + color.b.toString();\r\n\t\r\n\t\t\t\tif ( colorsHash[ hash ] !== undefined ) {\r\n\t\r\n\t\t\t\t\treturn colorsHash[ hash ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tcolorsHash[ hash ] = colors.length;\r\n\t\t\t\tcolors.push( color.getHex() );\r\n\t\r\n\t\t\t\treturn colorsHash[ hash ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfunction getUvIndex( uv ) {\r\n\t\r\n\t\t\t\tvar hash = uv.x.toString() + uv.y.toString();\r\n\t\r\n\t\t\t\tif ( uvsHash[ hash ] !== undefined ) {\r\n\t\r\n\t\t\t\t\treturn uvsHash[ hash ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tuvsHash[ hash ] = uvs.length / 2;\r\n\t\t\t\tuvs.push( uv.x, uv.y );\r\n\t\r\n\t\t\t\treturn uvsHash[ hash ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tdata.data = {};\r\n\t\r\n\t\t\tdata.data.vertices = vertices;\r\n\t\t\tdata.data.normals = normals;\r\n\t\t\tif ( colors.length > 0 ) data.data.colors = colors;\r\n\t\t\tif ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility\r\n\t\t\tdata.data.faces = faces;\r\n\t\r\n\t\t\treturn data;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\t/*\r\n\t\t\t// Handle primitives\r\n\t\r\n\t\t\tvar parameters = this.parameters;\r\n\t\r\n\t\t\tif ( parameters !== undefined ) {\r\n\t\r\n\t\t\t\tvar values = [];\r\n\t\r\n\t\t\t\tfor ( var key in parameters ) {\r\n\t\r\n\t\t\t\t\tvalues.push( parameters[ key ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar geometry = Object.create( this.constructor.prototype );\r\n\t\t\t\tthis.constructor.apply( geometry, values );\r\n\t\t\t\treturn geometry;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn new this.constructor().copy( this );\r\n\t\t\t*/\r\n\t\r\n\t\t\treturn new THREE.Geometry().copy( this );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( source ) {\r\n\t\r\n\t\t\tthis.vertices = [];\r\n\t\t\tthis.faces = [];\r\n\t\t\tthis.faceVertexUvs = [ [] ];\r\n\t\r\n\t\t\tvar vertices = source.vertices;\r\n\t\r\n\t\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tthis.vertices.push( vertices[ i ].clone() );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar faces = source.faces;\r\n\t\r\n\t\t\tfor ( var i = 0, il = faces.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tthis.faces.push( faces[ i ].clone() );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( var i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tvar faceVertexUvs = source.faceVertexUvs[ i ];\r\n\t\r\n\t\t\t\tif ( this.faceVertexUvs[ i ] === undefined ) {\r\n\t\r\n\t\t\t\t\tthis.faceVertexUvs[ i ] = [];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tfor ( var j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {\r\n\t\r\n\t\t\t\t\tvar uvs = faceVertexUvs[ j ], uvsCopy = [];\r\n\t\r\n\t\t\t\t\tfor ( var k = 0, kl = uvs.length; k < kl; k ++ ) {\r\n\t\r\n\t\t\t\t\t\tvar uv = uvs[ k ];\r\n\t\r\n\t\t\t\t\t\tuvsCopy.push( uv.clone() );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tthis.faceVertexUvs[ i ].push( uvsCopy );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdispose: function () {\r\n\t\r\n\t\t\tthis.dispatchEvent( { type: 'dispose' } );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.EventDispatcher.prototype.apply( THREE.Geometry.prototype );\r\n\t\r\n\tTHREE.GeometryIdCount = 0;\r\n\t\r\n\t// File:src/core/DirectGeometry.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.DirectGeometry = function () {\r\n\t\r\n\t\tObject.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );\r\n\t\r\n\t\tthis.uuid = THREE.Math.generateUUID();\r\n\t\r\n\t\tthis.name = '';\r\n\t\tthis.type = 'DirectGeometry';\r\n\t\r\n\t\tthis.indices = [];\r\n\t\tthis.vertices = [];\r\n\t\tthis.normals = [];\r\n\t\tthis.colors = [];\r\n\t\tthis.uvs = [];\r\n\t\tthis.uvs2 = [];\r\n\t\r\n\t\tthis.groups = [];\r\n\t\r\n\t\tthis.morphTargets = {};\r\n\t\r\n\t\tthis.skinWeights = [];\r\n\t\tthis.skinIndices = [];\r\n\t\r\n\t\t// this.lineDistances = [];\r\n\t\r\n\t\tthis.boundingBox = null;\r\n\t\tthis.boundingSphere = null;\r\n\t\r\n\t\t// update flags\r\n\t\r\n\t\tthis.verticesNeedUpdate = false;\r\n\t\tthis.normalsNeedUpdate = false;\r\n\t\tthis.colorsNeedUpdate = false;\r\n\t\tthis.uvsNeedUpdate = false;\r\n\t\tthis.groupsNeedUpdate = false;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.DirectGeometry.prototype = {\r\n\t\r\n\t\tconstructor: THREE.DirectGeometry,\r\n\t\r\n\t\tcomputeBoundingBox: THREE.Geometry.prototype.computeBoundingBox,\r\n\t\tcomputeBoundingSphere: THREE.Geometry.prototype.computeBoundingSphere,\r\n\t\r\n\t\tcomputeFaceNormals: function () {\r\n\t\r\n\t\t\tconsole.warn( 'THREE.DirectGeometry: computeFaceNormals() is not a method of this type of geometry.' );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcomputeVertexNormals: function () {\r\n\t\r\n\t\t\tconsole.warn( 'THREE.DirectGeometry: computeVertexNormals() is not a method of this type of geometry.' );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcomputeGroups: function ( geometry ) {\r\n\t\r\n\t\t\tvar group;\r\n\t\t\tvar groups = [];\r\n\t\t\tvar materialIndex;\r\n\t\r\n\t\t\tvar faces = geometry.faces;\r\n\t\r\n\t\t\tfor ( var i = 0; i < faces.length; i ++ ) {\r\n\t\r\n\t\t\t\tvar face = faces[ i ];\r\n\t\r\n\t\t\t\t// materials\r\n\t\r\n\t\t\t\tif ( face.materialIndex !== materialIndex ) {\r\n\t\r\n\t\t\t\t\tmaterialIndex = face.materialIndex;\r\n\t\r\n\t\t\t\t\tif ( group !== undefined ) {\r\n\t\r\n\t\t\t\t\t\tgroup.count = ( i * 3 ) - group.start;\r\n\t\t\t\t\t\tgroups.push( group );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tgroup = {\r\n\t\t\t\t\t\tstart: i * 3,\r\n\t\t\t\t\t\tmaterialIndex: materialIndex\r\n\t\t\t\t\t};\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( group !== undefined ) {\r\n\t\r\n\t\t\t\tgroup.count = ( i * 3 ) - group.start;\r\n\t\t\t\tgroups.push( group );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.groups = groups;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfromGeometry: function ( geometry ) {\r\n\t\r\n\t\t\tvar faces = geometry.faces;\r\n\t\t\tvar vertices = geometry.vertices;\r\n\t\t\tvar faceVertexUvs = geometry.faceVertexUvs;\r\n\t\r\n\t\t\tvar hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;\r\n\t\t\tvar hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;\r\n\t\r\n\t\t\t// morphs\r\n\t\r\n\t\t\tvar morphTargets = geometry.morphTargets;\r\n\t\t\tvar morphTargetsLength = morphTargets.length;\r\n\t\r\n\t\t\tvar morphTargetsPosition;\r\n\t\r\n\t\t\tif ( morphTargetsLength > 0 ) {\r\n\t\r\n\t\t\t\tmorphTargetsPosition = [];\r\n\t\r\n\t\t\t\tfor ( var i = 0; i < morphTargetsLength; i ++ ) {\r\n\t\r\n\t\t\t\t\tmorphTargetsPosition[ i ] = [];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tthis.morphTargets.position = morphTargetsPosition;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar morphNormals = geometry.morphNormals;\r\n\t\t\tvar morphNormalsLength = morphNormals.length;\r\n\t\r\n\t\t\tvar morphTargetsNormal;\r\n\t\r\n\t\t\tif ( morphNormalsLength > 0 ) {\r\n\t\r\n\t\t\t\tmorphTargetsNormal = [];\r\n\t\r\n\t\t\t\tfor ( var i = 0; i < morphNormalsLength; i ++ ) {\r\n\t\r\n\t\t\t\t\tmorphTargetsNormal[ i ] = [];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tthis.morphTargets.normal = morphTargetsNormal;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// skins\r\n\t\r\n\t\t\tvar skinIndices = geometry.skinIndices;\r\n\t\t\tvar skinWeights = geometry.skinWeights;\r\n\t\r\n\t\t\tvar hasSkinIndices = skinIndices.length === vertices.length;\r\n\t\t\tvar hasSkinWeights = skinWeights.length === vertices.length;\r\n\t\r\n\t\t\t//\r\n\t\r\n\t\t\tfor ( var i = 0; i < faces.length; i ++ ) {\r\n\t\r\n\t\t\t\tvar face = faces[ i ];\r\n\t\r\n\t\t\t\tthis.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );\r\n\t\r\n\t\t\t\tvar vertexNormals = face.vertexNormals;\r\n\t\r\n\t\t\t\tif ( vertexNormals.length === 3 ) {\r\n\t\r\n\t\t\t\t\tthis.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tvar normal = face.normal;\r\n\t\r\n\t\t\t\t\tthis.normals.push( normal, normal, normal );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar vertexColors = face.vertexColors;\r\n\t\r\n\t\t\t\tif ( vertexColors.length === 3 ) {\r\n\t\r\n\t\t\t\t\tthis.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tvar color = face.color;\r\n\t\r\n\t\t\t\t\tthis.colors.push( color, color, color );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( hasFaceVertexUv === true ) {\r\n\t\r\n\t\t\t\t\tvar vertexUvs = faceVertexUvs[ 0 ][ i ];\r\n\t\r\n\t\t\t\t\tif ( vertexUvs !== undefined ) {\r\n\t\r\n\t\t\t\t\t\tthis.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tconsole.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );\r\n\t\r\n\t\t\t\t\t\tthis.uvs.push( new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2() );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( hasFaceVertexUv2 === true ) {\r\n\t\r\n\t\t\t\t\tvar vertexUvs = faceVertexUvs[ 1 ][ i ];\r\n\t\r\n\t\t\t\t\tif ( vertexUvs !== undefined ) {\r\n\t\r\n\t\t\t\t\t\tthis.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tconsole.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );\r\n\t\r\n\t\t\t\t\t\tthis.uvs2.push( new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2() );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// morphs\r\n\t\r\n\t\t\t\tfor ( var j = 0; j < morphTargetsLength; j ++ ) {\r\n\t\r\n\t\t\t\t\tvar morphTarget = morphTargets[ j ].vertices;\r\n\t\r\n\t\t\t\t\tmorphTargetsPosition[ j ].push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tfor ( var j = 0; j < morphNormalsLength; j ++ ) {\r\n\t\r\n\t\t\t\t\tvar morphNormal = morphNormals[ j ].vertexNormals[ i ];\r\n\t\r\n\t\t\t\t\tmorphTargetsNormal[ j ].push( morphNormal.a, morphNormal.b, morphNormal.c );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// skins\r\n\t\r\n\t\t\t\tif ( hasSkinIndices ) {\r\n\t\r\n\t\t\t\t\tthis.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( hasSkinWeights ) {\r\n\t\r\n\t\t\t\t\tthis.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.computeGroups( geometry );\r\n\t\r\n\t\t\tthis.verticesNeedUpdate = geometry.verticesNeedUpdate;\r\n\t\t\tthis.normalsNeedUpdate = geometry.normalsNeedUpdate;\r\n\t\t\tthis.colorsNeedUpdate = geometry.colorsNeedUpdate;\r\n\t\t\tthis.uvsNeedUpdate = geometry.uvsNeedUpdate;\r\n\t\t\tthis.groupsNeedUpdate = geometry.groupsNeedUpdate;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdispose: function () {\r\n\t\r\n\t\t\tthis.dispatchEvent( { type: 'dispose' } );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.EventDispatcher.prototype.apply( THREE.DirectGeometry.prototype );\r\n\t\r\n\t// File:src/core/BufferGeometry.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.BufferGeometry = function () {\r\n\t\r\n\t\tObject.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );\r\n\t\r\n\t\tthis.uuid = THREE.Math.generateUUID();\r\n\t\r\n\t\tthis.name = '';\r\n\t\tthis.type = 'BufferGeometry';\r\n\t\r\n\t\tthis.index = null;\r\n\t\tthis.attributes = {};\r\n\t\r\n\t\tthis.morphAttributes = {};\r\n\t\r\n\t\tthis.groups = [];\r\n\t\r\n\t\tthis.boundingBox = null;\r\n\t\tthis.boundingSphere = null;\r\n\t\r\n\t\tthis.drawRange = { start: 0, count: Infinity };\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.BufferGeometry.prototype = {\r\n\t\r\n\t\tconstructor: THREE.BufferGeometry,\r\n\t\r\n\t\tgetIndex: function () {\r\n\t\r\n\t\t\treturn this.index;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetIndex: function ( index ) {\r\n\t\r\n\t\t\tthis.index = index;\r\n\t\r\n\t\t},\r\n\t\r\n\t\taddAttribute: function ( name, attribute ) {\r\n\t\r\n\t\t\tif ( attribute instanceof THREE.BufferAttribute === false && attribute instanceof THREE.InterleavedBufferAttribute === false ) {\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );\r\n\t\r\n\t\t\t\tthis.addAttribute( name, new THREE.BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );\r\n\t\r\n\t\t\t\treturn;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( name === 'index' ) {\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );\r\n\t\t\t\tthis.setIndex( attribute );\r\n\t\r\n\t\t\t\treturn;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.attributes[ name ] = attribute;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetAttribute: function ( name ) {\r\n\t\r\n\t\t\treturn this.attributes[ name ];\r\n\t\r\n\t\t},\r\n\t\r\n\t\tremoveAttribute: function ( name ) {\r\n\t\r\n\t\t\tdelete this.attributes[ name ];\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\taddGroup: function ( start, count, materialIndex ) {\r\n\t\r\n\t\t\tthis.groups.push( {\r\n\t\r\n\t\t\t\tstart: start,\r\n\t\t\t\tcount: count,\r\n\t\t\t\tmaterialIndex: materialIndex !== undefined ? materialIndex : 0\r\n\t\r\n\t\t\t} );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclearGroups: function () {\r\n\t\r\n\t\t\tthis.groups = [];\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetDrawRange: function ( start, count ) {\r\n\t\r\n\t\t\tthis.drawRange.start = start;\r\n\t\t\tthis.drawRange.count = count;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tapplyMatrix: function ( matrix ) {\r\n\t\r\n\t\t\tvar position = this.attributes.position;\r\n\t\r\n\t\t\tif ( position !== undefined ) {\r\n\t\r\n\t\t\t\tmatrix.applyToVector3Array( position.array );\r\n\t\t\t\tposition.needsUpdate = true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar normal = this.attributes.normal;\r\n\t\r\n\t\t\tif ( normal !== undefined ) {\r\n\t\r\n\t\t\t\tvar normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );\r\n\t\r\n\t\t\t\tnormalMatrix.applyToVector3Array( normal.array );\r\n\t\t\t\tnormal.needsUpdate = true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( this.boundingBox !== null ) {\r\n\t\r\n\t\t\t\tthis.computeBoundingBox();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( this.boundingSphere !== null ) {\r\n\t\r\n\t\t\t\tthis.computeBoundingSphere();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\trotateX: function () {\r\n\t\r\n\t\t\t// rotate geometry around world x-axis\r\n\t\r\n\t\t\tvar m1;\r\n\t\r\n\t\t\treturn function rotateX( angle ) {\r\n\t\r\n\t\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\r\n\t\r\n\t\t\t\tm1.makeRotationX( angle );\r\n\t\r\n\t\t\t\tthis.applyMatrix( m1 );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\trotateY: function () {\r\n\t\r\n\t\t\t// rotate geometry around world y-axis\r\n\t\r\n\t\t\tvar m1;\r\n\t\r\n\t\t\treturn function rotateY( angle ) {\r\n\t\r\n\t\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\r\n\t\r\n\t\t\t\tm1.makeRotationY( angle );\r\n\t\r\n\t\t\t\tthis.applyMatrix( m1 );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\trotateZ: function () {\r\n\t\r\n\t\t\t// rotate geometry around world z-axis\r\n\t\r\n\t\t\tvar m1;\r\n\t\r\n\t\t\treturn function rotateZ( angle ) {\r\n\t\r\n\t\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\r\n\t\r\n\t\t\t\tm1.makeRotationZ( angle );\r\n\t\r\n\t\t\t\tthis.applyMatrix( m1 );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\ttranslate: function () {\r\n\t\r\n\t\t\t// translate geometry\r\n\t\r\n\t\t\tvar m1;\r\n\t\r\n\t\t\treturn function translate( x, y, z ) {\r\n\t\r\n\t\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\r\n\t\r\n\t\t\t\tm1.makeTranslation( x, y, z );\r\n\t\r\n\t\t\t\tthis.applyMatrix( m1 );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tscale: function () {\r\n\t\r\n\t\t\t// scale geometry\r\n\t\r\n\t\t\tvar m1;\r\n\t\r\n\t\t\treturn function scale( x, y, z ) {\r\n\t\r\n\t\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\r\n\t\r\n\t\t\t\tm1.makeScale( x, y, z );\r\n\t\r\n\t\t\t\tthis.applyMatrix( m1 );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tlookAt: function () {\r\n\t\r\n\t\t\tvar obj;\r\n\t\r\n\t\t\treturn function lookAt( vector ) {\r\n\t\r\n\t\t\t\tif ( obj === undefined ) obj = new THREE.Object3D();\r\n\t\r\n\t\t\t\tobj.lookAt( vector );\r\n\t\r\n\t\t\t\tobj.updateMatrix();\r\n\t\r\n\t\t\t\tthis.applyMatrix( obj.matrix );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tcenter: function () {\r\n\t\r\n\t\t\tthis.computeBoundingBox();\r\n\t\r\n\t\t\tvar offset = this.boundingBox.center().negate();\r\n\t\r\n\t\t\tthis.translate( offset.x, offset.y, offset.z );\r\n\t\r\n\t\t\treturn offset;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromObject: function ( object ) {\r\n\t\r\n\t\t\t// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );\r\n\t\r\n\t\t\tvar geometry = object.geometry;\r\n\t\r\n\t\t\tif ( object instanceof THREE.Points || object instanceof THREE.Line ) {\r\n\t\r\n\t\t\t\tvar positions = new THREE.Float32Attribute( geometry.vertices.length * 3, 3 );\r\n\t\t\t\tvar colors = new THREE.Float32Attribute( geometry.colors.length * 3, 3 );\r\n\t\r\n\t\t\t\tthis.addAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );\r\n\t\t\t\tthis.addAttribute( 'color', colors.copyColorsArray( geometry.colors ) );\r\n\t\r\n\t\t\t\tif ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {\r\n\t\r\n\t\t\t\t\tvar lineDistances = new THREE.Float32Attribute( geometry.lineDistances.length, 1 );\r\n\t\r\n\t\t\t\t\tthis.addAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( geometry.boundingSphere !== null ) {\r\n\t\r\n\t\t\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( geometry.boundingBox !== null ) {\r\n\t\r\n\t\t\t\t\tthis.boundingBox = geometry.boundingBox.clone();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else if ( object instanceof THREE.Mesh ) {\r\n\t\r\n\t\t\t\tif ( geometry instanceof THREE.Geometry ) {\r\n\t\r\n\t\t\t\t\tthis.fromGeometry( geometry );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tupdateFromObject: function ( object ) {\r\n\t\r\n\t\t\tvar geometry = object.geometry;\r\n\t\r\n\t\t\tif ( object instanceof THREE.Mesh ) {\r\n\t\r\n\t\t\t\tvar direct = geometry.__directGeometry;\r\n\t\r\n\t\t\t\tif ( direct === undefined ) {\r\n\t\r\n\t\t\t\t\treturn this.fromGeometry( geometry );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tdirect.verticesNeedUpdate = geometry.verticesNeedUpdate;\r\n\t\t\t\tdirect.normalsNeedUpdate = geometry.normalsNeedUpdate;\r\n\t\t\t\tdirect.colorsNeedUpdate = geometry.colorsNeedUpdate;\r\n\t\t\t\tdirect.uvsNeedUpdate = geometry.uvsNeedUpdate;\r\n\t\t\t\tdirect.groupsNeedUpdate = geometry.groupsNeedUpdate;\r\n\t\r\n\t\t\t\tgeometry.verticesNeedUpdate = false;\r\n\t\t\t\tgeometry.normalsNeedUpdate = false;\r\n\t\t\t\tgeometry.colorsNeedUpdate = false;\r\n\t\t\t\tgeometry.uvsNeedUpdate = false;\r\n\t\t\t\tgeometry.groupsNeedUpdate = false;\r\n\t\r\n\t\t\t\tgeometry = direct;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( geometry.verticesNeedUpdate === true ) {\r\n\t\r\n\t\t\t\tvar attribute = this.attributes.position;\r\n\t\r\n\t\t\t\tif ( attribute !== undefined ) {\r\n\t\r\n\t\t\t\t\tattribute.copyVector3sArray( geometry.vertices );\r\n\t\t\t\t\tattribute.needsUpdate = true;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tgeometry.verticesNeedUpdate = false;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( geometry.normalsNeedUpdate === true ) {\r\n\t\r\n\t\t\t\tvar attribute = this.attributes.normal;\r\n\t\r\n\t\t\t\tif ( attribute !== undefined ) {\r\n\t\r\n\t\t\t\t\tattribute.copyVector3sArray( geometry.normals );\r\n\t\t\t\t\tattribute.needsUpdate = true;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tgeometry.normalsNeedUpdate = false;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( geometry.colorsNeedUpdate === true ) {\r\n\t\r\n\t\t\t\tvar attribute = this.attributes.color;\r\n\t\r\n\t\t\t\tif ( attribute !== undefined ) {\r\n\t\r\n\t\t\t\t\tattribute.copyColorsArray( geometry.colors );\r\n\t\t\t\t\tattribute.needsUpdate = true;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tgeometry.colorsNeedUpdate = false;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( geometry.uvsNeedUpdate ) {\r\n\t\r\n\t\t\t\tvar attribute = this.attributes.uv;\r\n\t\r\n\t\t\t\tif ( attribute !== undefined ) {\r\n\t\r\n\t\t\t\t\tattribute.copyVector2sArray( geometry.uvs );\r\n\t\t\t\t\tattribute.needsUpdate = true;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tgeometry.uvsNeedUpdate = false;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( geometry.lineDistancesNeedUpdate ) {\r\n\t\r\n\t\t\t\tvar attribute = this.attributes.lineDistance;\r\n\t\r\n\t\t\t\tif ( attribute !== undefined ) {\r\n\t\r\n\t\t\t\t\tattribute.copyArray( geometry.lineDistances );\r\n\t\t\t\t\tattribute.needsUpdate = true;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tgeometry.lineDistancesNeedUpdate = false;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( geometry.groupsNeedUpdate ) {\r\n\t\r\n\t\t\t\tgeometry.computeGroups( object.geometry );\r\n\t\t\t\tthis.groups = geometry.groups;\r\n\t\r\n\t\t\t\tgeometry.groupsNeedUpdate = false;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfromGeometry: function ( geometry ) {\r\n\t\r\n\t\t\tgeometry.__directGeometry = new THREE.DirectGeometry().fromGeometry( geometry );\r\n\t\r\n\t\t\treturn this.fromDirectGeometry( geometry.__directGeometry );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfromDirectGeometry: function ( geometry ) {\r\n\t\r\n\t\t\tvar positions = new Float32Array( geometry.vertices.length * 3 );\r\n\t\t\tthis.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );\r\n\t\r\n\t\t\tif ( geometry.normals.length > 0 ) {\r\n\t\r\n\t\t\t\tvar normals = new Float32Array( geometry.normals.length * 3 );\r\n\t\t\t\tthis.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( geometry.colors.length > 0 ) {\r\n\t\r\n\t\t\t\tvar colors = new Float32Array( geometry.colors.length * 3 );\r\n\t\t\t\tthis.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( geometry.uvs.length > 0 ) {\r\n\t\r\n\t\t\t\tvar uvs = new Float32Array( geometry.uvs.length * 2 );\r\n\t\t\t\tthis.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( geometry.uvs2.length > 0 ) {\r\n\t\r\n\t\t\t\tvar uvs2 = new Float32Array( geometry.uvs2.length * 2 );\r\n\t\t\t\tthis.addAttribute( 'uv2', new THREE.BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( geometry.indices.length > 0 ) {\r\n\t\r\n\t\t\t\tvar TypeArray = geometry.vertices.length > 65535 ? Uint32Array : Uint16Array;\r\n\t\t\t\tvar indices = new TypeArray( geometry.indices.length * 3 );\r\n\t\t\t\tthis.setIndex( new THREE.BufferAttribute( indices, 1 ).copyIndicesArray( geometry.indices ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// groups\r\n\t\r\n\t\t\tthis.groups = geometry.groups;\r\n\t\r\n\t\t\t// morphs\r\n\t\r\n\t\t\tfor ( var name in geometry.morphTargets ) {\r\n\t\r\n\t\t\t\tvar array = [];\r\n\t\t\t\tvar morphTargets = geometry.morphTargets[ name ];\r\n\t\r\n\t\t\t\tfor ( var i = 0, l = morphTargets.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\tvar morphTarget = morphTargets[ i ];\r\n\t\r\n\t\t\t\t\tvar attribute = new THREE.Float32Attribute( morphTarget.length * 3, 3 );\r\n\t\r\n\t\t\t\t\tarray.push( attribute.copyVector3sArray( morphTarget ) );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tthis.morphAttributes[ name ] = array;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// skinning\r\n\t\r\n\t\t\tif ( geometry.skinIndices.length > 0 ) {\r\n\t\r\n\t\t\t\tvar skinIndices = new THREE.Float32Attribute( geometry.skinIndices.length * 4, 4 );\r\n\t\t\t\tthis.addAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( geometry.skinWeights.length > 0 ) {\r\n\t\r\n\t\t\t\tvar skinWeights = new THREE.Float32Attribute( geometry.skinWeights.length * 4, 4 );\r\n\t\t\t\tthis.addAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t//\r\n\t\r\n\t\t\tif ( geometry.boundingSphere !== null ) {\r\n\t\r\n\t\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( geometry.boundingBox !== null ) {\r\n\t\r\n\t\t\t\tthis.boundingBox = geometry.boundingBox.clone();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcomputeBoundingBox: function () {\r\n\t\r\n\t\t\tif ( this.boundingBox === null ) {\r\n\t\r\n\t\t\t\tthis.boundingBox = new THREE.Box3();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar positions = this.attributes.position.array;\r\n\t\r\n\t\t\tif ( positions !== undefined ) {\r\n\t\r\n\t\t\t\tthis.boundingBox.setFromArray( positions );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tthis.boundingBox.makeEmpty();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {\r\n\t\r\n\t\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.', this );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcomputeBoundingSphere: function () {\r\n\t\r\n\t\t\tvar box = new THREE.Box3();\r\n\t\t\tvar vector = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function () {\r\n\t\r\n\t\t\t\tif ( this.boundingSphere === null ) {\r\n\t\r\n\t\t\t\t\tthis.boundingSphere = new THREE.Sphere();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar positions = this.attributes.position.array;\r\n\t\r\n\t\t\t\tif ( positions ) {\r\n\t\r\n\t\t\t\t\tvar center = this.boundingSphere.center;\r\n\t\r\n\t\t\t\t\tbox.setFromArray( positions );\r\n\t\t\t\t\tbox.center( center );\r\n\t\r\n\t\t\t\t\t// hoping to find a boundingSphere with a radius smaller than the\r\n\t\t\t\t\t// boundingSphere of the boundingBox: sqrt(3) smaller in the best case\r\n\t\r\n\t\t\t\t\tvar maxRadiusSq = 0;\r\n\t\r\n\t\t\t\t\tfor ( var i = 0, il = positions.length; i < il; i += 3 ) {\r\n\t\r\n\t\t\t\t\t\tvector.fromArray( positions, i );\r\n\t\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tthis.boundingSphere.radius = Math.sqrt( maxRadiusSq );\r\n\t\r\n\t\t\t\t\tif ( isNaN( this.boundingSphere.radius ) ) {\r\n\t\r\n\t\t\t\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.', this );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tcomputeFaceNormals: function () {\r\n\t\r\n\t\t\t// backwards compatibility\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcomputeVertexNormals: function () {\r\n\t\r\n\t\t\tvar index = this.index;\r\n\t\t\tvar attributes = this.attributes;\r\n\t\t\tvar groups = this.groups;\r\n\t\r\n\t\t\tif ( attributes.position ) {\r\n\t\r\n\t\t\t\tvar positions = attributes.position.array;\r\n\t\r\n\t\t\t\tif ( attributes.normal === undefined ) {\r\n\t\r\n\t\t\t\t\tthis.addAttribute( 'normal', new THREE.BufferAttribute( new Float32Array( positions.length ), 3 ) );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t// reset existing normals to zero\r\n\t\r\n\t\t\t\t\tvar array = attributes.normal.array;\r\n\t\r\n\t\t\t\t\tfor ( var i = 0, il = array.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\t\tarray[ i ] = 0;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar normals = attributes.normal.array;\r\n\t\r\n\t\t\t\tvar vA, vB, vC,\r\n\t\r\n\t\t\t\tpA = new THREE.Vector3(),\r\n\t\t\t\tpB = new THREE.Vector3(),\r\n\t\t\t\tpC = new THREE.Vector3(),\r\n\t\r\n\t\t\t\tcb = new THREE.Vector3(),\r\n\t\t\t\tab = new THREE.Vector3();\r\n\t\r\n\t\t\t\t// indexed elements\r\n\t\r\n\t\t\t\tif ( index ) {\r\n\t\r\n\t\t\t\t\tvar indices = index.array;\r\n\t\r\n\t\t\t\t\tif ( groups.length === 0 ) {\r\n\t\r\n\t\t\t\t\t\tthis.addGroup( 0, indices.length );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tfor ( var j = 0, jl = groups.length; j < jl; ++ j ) {\r\n\t\r\n\t\t\t\t\t\tvar group = groups[ j ];\r\n\t\r\n\t\t\t\t\t\tvar start = group.start;\r\n\t\t\t\t\t\tvar count = group.count;\r\n\t\r\n\t\t\t\t\t\tfor ( var i = start, il = start + count; i < il; i += 3 ) {\r\n\t\r\n\t\t\t\t\t\t\tvA = indices[ i + 0 ] * 3;\r\n\t\t\t\t\t\t\tvB = indices[ i + 1 ] * 3;\r\n\t\t\t\t\t\t\tvC = indices[ i + 2 ] * 3;\r\n\t\r\n\t\t\t\t\t\t\tpA.fromArray( positions, vA );\r\n\t\t\t\t\t\t\tpB.fromArray( positions, vB );\r\n\t\t\t\t\t\t\tpC.fromArray( positions, vC );\r\n\t\r\n\t\t\t\t\t\t\tcb.subVectors( pC, pB );\r\n\t\t\t\t\t\t\tab.subVectors( pA, pB );\r\n\t\t\t\t\t\t\tcb.cross( ab );\r\n\t\r\n\t\t\t\t\t\t\tnormals[ vA ] += cb.x;\r\n\t\t\t\t\t\t\tnormals[ vA + 1 ] += cb.y;\r\n\t\t\t\t\t\t\tnormals[ vA + 2 ] += cb.z;\r\n\t\r\n\t\t\t\t\t\t\tnormals[ vB ] += cb.x;\r\n\t\t\t\t\t\t\tnormals[ vB + 1 ] += cb.y;\r\n\t\t\t\t\t\t\tnormals[ vB + 2 ] += cb.z;\r\n\t\r\n\t\t\t\t\t\t\tnormals[ vC ] += cb.x;\r\n\t\t\t\t\t\t\tnormals[ vC + 1 ] += cb.y;\r\n\t\t\t\t\t\t\tnormals[ vC + 2 ] += cb.z;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t// non-indexed elements (unconnected triangle soup)\r\n\t\r\n\t\t\t\t\tfor ( var i = 0, il = positions.length; i < il; i += 9 ) {\r\n\t\r\n\t\t\t\t\t\tpA.fromArray( positions, i );\r\n\t\t\t\t\t\tpB.fromArray( positions, i + 3 );\r\n\t\t\t\t\t\tpC.fromArray( positions, i + 6 );\r\n\t\r\n\t\t\t\t\t\tcb.subVectors( pC, pB );\r\n\t\t\t\t\t\tab.subVectors( pA, pB );\r\n\t\t\t\t\t\tcb.cross( ab );\r\n\t\r\n\t\t\t\t\t\tnormals[ i ] = cb.x;\r\n\t\t\t\t\t\tnormals[ i + 1 ] = cb.y;\r\n\t\t\t\t\t\tnormals[ i + 2 ] = cb.z;\r\n\t\r\n\t\t\t\t\t\tnormals[ i + 3 ] = cb.x;\r\n\t\t\t\t\t\tnormals[ i + 4 ] = cb.y;\r\n\t\t\t\t\t\tnormals[ i + 5 ] = cb.z;\r\n\t\r\n\t\t\t\t\t\tnormals[ i + 6 ] = cb.x;\r\n\t\t\t\t\t\tnormals[ i + 7 ] = cb.y;\r\n\t\t\t\t\t\tnormals[ i + 8 ] = cb.z;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tthis.normalizeNormals();\r\n\t\r\n\t\t\t\tattributes.normal.needsUpdate = true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmerge: function ( geometry, offset ) {\r\n\t\r\n\t\t\tif ( geometry instanceof THREE.BufferGeometry === false ) {\r\n\t\r\n\t\t\t\tconsole.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );\r\n\t\t\t\treturn;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\r\n\t\t\tvar attributes = this.attributes;\r\n\t\r\n\t\t\tfor ( var key in attributes ) {\r\n\t\r\n\t\t\t\tif ( geometry.attributes[ key ] === undefined ) continue;\r\n\t\r\n\t\t\t\tvar attribute1 = attributes[ key ];\r\n\t\t\t\tvar attributeArray1 = attribute1.array;\r\n\t\r\n\t\t\t\tvar attribute2 = geometry.attributes[ key ];\r\n\t\t\t\tvar attributeArray2 = attribute2.array;\r\n\t\r\n\t\t\t\tvar attributeSize = attribute2.itemSize;\r\n\t\r\n\t\t\t\tfor ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {\r\n\t\r\n\t\t\t\t\tattributeArray1[ j ] = attributeArray2[ i ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tnormalizeNormals: function () {\r\n\t\r\n\t\t\tvar normals = this.attributes.normal.array;\r\n\t\r\n\t\t\tvar x, y, z, n;\r\n\t\r\n\t\t\tfor ( var i = 0, il = normals.length; i < il; i += 3 ) {\r\n\t\r\n\t\t\t\tx = normals[ i ];\r\n\t\t\t\ty = normals[ i + 1 ];\r\n\t\t\t\tz = normals[ i + 2 ];\r\n\t\r\n\t\t\t\tn = 1.0 / Math.sqrt( x * x + y * y + z * z );\r\n\t\r\n\t\t\t\tnormals[ i ] *= n;\r\n\t\t\t\tnormals[ i + 1 ] *= n;\r\n\t\t\t\tnormals[ i + 2 ] *= n;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttoNonIndexed: function () {\r\n\t\r\n\t\t\tif ( this.index === null ) {\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.' );\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar geometry2 = new THREE.BufferGeometry();\r\n\t\r\n\t\t\tvar indices = this.index.array;\r\n\t\t\tvar attributes = this.attributes;\r\n\t\r\n\t\t\tfor ( var name in attributes ) {\r\n\t\r\n\t\t\t\tvar attribute = attributes[ name ];\r\n\t\r\n\t\t\t\tvar array = attribute.array;\r\n\t\t\t\tvar itemSize = attribute.itemSize;\r\n\t\r\n\t\t\t\tvar array2 = new array.constructor( indices.length * itemSize );\r\n\t\r\n\t\t\t\tvar index = 0, index2 = 0;\r\n\t\r\n\t\t\t\tfor ( var i = 0, l = indices.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\tindex = indices[ i ] * itemSize;\r\n\t\r\n\t\t\t\t\tfor ( var j = 0; j < itemSize; j ++ ) {\r\n\t\r\n\t\t\t\t\t\tarray2[ index2 ++ ] = array[ index ++ ];\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tgeometry2.addAttribute( name, new THREE.BufferAttribute( array2, itemSize ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn geometry2;\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttoJSON: function () {\r\n\t\r\n\t\t\tvar data = {\r\n\t\t\t\tmetadata: {\r\n\t\t\t\t\tversion: 4.4,\r\n\t\t\t\t\ttype: 'BufferGeometry',\r\n\t\t\t\t\tgenerator: 'BufferGeometry.toJSON'\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\r\n\t\t\t// standard BufferGeometry serialization\r\n\t\r\n\t\t\tdata.uuid = this.uuid;\r\n\t\t\tdata.type = this.type;\r\n\t\t\tif ( this.name !== '' ) data.name = this.name;\r\n\t\r\n\t\t\tif ( this.parameters !== undefined ) {\r\n\t\r\n\t\t\t\tvar parameters = this.parameters;\r\n\t\r\n\t\t\t\tfor ( var key in parameters ) {\r\n\t\r\n\t\t\t\t\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn data;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tdata.data = { attributes: {} };\r\n\t\r\n\t\t\tvar index = this.index;\r\n\t\r\n\t\t\tif ( index !== null ) {\r\n\t\r\n\t\t\t\tvar array = Array.prototype.slice.call( index.array );\r\n\t\r\n\t\t\t\tdata.data.index = {\r\n\t\t\t\t\ttype: index.array.constructor.name,\r\n\t\t\t\t\tarray: array\r\n\t\t\t\t};\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar attributes = this.attributes;\r\n\t\r\n\t\t\tfor ( var key in attributes ) {\r\n\t\r\n\t\t\t\tvar attribute = attributes[ key ];\r\n\t\r\n\t\t\t\tvar array = Array.prototype.slice.call( attribute.array );\r\n\t\r\n\t\t\t\tdata.data.attributes[ key ] = {\r\n\t\t\t\t\titemSize: attribute.itemSize,\r\n\t\t\t\t\ttype: attribute.array.constructor.name,\r\n\t\t\t\t\tarray: array,\r\n\t\t\t\t\tnormalized: attribute.normalized\r\n\t\t\t\t};\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar groups = this.groups;\r\n\t\r\n\t\t\tif ( groups.length > 0 ) {\r\n\t\r\n\t\t\t\tdata.data.groups = JSON.parse( JSON.stringify( groups ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar boundingSphere = this.boundingSphere;\r\n\t\r\n\t\t\tif ( boundingSphere !== null ) {\r\n\t\r\n\t\t\t\tdata.data.boundingSphere = {\r\n\t\t\t\t\tcenter: boundingSphere.center.toArray(),\r\n\t\t\t\t\tradius: boundingSphere.radius\r\n\t\t\t\t};\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn data;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\t/*\r\n\t\t\t// Handle primitives\r\n\t\r\n\t\t\tvar parameters = this.parameters;\r\n\t\r\n\t\t\tif ( parameters !== undefined ) {\r\n\t\r\n\t\t\t\tvar values = [];\r\n\t\r\n\t\t\t\tfor ( var key in parameters ) {\r\n\t\r\n\t\t\t\t\tvalues.push( parameters[ key ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar geometry = Object.create( this.constructor.prototype );\r\n\t\t\t\tthis.constructor.apply( geometry, values );\r\n\t\t\t\treturn geometry;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn new this.constructor().copy( this );\r\n\t\t\t*/\r\n\t\r\n\t\t\treturn new THREE.BufferGeometry().copy( this );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( source ) {\r\n\t\r\n\t\t\tvar index = source.index;\r\n\t\r\n\t\t\tif ( index !== null ) {\r\n\t\r\n\t\t\t\tthis.setIndex( index.clone() );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar attributes = source.attributes;\r\n\t\r\n\t\t\tfor ( var name in attributes ) {\r\n\t\r\n\t\t\t\tvar attribute = attributes[ name ];\r\n\t\t\t\tthis.addAttribute( name, attribute.clone() );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar groups = source.groups;\r\n\t\r\n\t\t\tfor ( var i = 0, l = groups.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tvar group = groups[ i ];\r\n\t\t\t\tthis.addGroup( group.start, group.count, group.materialIndex );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdispose: function () {\r\n\t\r\n\t\t\tthis.dispatchEvent( { type: 'dispose' } );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.EventDispatcher.prototype.apply( THREE.BufferGeometry.prototype );\r\n\t\r\n\tTHREE.BufferGeometry.MaxIndex = 65535;\r\n\t\r\n\t// File:src/core/InstancedBufferGeometry.js\r\n\t\r\n\t/**\r\n\t * @author benaadams / https://twitter.com/ben_a_adams\r\n\t */\r\n\t\r\n\tTHREE.InstancedBufferGeometry = function () {\r\n\t\r\n\t\tTHREE.BufferGeometry.call( this );\r\n\t\r\n\t\tthis.type = 'InstancedBufferGeometry';\r\n\t\tthis.maxInstancedCount = undefined;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.InstancedBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\n\tTHREE.InstancedBufferGeometry.prototype.constructor = THREE.InstancedBufferGeometry;\r\n\t\r\n\tTHREE.InstancedBufferGeometry.prototype.addGroup = function ( start, count, instances ) {\r\n\t\r\n\t\tthis.groups.push( {\r\n\t\r\n\t\t\tstart: start,\r\n\t\t\tcount: count,\r\n\t\t\tinstances: instances\r\n\t\r\n\t\t} );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.InstancedBufferGeometry.prototype.copy = function ( source ) {\r\n\t\r\n\t\tvar index = source.index;\r\n\t\r\n\t\tif ( index !== null ) {\r\n\t\r\n\t\t\tthis.setIndex( index.clone() );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar attributes = source.attributes;\r\n\t\r\n\t\tfor ( var name in attributes ) {\r\n\t\r\n\t\t\tvar attribute = attributes[ name ];\r\n\t\t\tthis.addAttribute( name, attribute.clone() );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar groups = source.groups;\r\n\t\r\n\t\tfor ( var i = 0, l = groups.length; i < l; i ++ ) {\r\n\t\r\n\t\t\tvar group = groups[ i ];\r\n\t\t\tthis.addGroup( group.start, group.count, group.instances );\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn this;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.EventDispatcher.prototype.apply( THREE.InstancedBufferGeometry.prototype );\r\n\t\r\n\t// File:src/core/Uniform.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.Uniform = function ( value ) {\r\n\t\r\n\t\tif ( typeof value === 'string' ) {\r\n\t\r\n\t\t\tconsole.warn( 'THREE.Uniform: Type parameter is no longer needed.' );\r\n\t\t\tvalue = arguments[ 1 ];\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.value = value;\r\n\t\r\n\t\tthis.dynamic = false;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Uniform.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Uniform,\r\n\t\r\n\t\tonUpdate: function ( callback ) {\r\n\t\r\n\t\t\tthis.dynamic = true;\r\n\t\t\tthis.onUpdateCallback = callback;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/animation/AnimationClip.js\r\n\t\r\n\t/**\r\n\t *\r\n\t * Reusable set of Tracks that represent an animation.\r\n\t *\r\n\t * @author Ben Houston / http://clara.io/\r\n\t * @author David Sarno / http://lighthaus.us/\r\n\t */\r\n\t\r\n\tTHREE.AnimationClip = function ( name, duration, tracks ) {\r\n\t\r\n\t\tthis.name = name || THREE.Math.generateUUID();\r\n\t\tthis.tracks = tracks;\r\n\t\tthis.duration = ( duration !== undefined ) ? duration : -1;\r\n\t\r\n\t\t// this means it should figure out its duration by scanning the tracks\r\n\t\tif ( this.duration < 0 ) {\r\n\t\r\n\t\t\tthis.resetDuration();\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// maybe only do these on demand, as doing them here could potentially slow down loading\r\n\t\t// but leaving these here during development as this ensures a lot of testing of these functions\r\n\t\tthis.trim();\r\n\t\tthis.optimize();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.AnimationClip.prototype = {\r\n\t\r\n\t\tconstructor: THREE.AnimationClip,\r\n\t\r\n\t\tresetDuration: function() {\r\n\t\r\n\t\t\tvar tracks = this.tracks,\r\n\t\t\t\tduration = 0;\r\n\t\r\n\t\t\tfor ( var i = 0, n = tracks.length; i !== n; ++ i ) {\r\n\t\r\n\t\t\t\tvar track = this.tracks[ i ];\r\n\t\r\n\t\t\t\tduration = Math.max(\r\n\t\t\t\t\t\tduration, track.times[ track.times.length - 1 ] );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.duration = duration;\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttrim: function() {\r\n\t\r\n\t\t\tfor ( var i = 0; i < this.tracks.length; i ++ ) {\r\n\t\r\n\t\t\t\tthis.tracks[ i ].trim( 0, this.duration );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\toptimize: function() {\r\n\t\r\n\t\t\tfor ( var i = 0; i < this.tracks.length; i ++ ) {\r\n\t\r\n\t\t\t\tthis.tracks[ i ].optimize();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// Static methods:\r\n\t\r\n\tObject.assign( THREE.AnimationClip, {\r\n\t\r\n\t\tparse: function( json ) {\r\n\t\r\n\t\t\tvar tracks = [],\r\n\t\t\t\tjsonTracks = json.tracks,\r\n\t\t\t\tframeTime = 1.0 / ( json.fps || 1.0 );\r\n\t\r\n\t\t\tfor ( var i = 0, n = jsonTracks.length; i !== n; ++ i ) {\r\n\t\r\n\t\t\t\ttracks.push( THREE.KeyframeTrack.parse( jsonTracks[ i ] ).scale( frameTime ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn new THREE.AnimationClip( json.name, json.duration, tracks );\r\n\t\r\n\t\t},\r\n\t\r\n\t\r\n\t\ttoJSON: function( clip ) {\r\n\t\r\n\t\t\tvar tracks = [],\r\n\t\t\t\tclipTracks = clip.tracks;\r\n\t\r\n\t\t\tvar json = {\r\n\t\r\n\t\t\t\t'name': clip.name,\r\n\t\t\t\t'duration': clip.duration,\r\n\t\t\t\t'tracks': tracks\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t\tfor ( var i = 0, n = clipTracks.length; i !== n; ++ i ) {\r\n\t\r\n\t\t\t\ttracks.push( THREE.KeyframeTrack.toJSON( clipTracks[ i ] ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn json;\r\n\t\r\n\t\t},\r\n\t\r\n\t\r\n\t\tCreateFromMorphTargetSequence: function( name, morphTargetSequence, fps, noLoop ) {\r\n\t\r\n\t\t\tvar numMorphTargets = morphTargetSequence.length;\r\n\t\t\tvar tracks = [];\r\n\t\r\n\t\t\tfor ( var i = 0; i < numMorphTargets; i ++ ) {\r\n\t\r\n\t\t\t\tvar times = [];\r\n\t\t\t\tvar values = [];\r\n\t\r\n\t\t\t\ttimes.push(\r\n\t\t\t\t\t\t( i + numMorphTargets - 1 ) % numMorphTargets,\r\n\t\t\t\t\t\ti,\r\n\t\t\t\t\t\t( i + 1 ) % numMorphTargets );\r\n\t\r\n\t\t\t\tvalues.push( 0, 1, 0 );\r\n\t\r\n\t\t\t\tvar order = THREE.AnimationUtils.getKeyframeOrder( times );\r\n\t\t\t\ttimes = THREE.AnimationUtils.sortedArray( times, 1, order );\r\n\t\t\t\tvalues = THREE.AnimationUtils.sortedArray( values, 1, order );\r\n\t\r\n\t\t\t\t// if there is a key at the first frame, duplicate it as the\r\n\t\t\t\t// last frame as well for perfect loop.\r\n\t\t\t\tif ( ! noLoop && times[ 0 ] === 0 ) {\r\n\t\r\n\t\t\t\t\ttimes.push( numMorphTargets );\r\n\t\t\t\t\tvalues.push( values[ 0 ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\ttracks.push(\r\n\t\t\t\t\t\tnew THREE.NumberKeyframeTrack(\r\n\t\t\t\t\t\t\t'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',\r\n\t\t\t\t\t\t\ttimes, values\r\n\t\t\t\t\t\t).scale( 1.0 / fps ) );\r\n\t\t\t}\r\n\t\r\n\t\t\treturn new THREE.AnimationClip( name, -1, tracks );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfindByName: function( clipArray, name ) {\r\n\t\r\n\t\t\tfor ( var i = 0; i < clipArray.length; i ++ ) {\r\n\t\r\n\t\t\t\tif ( clipArray[ i ].name === name ) {\r\n\t\r\n\t\t\t\t\treturn clipArray[ i ];\r\n\t\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\r\n\t\t\treturn null;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tCreateClipsFromMorphTargetSequences: function( morphTargets, fps, noLoop ) {\r\n\t\r\n\t\t\tvar animationToMorphTargets = {};\r\n\t\r\n\t\t\t// tested with https://regex101.com/ on trick sequences\r\n\t\t\t// such flamingo_flyA_003, flamingo_run1_003, crdeath0059\r\n\t\t\tvar pattern = /^([\\w-]*?)([\\d]+)$/;\r\n\t\r\n\t\t\t// sort morph target names into animation groups based\r\n\t\t\t// patterns like Walk_001, Walk_002, Run_001, Run_002\r\n\t\t\tfor ( var i = 0, il = morphTargets.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tvar morphTarget = morphTargets[ i ];\r\n\t\t\t\tvar parts = morphTarget.name.match( pattern );\r\n\t\r\n\t\t\t\tif ( parts && parts.length > 1 ) {\r\n\t\r\n\t\t\t\t\tvar name = parts[ 1 ];\r\n\t\r\n\t\t\t\t\tvar animationMorphTargets = animationToMorphTargets[ name ];\r\n\t\t\t\t\tif ( ! animationMorphTargets ) {\r\n\t\r\n\t\t\t\t\t\tanimationToMorphTargets[ name ] = animationMorphTargets = [];\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tanimationMorphTargets.push( morphTarget );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar clips = [];\r\n\t\r\n\t\t\tfor ( var name in animationToMorphTargets ) {\r\n\t\r\n\t\t\t\tclips.push( THREE.AnimationClip.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn clips;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// parse the animation.hierarchy format\r\n\t\tparseAnimation: function( animation, bones, nodeName ) {\r\n\t\r\n\t\t\tif ( ! animation ) {\r\n\t\r\n\t\t\t\tconsole.error( \"  no animation in JSONLoader data\" );\r\n\t\t\t\treturn null;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar addNonemptyTrack = function(\r\n\t\t\t\t\ttrackType, trackName, animationKeys, propertyName, destTracks ) {\r\n\t\r\n\t\t\t\t// only return track if there are actually keys.\r\n\t\t\t\tif ( animationKeys.length !== 0 ) {\r\n\t\r\n\t\t\t\t\tvar times = [];\r\n\t\t\t\t\tvar values = [];\r\n\t\r\n\t\t\t\t\tTHREE.AnimationUtils.flattenJSON(\r\n\t\t\t\t\t\t\tanimationKeys, times, values, propertyName );\r\n\t\r\n\t\t\t\t\t// empty keys are filtered out, so check again\r\n\t\t\t\t\tif ( times.length !== 0 ) {\r\n\t\r\n\t\t\t\t\t\tdestTracks.push( new trackType( trackName, times, values ) );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t\tvar tracks = [];\r\n\t\r\n\t\t\tvar clipName = animation.name || 'default';\r\n\t\t\t// automatic length determination in AnimationClip.\r\n\t\t\tvar duration = animation.length || -1;\r\n\t\t\tvar fps = animation.fps || 30;\r\n\t\r\n\t\t\tvar hierarchyTracks = animation.hierarchy || [];\r\n\t\r\n\t\t\tfor ( var h = 0; h < hierarchyTracks.length; h ++ ) {\r\n\t\r\n\t\t\t\tvar animationKeys = hierarchyTracks[ h ].keys;\r\n\t\r\n\t\t\t\t// skip empty tracks\r\n\t\t\t\tif ( ! animationKeys || animationKeys.length == 0 ) continue;\r\n\t\r\n\t\t\t\t// process morph targets in a way exactly compatible\r\n\t\t\t\t// with AnimationHandler.init( animation )\r\n\t\t\t\tif ( animationKeys[0].morphTargets ) {\r\n\t\r\n\t\t\t\t\t// figure out all morph targets used in this track\r\n\t\t\t\t\tvar morphTargetNames = {};\r\n\t\t\t\t\tfor ( var k = 0; k < animationKeys.length; k ++ ) {\r\n\t\r\n\t\t\t\t\t\tif ( animationKeys[k].morphTargets ) {\r\n\t\r\n\t\t\t\t\t\t\tfor ( var m = 0; m < animationKeys[k].morphTargets.length; m ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\tmorphTargetNames[ animationKeys[k].morphTargets[m] ] = -1;\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t// create a track for each morph target with all zero\r\n\t\t\t\t\t// morphTargetInfluences except for the keys in which\r\n\t\t\t\t\t// the morphTarget is named.\r\n\t\t\t\t\tfor ( var morphTargetName in morphTargetNames ) {\r\n\t\r\n\t\t\t\t\t\tvar times = [];\r\n\t\t\t\t\t\tvar values = [];\r\n\t\r\n\t\t\t\t\t\tfor ( var m = 0;\r\n\t\t\t\t\t\t\t\tm !== animationKeys[k].morphTargets.length; ++ m ) {\r\n\t\r\n\t\t\t\t\t\t\tvar animationKey = animationKeys[k];\r\n\t\r\n\t\t\t\t\t\t\ttimes.push( animationKey.time );\r\n\t\t\t\t\t\t\tvalues.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 )\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\ttracks.push( new THREE.NumberKeyframeTrack(\r\n\t\t\t\t\t\t\t\t'.morphTargetInfluence[' + morphTargetName + ']', times, values ) );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tduration = morphTargetNames.length * ( fps || 1.0 );\r\n\t\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// ...assume skeletal animation\r\n\t\r\n\t\t\t\t\tvar boneName = '.bones[' + bones[ h ].name + ']';\r\n\t\r\n\t\t\t\t\taddNonemptyTrack(\r\n\t\t\t\t\t\t\tTHREE.VectorKeyframeTrack, boneName + '.position',\r\n\t\t\t\t\t\t\tanimationKeys, 'pos', tracks );\r\n\t\r\n\t\t\t\t\taddNonemptyTrack(\r\n\t\t\t\t\t\t\tTHREE.QuaternionKeyframeTrack, boneName + '.quaternion',\r\n\t\t\t\t\t\t\tanimationKeys, 'rot', tracks );\r\n\t\r\n\t\t\t\t\taddNonemptyTrack(\r\n\t\t\t\t\t\t\tTHREE.VectorKeyframeTrack, boneName + '.scale',\r\n\t\t\t\t\t\t\tanimationKeys, 'scl', tracks );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( tracks.length === 0 ) {\r\n\t\r\n\t\t\t\treturn null;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar clip = new THREE.AnimationClip( clipName, duration, tracks );\r\n\t\r\n\t\t\treturn clip;\r\n\t\r\n\t\t}\r\n\t\r\n\t} );\r\n\t\r\n\t\r\n\t// File:src/animation/AnimationMixer.js\r\n\t\r\n\t/**\r\n\t *\r\n\t * Player for AnimationClips.\r\n\t *\r\n\t *\r\n\t * @author Ben Houston / http://clara.io/\r\n\t * @author David Sarno / http://lighthaus.us/\r\n\t * @author tschw\r\n\t */\r\n\t\r\n\tTHREE.AnimationMixer = function( root ) {\r\n\t\r\n\t\tthis._root = root;\r\n\t\tthis._initMemoryManager();\r\n\t\tthis._accuIndex = 0;\r\n\t\r\n\t\tthis.time = 0;\r\n\t\r\n\t\tthis.timeScale = 1.0;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.AnimationMixer.prototype = {\r\n\t\r\n\t\tconstructor: THREE.AnimationMixer,\r\n\t\r\n\t\t// return an action for a clip optionally using a custom root target\r\n\t\t// object (this method allocates a lot of dynamic memory in case a\r\n\t\t// previously unknown clip/root combination is specified)\r\n\t\tclipAction: function( clip, optionalRoot ) {\r\n\t\r\n\t\t\tvar root = optionalRoot || this._root,\r\n\t\t\t\trootUuid = root.uuid,\r\n\t\t\t\tclipName = ( typeof clip === 'string' ) ? clip : clip.name,\r\n\t\t\t\tclipObject = ( clip !== clipName ) ? clip : null,\r\n\t\r\n\t\t\t\tactionsForClip = this._actionsByClip[ clipName ],\r\n\t\t\t\tprototypeAction;\r\n\t\r\n\t\t\tif ( actionsForClip !== undefined ) {\r\n\t\r\n\t\t\t\tvar existingAction =\r\n\t\t\t\t\t\tactionsForClip.actionByRoot[ rootUuid ];\r\n\t\r\n\t\t\t\tif ( existingAction !== undefined ) {\r\n\t\r\n\t\t\t\t\treturn existingAction;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// we know the clip, so we don't have to parse all\r\n\t\t\t\t// the bindings again but can just copy\r\n\t\t\t\tprototypeAction = actionsForClip.knownActions[ 0 ];\r\n\t\r\n\t\t\t\t// also, take the clip from the prototype action\r\n\t\t\t\tclipObject = prototypeAction._clip;\r\n\t\r\n\t\t\t\tif ( clip !== clipName && clip !== clipObject ) {\r\n\t\r\n\t\t\t\t\tthrow new Error(\r\n\t\t\t\t\t\t\t\"Different clips with the same name detected!\" );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// clip must be known when specified via string\r\n\t\t\tif ( clipObject === null ) return null;\r\n\t\r\n\t\t\t// allocate all resources required to run it\r\n\t\t\tvar newAction = new THREE.\r\n\t\t\t\t\tAnimationMixer._Action( this, clipObject, optionalRoot );\r\n\t\r\n\t\t\tthis._bindAction( newAction, prototypeAction );\r\n\t\r\n\t\t\t// and make the action known to the memory manager\r\n\t\t\tthis._addInactiveAction( newAction, clipName, rootUuid );\r\n\t\r\n\t\t\treturn newAction;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// get an existing action\r\n\t\texistingAction: function( clip, optionalRoot ) {\r\n\t\r\n\t\t\tvar root = optionalRoot || this._root,\r\n\t\t\t\trootUuid = root.uuid,\r\n\t\t\t\tclipName = ( typeof clip === 'string' ) ? clip : clip.name,\r\n\t\t\t\tactionsForClip = this._actionsByClip[ clipName ];\r\n\t\r\n\t\t\tif ( actionsForClip !== undefined ) {\r\n\t\r\n\t\t\t\treturn actionsForClip.actionByRoot[ rootUuid ] || null;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn null;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// deactivates all previously scheduled actions\r\n\t\tstopAllAction: function() {\r\n\t\r\n\t\t\tvar actions = this._actions,\r\n\t\t\t\tnActions = this._nActiveActions,\r\n\t\t\t\tbindings = this._bindings,\r\n\t\t\t\tnBindings = this._nActiveBindings;\r\n\t\r\n\t\t\tthis._nActiveActions = 0;\r\n\t\t\tthis._nActiveBindings = 0;\r\n\t\r\n\t\t\tfor ( var i = 0; i !== nActions; ++ i ) {\r\n\t\r\n\t\t\t\tactions[ i ].reset();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( var i = 0; i !== nBindings; ++ i ) {\r\n\t\r\n\t\t\t\tbindings[ i ].useCount = 0;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// advance the time and update apply the animation\r\n\t\tupdate: function( deltaTime ) {\r\n\t\r\n\t\t\tdeltaTime *= this.timeScale;\r\n\t\r\n\t\t\tvar actions = this._actions,\r\n\t\t\t\tnActions = this._nActiveActions,\r\n\t\r\n\t\t\t\ttime = this.time += deltaTime,\r\n\t\t\t\ttimeDirection = Math.sign( deltaTime ),\r\n\t\r\n\t\t\t\taccuIndex = this._accuIndex ^= 1;\r\n\t\r\n\t\t\t// run active actions\r\n\t\r\n\t\t\tfor ( var i = 0; i !== nActions; ++ i ) {\r\n\t\r\n\t\t\t\tvar action = actions[ i ];\r\n\t\r\n\t\t\t\tif ( action.enabled ) {\r\n\t\r\n\t\t\t\t\taction._update( time, deltaTime, timeDirection, accuIndex );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// update scene graph\r\n\t\r\n\t\t\tvar bindings = this._bindings,\r\n\t\t\t\tnBindings = this._nActiveBindings;\r\n\t\r\n\t\t\tfor ( var i = 0; i !== nBindings; ++ i ) {\r\n\t\r\n\t\t\t\tbindings[ i ].apply( accuIndex );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// return this mixer's root target object\r\n\t\tgetRoot: function() {\r\n\t\r\n\t\t\treturn this._root;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// free all resources specific to a particular clip\r\n\t\tuncacheClip: function( clip ) {\r\n\t\r\n\t\t\tvar actions = this._actions,\r\n\t\t\t\tclipName = clip.name,\r\n\t\t\t\tactionsByClip = this._actionsByClip,\r\n\t\t\t\tactionsForClip = actionsByClip[ clipName ];\r\n\t\r\n\t\t\tif ( actionsForClip !== undefined ) {\r\n\t\r\n\t\t\t\t// note: just calling _removeInactiveAction would mess up the\r\n\t\t\t\t// iteration state and also require updating the state we can\r\n\t\t\t\t// just throw away\r\n\t\r\n\t\t\t\tvar actionsToRemove = actionsForClip.knownActions;\r\n\t\r\n\t\t\t\tfor ( var i = 0, n = actionsToRemove.length; i !== n; ++ i ) {\r\n\t\r\n\t\t\t\t\tvar action = actionsToRemove[ i ];\r\n\t\r\n\t\t\t\t\tthis._deactivateAction( action );\r\n\t\r\n\t\t\t\t\tvar cacheIndex = action._cacheIndex,\r\n\t\t\t\t\t\tlastInactiveAction = actions[ actions.length - 1 ];\r\n\t\r\n\t\t\t\t\taction._cacheIndex = null;\r\n\t\t\t\t\taction._byClipCacheIndex = null;\r\n\t\r\n\t\t\t\t\tlastInactiveAction._cacheIndex = cacheIndex;\r\n\t\t\t\t\tactions[ cacheIndex ] = lastInactiveAction;\r\n\t\t\t\t\tactions.pop();\r\n\t\r\n\t\t\t\t\tthis._removeInactiveBindingsForAction( action );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tdelete actionsByClip[ clipName ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// free all resources specific to a particular root target object\r\n\t\tuncacheRoot: function( root ) {\r\n\t\r\n\t\t\tvar rootUuid = root.uuid,\r\n\t\t\t\tactionsByClip = this._actionsByClip;\r\n\t\r\n\t\t\tfor ( var clipName in actionsByClip ) {\r\n\t\r\n\t\t\t\tvar actionByRoot = actionsByClip[ clipName ].actionByRoot,\r\n\t\t\t\t\taction = actionByRoot[ rootUuid ];\r\n\t\r\n\t\t\t\tif ( action !== undefined ) {\r\n\t\r\n\t\t\t\t\tthis._deactivateAction( action );\r\n\t\t\t\t\tthis._removeInactiveAction( action );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar bindingsByRoot = this._bindingsByRootAndName,\r\n\t\t\t\tbindingByName = bindingsByRoot[ rootUuid ];\r\n\t\r\n\t\t\tif ( bindingByName !== undefined ) {\r\n\t\r\n\t\t\t\tfor ( var trackName in bindingByName ) {\r\n\t\r\n\t\t\t\t\tvar binding = bindingByName[ trackName ];\r\n\t\t\t\t\tbinding.restoreOriginalState();\r\n\t\t\t\t\tthis._removeInactiveBinding( binding );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// remove a targeted clip from the cache\r\n\t\tuncacheAction: function( clip, optionalRoot ) {\r\n\t\r\n\t\t\tvar action = this.existingAction( clip, optionalRoot );\r\n\t\r\n\t\t\tif ( action !== null ) {\r\n\t\r\n\t\t\t\tthis._deactivateAction( action );\r\n\t\t\t\tthis._removeInactiveAction( action );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.EventDispatcher.prototype.apply( THREE.AnimationMixer.prototype );\r\n\t\r\n\tTHREE.AnimationMixer._Action =\r\n\t\t\tfunction( mixer, clip, localRoot ) {\r\n\t\r\n\t\tthis._mixer = mixer;\r\n\t\tthis._clip = clip;\r\n\t\tthis._localRoot = localRoot || null;\r\n\t\r\n\t\tvar tracks = clip.tracks,\r\n\t\t\tnTracks = tracks.length,\r\n\t\t\tinterpolants = new Array( nTracks );\r\n\t\r\n\t\tvar interpolantSettings = {\r\n\t\t\t\tendingStart: \tTHREE.ZeroCurvatureEnding,\r\n\t\t\t\tendingEnd:\t\tTHREE.ZeroCurvatureEnding\r\n\t\t};\r\n\t\r\n\t\tfor ( var i = 0; i !== nTracks; ++ i ) {\r\n\t\r\n\t\t\tvar interpolant = tracks[ i ].createInterpolant( null );\r\n\t\t\tinterpolants[ i ] = interpolant;\r\n\t\t\tinterpolant.settings = interpolantSettings\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis._interpolantSettings = interpolantSettings;\r\n\t\r\n\t\tthis._interpolants = interpolants;\t// bound by the mixer\r\n\t\r\n\t\t// inside: PropertyMixer (managed by the mixer)\r\n\t\tthis._propertyBindings = new Array( nTracks );\r\n\t\r\n\t\tthis._cacheIndex = null;\t\t\t// for the memory manager\r\n\t\tthis._byClipCacheIndex = null;\t\t// for the memory manager\r\n\t\r\n\t\tthis._timeScaleInterpolant = null;\r\n\t\tthis._weightInterpolant = null;\r\n\t\r\n\t\tthis.loop = THREE.LoopRepeat;\r\n\t\tthis._loopCount = -1;\r\n\t\r\n\t\t// global mixer time when the action is to be started\r\n\t\t// it's set back to 'null' upon start of the action\r\n\t\tthis._startTime = null;\r\n\t\r\n\t\t// scaled local time of the action\r\n\t\t// gets clamped or wrapped to 0..clip.duration according to loop\r\n\t\tthis.time = 0;\r\n\t\r\n\t\tthis.timeScale = 1;\r\n\t\tthis._effectiveTimeScale = 1;\r\n\t\r\n\t\tthis.weight = 1;\r\n\t\tthis._effectiveWeight = 1;\r\n\t\r\n\t\tthis.repetitions = Infinity; \t\t// no. of repetitions when looping\r\n\t\r\n\t\tthis.paused = false;\t\t\t\t// false -> zero effective time scale\r\n\t\tthis.enabled = true;\t\t\t\t// true -> zero effective weight\r\n\t\r\n\t\tthis.clampWhenFinished \t= false;\t// keep feeding the last frame?\r\n\t\r\n\t\tthis.zeroSlopeAtStart \t= true;\t\t// for smooth interpolation w/o separate\r\n\t\tthis.zeroSlopeAtEnd\t\t= true;\t\t// clips for start, loop and end\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.AnimationMixer._Action.prototype = {\r\n\t\r\n\t\tconstructor: THREE.AnimationMixer._Action,\r\n\t\r\n\t\t// State & Scheduling\r\n\t\r\n\t\tplay: function() {\r\n\t\r\n\t\t\tthis._mixer._activateAction( this );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tstop: function() {\r\n\t\r\n\t\t\tthis._mixer._deactivateAction( this );\r\n\t\r\n\t\t\treturn this.reset();\r\n\t\r\n\t\t},\r\n\t\r\n\t\treset: function() {\r\n\t\r\n\t\t\tthis.paused = false;\r\n\t\t\tthis.enabled = true;\r\n\t\r\n\t\t\tthis.time = 0;\t\t\t// restart clip\r\n\t\t\tthis._loopCount = -1;\t// forget previous loops\r\n\t\t\tthis._startTime = null;\t// forget scheduling\r\n\t\r\n\t\t\treturn this.stopFading().stopWarping();\r\n\t\r\n\t\t},\r\n\t\r\n\t\tisRunning: function() {\r\n\t\r\n\t\t\tvar start = this._startTime;\r\n\t\r\n\t\t\treturn this.enabled && ! this.paused && this.timeScale !== 0 &&\r\n\t\t\t\t\tthis._startTime === null && this._mixer._isActiveAction( this )\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// return true when play has been called\r\n\t\tisScheduled: function() {\r\n\t\r\n\t\t\treturn this._mixer._isActiveAction( this );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tstartAt: function( time ) {\r\n\t\r\n\t\t\tthis._startTime = time;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetLoop: function( mode, repetitions ) {\r\n\t\r\n\t\t\tthis.loop = mode;\r\n\t\t\tthis.repetitions = repetitions;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Weight\r\n\t\r\n\t\t// set the weight stopping any scheduled fading\r\n\t\t// although .enabled = false yields an effective weight of zero, this\r\n\t\t// method does *not* change .enabled, because it would be confusing\r\n\t\tsetEffectiveWeight: function( weight ) {\r\n\t\r\n\t\t\tthis.weight = weight;\r\n\t\r\n\t\t\t// note: same logic as when updated at runtime\r\n\t\t\tthis._effectiveWeight = this.enabled ? weight : 0;\r\n\t\r\n\t\t\treturn this.stopFading();\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// return the weight considering fading and .enabled\r\n\t\tgetEffectiveWeight: function() {\r\n\t\r\n\t\t\treturn this._effectiveWeight;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfadeIn: function( duration ) {\r\n\t\r\n\t\t\treturn this._scheduleFading( duration, 0, 1 );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfadeOut: function( duration ) {\r\n\t\r\n\t\t\treturn this._scheduleFading( duration, 1, 0 );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcrossFadeFrom: function( fadeOutAction, duration, warp ) {\r\n\t\r\n\t\t\tvar mixer = this._mixer;\r\n\t\r\n\t\t\tfadeOutAction.fadeOut( duration );\r\n\t\t\tthis.fadeIn( duration );\r\n\t\r\n\t\t\tif( warp ) {\r\n\t\r\n\t\t\t\tvar fadeInDuration = this._clip.duration,\r\n\t\t\t\t\tfadeOutDuration = fadeOutAction._clip.duration,\r\n\t\r\n\t\t\t\t\tstartEndRatio = fadeOutDuration / fadeInDuration,\r\n\t\t\t\t\tendStartRatio = fadeInDuration / fadeOutDuration;\r\n\t\r\n\t\t\t\tfadeOutAction.warp( 1.0, startEndRatio, duration );\r\n\t\t\t\tthis.warp( endStartRatio, 1.0, duration );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcrossFadeTo: function( fadeInAction, duration, warp ) {\r\n\t\r\n\t\t\treturn fadeInAction.crossFadeFrom( this, duration, warp );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tstopFading: function() {\r\n\t\r\n\t\t\tvar weightInterpolant = this._weightInterpolant;\r\n\t\r\n\t\t\tif ( weightInterpolant !== null ) {\r\n\t\r\n\t\t\t\tthis._weightInterpolant = null;\r\n\t\t\t\tthis._mixer._takeBackControlInterpolant( weightInterpolant );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Time Scale Control\r\n\t\r\n\t\t// set the weight stopping any scheduled warping\r\n\t\t// although .paused = true yields an effective time scale of zero, this\r\n\t\t// method does *not* change .paused, because it would be confusing\r\n\t\tsetEffectiveTimeScale: function( timeScale ) {\r\n\t\r\n\t\t\tthis.timeScale = timeScale;\r\n\t\t\tthis._effectiveTimeScale = this.paused ? 0 :timeScale;\r\n\t\r\n\t\t\treturn this.stopWarping();\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// return the time scale considering warping and .paused\r\n\t\tgetEffectiveTimeScale: function() {\r\n\t\r\n\t\t\treturn this._effectiveTimeScale;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetDuration: function( duration ) {\r\n\t\r\n\t\t\tthis.timeScale = this._clip.duration / duration;\r\n\t\r\n\t\t\treturn this.stopWarping();\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsyncWith: function( action ) {\r\n\t\r\n\t\t\tthis.time = action.time;\r\n\t\t\tthis.timeScale = action.timeScale;\r\n\t\r\n\t\t\treturn this.stopWarping();\r\n\t\r\n\t\t},\r\n\t\r\n\t\thalt: function( duration ) {\r\n\t\r\n\t\t\treturn this.warp( this._currentTimeScale, 0, duration );\r\n\t\r\n\t\t},\r\n\t\r\n\t\twarp: function( startTimeScale, endTimeScale, duration ) {\r\n\t\r\n\t\t\tvar mixer = this._mixer, now = mixer.time,\r\n\t\t\t\tinterpolant = this._timeScaleInterpolant,\r\n\t\r\n\t\t\t\ttimeScale = this.timeScale;\r\n\t\r\n\t\t\tif ( interpolant === null ) {\r\n\t\r\n\t\t\t\tinterpolant = mixer._lendControlInterpolant(),\r\n\t\t\t\tthis._timeScaleInterpolant = interpolant;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar times = interpolant.parameterPositions,\r\n\t\t\t\tvalues = interpolant.sampleValues;\r\n\t\r\n\t\t\ttimes[ 0 ] = now;\r\n\t\t\ttimes[ 1 ] = now + duration;\r\n\t\r\n\t\t\tvalues[ 0 ] = startTimeScale / timeScale;\r\n\t\t\tvalues[ 1 ] = endTimeScale / timeScale;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tstopWarping: function() {\r\n\t\r\n\t\t\tvar timeScaleInterpolant = this._timeScaleInterpolant;\r\n\t\r\n\t\t\tif ( timeScaleInterpolant !== null ) {\r\n\t\r\n\t\t\t\tthis._timeScaleInterpolant = null;\r\n\t\t\t\tthis._mixer._takeBackControlInterpolant( timeScaleInterpolant );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Object Accessors\r\n\t\r\n\t\tgetMixer: function() {\r\n\t\r\n\t\t\treturn this._mixer;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetClip: function() {\r\n\t\r\n\t\t\treturn this._clip;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetRoot: function() {\r\n\t\r\n\t\t\treturn this._localRoot || this._mixer._root;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Interna\r\n\t\r\n\t\t_update: function( time, deltaTime, timeDirection, accuIndex ) {\r\n\t\t\t// called by the mixer\r\n\t\r\n\t\t\tvar startTime = this._startTime;\r\n\t\r\n\t\t\tif ( startTime !== null ) {\r\n\t\r\n\t\t\t\t// check for scheduled start of action\r\n\t\r\n\t\t\t\tvar timeRunning = ( time - startTime ) * timeDirection;\r\n\t\t\t\tif ( timeRunning < 0 || timeDirection === 0 ) {\r\n\t\r\n\t\t\t\t\treturn; // yet to come / don't decide when delta = 0\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// start\r\n\t\r\n\t\t\t\tthis._startTime = null; // unschedule\r\n\t\t\t\tdeltaTime = timeDirection * timeRunning;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// apply time scale and advance time\r\n\t\r\n\t\t\tdeltaTime *= this._updateTimeScale( time );\r\n\t\t\tvar clipTime = this._updateTime( deltaTime );\r\n\t\r\n\t\t\t// note: _updateTime may disable the action resulting in\r\n\t\t\t// an effective weight of 0\r\n\t\r\n\t\t\tvar weight = this._updateWeight( time );\r\n\t\r\n\t\t\tif ( weight > 0 ) {\r\n\t\r\n\t\t\t\tvar interpolants = this._interpolants;\r\n\t\t\t\tvar propertyMixers = this._propertyBindings;\r\n\t\r\n\t\t\t\tfor ( var j = 0, m = interpolants.length; j !== m; ++ j ) {\r\n\t\r\n\t\t\t\t\tinterpolants[ j ].evaluate( clipTime );\r\n\t\t\t\t\tpropertyMixers[ j ].accumulate( accuIndex, weight );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\t_updateWeight: function( time ) {\r\n\t\r\n\t\t\tvar weight = 0;\r\n\t\r\n\t\t\tif ( this.enabled ) {\r\n\t\r\n\t\t\t\tweight = this.weight;\r\n\t\t\t\tvar interpolant = this._weightInterpolant;\r\n\t\r\n\t\t\t\tif ( interpolant !== null ) {\r\n\t\r\n\t\t\t\t\tvar interpolantValue = interpolant.evaluate( time )[ 0 ];\r\n\t\r\n\t\t\t\t\tweight *= interpolantValue;\r\n\t\r\n\t\t\t\t\tif ( time > interpolant.parameterPositions[ 1 ] ) {\r\n\t\r\n\t\t\t\t\t\tthis.stopFading();\r\n\t\r\n\t\t\t\t\t\tif ( interpolantValue === 0 ) {\r\n\t\r\n\t\t\t\t\t\t\t// faded out, disable\r\n\t\t\t\t\t\t\tthis.enabled = false;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis._effectiveWeight = weight;\r\n\t\t\treturn weight;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t_updateTimeScale: function( time ) {\r\n\t\r\n\t\t\tvar timeScale = 0;\r\n\t\r\n\t\t\tif ( ! this.paused ) {\r\n\t\r\n\t\t\t\ttimeScale = this.timeScale;\r\n\t\r\n\t\t\t\tvar interpolant = this._timeScaleInterpolant;\r\n\t\r\n\t\t\t\tif ( interpolant !== null ) {\r\n\t\r\n\t\t\t\t\tvar interpolantValue = interpolant.evaluate( time )[ 0 ];\r\n\t\r\n\t\t\t\t\ttimeScale *= interpolantValue;\r\n\t\r\n\t\t\t\t\tif ( time > interpolant.parameterPositions[ 1 ] ) {\r\n\t\r\n\t\t\t\t\t\tthis.stopWarping();\r\n\t\r\n\t\t\t\t\t\tif ( timeScale === 0 ) {\r\n\t\r\n\t\t\t\t\t\t\t// motion has halted, pause\r\n\t\t\t\t\t\t\tthis.pause = true;\r\n\t\r\n\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\t// warp done - apply final time scale\r\n\t\t\t\t\t\t\tthis.timeScale = timeScale;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis._effectiveTimeScale = timeScale;\r\n\t\t\treturn timeScale;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t_updateTime: function( deltaTime ) {\r\n\t\r\n\t\t\tvar time = this.time + deltaTime;\r\n\t\r\n\t\t\tif ( deltaTime === 0 ) return time;\r\n\t\r\n\t\t\tvar duration = this._clip.duration,\r\n\t\r\n\t\t\t\tloop = this.loop,\r\n\t\t\t\tloopCount = this._loopCount,\r\n\t\r\n\t\t\t\tpingPong = false;\r\n\t\r\n\t\t\tswitch ( loop ) {\r\n\t\r\n\t\t\t\tcase THREE.LoopOnce:\r\n\t\r\n\t\t\t\t\tif ( loopCount === -1 ) {\r\n\t\r\n\t\t\t\t\t\t// just started\r\n\t\r\n\t\t\t\t\t\tthis.loopCount = 0;\r\n\t\t\t\t\t\tthis._setEndings( true, true, false );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( time >= duration ) {\r\n\t\r\n\t\t\t\t\t\ttime = duration;\r\n\t\r\n\t\t\t\t\t} else if ( time < 0 ) {\r\n\t\r\n\t\t\t\t\t\ttime = 0;\r\n\t\r\n\t\t\t\t\t} else break;\r\n\t\r\n\t\t\t\t\t// reached the end\r\n\t\r\n\t\t\t\t\tif ( this.clampWhenFinished ) this.pause = true;\r\n\t\t\t\t\telse this.enabled = false;\r\n\t\r\n\t\t\t\t\tthis._mixer.dispatchEvent( {\r\n\t\t\t\t\t\ttype: 'finished', action: this,\r\n\t\t\t\t\t\tdirection: deltaTime < 0 ? -1 : 1\r\n\t\t\t\t\t} );\r\n\t\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\tcase THREE.LoopPingPong:\r\n\t\r\n\t\t\t\t\tpingPong = true;\r\n\t\r\n\t\t\t\tcase THREE.LoopRepeat:\r\n\t\r\n\t\t\t\t\tif ( loopCount === -1 ) {\r\n\t\r\n\t\t\t\t\t\t// just started\r\n\t\r\n\t\t\t\t\t\tif ( deltaTime > 0 ) {\r\n\t\r\n\t\t\t\t\t\t\tloopCount = 0;\r\n\t\r\n\t\t\t\t\t\t\tthis._setEndings(\r\n\t\t\t\t\t\t\t\t\ttrue, this.repetitions === 0, pingPong );\r\n\t\r\n\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\t// when looping in reverse direction, the initial\r\n\t\t\t\t\t\t\t// transition through zero counts as a repetition,\r\n\t\t\t\t\t\t\t// so leave loopCount at -1\r\n\t\r\n\t\t\t\t\t\t\tthis._setEndings(\r\n\t\t\t\t\t\t\t\t\tthis.repetitions === 0, true, pingPong );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( time >= duration || time < 0 ) {\r\n\t\r\n\t\t\t\t\t\t// wrap around\r\n\t\r\n\t\t\t\t\t\tvar loopDelta = Math.floor( time / duration ); // signed\r\n\t\t\t\t\t\ttime -= duration * loopDelta;\r\n\t\r\n\t\t\t\t\t\tloopCount += Math.abs( loopDelta );\r\n\t\r\n\t\t\t\t\t\tvar pending = this.repetitions - loopCount;\r\n\t\r\n\t\t\t\t\t\tif ( pending < 0 ) {\r\n\t\r\n\t\t\t\t\t\t\t// stop (switch state, clamp time, fire event)\r\n\t\r\n\t\t\t\t\t\t\tif ( this.clampWhenFinished ) this.paused = true;\r\n\t\t\t\t\t\t\telse this.enabled = false;\r\n\t\r\n\t\t\t\t\t\t\ttime = deltaTime > 0 ? duration : 0;\r\n\t\r\n\t\t\t\t\t\t\tthis._mixer.dispatchEvent( {\r\n\t\t\t\t\t\t\t\ttype: 'finished', action: this,\r\n\t\t\t\t\t\t\t\tdirection: deltaTime > 0 ? 1 : -1\r\n\t\t\t\t\t\t\t} );\r\n\t\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\t} else if ( pending === 0 ) {\r\n\t\r\n\t\t\t\t\t\t\t// transition to last round\r\n\t\r\n\t\t\t\t\t\t\tvar atStart = deltaTime < 0;\r\n\t\t\t\t\t\t\tthis._setEndings( atStart, ! atStart, pingPong );\r\n\t\r\n\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\tthis._setEndings( false, false, pingPong );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tthis._loopCount = loopCount;\r\n\t\r\n\t\t\t\t\t\tthis._mixer.dispatchEvent( {\r\n\t\t\t\t\t\t\ttype: 'loop', action: this, loopDelta: loopDelta\r\n\t\t\t\t\t\t} );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( loop === THREE.LoopPingPong && ( loopCount & 1 ) === 1 ) {\r\n\t\r\n\t\t\t\t\t\t// invert time for the \"pong round\"\r\n\t\r\n\t\t\t\t\t\tthis.time = time;\r\n\t\r\n\t\t\t\t\t\treturn duration - time;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.time = time;\r\n\t\r\n\t\t\treturn time;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t_setEndings: function( atStart, atEnd, pingPong ) {\r\n\t\r\n\t\t\tvar settings = this._interpolantSettings;\r\n\t\r\n\t\t\tif ( pingPong ) {\r\n\t\r\n\t\t\t\tsettings.endingStart \t= THREE.ZeroSlopeEnding;\r\n\t\t\t\tsettings.endingEnd\t\t= THREE.ZeroSlopeEnding;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\t// assuming for LoopOnce atStart == atEnd == true\r\n\t\r\n\t\t\t\tif ( atStart ) {\r\n\t\r\n\t\t\t\t\tsettings.endingStart = this.zeroSlopeAtStart ?\r\n\t\t\t\t\t\t\tTHREE.ZeroSlopeEnding : THREE.ZeroCurvatureEnding;\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tsettings.endingStart = THREE.WrapAroundEnding;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( atEnd ) {\r\n\t\r\n\t\t\t\t\tsettings.endingEnd = this.zeroSlopeAtEnd ?\r\n\t\t\t\t\t\t\tTHREE.ZeroSlopeEnding : THREE.ZeroCurvatureEnding;\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tsettings.endingEnd \t = THREE.WrapAroundEnding;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\t_scheduleFading: function( duration, weightNow, weightThen ) {\r\n\t\r\n\t\t\tvar mixer = this._mixer, now = mixer.time,\r\n\t\t\t\tinterpolant = this._weightInterpolant;\r\n\t\r\n\t\t\tif ( interpolant === null ) {\r\n\t\r\n\t\t\t\tinterpolant = mixer._lendControlInterpolant(),\r\n\t\t\t\tthis._weightInterpolant = interpolant;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar times = interpolant.parameterPositions,\r\n\t\t\t\tvalues = interpolant.sampleValues;\r\n\t\r\n\t\t\ttimes[ 0 ] = now; \t\t\t\tvalues[ 0 ] = weightNow;\r\n\t\t\ttimes[ 1 ] = now + duration;\tvalues[ 1 ] = weightThen;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// Implementation details:\r\n\t\r\n\tObject.assign( THREE.AnimationMixer.prototype, {\r\n\t\r\n\t\t_bindAction: function( action, prototypeAction ) {\r\n\t\r\n\t\t\tvar root = action._localRoot || this._root,\r\n\t\t\t\ttracks = action._clip.tracks,\r\n\t\t\t\tnTracks = tracks.length,\r\n\t\t\t\tbindings = action._propertyBindings,\r\n\t\t\t\tinterpolants = action._interpolants,\r\n\t\t\t\trootUuid = root.uuid,\r\n\t\t\t\tbindingsByRoot = this._bindingsByRootAndName,\r\n\t\t\t\tbindingsByName = bindingsByRoot[ rootUuid ];\r\n\t\r\n\t\t\tif ( bindingsByName === undefined ) {\r\n\t\r\n\t\t\t\tbindingsByName = {};\r\n\t\t\t\tbindingsByRoot[ rootUuid ] = bindingsByName;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( var i = 0; i !== nTracks; ++ i ) {\r\n\t\r\n\t\t\t\tvar track = tracks[ i ],\r\n\t\t\t\t\ttrackName = track.name,\r\n\t\t\t\t\tbinding = bindingsByName[ trackName ];\r\n\t\r\n\t\t\t\tif ( binding !== undefined ) {\r\n\t\r\n\t\t\t\t\tbindings[ i ] = binding;\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tbinding = bindings[ i ];\r\n\t\r\n\t\t\t\t\tif ( binding !== undefined ) {\r\n\t\r\n\t\t\t\t\t\t// existing binding, make sure the cache knows\r\n\t\r\n\t\t\t\t\t\tif ( binding._cacheIndex === null ) {\r\n\t\r\n\t\t\t\t\t\t\t++ binding.referenceCount;\r\n\t\t\t\t\t\t\tthis._addInactiveBinding( binding, rootUuid, trackName );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tcontinue;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tvar path = prototypeAction && prototypeAction.\r\n\t\t\t\t\t\t\t_propertyBindings[ i ].binding.parsedPath;\r\n\t\r\n\t\t\t\t\tbinding = new THREE.PropertyMixer(\r\n\t\t\t\t\t\t\tTHREE.PropertyBinding.create( root, trackName, path ),\r\n\t\t\t\t\t\t\ttrack.ValueTypeName, track.getValueSize() );\r\n\t\r\n\t\t\t\t\t++ binding.referenceCount;\r\n\t\t\t\t\tthis._addInactiveBinding( binding, rootUuid, trackName );\r\n\t\r\n\t\t\t\t\tbindings[ i ] = binding;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tinterpolants[ i ].resultBuffer = binding.buffer;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\t_activateAction: function( action ) {\r\n\t\r\n\t\t\tif ( ! this._isActiveAction( action ) ) {\r\n\t\r\n\t\t\t\tif ( action._cacheIndex === null ) {\r\n\t\r\n\t\t\t\t\t// this action has been forgotten by the cache, but the user\r\n\t\t\t\t\t// appears to be still using it -> rebind\r\n\t\r\n\t\t\t\t\tvar rootUuid = ( action._localRoot || this._root ).uuid,\r\n\t\t\t\t\t\tclipName = action._clip.name,\r\n\t\t\t\t\t\tactionsForClip = this._actionsByClip[ clipName ];\r\n\t\r\n\t\t\t\t\tthis._bindAction( action,\r\n\t\t\t\t\t\t\tactionsForClip && actionsForClip.knownActions[ 0 ] );\r\n\t\r\n\t\t\t\t\tthis._addInactiveAction( action, clipName, rootUuid );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar bindings = action._propertyBindings;\r\n\t\r\n\t\t\t\t// increment reference counts / sort out state\r\n\t\t\t\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\r\n\t\r\n\t\t\t\t\tvar binding = bindings[ i ];\r\n\t\r\n\t\t\t\t\tif ( binding.useCount ++ === 0 ) {\r\n\t\r\n\t\t\t\t\t\tthis._lendBinding( binding );\r\n\t\t\t\t\t\tbinding.saveOriginalState();\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tthis._lendAction( action );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\t_deactivateAction: function( action ) {\r\n\t\r\n\t\t\tif ( this._isActiveAction( action ) ) {\r\n\t\r\n\t\t\t\tvar bindings = action._propertyBindings;\r\n\t\r\n\t\t\t\t// decrement reference counts / sort out state\r\n\t\t\t\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\r\n\t\r\n\t\t\t\t\tvar binding = bindings[ i ];\r\n\t\r\n\t\t\t\t\tif ( -- binding.useCount === 0 ) {\r\n\t\r\n\t\t\t\t\t\tbinding.restoreOriginalState();\r\n\t\t\t\t\t\tthis._takeBackBinding( binding );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tthis._takeBackAction( action );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Memory manager\r\n\t\r\n\t\t_initMemoryManager: function() {\r\n\t\r\n\t\t\tthis._actions = []; // 'nActiveActions' followed by inactive ones\r\n\t\t\tthis._nActiveActions = 0;\r\n\t\r\n\t\t\tthis._actionsByClip = {};\r\n\t\t\t// inside:\r\n\t\t\t// {\r\n\t\t\t// \t\tknownActions: Array< _Action >\t- used as prototypes\r\n\t\t\t// \t\tactionByRoot: _Action\t\t\t- lookup\r\n\t\t\t// }\r\n\t\r\n\t\r\n\t\t\tthis._bindings = []; // 'nActiveBindings' followed by inactive ones\r\n\t\t\tthis._nActiveBindings = 0;\r\n\t\r\n\t\t\tthis._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >\r\n\t\r\n\t\r\n\t\t\tthis._controlInterpolants = []; // same game as above\r\n\t\t\tthis._nActiveControlInterpolants = 0;\r\n\t\r\n\t\t\tvar scope = this;\r\n\t\r\n\t\t\tthis.stats = {\r\n\t\r\n\t\t\t\tactions: {\r\n\t\t\t\t\tget total() { return scope._actions.length; },\r\n\t\t\t\t\tget inUse() { return scope._nActiveActions; }\r\n\t\t\t\t},\r\n\t\t\t\tbindings: {\r\n\t\t\t\t\tget total() { return scope._bindings.length; },\r\n\t\t\t\t\tget inUse() { return scope._nActiveBindings; }\r\n\t\t\t\t},\r\n\t\t\t\tcontrolInterpolants: {\r\n\t\t\t\t\tget total() { return scope._controlInterpolants.length; },\r\n\t\t\t\t\tget inUse() { return scope._nActiveControlInterpolants; }\r\n\t\t\t\t}\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Memory management for _Action objects\r\n\t\r\n\t\t_isActiveAction: function( action ) {\r\n\t\r\n\t\t\tvar index = action._cacheIndex;\r\n\t\t\treturn index !== null && index < this._nActiveActions;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t_addInactiveAction: function( action, clipName, rootUuid ) {\r\n\t\r\n\t\t\tvar actions = this._actions,\r\n\t\t\t\tactionsByClip = this._actionsByClip,\r\n\t\t\t\tactionsForClip = actionsByClip[ clipName ];\r\n\t\r\n\t\t\tif ( actionsForClip === undefined ) {\r\n\t\r\n\t\t\t\tactionsForClip = {\r\n\t\r\n\t\t\t\t\tknownActions: [ action ],\r\n\t\t\t\t\tactionByRoot: {}\r\n\t\r\n\t\t\t\t};\r\n\t\r\n\t\t\t\taction._byClipCacheIndex = 0;\r\n\t\r\n\t\t\t\tactionsByClip[ clipName ] = actionsForClip;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tvar knownActions = actionsForClip.knownActions;\r\n\t\r\n\t\t\t\taction._byClipCacheIndex = knownActions.length;\r\n\t\t\t\tknownActions.push( action );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\taction._cacheIndex = actions.length;\r\n\t\t\tactions.push( action );\r\n\t\r\n\t\t\tactionsForClip.actionByRoot[ rootUuid ] = action;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t_removeInactiveAction: function( action ) {\r\n\t\r\n\t\t\tvar actions = this._actions,\r\n\t\t\t\tlastInactiveAction = actions[ actions.length - 1 ],\r\n\t\t\t\tcacheIndex = action._cacheIndex;\r\n\t\r\n\t\t\tlastInactiveAction._cacheIndex = cacheIndex;\r\n\t\t\tactions[ cacheIndex ] = lastInactiveAction;\r\n\t\t\tactions.pop();\r\n\t\r\n\t\t\taction._cacheIndex = null;\r\n\t\r\n\t\r\n\t\t\tvar clipName = action._clip.name,\r\n\t\t\t\tactionsByClip = this._actionsByClip,\r\n\t\t\t\tactionsForClip = actionsByClip[ clipName ],\r\n\t\t\t\tknownActionsForClip = actionsForClip.knownActions,\r\n\t\r\n\t\t\t\tlastKnownAction =\r\n\t\t\t\t\tknownActionsForClip[ knownActionsForClip.length - 1 ],\r\n\t\r\n\t\t\t\tbyClipCacheIndex = action._byClipCacheIndex;\r\n\t\r\n\t\t\tlastKnownAction._byClipCacheIndex = byClipCacheIndex;\r\n\t\t\tknownActionsForClip[ byClipCacheIndex ] = lastKnownAction;\r\n\t\t\tknownActionsForClip.pop();\r\n\t\r\n\t\t\taction._byClipCacheIndex = null;\r\n\t\r\n\t\r\n\t\t\tvar actionByRoot = actionsForClip.actionByRoot,\r\n\t\t\t\trootUuid = ( actions._localRoot || this._root ).uuid;\r\n\t\r\n\t\t\tdelete actionByRoot[ rootUuid ];\r\n\t\r\n\t\t\tif ( knownActionsForClip.length === 0 ) {\r\n\t\r\n\t\t\t\tdelete actionsByClip[ clipName ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis._removeInactiveBindingsForAction( action );\r\n\t\r\n\t\t},\r\n\t\r\n\t\t_removeInactiveBindingsForAction: function( action ) {\r\n\t\r\n\t\t\tvar bindings = action._propertyBindings;\r\n\t\t\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\r\n\t\r\n\t\t\t\tvar binding = bindings[ i ];\r\n\t\r\n\t\t\t\tif ( -- binding.referenceCount === 0 ) {\r\n\t\r\n\t\t\t\t\tthis._removeInactiveBinding( binding );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\t_lendAction: function( action ) {\r\n\t\r\n\t\t\t// [ active actions |  inactive actions  ]\r\n\t\t\t// [  active actions >| inactive actions ]\r\n\t\t\t//                 s        a\r\n\t\t\t//                  <-swap->\r\n\t\t\t//                 a        s\r\n\t\r\n\t\t\tvar actions = this._actions,\r\n\t\t\t\tprevIndex = action._cacheIndex,\r\n\t\r\n\t\t\t\tlastActiveIndex = this._nActiveActions ++,\r\n\t\r\n\t\t\t\tfirstInactiveAction = actions[ lastActiveIndex ];\r\n\t\r\n\t\t\taction._cacheIndex = lastActiveIndex;\r\n\t\t\tactions[ lastActiveIndex ] = action;\r\n\t\r\n\t\t\tfirstInactiveAction._cacheIndex = prevIndex;\r\n\t\t\tactions[ prevIndex ] = firstInactiveAction;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t_takeBackAction: function( action ) {\r\n\t\r\n\t\t\t// [  active actions  | inactive actions ]\r\n\t\t\t// [ active actions |< inactive actions  ]\r\n\t\t\t//        a        s\r\n\t\t\t//         <-swap->\r\n\t\t\t//        s        a\r\n\t\r\n\t\t\tvar actions = this._actions,\r\n\t\t\t\tprevIndex = action._cacheIndex,\r\n\t\r\n\t\t\t\tfirstInactiveIndex = -- this._nActiveActions,\r\n\t\r\n\t\t\t\tlastActiveAction = actions[ firstInactiveIndex ];\r\n\t\r\n\t\t\taction._cacheIndex = firstInactiveIndex;\r\n\t\t\tactions[ firstInactiveIndex ] = action;\r\n\t\r\n\t\t\tlastActiveAction._cacheIndex = prevIndex;\r\n\t\t\tactions[ prevIndex ] = lastActiveAction;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Memory management for PropertyMixer objects\r\n\t\r\n\t\t_addInactiveBinding: function( binding, rootUuid, trackName ) {\r\n\t\r\n\t\t\tvar bindingsByRoot = this._bindingsByRootAndName,\r\n\t\t\t\tbindingByName = bindingsByRoot[ rootUuid ],\r\n\t\r\n\t\t\t\tbindings = this._bindings;\r\n\t\r\n\t\t\tif ( bindingByName === undefined ) {\r\n\t\r\n\t\t\t\tbindingByName = {};\r\n\t\t\t\tbindingsByRoot[ rootUuid ] = bindingByName;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tbindingByName[ trackName ] = binding;\r\n\t\r\n\t\t\tbinding._cacheIndex = bindings.length;\r\n\t\t\tbindings.push( binding );\r\n\t\r\n\t\t},\r\n\t\r\n\t\t_removeInactiveBinding: function( binding ) {\r\n\t\r\n\t\t\tvar bindings = this._bindings,\r\n\t\t\t\tpropBinding = binding.binding,\r\n\t\t\t\trootUuid = propBinding.rootNode.uuid,\r\n\t\t\t\ttrackName = propBinding.path,\r\n\t\t\t\tbindingsByRoot = this._bindingsByRootAndName,\r\n\t\t\t\tbindingByName = bindingsByRoot[ rootUuid ],\r\n\t\r\n\t\t\t\tlastInactiveBinding = bindings[ bindings.length - 1 ],\r\n\t\t\t\tcacheIndex = binding._cacheIndex;\r\n\t\r\n\t\t\tlastInactiveBinding._cacheIndex = cacheIndex;\r\n\t\t\tbindings[ cacheIndex ] = lastInactiveBinding;\r\n\t\t\tbindings.pop();\r\n\t\r\n\t\t\tdelete bindingByName[ trackName ];\r\n\t\r\n\t\t\tremove_empty_map: {\r\n\t\r\n\t\t\t\tfor ( var _ in bindingByName ) break remove_empty_map;\r\n\t\r\n\t\t\t\tdelete bindingsByRoot[ rootUuid ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\t_lendBinding: function( binding ) {\r\n\t\r\n\t\t\tvar bindings = this._bindings,\r\n\t\t\t\tprevIndex = binding._cacheIndex,\r\n\t\r\n\t\t\t\tlastActiveIndex = this._nActiveBindings ++,\r\n\t\r\n\t\t\t\tfirstInactiveBinding = bindings[ lastActiveIndex ];\r\n\t\r\n\t\t\tbinding._cacheIndex = lastActiveIndex;\r\n\t\t\tbindings[ lastActiveIndex ] = binding;\r\n\t\r\n\t\t\tfirstInactiveBinding._cacheIndex = prevIndex;\r\n\t\t\tbindings[ prevIndex ] = firstInactiveBinding;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t_takeBackBinding: function( binding ) {\r\n\t\r\n\t\t\tvar bindings = this._bindings,\r\n\t\t\t\tprevIndex = binding._cacheIndex,\r\n\t\r\n\t\t\t\tfirstInactiveIndex = -- this._nActiveBindings,\r\n\t\r\n\t\t\t\tlastActiveBinding = bindings[ firstInactiveIndex ];\r\n\t\r\n\t\t\tbinding._cacheIndex = firstInactiveIndex;\r\n\t\t\tbindings[ firstInactiveIndex ] = binding;\r\n\t\r\n\t\t\tlastActiveBinding._cacheIndex = prevIndex;\r\n\t\t\tbindings[ prevIndex ] = lastActiveBinding;\r\n\t\r\n\t\t},\r\n\t\r\n\t\r\n\t\t// Memory management of Interpolants for weight and time scale\r\n\t\r\n\t\t_lendControlInterpolant: function() {\r\n\t\r\n\t\t\tvar interpolants = this._controlInterpolants,\r\n\t\t\t\tlastActiveIndex = this._nActiveControlInterpolants ++,\r\n\t\t\t\tinterpolant = interpolants[ lastActiveIndex ];\r\n\t\r\n\t\t\tif ( interpolant === undefined ) {\r\n\t\r\n\t\t\t\tinterpolant = new THREE.LinearInterpolant(\r\n\t\t\t\t\t\tnew Float32Array( 2 ), new Float32Array( 2 ),\r\n\t\t\t\t\t\t\t1, this._controlInterpolantsResultBuffer );\r\n\t\r\n\t\t\t\tinterpolant.__cacheIndex = lastActiveIndex;\r\n\t\t\t\tinterpolants[ lastActiveIndex ] = interpolant;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn interpolant;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t_takeBackControlInterpolant: function( interpolant ) {\r\n\t\r\n\t\t\tvar interpolants = this._controlInterpolants,\r\n\t\t\t\tprevIndex = interpolant.__cacheIndex,\r\n\t\r\n\t\t\t\tfirstInactiveIndex = -- this._nActiveControlInterpolants,\r\n\t\r\n\t\t\t\tlastActiveInterpolant = interpolants[ firstInactiveIndex ];\r\n\t\r\n\t\t\tinterpolant.__cacheIndex = firstInactiveIndex;\r\n\t\t\tinterpolants[ firstInactiveIndex ] = interpolant;\r\n\t\r\n\t\t\tlastActiveInterpolant.__cacheIndex = prevIndex;\r\n\t\t\tinterpolants[ prevIndex ] = lastActiveInterpolant;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t_controlInterpolantsResultBuffer: new Float32Array( 1 )\r\n\t\r\n\t} );\r\n\t\r\n\t\r\n\t// File:src/animation/AnimationObjectGroup.js\r\n\t\r\n\t/**\r\n\t *\r\n\t * A group of objects that receives a shared animation state.\r\n\t *\r\n\t * Usage:\r\n\t *\r\n\t * \t-\tAdd objects you would otherwise pass as 'root' to the\r\n\t * \t\tconstructor or the .clipAction method of AnimationMixer.\r\n\t *\r\n\t * \t-\tInstead pass this object as 'root'.\r\n\t *\r\n\t * \t-\tYou can also add and remove objects later when the mixer\r\n\t * \t\tis running.\r\n\t *\r\n\t * Note:\r\n\t *\r\n\t *  \tObjects of this class appear as one object to the mixer,\r\n\t *  \tso cache control of the individual objects must be done\r\n\t *  \ton the group.\r\n\t *\r\n\t * Limitation:\r\n\t *\r\n\t * \t- \tThe animated properties must be compatible among the\r\n\t * \t\tall objects in the group.\r\n\t *\r\n\t *  -\tA single property can either be controlled through a\r\n\t *  \ttarget group or directly, but not both.\r\n\t *\r\n\t * @author tschw\r\n\t */\r\n\t\r\n\tTHREE.AnimationObjectGroup = function( var_args ) {\r\n\t\r\n\t\tthis.uuid = THREE.Math.generateUUID();\r\n\t\r\n\t\t// cached objects followed by the active ones\r\n\t\tthis._objects = Array.prototype.slice.call( arguments );\r\n\t\r\n\t\tthis.nCachedObjects_ = 0;\t\t\t// threshold\r\n\t\t// note: read by PropertyBinding.Composite\r\n\t\r\n\t\tvar indices = {};\r\n\t\tthis._indicesByUUID = indices;\t\t// for bookkeeping\r\n\t\r\n\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\r\n\t\r\n\t\t\tindices[ arguments[ i ].uuid ] = i;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis._paths = [];\t\t\t\t\t// inside: string\r\n\t\tthis._parsedPaths = [];\t\t\t\t// inside: { we don't care, here }\r\n\t\tthis._bindings = []; \t\t\t\t// inside: Array< PropertyBinding >\r\n\t\tthis._bindingsIndicesByPath = {}; \t// inside: indices in these arrays\r\n\t\r\n\t\tvar scope = this;\r\n\t\r\n\t\tthis.stats = {\r\n\t\r\n\t\t\tobjects: {\r\n\t\t\t\tget total() { return scope._objects.length; },\r\n\t\t\t\tget inUse() { return this.total - scope.nCachedObjects_;  }\r\n\t\t\t},\r\n\t\r\n\t\t\tget bindingsPerObject() { return scope._bindings.length; }\r\n\t\r\n\t\t};\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.AnimationObjectGroup.prototype = {\r\n\t\r\n\t\tconstructor: THREE.AnimationObjectGroup,\r\n\t\r\n\t\tadd: function( var_args ) {\r\n\t\r\n\t\t\tvar objects = this._objects,\r\n\t\t\t\tnObjects = objects.length,\r\n\t\t\t\tnCachedObjects = this.nCachedObjects_,\r\n\t\t\t\tindicesByUUID = this._indicesByUUID,\r\n\t\t\t\tpaths = this._paths,\r\n\t\t\t\tparsedPaths = this._parsedPaths,\r\n\t\t\t\tbindings = this._bindings,\r\n\t\t\t\tnBindings = bindings.length;\r\n\t\r\n\t\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\r\n\t\r\n\t\t\t\tvar object = arguments[ i ],\r\n\t\t\t\t\tuuid = object.uuid,\r\n\t\t\t\t\tindex = indicesByUUID[ uuid ];\r\n\t\r\n\t\t\t\tif ( index === undefined ) {\r\n\t\r\n\t\t\t\t\t// unknown object -> add it to the ACTIVE region\r\n\t\r\n\t\t\t\t\tindex = nObjects ++;\r\n\t\t\t\t\tindicesByUUID[ uuid ] = index;\r\n\t\t\t\t\tobjects.push( object );\r\n\t\r\n\t\t\t\t\t// accounting is done, now do the same for all bindings\r\n\t\r\n\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\r\n\t\r\n\t\t\t\t\t\tbindings[ j ].push(\r\n\t\t\t\t\t\t\t\tnew THREE.PropertyBinding(\r\n\t\t\t\t\t\t\t\t\tobject, paths[ j ], parsedPaths[ j ] ) );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else if ( index < nCachedObjects ) {\r\n\t\r\n\t\t\t\t\tvar knownObject = objects[ index ];\r\n\t\r\n\t\t\t\t\t// move existing object to the ACTIVE region\r\n\t\r\n\t\t\t\t\tvar firstActiveIndex = -- nCachedObjects,\r\n\t\t\t\t\t\tlastCachedObject = objects[ firstActiveIndex ];\r\n\t\r\n\t\t\t\t\tindicesByUUID[ lastCachedObject.uuid ] = index;\r\n\t\t\t\t\tobjects[ index ] = lastCachedObject;\r\n\t\r\n\t\t\t\t\tindicesByUUID[ uuid ] = firstActiveIndex;\r\n\t\t\t\t\tobjects[ firstActiveIndex ] = object;\r\n\t\r\n\t\t\t\t\t// accounting is done, now do the same for all bindings\r\n\t\r\n\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\r\n\t\r\n\t\t\t\t\t\tvar bindingsForPath = bindings[ j ],\r\n\t\t\t\t\t\t\tlastCached = bindingsForPath[ firstActiveIndex ],\r\n\t\t\t\t\t\t\tbinding = bindingsForPath[ index ];\r\n\t\r\n\t\t\t\t\t\tbindingsForPath[ index ] = lastCached;\r\n\t\r\n\t\t\t\t\t\tif ( binding === undefined ) {\r\n\t\r\n\t\t\t\t\t\t\t// since we do not bother to create new bindings\r\n\t\t\t\t\t\t\t// for objects that are cached, the binding may\r\n\t\t\t\t\t\t\t// or may not exist\r\n\t\r\n\t\t\t\t\t\t\tbinding = new THREE.PropertyBinding(\r\n\t\t\t\t\t\t\t\t\tobject, paths[ j ], parsedPaths[ j ] );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tbindingsForPath[ firstActiveIndex ] = binding;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else if ( objects[ index ] !== knownObject) {\r\n\t\r\n\t\t\t\t\tconsole.error( \"Different objects with the same UUID \" +\r\n\t\t\t\t\t\t\t\"detected. Clean the caches or recreate your \" +\r\n\t\t\t\t\t\t\t\"infrastructure when reloading scenes...\" );\r\n\t\r\n\t\t\t\t} // else the object is already where we want it to be\r\n\t\r\n\t\t\t} // for arguments\r\n\t\r\n\t\t\tthis.nCachedObjects_ = nCachedObjects;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tremove: function( var_args ) {\r\n\t\r\n\t\t\tvar objects = this._objects,\r\n\t\t\t\tnObjects = objects.length,\r\n\t\t\t\tnCachedObjects = this.nCachedObjects_,\r\n\t\t\t\tindicesByUUID = this._indicesByUUID,\r\n\t\t\t\tbindings = this._bindings,\r\n\t\t\t\tnBindings = bindings.length;\r\n\t\r\n\t\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\r\n\t\r\n\t\t\t\tvar object = arguments[ i ],\r\n\t\t\t\t\tuuid = object.uuid,\r\n\t\t\t\t\tindex = indicesByUUID[ uuid ];\r\n\t\r\n\t\t\t\tif ( index !== undefined && index >= nCachedObjects ) {\r\n\t\r\n\t\t\t\t\t// move existing object into the CACHED region\r\n\t\r\n\t\t\t\t\tvar lastCachedIndex = nCachedObjects ++,\r\n\t\t\t\t\t\tfirstActiveObject = objects[ lastCachedIndex ];\r\n\t\r\n\t\t\t\t\tindicesByUUID[ firstActiveObject.uuid ] = index;\r\n\t\t\t\t\tobjects[ index ] = firstActiveObject;\r\n\t\r\n\t\t\t\t\tindicesByUUID[ uuid ] = lastCachedIndex;\r\n\t\t\t\t\tobjects[ lastCachedIndex ] = object;\r\n\t\r\n\t\t\t\t\t// accounting is done, now do the same for all bindings\r\n\t\r\n\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\r\n\t\r\n\t\t\t\t\t\tvar bindingsForPath = bindings[ j ],\r\n\t\t\t\t\t\t\tfirstActive = bindingsForPath[ lastCachedIndex ],\r\n\t\t\t\t\t\t\tbinding = bindingsForPath[ index ];\r\n\t\r\n\t\t\t\t\t\tbindingsForPath[ index ] = firstActive;\r\n\t\t\t\t\t\tbindingsForPath[ lastCachedIndex ] = binding;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} // for arguments\r\n\t\r\n\t\t\tthis.nCachedObjects_ = nCachedObjects;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// remove & forget\r\n\t\tuncache: function( var_args ) {\r\n\t\r\n\t\t\tvar objects = this._objects,\r\n\t\t\t\tnObjects = objects.length,\r\n\t\t\t\tnCachedObjects = this.nCachedObjects_,\r\n\t\t\t\tindicesByUUID = this._indicesByUUID,\r\n\t\t\t\tbindings = this._bindings,\r\n\t\t\t\tnBindings = bindings.length;\r\n\t\r\n\t\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\r\n\t\r\n\t\t\t\tvar object = arguments[ i ],\r\n\t\t\t\t\tuuid = object.uuid,\r\n\t\t\t\t\tindex = indicesByUUID[ uuid ];\r\n\t\r\n\t\t\t\tif ( index !== undefined ) {\r\n\t\r\n\t\t\t\t\tdelete indicesByUUID[ uuid ];\r\n\t\r\n\t\t\t\t\tif ( index < nCachedObjects ) {\r\n\t\r\n\t\t\t\t\t\t// object is cached, shrink the CACHED region\r\n\t\r\n\t\t\t\t\t\tvar firstActiveIndex = -- nCachedObjects,\r\n\t\t\t\t\t\t\tlastCachedObject = objects[ firstActiveIndex ],\r\n\t\t\t\t\t\t\tlastIndex = -- nObjects,\r\n\t\t\t\t\t\t\tlastObject = objects[ lastIndex ];\r\n\t\r\n\t\t\t\t\t\t// last cached object takes this object's place\r\n\t\t\t\t\t\tindicesByUUID[ lastCachedObject.uuid ] = index;\r\n\t\t\t\t\t\tobjects[ index ] = lastCachedObject;\r\n\t\r\n\t\t\t\t\t\t// last object goes to the activated slot and pop\r\n\t\t\t\t\t\tindicesByUUID[ lastObject.uuid ] = firstActiveIndex;\r\n\t\t\t\t\t\tobjects[ firstActiveIndex ] = lastObject;\r\n\t\t\t\t\t\tobjects.pop();\r\n\t\r\n\t\t\t\t\t\t// accounting is done, now do the same for all bindings\r\n\t\r\n\t\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\r\n\t\r\n\t\t\t\t\t\t\tvar bindingsForPath = bindings[ j ],\r\n\t\t\t\t\t\t\t\tlastCached = bindingsForPath[ firstActiveIndex ],\r\n\t\t\t\t\t\t\t\tlast = bindingsForPath[ lastIndex ];\r\n\t\r\n\t\t\t\t\t\t\tbindingsForPath[ index ] = lastCached;\r\n\t\t\t\t\t\t\tbindingsForPath[ firstActiveIndex ] = last;\r\n\t\t\t\t\t\t\tbindingsForPath.pop();\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t// object is active, just swap with the last and pop\r\n\t\r\n\t\t\t\t\t\tvar lastIndex = -- nObjects,\r\n\t\t\t\t\t\t\tlastObject = objects[ lastIndex ];\r\n\t\r\n\t\t\t\t\t\tindicesByUUID[ lastObject.uuid ] = index;\r\n\t\t\t\t\t\tobjects[ index ] = lastObject;\r\n\t\t\t\t\t\tobjects.pop();\r\n\t\r\n\t\t\t\t\t\t// accounting is done, now do the same for all bindings\r\n\t\r\n\t\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\r\n\t\r\n\t\t\t\t\t\t\tvar bindingsForPath = bindings[ j ];\r\n\t\r\n\t\t\t\t\t\t\tbindingsForPath[ index ] = bindingsForPath[ lastIndex ];\r\n\t\t\t\t\t\t\tbindingsForPath.pop();\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t} // cached or active\r\n\t\r\n\t\t\t\t} // if object is known\r\n\t\r\n\t\t\t} // for arguments\r\n\t\r\n\t\t\tthis.nCachedObjects_ = nCachedObjects;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Internal interface used by befriended PropertyBinding.Composite:\r\n\t\r\n\t\tsubscribe_: function( path, parsedPath ) {\r\n\t\t\t// returns an array of bindings for the given path that is changed\r\n\t\t\t// according to the contained objects in the group\r\n\t\r\n\t\t\tvar indicesByPath = this._bindingsIndicesByPath,\r\n\t\t\t\tindex = indicesByPath[ path ],\r\n\t\t\t\tbindings = this._bindings;\r\n\t\r\n\t\t\tif ( index !== undefined ) return bindings[ index ];\r\n\t\r\n\t\t\tvar paths = this._paths,\r\n\t\t\t\tparsedPaths = this._parsedPaths,\r\n\t\t\t\tobjects = this._objects,\r\n\t\t\t\tnObjects = objects.length,\r\n\t\t\t\tnCachedObjects = this.nCachedObjects_,\r\n\t\t\t\tbindingsForPath = new Array( nObjects );\r\n\t\r\n\t\t\tindex = bindings.length;\r\n\t\r\n\t\t\tindicesByPath[ path ] = index;\r\n\t\r\n\t\t\tpaths.push( path );\r\n\t\t\tparsedPaths.push( parsedPath );\r\n\t\t\tbindings.push( bindingsForPath );\r\n\t\r\n\t\t\tfor ( var i = nCachedObjects,\r\n\t\t\t\t\tn = objects.length; i !== n; ++ i ) {\r\n\t\r\n\t\t\t\tvar object = objects[ i ];\r\n\t\r\n\t\t\t\tbindingsForPath[ i ] =\r\n\t\t\t\t\t\tnew THREE.PropertyBinding( object, path, parsedPath );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn bindingsForPath;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tunsubscribe_: function( path ) {\r\n\t\t\t// tells the group to forget about a property path and no longer\r\n\t\t\t// update the array previously obtained with 'subscribe_'\r\n\t\r\n\t\t\tvar indicesByPath = this._bindingsIndicesByPath,\r\n\t\t\t\tindex = indicesByPath[ path ];\r\n\t\r\n\t\t\tif ( index !== undefined ) {\r\n\t\r\n\t\t\t\tvar paths = this._paths,\r\n\t\t\t\t\tparsedPaths = this._parsedPaths,\r\n\t\t\t\t\tbindings = this._bindings,\r\n\t\t\t\t\tlastBindingsIndex = bindings.length - 1,\r\n\t\t\t\t\tlastBindings = bindings[ lastBindingsIndex ],\r\n\t\t\t\t\tlastBindingsPath = path[ lastBindingsIndex ];\r\n\t\r\n\t\t\t\tindicesByPath[ lastBindingsPath ] = index;\r\n\t\r\n\t\t\t\tbindings[ index ] = lastBindings;\r\n\t\t\t\tbindings.pop();\r\n\t\r\n\t\t\t\tparsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];\r\n\t\t\t\tparsedPaths.pop();\r\n\t\r\n\t\t\t\tpaths[ index ] = paths[ lastBindingsIndex ];\r\n\t\t\t\tpaths.pop();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\t// File:src/animation/AnimationUtils.js\r\n\t\r\n\t/**\r\n\t * @author tschw\r\n\t * @author Ben Houston / http://clara.io/\r\n\t * @author David Sarno / http://lighthaus.us/\r\n\t */\r\n\t\r\n\tTHREE.AnimationUtils = {\r\n\t\r\n\t\t// same as Array.prototype.slice, but also works on typed arrays\r\n\t\tarraySlice: function( array, from, to ) {\r\n\t\r\n\t\t\tif ( THREE.AnimationUtils.isTypedArray( array ) ) {\r\n\t\r\n\t\t\t\treturn new array.constructor( array.subarray( from, to ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn array.slice( from, to );\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// converts an array to a specific type\r\n\t\tconvertArray: function( array, type, forceClone ) {\r\n\t\r\n\t\t\tif ( ! array || // let 'undefined' and 'null' pass\r\n\t\t\t\t\t! forceClone && array.constructor === type ) return array;\r\n\t\r\n\t\t\tif ( typeof type.BYTES_PER_ELEMENT === 'number' ) {\r\n\t\r\n\t\t\t\treturn new type( array ); // create typed array\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn Array.prototype.slice.call( array ); // create Array\r\n\t\r\n\t\t},\r\n\t\r\n\t\tisTypedArray: function( object ) {\r\n\t\r\n\t\t\treturn ArrayBuffer.isView( object ) &&\r\n\t\t\t\t\t! ( object instanceof DataView );\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// returns an array by which times and values can be sorted\r\n\t\tgetKeyframeOrder: function( times ) {\r\n\t\r\n\t\t\tfunction compareTime( i, j ) {\r\n\t\r\n\t\t\t\treturn times[ i ] - times[ j ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar n = times.length;\r\n\t\t\tvar result = new Array( n );\r\n\t\t\tfor ( var i = 0; i !== n; ++ i ) result[ i ] = i;\r\n\t\r\n\t\t\tresult.sort( compareTime );\r\n\t\r\n\t\t\treturn result;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// uses the array previously returned by 'getKeyframeOrder' to sort data\r\n\t\tsortedArray: function( values, stride, order ) {\r\n\t\r\n\t\t\tvar nValues = values.length;\r\n\t\t\tvar result = new values.constructor( nValues );\r\n\t\r\n\t\t\tfor ( var i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {\r\n\t\r\n\t\t\t\tvar srcOffset = order[ i ] * stride;\r\n\t\r\n\t\t\t\tfor ( var j = 0; j !== stride; ++ j ) {\r\n\t\r\n\t\t\t\t\tresult[ dstOffset ++ ] = values[ srcOffset + j ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn result;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// function for parsing AOS keyframe formats\r\n\t\tflattenJSON: function( jsonKeys, times, values, valuePropertyName ) {\r\n\t\r\n\t\t\tvar i = 1, key = jsonKeys[ 0 ];\r\n\t\r\n\t\t\twhile ( key !== undefined && key[ valuePropertyName ] === undefined ) {\r\n\t\r\n\t\t\t\tkey = jsonKeys[ i ++ ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( key === undefined ) return; // no data\r\n\t\r\n\t\t\tvar value = key[ valuePropertyName ];\r\n\t\t\tif ( value === undefined ) return; // no data\r\n\t\r\n\t\t\tif ( Array.isArray( value ) ) {\r\n\t\r\n\t\t\t\tdo {\r\n\t\r\n\t\t\t\t\tvalue = key[ valuePropertyName ];\r\n\t\r\n\t\t\t\t\tif ( value !== undefined ) {\r\n\t\r\n\t\t\t\t\t\ttimes.push( key.time );\r\n\t\t\t\t\t\tvalues.push.apply( values, value ); // push all elements\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tkey = jsonKeys[ i ++ ];\r\n\t\r\n\t\t\t\t} while ( key !== undefined );\r\n\t\r\n\t\t\t} else if ( value.toArray !== undefined ) {\r\n\t\t\t\t// ...assume THREE.Math-ish\r\n\t\r\n\t\t\t\tdo {\r\n\t\r\n\t\t\t\t\tvalue = key[ valuePropertyName ];\r\n\t\r\n\t\t\t\t\tif ( value !== undefined ) {\r\n\t\r\n\t\t\t\t\t\ttimes.push( key.time );\r\n\t\t\t\t\t\tvalue.toArray( values, values.length );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tkey = jsonKeys[ i ++ ];\r\n\t\r\n\t\t\t\t} while ( key !== undefined );\r\n\t\r\n\t\t\t} else {\r\n\t\t\t\t// otherwise push as-is\r\n\t\r\n\t\t\t\tdo {\r\n\t\r\n\t\t\t\t\tvalue = key[ valuePropertyName ];\r\n\t\r\n\t\t\t\t\tif ( value !== undefined ) {\r\n\t\r\n\t\t\t\t\t\ttimes.push( key.time );\r\n\t\t\t\t\t\tvalues.push( value );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tkey = jsonKeys[ i ++ ];\r\n\t\r\n\t\t\t\t} while ( key !== undefined );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/animation/KeyframeTrack.js\r\n\t\r\n\t/**\r\n\t *\r\n\t * A timed sequence of keyframes for a specific property.\r\n\t *\r\n\t *\r\n\t * @author Ben Houston / http://clara.io/\r\n\t * @author David Sarno / http://lighthaus.us/\r\n\t * @author tschw\r\n\t */\r\n\t\r\n\tTHREE.KeyframeTrack = function ( name, times, values, interpolation ) {\r\n\t\r\n\t\tif( name === undefined ) throw new Error( \"track name is undefined\" );\r\n\t\r\n\t\tif( times === undefined || times.length === 0 ) {\r\n\t\r\n\t\t\tthrow new Error( \"no keyframes in track named \" + name );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.name = name;\r\n\t\r\n\t\tthis.times = THREE.AnimationUtils.convertArray( times, this.TimeBufferType );\r\n\t\tthis.values = THREE.AnimationUtils.convertArray( values, this.ValueBufferType );\r\n\t\r\n\t\tthis.setInterpolation( interpolation || this.DefaultInterpolation );\r\n\t\r\n\t\tthis.validate();\r\n\t\tthis.optimize();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.KeyframeTrack.prototype = {\r\n\t\r\n\t\tconstructor: THREE.KeyframeTrack,\r\n\t\r\n\t\tTimeBufferType: Float32Array,\r\n\t\tValueBufferType: Float32Array,\r\n\t\r\n\t\tDefaultInterpolation: THREE.InterpolateLinear,\r\n\t\r\n\t\tInterpolantFactoryMethodDiscrete: function( result ) {\r\n\t\r\n\t\t\treturn new THREE.DiscreteInterpolant(\r\n\t\t\t\t\tthis.times, this.values, this.getValueSize(), result );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tInterpolantFactoryMethodLinear: function( result ) {\r\n\t\r\n\t\t\treturn new THREE.LinearInterpolant(\r\n\t\t\t\t\tthis.times, this.values, this.getValueSize(), result );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tInterpolantFactoryMethodSmooth: function( result ) {\r\n\t\r\n\t\t\treturn new THREE.CubicInterpolant(\r\n\t\t\t\t\tthis.times, this.values, this.getValueSize(), result );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetInterpolation: function( interpolation ) {\r\n\t\r\n\t\t\tvar factoryMethod = undefined;\r\n\t\r\n\t\t\tswitch ( interpolation ) {\r\n\t\r\n\t\t\t\tcase THREE.InterpolateDiscrete:\r\n\t\r\n\t\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodDiscrete;\r\n\t\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\tcase THREE.InterpolateLinear:\r\n\t\r\n\t\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodLinear;\r\n\t\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\tcase THREE.InterpolateSmooth:\r\n\t\r\n\t\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodSmooth;\r\n\t\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( factoryMethod === undefined ) {\r\n\t\r\n\t\t\t\tvar message = \"unsupported interpolation for \" +\r\n\t\t\t\t\t\tthis.ValueTypeName + \" keyframe track named \" + this.name;\r\n\t\r\n\t\t\t\tif ( this.createInterpolant === undefined ) {\r\n\t\r\n\t\t\t\t\t// fall back to default, unless the default itself is messed up\r\n\t\t\t\t\tif ( interpolation !== this.DefaultInterpolation ) {\r\n\t\r\n\t\t\t\t\t\tthis.setInterpolation( this.DefaultInterpolation );\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tthrow new Error( message ); // fatal, in this case\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tconsole.warn( message );\r\n\t\t\t\treturn;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.createInterpolant = factoryMethod;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetInterpolation: function() {\r\n\t\r\n\t\t\tswitch ( this.createInterpolant ) {\r\n\t\r\n\t\t\t\tcase this.InterpolantFactoryMethodDiscrete:\r\n\t\r\n\t\t\t\t\treturn THREE.InterpolateDiscrete;\r\n\t\r\n\t\t\t\tcase this.InterpolantFactoryMethodLinear:\r\n\t\r\n\t\t\t\t\treturn THREE.InterpolateLinear;\r\n\t\r\n\t\t\t\tcase this.InterpolantFactoryMethodSmooth:\r\n\t\r\n\t\t\t\t\treturn THREE.InterpolateSmooth;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetValueSize: function() {\r\n\t\r\n\t\t\treturn this.values.length / this.times.length;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// move all keyframes either forwards or backwards in time\r\n\t\tshift: function( timeOffset ) {\r\n\t\r\n\t\t\tif( timeOffset !== 0.0 ) {\r\n\t\r\n\t\t\t\tvar times = this.times;\r\n\t\r\n\t\t\t\tfor( var i = 0, n = times.length; i !== n; ++ i ) {\r\n\t\r\n\t\t\t\t\ttimes[ i ] += timeOffset;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// scale all keyframe times by a factor (useful for frame <-> seconds conversions)\r\n\t\tscale: function( timeScale ) {\r\n\t\r\n\t\t\tif( timeScale !== 1.0 ) {\r\n\t\r\n\t\t\t\tvar times = this.times;\r\n\t\r\n\t\t\t\tfor( var i = 0, n = times.length; i !== n; ++ i ) {\r\n\t\r\n\t\t\t\t\ttimes[ i ] *= timeScale;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// removes keyframes before and after animation without changing any values within the range [startTime, endTime].\r\n\t\t// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values\r\n\t\ttrim: function( startTime, endTime ) {\r\n\t\r\n\t\t\tvar times = this.times,\r\n\t\t\t\tnKeys = times.length,\r\n\t\t\t\tfrom = 0,\r\n\t\t\t\tto = nKeys - 1;\r\n\t\r\n\t\t\twhile ( from !== nKeys && times[ from ] < startTime ) ++ from;\r\n\t\t\twhile ( to !== -1 && times[ to ] > endTime ) -- to;\r\n\t\r\n\t\t\t++ to; // inclusive -> exclusive bound\r\n\t\r\n\t\t\tif( from !== 0 || to !== nKeys ) {\r\n\t\r\n\t\t\t\t// empty tracks are forbidden, so keep at least one keyframe\r\n\t\t\t\tif ( from >= to ) to = Math.max( to , 1 ), from = to - 1;\r\n\t\r\n\t\t\t\tvar stride = this.getValueSize();\r\n\t\t\t\tthis.times = THREE.AnimationUtils.arraySlice( times, from, to );\r\n\t\t\t\tthis.values = THREE.AnimationUtils.\r\n\t\t\t\t\t\tarraySlice( this.values, from * stride, to * stride );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable\r\n\t\tvalidate: function() {\r\n\t\r\n\t\t\tvar valid = true;\r\n\t\r\n\t\t\tvar valueSize = this.getValueSize();\r\n\t\t\tif ( valueSize - Math.floor( valueSize ) !== 0 ) {\r\n\t\r\n\t\t\t\tconsole.error( \"invalid value size in track\", this );\r\n\t\t\t\tvalid = false;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar times = this.times,\r\n\t\t\t\tvalues = this.values,\r\n\t\r\n\t\t\t\tnKeys = times.length;\r\n\t\r\n\t\t\tif( nKeys === 0 ) {\r\n\t\r\n\t\t\t\tconsole.error( \"track is empty\", this );\r\n\t\t\t\tvalid = false;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar prevTime = null;\r\n\t\r\n\t\t\tfor( var i = 0; i !== nKeys; i ++ ) {\r\n\t\r\n\t\t\t\tvar currTime = times[ i ];\r\n\t\r\n\t\t\t\tif ( typeof currTime === 'number' && isNaN( currTime ) ) {\r\n\t\r\n\t\t\t\t\tconsole.error( \"time is not a valid number\", this, i, currTime );\r\n\t\t\t\t\tvalid = false;\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif( prevTime !== null && prevTime > currTime ) {\r\n\t\r\n\t\t\t\t\tconsole.error( \"out of order keys\", this, i, currTime, prevTime );\r\n\t\t\t\t\tvalid = false;\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tprevTime = currTime;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( values !== undefined ) {\r\n\t\r\n\t\t\t\tif ( THREE.AnimationUtils.isTypedArray( values ) ) {\r\n\t\r\n\t\t\t\t\tfor ( var i = 0, n = values.length; i !== n; ++ i ) {\r\n\t\r\n\t\t\t\t\t\tvar value = values[ i ];\r\n\t\r\n\t\t\t\t\t\tif ( isNaN( value ) ) {\r\n\t\r\n\t\t\t\t\t\t\tconsole.error( \"value is not a valid number\", this, i, value );\r\n\t\t\t\t\t\t\tvalid = false;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn valid;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// removes equivalent sequential keys as common in morph target sequences\r\n\t\t// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)\r\n\t\toptimize: function() {\r\n\t\r\n\t\t\tvar times = this.times,\r\n\t\t\t\tvalues = this.values,\r\n\t\t\t\tstride = this.getValueSize(),\r\n\t\r\n\t\t\t\twriteIndex = 1;\r\n\t\r\n\t\t\tfor( var i = 1, n = times.length - 1; i <= n; ++ i ) {\r\n\t\r\n\t\t\t\tvar keep = false;\r\n\t\r\n\t\t\t\tvar time = times[ i ];\r\n\t\t\t\tvar timeNext = times[ i + 1 ];\r\n\t\r\n\t\t\t\t// remove adjacent keyframes scheduled at the same time\r\n\t\r\n\t\t\t\tif ( time !== timeNext && ( i !== 1 || time !== time[ 0 ] ) ) {\r\n\t\r\n\t\t\t\t\t// remove unnecessary keyframes same as their neighbors\r\n\t\t\t\t\tvar offset = i * stride,\r\n\t\t\t\t\t\toffsetP = offset - stride,\r\n\t\t\t\t\t\toffsetN = offset + stride;\r\n\t\r\n\t\t\t\t\tfor ( var j = 0; j !== stride; ++ j ) {\r\n\t\r\n\t\t\t\t\t\tvar value = values[ offset + j ];\r\n\t\r\n\t\t\t\t\t\tif ( value !== values[ offsetP + j ] ||\r\n\t\t\t\t\t\t\t\tvalue !== values[ offsetN + j ] ) {\r\n\t\r\n\t\t\t\t\t\t\tkeep = true;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// in-place compaction\r\n\t\r\n\t\t\t\tif ( keep ) {\r\n\t\r\n\t\t\t\t\tif ( i !== writeIndex ) {\r\n\t\r\n\t\t\t\t\t\ttimes[ writeIndex ] = times[ i ];\r\n\t\r\n\t\t\t\t\t\tvar readOffset = i * stride,\r\n\t\t\t\t\t\t\twriteOffset = writeIndex * stride;\r\n\t\r\n\t\t\t\t\t\tfor ( var j = 0; j !== stride; ++ j ) {\r\n\t\r\n\t\t\t\t\t\t\tvalues[ writeOffset + j ] = values[ readOffset + j ];\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t++ writeIndex;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( writeIndex !== times.length ) {\r\n\t\r\n\t\t\t\tthis.times = THREE.AnimationUtils.arraySlice( times, 0, writeIndex );\r\n\t\t\t\tthis.values = THREE.AnimationUtils.arraySlice( values, 0, writeIndex * stride );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// Static methods:\r\n\t\r\n\tObject.assign( THREE.KeyframeTrack, {\r\n\t\r\n\t\t// Serialization (in static context, because of constructor invocation\r\n\t\t// and automatic invocation of .toJSON):\r\n\t\r\n\t\tparse: function( json ) {\r\n\t\r\n\t\t\tif( json.type === undefined ) {\r\n\t\r\n\t\t\t\tthrow new Error( \"track type undefined, can not parse\" );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar trackType = THREE.KeyframeTrack._getTrackTypeForValueTypeName( json.type );\r\n\t\r\n\t\t\tif ( json.times === undefined ) {\r\n\t\r\n\t\t\t\tconsole.warn( \"legacy JSON format detected, converting\" );\r\n\t\r\n\t\t\t\tvar times = [], values = [];\r\n\t\r\n\t\t\t\tTHREE.AnimationUtils.flattenJSON( json.keys, times, values, 'value' );\r\n\t\r\n\t\t\t\tjson.times = times;\r\n\t\t\t\tjson.values = values;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// derived classes can define a static parse method\r\n\t\t\tif ( trackType.parse !== undefined ) {\r\n\t\r\n\t\t\t\treturn trackType.parse( json );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\t// by default, we asssume a constructor compatible with the base\r\n\t\t\t\treturn new trackType(\r\n\t\t\t\t\t\tjson.name, json.times, json.values, json.interpolation );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttoJSON: function( track ) {\r\n\t\r\n\t\t\tvar trackType = track.constructor;\r\n\t\r\n\t\t\tvar json;\r\n\t\r\n\t\t\t// derived classes can define a static toJSON method\r\n\t\t\tif ( trackType.toJSON !== undefined ) {\r\n\t\r\n\t\t\t\tjson = trackType.toJSON( track );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\t// by default, we assume the data can be serialized as-is\r\n\t\t\t\tjson = {\r\n\t\r\n\t\t\t\t\t'name': track.name,\r\n\t\t\t\t\t'times': THREE.AnimationUtils.convertArray( track.times, Array ),\r\n\t\t\t\t\t'values': THREE.AnimationUtils.convertArray( track.values, Array )\r\n\t\r\n\t\t\t\t};\r\n\t\r\n\t\t\t\tvar interpolation = track.getInterpolation();\r\n\t\r\n\t\t\t\tif ( interpolation !== track.DefaultInterpolation ) {\r\n\t\r\n\t\t\t\t\tjson.interpolation = interpolation;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tjson.type = track.ValueTypeName; // mandatory\r\n\t\r\n\t\t\treturn json;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t_getTrackTypeForValueTypeName: function( typeName ) {\r\n\t\r\n\t\t\tswitch( typeName.toLowerCase() ) {\r\n\t\r\n\t\t\t\tcase \"scalar\":\r\n\t\t\t\tcase \"double\":\r\n\t\t\t\tcase \"float\":\r\n\t\t\t\tcase \"number\":\r\n\t\t\t\tcase \"integer\":\r\n\t\r\n\t\t\t\t\treturn THREE.NumberKeyframeTrack;\r\n\t\r\n\t\t\t\tcase \"vector\":\r\n\t\t\t\tcase \"vector2\":\r\n\t\t\t\tcase \"vector3\":\r\n\t\t\t\tcase \"vector4\":\r\n\t\r\n\t\t\t\t\treturn THREE.VectorKeyframeTrack;\r\n\t\r\n\t\t\t\tcase \"color\":\r\n\t\r\n\t\t\t\t\treturn THREE.ColorKeyframeTrack;\r\n\t\r\n\t\t\t\tcase \"quaternion\":\r\n\t\r\n\t\t\t\t\treturn THREE.QuaternionKeyframeTrack;\r\n\t\r\n\t\t\t\tcase \"bool\":\r\n\t\t\t\tcase \"boolean\":\r\n\t\r\n\t\t\t\t\treturn THREE.BooleanKeyframeTrack;\r\n\t\r\n\t\t\t\tcase \"string\":\r\n\t\r\n\t\t\t\t\treturn THREE.StringKeyframeTrack;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t\tthrow new Error( \"Unsupported typeName: \" + typeName );\r\n\t\r\n\t\t}\r\n\t\r\n\t} );\r\n\t\r\n\t// File:src/animation/PropertyBinding.js\r\n\t\r\n\t/**\r\n\t *\r\n\t * A reference to a real property in the scene graph.\r\n\t *\r\n\t *\r\n\t * @author Ben Houston / http://clara.io/\r\n\t * @author David Sarno / http://lighthaus.us/\r\n\t * @author tschw\r\n\t */\r\n\t\r\n\tTHREE.PropertyBinding = function ( rootNode, path, parsedPath ) {\r\n\t\r\n\t\tthis.path = path;\r\n\t\tthis.parsedPath = parsedPath ||\r\n\t\t\t\tTHREE.PropertyBinding.parseTrackName( path );\r\n\t\r\n\t\tthis.node = THREE.PropertyBinding.findNode(\r\n\t\t\t\trootNode, this.parsedPath.nodeName ) || rootNode;\r\n\t\r\n\t\tthis.rootNode = rootNode;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.PropertyBinding.prototype = {\r\n\t\r\n\t\tconstructor: THREE.PropertyBinding,\r\n\t\r\n\t\tgetValue: function getValue_unbound( targetArray, offset ) {\r\n\t\r\n\t\t\tthis.bind();\r\n\t\t\tthis.getValue( targetArray, offset );\r\n\t\r\n\t\t\t// Note: This class uses a State pattern on a per-method basis:\r\n\t\t\t// 'bind' sets 'this.getValue' / 'setValue' and shadows the\r\n\t\t\t// prototype version of these methods with one that represents\r\n\t\t\t// the bound state. When the property is not found, the methods\r\n\t\t\t// become no-ops.\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetValue: function getValue_unbound( sourceArray, offset ) {\r\n\t\r\n\t\t\tthis.bind();\r\n\t\t\tthis.setValue( sourceArray, offset );\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// create getter / setter pair for a property in the scene graph\r\n\t\tbind: function() {\r\n\t\r\n\t\t\tvar targetObject = this.node,\r\n\t\t\t\tparsedPath = this.parsedPath,\r\n\t\r\n\t\t\t\tobjectName = parsedPath.objectName,\r\n\t\t\t\tpropertyName = parsedPath.propertyName,\r\n\t\t\t\tpropertyIndex = parsedPath.propertyIndex;\r\n\t\r\n\t\t\tif ( ! targetObject ) {\r\n\t\r\n\t\t\t\ttargetObject = THREE.PropertyBinding.findNode(\r\n\t\t\t\t\t\tthis.rootNode, parsedPath.nodeName ) || this.rootNode;\r\n\t\r\n\t\t\t\tthis.node = targetObject;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// set fail state so we can just 'return' on error\r\n\t\t\tthis.getValue = this._getValue_unavailable;\r\n\t\t\tthis.setValue = this._setValue_unavailable;\r\n\t\r\n\t \t\t// ensure there is a value node\r\n\t\t\tif ( ! targetObject ) {\r\n\t\r\n\t\t\t\tconsole.error( \"  trying to update node for track: \" + this.path + \" but it wasn't found.\" );\r\n\t\t\t\treturn;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif( objectName ) {\r\n\t\r\n\t\t\t\tvar objectIndex = parsedPath.objectIndex;\r\n\t\r\n\t\t\t\t// special cases were we need to reach deeper into the hierarchy to get the face materials....\r\n\t\t\t\tswitch ( objectName ) {\r\n\t\r\n\t\t\t\t\tcase 'materials':\r\n\t\r\n\t\t\t\t\t\tif( ! targetObject.material ) {\r\n\t\r\n\t\t\t\t\t\t\tconsole.error( '  can not bind to material as node does not have a material', this );\r\n\t\t\t\t\t\t\treturn;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tif( ! targetObject.material.materials ) {\r\n\t\r\n\t\t\t\t\t\t\tconsole.error( '  can not bind to material.materials as node.material does not have a materials array', this );\r\n\t\t\t\t\t\t\treturn;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\ttargetObject = targetObject.material.materials;\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'bones':\r\n\t\r\n\t\t\t\t\t\tif( ! targetObject.skeleton ) {\r\n\t\r\n\t\t\t\t\t\t\tconsole.error( '  can not bind to bones as node does not have a skeleton', this );\r\n\t\t\t\t\t\t\treturn;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t// potential future optimization: skip this if propertyIndex is already an integer\r\n\t\t\t\t\t\t// and convert the integer string to a true integer.\r\n\t\r\n\t\t\t\t\t\ttargetObject = targetObject.skeleton.bones;\r\n\t\r\n\t\t\t\t\t\t// support resolving morphTarget names into indices.\r\n\t\t\t\t\t\tfor ( var i = 0; i < targetObject.length; i ++ ) {\r\n\t\r\n\t\t\t\t\t\t\tif ( targetObject[i].name === objectIndex ) {\r\n\t\r\n\t\t\t\t\t\t\t\tobjectIndex = i;\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tdefault:\r\n\t\r\n\t\t\t\t\t\tif ( targetObject[ objectName ] === undefined ) {\r\n\t\r\n\t\t\t\t\t\t\tconsole.error( '  can not bind to objectName of node, undefined', this );\r\n\t\t\t\t\t\t\treturn;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\ttargetObject = targetObject[ objectName ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\r\n\t\t\t\tif ( objectIndex !== undefined ) {\r\n\t\r\n\t\t\t\t\tif( targetObject[ objectIndex ] === undefined ) {\r\n\t\r\n\t\t\t\t\t\tconsole.error( \"  trying to bind to objectIndex of objectName, but is undefined:\", this, targetObject );\r\n\t\t\t\t\t\treturn;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\ttargetObject = targetObject[ objectIndex ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// resolve property\r\n\t\t\tvar nodeProperty = targetObject[ propertyName ];\r\n\t\r\n\t\t\tif ( ! nodeProperty ) {\r\n\t\r\n\t\t\t\tvar nodeName = parsedPath.nodeName;\r\n\t\r\n\t\t\t\tconsole.error( \"  trying to update property for track: \" + nodeName +\r\n\t\t\t\t\t\t'.' + propertyName + \" but it wasn't found.\", targetObject );\r\n\t\t\t\treturn;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// determine versioning scheme\r\n\t\t\tvar versioning = this.Versioning.None;\r\n\t\r\n\t\t\tif ( targetObject.needsUpdate !== undefined ) { // material\r\n\t\r\n\t\t\t\tversioning = this.Versioning.NeedsUpdate;\r\n\t\t\t\tthis.targetObject = targetObject;\r\n\t\r\n\t\t\t} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform\r\n\t\r\n\t\t\t\tversioning = this.Versioning.MatrixWorldNeedsUpdate;\r\n\t\t\t\tthis.targetObject = targetObject;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// determine how the property gets bound\r\n\t\t\tvar bindingType = this.BindingType.Direct;\r\n\t\r\n\t\t\tif ( propertyIndex !== undefined ) {\r\n\t\t\t\t// access a sub element of the property array (only primitives are supported right now)\r\n\t\r\n\t\t\t\tif ( propertyName === \"morphTargetInfluences\" ) {\r\n\t\t\t\t\t// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.\r\n\t\r\n\t\t\t\t\t// support resolving morphTarget names into indices.\r\n\t\t\t\t\tif ( ! targetObject.geometry ) {\r\n\t\r\n\t\t\t\t\t\tconsole.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry', this );\r\n\t\t\t\t\t\treturn;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( ! targetObject.geometry.morphTargets ) {\r\n\t\r\n\t\t\t\t\t\tconsole.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets', this );\r\n\t\t\t\t\t\treturn;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tfor ( var i = 0; i < this.node.geometry.morphTargets.length; i ++ ) {\r\n\t\r\n\t\t\t\t\t\tif ( targetObject.geometry.morphTargets[i].name === propertyIndex ) {\r\n\t\r\n\t\t\t\t\t\t\tpropertyIndex = i;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tbindingType = this.BindingType.ArrayElement;\r\n\t\r\n\t\t\t\tthis.resolvedProperty = nodeProperty;\r\n\t\t\t\tthis.propertyIndex = propertyIndex;\r\n\t\r\n\t\t\t} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {\r\n\t\t\t\t// must use copy for Object3D.Euler/Quaternion\r\n\t\r\n\t\t\t\tbindingType = this.BindingType.HasFromToArray;\r\n\t\r\n\t\t\t\tthis.resolvedProperty = nodeProperty;\r\n\t\r\n\t\t\t} else if ( nodeProperty.length !== undefined ) {\r\n\t\r\n\t\t\t\tbindingType = this.BindingType.EntireArray;\r\n\t\r\n\t\t\t\tthis.resolvedProperty = nodeProperty;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tthis.propertyName = propertyName;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// select getter / setter\r\n\t\t\tthis.getValue = this.GetterByBindingType[ bindingType ];\r\n\t\t\tthis.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];\r\n\t\r\n\t\t},\r\n\t\r\n\t\tunbind: function() {\r\n\t\r\n\t\t\tthis.node = null;\r\n\t\r\n\t\t\t// back to the prototype version of getValue / setValue\r\n\t\t\t// note: avoiding to mutate the shape of 'this' via 'delete'\r\n\t\t\tthis.getValue = this._getValue_unbound;\r\n\t\t\tthis.setValue = this._setValue_unbound;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tObject.assign( THREE.PropertyBinding.prototype, { // prototype, continued\r\n\t\r\n\t\t// these are used to \"bind\" a nonexistent property\r\n\t\t_getValue_unavailable: function() {},\r\n\t\t_setValue_unavailable: function() {},\r\n\t\r\n\t\t// initial state of these methods that calls 'bind'\r\n\t\t_getValue_unbound: THREE.PropertyBinding.prototype.getValue,\r\n\t\t_setValue_unbound: THREE.PropertyBinding.prototype.setValue,\r\n\t\r\n\t\tBindingType: {\r\n\t\t\tDirect: 0,\r\n\t\t\tEntireArray: 1,\r\n\t\t\tArrayElement: 2,\r\n\t\t\tHasFromToArray: 3\r\n\t\t},\r\n\t\r\n\t\tVersioning: {\r\n\t\t\tNone: 0,\r\n\t\t\tNeedsUpdate: 1,\r\n\t\t\tMatrixWorldNeedsUpdate: 2\r\n\t\t},\r\n\t\r\n\t\tGetterByBindingType: [\r\n\t\r\n\t\t\tfunction getValue_direct( buffer, offset ) {\r\n\t\r\n\t\t\t\tbuffer[ offset ] = this.node[ this.propertyName ];\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t\tfunction getValue_array( buffer, offset ) {\r\n\t\r\n\t\t\t\tvar source = this.resolvedProperty;\r\n\t\r\n\t\t\t\tfor ( var i = 0, n = source.length; i !== n; ++ i ) {\r\n\t\r\n\t\t\t\t\tbuffer[ offset ++ ] = source[ i ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t\tfunction getValue_arrayElement( buffer, offset ) {\r\n\t\r\n\t\t\t\tbuffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t\tfunction getValue_toArray( buffer, offset ) {\r\n\t\r\n\t\t\t\tthis.resolvedProperty.toArray( buffer, offset );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t],\r\n\t\r\n\t\tSetterByBindingTypeAndVersioning: [\r\n\t\r\n\t\t\t[\r\n\t\t\t\t// Direct\r\n\t\r\n\t\t\t\tfunction setValue_direct( buffer, offset ) {\r\n\t\r\n\t\t\t\t\tthis.node[ this.propertyName ] = buffer[ offset ];\r\n\t\r\n\t\t\t\t},\r\n\t\r\n\t\t\t\tfunction setValue_direct_setNeedsUpdate( buffer, offset ) {\r\n\t\r\n\t\t\t\t\tthis.node[ this.propertyName ] = buffer[ offset ];\r\n\t\t\t\t\tthis.targetObject.needsUpdate = true;\r\n\t\r\n\t\t\t\t},\r\n\t\r\n\t\t\t\tfunction setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {\r\n\t\r\n\t\t\t\t\tthis.node[ this.propertyName ] = buffer[ offset ];\r\n\t\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t], [\r\n\t\r\n\t\t\t\t// EntireArray\r\n\t\r\n\t\t\t\tfunction setValue_array( buffer, offset ) {\r\n\t\r\n\t\t\t\t\tvar dest = this.resolvedProperty;\r\n\t\r\n\t\t\t\t\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\r\n\t\r\n\t\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t},\r\n\t\r\n\t\t\t\tfunction setValue_array_setNeedsUpdate( buffer, offset ) {\r\n\t\r\n\t\t\t\t\tvar dest = this.resolvedProperty;\r\n\t\r\n\t\t\t\t\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\r\n\t\r\n\t\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tthis.targetObject.needsUpdate = true;\r\n\t\r\n\t\t\t\t},\r\n\t\r\n\t\t\t\tfunction setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {\r\n\t\r\n\t\t\t\t\tvar dest = this.resolvedProperty;\r\n\t\r\n\t\t\t\t\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\r\n\t\r\n\t\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t], [\r\n\t\r\n\t\t\t\t// ArrayElement\r\n\t\r\n\t\t\t\tfunction setValue_arrayElement( buffer, offset ) {\r\n\t\r\n\t\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\r\n\t\r\n\t\t\t\t},\r\n\t\r\n\t\t\t\tfunction setValue_arrayElement_setNeedsUpdate( buffer, offset ) {\r\n\t\r\n\t\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\r\n\t\t\t\t\tthis.targetObject.needsUpdate = true;\r\n\t\r\n\t\t\t\t},\r\n\t\r\n\t\t\t\tfunction setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {\r\n\t\r\n\t\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\r\n\t\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t], [\r\n\t\r\n\t\t\t\t// HasToFromArray\r\n\t\r\n\t\t\t\tfunction setValue_fromArray( buffer, offset ) {\r\n\t\r\n\t\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\r\n\t\r\n\t\t\t\t},\r\n\t\r\n\t\t\t\tfunction setValue_fromArray_setNeedsUpdate( buffer, offset ) {\r\n\t\r\n\t\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\r\n\t\t\t\t\tthis.targetObject.needsUpdate = true;\r\n\t\r\n\t\t\t\t},\r\n\t\r\n\t\t\t\tfunction setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {\r\n\t\r\n\t\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\r\n\t\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t]\r\n\t\r\n\t\t]\r\n\t\r\n\t} );\r\n\t\r\n\tTHREE.PropertyBinding.Composite =\r\n\t\t\tfunction( targetGroup, path, optionalParsedPath ) {\r\n\t\r\n\t\tvar parsedPath = optionalParsedPath ||\r\n\t\t\t\tTHREE.PropertyBinding.parseTrackName( path );\r\n\t\r\n\t\tthis._targetGroup = targetGroup;\r\n\t\tthis._bindings = targetGroup.subscribe_( path, parsedPath );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.PropertyBinding.Composite.prototype = {\r\n\t\r\n\t\tconstructor: THREE.PropertyBinding.Composite,\r\n\t\r\n\t\tgetValue: function( array, offset ) {\r\n\t\r\n\t\t\tthis.bind(); // bind all binding\r\n\t\r\n\t\t\tvar firstValidIndex = this._targetGroup.nCachedObjects_,\r\n\t\t\t\tbinding = this._bindings[ firstValidIndex ];\r\n\t\r\n\t\t\t// and only call .getValue on the first\r\n\t\t\tif ( binding !== undefined ) binding.getValue( array, offset );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetValue: function( array, offset ) {\r\n\t\r\n\t\t\tvar bindings = this._bindings;\r\n\t\r\n\t\t\tfor ( var i = this._targetGroup.nCachedObjects_,\r\n\t\t\t\t\tn = bindings.length; i !== n; ++ i ) {\r\n\t\r\n\t\t\t\tbindings[ i ].setValue( array, offset );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tbind: function() {\r\n\t\r\n\t\t\tvar bindings = this._bindings;\r\n\t\r\n\t\t\tfor ( var i = this._targetGroup.nCachedObjects_,\r\n\t\t\t\t\tn = bindings.length; i !== n; ++ i ) {\r\n\t\r\n\t\t\t\tbindings[ i ].bind();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tunbind: function() {\r\n\t\r\n\t\t\tvar bindings = this._bindings;\r\n\t\r\n\t\t\tfor ( var i = this._targetGroup.nCachedObjects_,\r\n\t\t\t\t\tn = bindings.length; i !== n; ++ i ) {\r\n\t\r\n\t\t\t\tbindings[ i ].unbind();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.PropertyBinding.create = function( root, path, parsedPath ) {\r\n\t\r\n\t\tif ( ! ( root instanceof THREE.AnimationObjectGroup ) ) {\r\n\t\r\n\t\t\treturn new THREE.PropertyBinding( root, path, parsedPath );\r\n\t\r\n\t\t} else {\r\n\t\r\n\t\t\treturn new THREE.PropertyBinding.Composite( root, path, parsedPath );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.PropertyBinding.parseTrackName = function( trackName ) {\r\n\t\r\n\t\t// matches strings in the form of:\r\n\t\t//    nodeName.property\r\n\t\t//    nodeName.property[accessor]\r\n\t\t//    nodeName.material.property[accessor]\r\n\t\t//    uuid.property[accessor]\r\n\t\t//    uuid.objectName[objectIndex].propertyName[propertyIndex]\r\n\t\t//    parentName/nodeName.property\r\n\t\t//    parentName/parentName/nodeName.property[index]\r\n\t\t//\t  .bone[Armature.DEF_cog].position\r\n\t\t// created and tested via https://regex101.com/#javascript\r\n\t\r\n\t\tvar re = /^(([\\w]+\\/)*)([\\w-\\d]+)?(\\.([\\w]+)(\\[([\\w\\d\\[\\]\\_.:\\- ]+)\\])?)?(\\.([\\w.]+)(\\[([\\w\\d\\[\\]\\_. ]+)\\])?)$/;\r\n\t\tvar matches = re.exec(trackName);\r\n\t\r\n\t\tif( ! matches ) {\r\n\t\t\tthrow new Error( \"cannot parse trackName at all: \" + trackName );\r\n\t\t}\r\n\t\r\n\t    if (matches.index === re.lastIndex) {\r\n\t        re.lastIndex++;\r\n\t    }\r\n\t\r\n\t\tvar results = {\r\n\t\t\t// directoryName: matches[1], // (tschw) currently unused\r\n\t\t\tnodeName: matches[3], \t// allowed to be null, specified root node.\r\n\t\t\tobjectName: matches[5],\r\n\t\t\tobjectIndex: matches[7],\r\n\t\t\tpropertyName: matches[9],\r\n\t\t\tpropertyIndex: matches[11]\t// allowed to be null, specifies that the whole property is set.\r\n\t\t};\r\n\t\r\n\t\tif( results.propertyName === null || results.propertyName.length === 0 ) {\r\n\t\t\tthrow new Error( \"can not parse propertyName from trackName: \" + trackName );\r\n\t\t}\r\n\t\r\n\t\treturn results;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.PropertyBinding.findNode = function( root, nodeName ) {\r\n\t\r\n\t\tif( ! nodeName || nodeName === \"\" || nodeName === \"root\" || nodeName === \".\" || nodeName === -1 || nodeName === root.name || nodeName === root.uuid ) {\r\n\t\r\n\t\t\treturn root;\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// search into skeleton bones.\r\n\t\tif( root.skeleton ) {\r\n\t\r\n\t\t\tvar searchSkeleton = function( skeleton ) {\r\n\t\r\n\t\t\t\tfor( var i = 0; i < skeleton.bones.length; i ++ ) {\r\n\t\r\n\t\t\t\t\tvar bone = skeleton.bones[i];\r\n\t\r\n\t\t\t\t\tif( bone.name === nodeName ) {\r\n\t\r\n\t\t\t\t\t\treturn bone;\r\n\t\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn null;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t\tvar bone = searchSkeleton( root.skeleton );\r\n\t\r\n\t\t\tif( bone ) {\r\n\t\r\n\t\t\t\treturn bone;\r\n\t\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\t// search into node subtree.\r\n\t\tif( root.children ) {\r\n\t\r\n\t\t\tvar searchNodeSubtree = function( children ) {\r\n\t\r\n\t\t\t\tfor( var i = 0; i < children.length; i ++ ) {\r\n\t\r\n\t\t\t\t\tvar childNode = children[i];\r\n\t\r\n\t\t\t\t\tif( childNode.name === nodeName || childNode.uuid === nodeName ) {\r\n\t\r\n\t\t\t\t\t\treturn childNode;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tvar result = searchNodeSubtree( childNode.children );\r\n\t\r\n\t\t\t\t\tif( result ) return result;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn null;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t\tvar subTreeNode = searchNodeSubtree( root.children );\r\n\t\r\n\t\t\tif( subTreeNode ) {\r\n\t\r\n\t\t\t\treturn subTreeNode;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn null;\r\n\t\r\n\t}\r\n\t\r\n\t// File:src/animation/PropertyMixer.js\r\n\t\r\n\t/**\r\n\t *\r\n\t * Buffered scene graph property that allows weighted accumulation.\r\n\t *\r\n\t *\r\n\t * @author Ben Houston / http://clara.io/\r\n\t * @author David Sarno / http://lighthaus.us/\r\n\t * @author tschw\r\n\t */\r\n\t\r\n\tTHREE.PropertyMixer = function ( binding, typeName, valueSize ) {\r\n\t\r\n\t\tthis.binding = binding;\r\n\t\tthis.valueSize = valueSize;\r\n\t\r\n\t\tvar bufferType = Float64Array,\r\n\t\t\tmixFunction;\r\n\t\r\n\t\tswitch ( typeName ) {\r\n\t\r\n\t\t\tcase 'quaternion':\t\t\tmixFunction = this._slerp;\t\tbreak;\r\n\t\r\n\t\t\tcase 'string':\r\n\t\t\tcase 'bool':\r\n\t\r\n\t\t\t\tbufferType = Array,\t\tmixFunction = this._select;\t\tbreak;\r\n\t\r\n\t\t\tdefault:\t\t\t\t\tmixFunction = this._lerp;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.buffer = new bufferType( valueSize * 4 );\r\n\t\t// layout: [ incoming | accu0 | accu1 | orig ]\r\n\t\t//\r\n\t\t// interpolators can use .buffer as their .result\r\n\t\t// the data then goes to 'incoming'\r\n\t\t//\r\n\t\t// 'accu0' and 'accu1' are used frame-interleaved for\r\n\t\t// the cumulative result and are compared to detect\r\n\t\t// changes\r\n\t\t//\r\n\t\t// 'orig' stores the original state of the property\r\n\t\r\n\t\tthis._mixBufferRegion = mixFunction;\r\n\t\r\n\t\tthis.cumulativeWeight = 0;\r\n\t\r\n\t\tthis.useCount = 0;\r\n\t\tthis.referenceCount = 0;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.PropertyMixer.prototype = {\r\n\t\r\n\t\tconstructor: THREE.PropertyMixer,\r\n\t\r\n\t\t// accumulate data in the 'incoming' region into 'accu<i>'\r\n\t\taccumulate: function( accuIndex, weight ) {\r\n\t\r\n\t\t\t// note: happily accumulating nothing when weight = 0, the caller knows\r\n\t\t\t// the weight and shouldn't have made the call in the first place\r\n\t\r\n\t\t\tvar buffer = this.buffer,\r\n\t\t\t\tstride = this.valueSize,\r\n\t\t\t\toffset = accuIndex * stride + stride,\r\n\t\r\n\t\t\t\tcurrentWeight = this.cumulativeWeight;\r\n\t\r\n\t\t\tif ( currentWeight === 0 ) {\r\n\t\r\n\t\t\t\t// accuN := incoming * weight\r\n\t\r\n\t\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\r\n\t\r\n\t\t\t\t\tbuffer[ offset + i ] = buffer[ i ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tcurrentWeight = weight;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\t// accuN := accuN + incoming * weight\r\n\t\r\n\t\t\t\tcurrentWeight += weight;\r\n\t\t\t\tvar mix = weight / currentWeight;\r\n\t\t\t\tthis._mixBufferRegion( buffer, offset, 0, mix, stride );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.cumulativeWeight = currentWeight;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// apply the state of 'accu<i>' to the binding when accus differ\r\n\t\tapply: function( accuIndex ) {\r\n\t\r\n\t\t\tvar stride = this.valueSize,\r\n\t\t\t\tbuffer = this.buffer,\r\n\t\t\t\toffset = accuIndex * stride + stride,\r\n\t\r\n\t\t\t\tweight = this.cumulativeWeight,\r\n\t\r\n\t\t\t\tbinding = this.binding;\r\n\t\r\n\t\t\tthis.cumulativeWeight = 0;\r\n\t\r\n\t\t\tif ( weight < 1 ) {\r\n\t\r\n\t\t\t\t// accuN := accuN + original * ( 1 - cumulativeWeight )\r\n\t\r\n\t\t\t\tvar originalValueOffset = stride * 3;\r\n\t\r\n\t\t\t\tthis._mixBufferRegion(\r\n\t\t\t\t\t\tbuffer, offset, originalValueOffset, 1 - weight, stride );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( var i = stride, e = stride + stride; i !== e; ++ i ) {\r\n\t\r\n\t\t\t\tif ( buffer[ i ] !== buffer[ i + stride ] ) {\r\n\t\r\n\t\t\t\t\t// value has changed -> update scene graph\r\n\t\r\n\t\t\t\t\tbinding.setValue( buffer, offset );\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// remember the state of the bound property and copy it to both accus\r\n\t\tsaveOriginalState: function() {\r\n\t\r\n\t\t\tvar binding = this.binding;\r\n\t\r\n\t\t\tvar buffer = this.buffer,\r\n\t\t\t\tstride = this.valueSize,\r\n\t\r\n\t\t\t\toriginalValueOffset = stride * 3;\r\n\t\r\n\t\t\tbinding.getValue( buffer, originalValueOffset );\r\n\t\r\n\t\t\t// accu[0..1] := orig -- initially detect changes against the original\r\n\t\t\tfor ( var i = stride, e = originalValueOffset; i !== e; ++ i ) {\r\n\t\r\n\t\t\t\tbuffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.cumulativeWeight = 0;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// apply the state previously taken via 'saveOriginalState' to the binding\r\n\t\trestoreOriginalState: function() {\r\n\t\r\n\t\t\tvar originalValueOffset = this.valueSize * 3;\r\n\t\t\tthis.binding.setValue( this.buffer, originalValueOffset );\r\n\t\r\n\t\t},\r\n\t\r\n\t\r\n\t\t// mix functions\r\n\t\r\n\t\t_select: function( buffer, dstOffset, srcOffset, t, stride ) {\r\n\t\r\n\t\t\tif ( t >= 0.5 ) {\r\n\t\r\n\t\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\r\n\t\r\n\t\t\t\t\tbuffer[ dstOffset + i ] = buffer[ srcOffset + i ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\t_slerp: function( buffer, dstOffset, srcOffset, t, stride ) {\r\n\t\r\n\t\t\tTHREE.Quaternion.slerpFlat( buffer, dstOffset,\r\n\t\t\t\t\tbuffer, dstOffset, buffer, srcOffset, t );\r\n\t\r\n\t\t},\r\n\t\r\n\t\t_lerp: function( buffer, dstOffset, srcOffset, t, stride ) {\r\n\t\r\n\t\t\tvar s = 1 - t;\r\n\t\r\n\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\r\n\t\r\n\t\t\t\tvar j = dstOffset + i;\r\n\t\r\n\t\t\t\tbuffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/animation/tracks/BooleanKeyframeTrack.js\r\n\t\r\n\t/**\r\n\t *\r\n\t * A Track of Boolean keyframe values.\r\n\t *\r\n\t *\r\n\t * @author Ben Houston / http://clara.io/\r\n\t * @author David Sarno / http://lighthaus.us/\r\n\t * @author tschw\r\n\t */\r\n\t\r\n\tTHREE.BooleanKeyframeTrack = function ( name, times, values ) {\r\n\t\r\n\t\tTHREE.KeyframeTrack.call( this, name, times, values );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.BooleanKeyframeTrack.prototype =\r\n\t\t\tObject.assign( Object.create( THREE.KeyframeTrack.prototype ), {\r\n\t\r\n\t\tconstructor: THREE.BooleanKeyframeTrack,\r\n\t\r\n\t\tValueTypeName: 'bool',\r\n\t\tValueBufferType: Array,\r\n\t\r\n\t\tDefaultInterpolation: THREE.InterpolateDiscrete,\r\n\t\r\n\t\tInterpolantFactoryMethodLinear: undefined,\r\n\t\tInterpolantFactoryMethodSmooth: undefined\r\n\t\r\n\t\t// Note: Actually this track could have a optimized / compressed\r\n\t\t// representation of a single value and a custom interpolant that\r\n\t\t// computes \"firstValue ^ isOdd( index )\".\r\n\t\r\n\t} );\r\n\t\r\n\t// File:src/animation/tracks/ColorKeyframeTrack.js\r\n\t\r\n\t/**\r\n\t *\r\n\t * A Track of keyframe values that represent color.\r\n\t *\r\n\t *\r\n\t * @author Ben Houston / http://clara.io/\r\n\t * @author David Sarno / http://lighthaus.us/\r\n\t * @author tschw\r\n\t */\r\n\t\r\n\tTHREE.ColorKeyframeTrack = function ( name, times, values, interpolation ) {\r\n\t\r\n\t\tTHREE.KeyframeTrack.call( this, name, times, values, interpolation );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.ColorKeyframeTrack.prototype =\r\n\t\t\tObject.assign( Object.create( THREE.KeyframeTrack.prototype ), {\r\n\t\r\n\t\tconstructor: THREE.ColorKeyframeTrack,\r\n\t\r\n\t\tValueTypeName: 'color'\r\n\t\r\n\t\t// ValueBufferType is inherited\r\n\t\r\n\t\t// DefaultInterpolation is inherited\r\n\t\r\n\t\r\n\t\t// Note: Very basic implementation and nothing special yet.\r\n\t\t// However, this is the place for color space parameterization.\r\n\t\r\n\t} );\r\n\t\r\n\t// File:src/animation/tracks/NumberKeyframeTrack.js\r\n\t\r\n\t/**\r\n\t *\r\n\t * A Track of numeric keyframe values.\r\n\t *\r\n\t * @author Ben Houston / http://clara.io/\r\n\t * @author David Sarno / http://lighthaus.us/\r\n\t * @author tschw\r\n\t */\r\n\t\r\n\tTHREE.NumberKeyframeTrack = function ( name, times, values, interpolation ) {\r\n\t\r\n\t\tTHREE.KeyframeTrack.call( this, name, times, values, interpolation );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.NumberKeyframeTrack.prototype =\r\n\t\t\tObject.assign( Object.create( THREE.KeyframeTrack.prototype ), {\r\n\t\r\n\t\tconstructor: THREE.NumberKeyframeTrack,\r\n\t\r\n\t\tValueTypeName: 'number',\r\n\t\r\n\t\t// ValueBufferType is inherited\r\n\t\r\n\t\t// DefaultInterpolation is inherited\r\n\t\r\n\t} );\r\n\t\r\n\t// File:src/animation/tracks/QuaternionKeyframeTrack.js\r\n\t\r\n\t/**\r\n\t *\r\n\t * A Track of quaternion keyframe values.\r\n\t *\r\n\t * @author Ben Houston / http://clara.io/\r\n\t * @author David Sarno / http://lighthaus.us/\r\n\t * @author tschw\r\n\t */\r\n\t\r\n\tTHREE.QuaternionKeyframeTrack = function ( name, times, values, interpolation ) {\r\n\t\r\n\t\tTHREE.KeyframeTrack.call( this, name, times, values, interpolation );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.QuaternionKeyframeTrack.prototype =\r\n\t\t\tObject.assign( Object.create( THREE.KeyframeTrack.prototype ), {\r\n\t\r\n\t\tconstructor: THREE.QuaternionKeyframeTrack,\r\n\t\r\n\t\tValueTypeName: 'quaternion',\r\n\t\r\n\t\t// ValueBufferType is inherited\r\n\t\r\n\t\tDefaultInterpolation: THREE.InterpolateLinear,\r\n\t\r\n\t\tInterpolantFactoryMethodLinear: function( result ) {\r\n\t\r\n\t\t\treturn new THREE.QuaternionLinearInterpolant(\r\n\t\t\t\t\tthis.times, this.values, this.getValueSize(), result );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tInterpolantFactoryMethodSmooth: undefined // not yet implemented\r\n\t\r\n\t} );\r\n\t\r\n\t// File:src/animation/tracks/StringKeyframeTrack.js\r\n\t\r\n\t/**\r\n\t *\r\n\t * A Track that interpolates Strings\r\n\t *\r\n\t *\r\n\t * @author Ben Houston / http://clara.io/\r\n\t * @author David Sarno / http://lighthaus.us/\r\n\t * @author tschw\r\n\t */\r\n\t\r\n\tTHREE.StringKeyframeTrack = function ( name, times, values, interpolation ) {\r\n\t\r\n\t\tTHREE.KeyframeTrack.call( this, name, times, values, interpolation );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.StringKeyframeTrack.prototype =\r\n\t\t\tObject.assign( Object.create( THREE.KeyframeTrack.prototype ), {\r\n\t\r\n\t\tconstructor: THREE.StringKeyframeTrack,\r\n\t\r\n\t\tValueTypeName: 'string',\r\n\t\tValueBufferType: Array,\r\n\t\r\n\t\tDefaultInterpolation: THREE.InterpolateDiscrete,\r\n\t\r\n\t\tInterpolantFactoryMethodLinear: undefined,\r\n\t\r\n\t\tInterpolantFactoryMethodSmooth: undefined\r\n\t\r\n\t} );\r\n\t\r\n\t// File:src/animation/tracks/VectorKeyframeTrack.js\r\n\t\r\n\t/**\r\n\t *\r\n\t * A Track of vectored keyframe values.\r\n\t *\r\n\t *\r\n\t * @author Ben Houston / http://clara.io/\r\n\t * @author David Sarno / http://lighthaus.us/\r\n\t * @author tschw\r\n\t */\r\n\t\r\n\tTHREE.VectorKeyframeTrack = function ( name, times, values, interpolation ) {\r\n\t\r\n\t\tTHREE.KeyframeTrack.call( this, name, times, values, interpolation );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.VectorKeyframeTrack.prototype =\r\n\t\t\tObject.assign( Object.create( THREE.KeyframeTrack.prototype ), {\r\n\t\r\n\t\tconstructor: THREE.VectorKeyframeTrack,\r\n\t\r\n\t\tValueTypeName: 'vector'\r\n\t\r\n\t\t// ValueBufferType is inherited\r\n\t\r\n\t\t// DefaultInterpolation is inherited\r\n\t\r\n\t} );\r\n\t\r\n\t// File:src/audio/Audio.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author Reece Aaron Lecrivain / http://reecenotes.com/\r\n\t */\r\n\t\r\n\tTHREE.Audio = function ( listener ) {\r\n\t\r\n\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\tthis.type = 'Audio';\r\n\t\r\n\t\tthis.context = listener.context;\r\n\t\tthis.source = this.context.createBufferSource();\r\n\t\tthis.source.onended = this.onEnded.bind( this );\r\n\t\r\n\t\tthis.gain = this.context.createGain();\r\n\t\tthis.gain.connect( listener.getInput() );\r\n\t\r\n\t\tthis.autoplay = false;\r\n\t\r\n\t\tthis.startTime = 0;\r\n\t\tthis.playbackRate = 1;\r\n\t\tthis.isPlaying = false;\r\n\t\tthis.hasPlaybackControl = true;\r\n\t\tthis.sourceType = 'empty';\r\n\t\r\n\t\tthis.filter = null;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Audio.prototype = Object.create( THREE.Object3D.prototype );\r\n\tTHREE.Audio.prototype.constructor = THREE.Audio;\r\n\t\r\n\tTHREE.Audio.prototype.getOutput = function () {\r\n\t\r\n\t\treturn this.gain;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Audio.prototype.setNodeSource = function ( audioNode ) {\r\n\t\r\n\t\tthis.hasPlaybackControl = false;\r\n\t\tthis.sourceType = 'audioNode';\r\n\t\tthis.source = audioNode;\r\n\t\tthis.connect();\r\n\t\r\n\t\treturn this;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Audio.prototype.setBuffer = function ( audioBuffer ) {\r\n\t\r\n\t\tvar scope = this;\r\n\t\r\n\t\tscope.source.buffer = audioBuffer;\r\n\t\tscope.sourceType = 'buffer';\r\n\t\tif ( scope.autoplay ) scope.play();\r\n\t\r\n\t\treturn this;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Audio.prototype.play = function () {\r\n\t\r\n\t\tif ( this.isPlaying === true ) {\r\n\t\r\n\t\t\tconsole.warn( 'THREE.Audio: Audio is already playing.' );\r\n\t\t\treturn;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tif ( this.hasPlaybackControl === false ) {\r\n\t\r\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\r\n\t\t\treturn;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar source = this.context.createBufferSource();\r\n\t\r\n\t\tsource.buffer = this.source.buffer;\r\n\t\tsource.loop = this.source.loop;\r\n\t\tsource.onended = this.source.onended;\r\n\t\tsource.start( 0, this.startTime );\r\n\t\tsource.playbackRate.value = this.playbackRate;\r\n\t\r\n\t\tthis.isPlaying = true;\r\n\t\r\n\t\tthis.source = source;\r\n\t\r\n\t\tthis.connect();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Audio.prototype.pause = function () {\r\n\t\r\n\t\tif ( this.hasPlaybackControl === false ) {\r\n\t\r\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\r\n\t\t\treturn;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.source.stop();\r\n\t\tthis.startTime = this.context.currentTime;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Audio.prototype.stop = function () {\r\n\t\r\n\t\tif ( this.hasPlaybackControl === false ) {\r\n\t\r\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\r\n\t\t\treturn;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.source.stop();\r\n\t\tthis.startTime = 0;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Audio.prototype.connect = function () {\r\n\t\r\n\t\tif ( this.filter !== null ) {\r\n\t\r\n\t\t\tthis.source.connect( this.filter );\r\n\t\t\tthis.filter.connect( this.getOutput() );\r\n\t\r\n\t\t} else {\r\n\t\r\n\t\t\tthis.source.connect( this.getOutput() );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Audio.prototype.disconnect = function () {\r\n\t\r\n\t\tif ( this.filter !== null ) {\r\n\t\r\n\t\t\tthis.source.disconnect( this.filter );\r\n\t\t\tthis.filter.disconnect( this.getOutput() );\r\n\t\r\n\t\t} else {\r\n\t\r\n\t\t\tthis.source.disconnect( this.getOutput() );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Audio.prototype.getFilter = function () {\r\n\t\r\n\t\treturn this.filter;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Audio.prototype.setFilter = function ( value ) {\r\n\t\r\n\t\tif ( value === undefined ) value = null;\r\n\t\r\n\t\tif ( this.isPlaying === true ) {\r\n\t\r\n\t\t\tthis.disconnect();\r\n\t\t\tthis.filter = value;\r\n\t\t\tthis.connect();\r\n\t\r\n\t\t} else {\r\n\t\r\n\t\t\tthis.filter = value;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Audio.prototype.setPlaybackRate = function ( value ) {\r\n\t\r\n\t\tif ( this.hasPlaybackControl === false ) {\r\n\t\r\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\r\n\t\t\treturn;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.playbackRate = value;\r\n\t\r\n\t\tif ( this.isPlaying === true ) {\r\n\t\r\n\t\t\tthis.source.playbackRate.value = this.playbackRate;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Audio.prototype.getPlaybackRate = function () {\r\n\t\r\n\t\treturn this.playbackRate;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Audio.prototype.onEnded = function () {\r\n\t\r\n\t\tthis.isPlaying = false;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Audio.prototype.setLoop = function ( value ) {\r\n\t\r\n\t\tif ( this.hasPlaybackControl === false ) {\r\n\t\r\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\r\n\t\t\treturn;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.source.loop = value;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Audio.prototype.getLoop = function () {\r\n\t\r\n\t\tif ( this.hasPlaybackControl === false ) {\r\n\t\r\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\r\n\t\t\treturn false;\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn this.source.loop;\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\tTHREE.Audio.prototype.setVolume = function ( value ) {\r\n\t\r\n\t\tthis.gain.gain.value = value;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Audio.prototype.getVolume = function () {\r\n\t\r\n\t\treturn this.gain.gain.value;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/audio/AudioAnalyser.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.AudioAnalyser = function ( audio, fftSize ) {\r\n\t\r\n\t\tthis.analyser = audio.context.createAnalyser();\r\n\t\tthis.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;\r\n\t\r\n\t\tthis.data = new Uint8Array( this.analyser.frequencyBinCount );\r\n\t\r\n\t\taudio.getOutput().connect( this.analyser );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.AudioAnalyser.prototype = {\r\n\t\r\n\t\tconstructor: THREE.AudioAnalyser,\r\n\t\r\n\t\tgetData: function () {\r\n\t\r\n\t\t\tthis.analyser.getByteFrequencyData( this.data );\r\n\t\t\treturn this.data;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/audio/AudioContext.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tObject.defineProperty( THREE, 'AudioContext', {\r\n\t\r\n\t\tget: ( function () {\r\n\t\r\n\t\t\tvar context;\r\n\t\r\n\t\t\treturn function () {\r\n\t\r\n\t\t\t\tif ( context === undefined ) {\r\n\t\r\n\t\t\t\t\tcontext = new ( window.AudioContext || window.webkitAudioContext )();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn context;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t} )()\r\n\t\r\n\t} );\r\n\t\r\n\t// File:src/audio/PositionalAudio.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.PositionalAudio = function ( listener ) {\r\n\t\r\n\t\tTHREE.Audio.call( this, listener );\r\n\t\r\n\t\tthis.panner = this.context.createPanner();\r\n\t\tthis.panner.connect( this.gain );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.PositionalAudio.prototype = Object.create( THREE.Audio.prototype );\r\n\tTHREE.PositionalAudio.prototype.constructor = THREE.PositionalAudio;\r\n\t\r\n\tTHREE.PositionalAudio.prototype.getOutput = function () {\r\n\t\r\n\t\treturn this.panner;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.PositionalAudio.prototype.setRefDistance = function ( value ) {\r\n\t\r\n\t\tthis.panner.refDistance = value;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.PositionalAudio.prototype.getRefDistance = function () {\r\n\t\r\n\t\treturn this.panner.refDistance;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.PositionalAudio.prototype.setRolloffFactor = function ( value ) {\r\n\t\r\n\t\tthis.panner.rolloffFactor = value;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.PositionalAudio.prototype.getRolloffFactor = function () {\r\n\t\r\n\t\treturn this.panner.rolloffFactor;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.PositionalAudio.prototype.setDistanceModel = function ( value ) {\r\n\t\r\n\t\tthis.panner.distanceModel = value;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.PositionalAudio.prototype.getDistanceModel = function () {\r\n\t\r\n\t\treturn this.panner.distanceModel;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.PositionalAudio.prototype.setMaxDistance = function ( value ) {\r\n\t\r\n\t\tthis.panner.maxDistance = value;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.PositionalAudio.prototype.getMaxDistance = function () {\r\n\t\r\n\t\treturn this.panner.maxDistance;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.PositionalAudio.prototype.updateMatrixWorld = ( function () {\r\n\t\r\n\t\tvar position = new THREE.Vector3();\r\n\t\r\n\t\treturn function updateMatrixWorld( force ) {\r\n\t\r\n\t\t\tTHREE.Object3D.prototype.updateMatrixWorld.call( this, force );\r\n\t\r\n\t\t\tposition.setFromMatrixPosition( this.matrixWorld );\r\n\t\r\n\t\t\tthis.panner.setPosition( position.x, position.y, position.z );\r\n\t\r\n\t\t};\r\n\t\r\n\t} )();\r\n\t\r\n\t// File:src/audio/AudioListener.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.AudioListener = function () {\r\n\t\r\n\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\tthis.type = 'AudioListener';\r\n\t\r\n\t\tthis.context = THREE.AudioContext;\r\n\t\r\n\t\tthis.gain = this.context.createGain();\r\n\t\tthis.gain.connect( this.context.destination );\r\n\t\r\n\t\tthis.filter = null;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.AudioListener.prototype = Object.create( THREE.Object3D.prototype );\r\n\tTHREE.AudioListener.prototype.constructor = THREE.AudioListener;\r\n\t\r\n\tTHREE.AudioListener.prototype.getInput = function () {\r\n\t\r\n\t\treturn this.gain;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.AudioListener.prototype.removeFilter = function ( ) {\r\n\t\r\n\t\tif ( this.filter !== null ) {\r\n\t\r\n\t\t\tthis.gain.disconnect( this.filter );\r\n\t\t\tthis.filter.disconnect( this.context.destination );\r\n\t\t\tthis.gain.connect( this.context.destination );\r\n\t\t\tthis.filter = null;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.AudioListener.prototype.setFilter = function ( value ) {\r\n\t\r\n\t\tif ( this.filter !== null ) {\r\n\t\r\n\t\t\tthis.gain.disconnect( this.filter );\r\n\t\t\tthis.filter.disconnect( this.context.destination );\r\n\t\r\n\t\t} else {\r\n\t\r\n\t\t\tthis.gain.disconnect( this.context.destination );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.filter = value;\r\n\t\tthis.gain.connect( this.filter );\r\n\t\tthis.filter.connect( this.context.destination );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.AudioListener.prototype.getFilter = function () {\r\n\t\r\n\t\treturn this.filter;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.AudioListener.prototype.setMasterVolume = function ( value ) {\r\n\t\r\n\t\tthis.gain.gain.value = value;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.AudioListener.prototype.getMasterVolume = function () {\r\n\t\r\n\t\treturn this.gain.gain.value;\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\tTHREE.AudioListener.prototype.updateMatrixWorld = ( function () {\r\n\t\r\n\t\tvar position = new THREE.Vector3();\r\n\t\tvar quaternion = new THREE.Quaternion();\r\n\t\tvar scale = new THREE.Vector3();\r\n\t\r\n\t\tvar orientation = new THREE.Vector3();\r\n\t\r\n\t\treturn function updateMatrixWorld( force ) {\r\n\t\r\n\t\t\tTHREE.Object3D.prototype.updateMatrixWorld.call( this, force );\r\n\t\r\n\t\t\tvar listener = this.context.listener;\r\n\t\t\tvar up = this.up;\r\n\t\r\n\t\t\tthis.matrixWorld.decompose( position, quaternion, scale );\r\n\t\r\n\t\t\torientation.set( 0, 0, - 1 ).applyQuaternion( quaternion );\r\n\t\r\n\t\t\tlistener.setPosition( position.x, position.y, position.z );\r\n\t\t\tlistener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );\r\n\t\r\n\t\t};\r\n\t\r\n\t} )();\r\n\t\r\n\t// File:src/cameras/Camera.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t*/\r\n\t\r\n\tTHREE.Camera = function () {\r\n\t\r\n\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\tthis.type = 'Camera';\r\n\t\r\n\t\tthis.matrixWorldInverse = new THREE.Matrix4();\r\n\t\tthis.projectionMatrix = new THREE.Matrix4();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Camera.prototype = Object.create( THREE.Object3D.prototype );\r\n\tTHREE.Camera.prototype.constructor = THREE.Camera;\r\n\t\r\n\tTHREE.Camera.prototype.getWorldDirection = function () {\r\n\t\r\n\t\tvar quaternion = new THREE.Quaternion();\r\n\t\r\n\t\treturn function ( optionalTarget ) {\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\r\n\t\t\tthis.getWorldQuaternion( quaternion );\r\n\t\r\n\t\t\treturn result.set( 0, 0, - 1 ).applyQuaternion( quaternion );\r\n\t\r\n\t\t};\r\n\t\r\n\t}();\r\n\t\r\n\tTHREE.Camera.prototype.lookAt = function () {\r\n\t\r\n\t\t// This routine does not support cameras with rotated and/or translated parent(s)\r\n\t\r\n\t\tvar m1 = new THREE.Matrix4();\r\n\t\r\n\t\treturn function ( vector ) {\r\n\t\r\n\t\t\tm1.lookAt( this.position, vector, this.up );\r\n\t\r\n\t\t\tthis.quaternion.setFromRotationMatrix( m1 );\r\n\t\r\n\t\t};\r\n\t\r\n\t}();\r\n\t\r\n\tTHREE.Camera.prototype.clone = function () {\r\n\t\r\n\t\treturn new this.constructor().copy( this );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Camera.prototype.copy = function ( source ) {\r\n\t\r\n\t\tTHREE.Object3D.prototype.copy.call( this, source );\r\n\t\r\n\t\tthis.matrixWorldInverse.copy( source.matrixWorldInverse );\r\n\t\tthis.projectionMatrix.copy( source.projectionMatrix );\r\n\t\r\n\t\treturn this;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/cameras/CubeCamera.js\r\n\t\r\n\t/**\r\n\t * Camera for rendering cube maps\r\n\t *\t- renders scene into axis-aligned cube\r\n\t *\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.CubeCamera = function ( near, far, cubeResolution ) {\r\n\t\r\n\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\tthis.type = 'CubeCamera';\r\n\t\r\n\t\tvar fov = 90, aspect = 1;\r\n\t\r\n\t\tvar cameraPX = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n\t\tcameraPX.up.set( 0, - 1, 0 );\r\n\t\tcameraPX.lookAt( new THREE.Vector3( 1, 0, 0 ) );\r\n\t\tthis.add( cameraPX );\r\n\t\r\n\t\tvar cameraNX = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n\t\tcameraNX.up.set( 0, - 1, 0 );\r\n\t\tcameraNX.lookAt( new THREE.Vector3( - 1, 0, 0 ) );\r\n\t\tthis.add( cameraNX );\r\n\t\r\n\t\tvar cameraPY = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n\t\tcameraPY.up.set( 0, 0, 1 );\r\n\t\tcameraPY.lookAt( new THREE.Vector3( 0, 1, 0 ) );\r\n\t\tthis.add( cameraPY );\r\n\t\r\n\t\tvar cameraNY = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n\t\tcameraNY.up.set( 0, 0, - 1 );\r\n\t\tcameraNY.lookAt( new THREE.Vector3( 0, - 1, 0 ) );\r\n\t\tthis.add( cameraNY );\r\n\t\r\n\t\tvar cameraPZ = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n\t\tcameraPZ.up.set( 0, - 1, 0 );\r\n\t\tcameraPZ.lookAt( new THREE.Vector3( 0, 0, 1 ) );\r\n\t\tthis.add( cameraPZ );\r\n\t\r\n\t\tvar cameraNZ = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n\t\tcameraNZ.up.set( 0, - 1, 0 );\r\n\t\tcameraNZ.lookAt( new THREE.Vector3( 0, 0, - 1 ) );\r\n\t\tthis.add( cameraNZ );\r\n\t\r\n\t\tvar options = { format: THREE.RGBFormat, magFilter: THREE.LinearFilter, minFilter: THREE.LinearFilter };\r\n\t\r\n\t\tthis.renderTarget = new THREE.WebGLRenderTargetCube( cubeResolution, cubeResolution, options );\r\n\t\r\n\t\tthis.updateCubeMap = function ( renderer, scene ) {\r\n\t\r\n\t\t\tif ( this.parent === null ) this.updateMatrixWorld();\r\n\t\r\n\t\t\tvar renderTarget = this.renderTarget;\r\n\t\t\tvar generateMipmaps = renderTarget.texture.generateMipmaps;\r\n\t\r\n\t\t\trenderTarget.texture.generateMipmaps = false;\r\n\t\r\n\t\t\trenderTarget.activeCubeFace = 0;\r\n\t\t\trenderer.render( scene, cameraPX, renderTarget );\r\n\t\r\n\t\t\trenderTarget.activeCubeFace = 1;\r\n\t\t\trenderer.render( scene, cameraNX, renderTarget );\r\n\t\r\n\t\t\trenderTarget.activeCubeFace = 2;\r\n\t\t\trenderer.render( scene, cameraPY, renderTarget );\r\n\t\r\n\t\t\trenderTarget.activeCubeFace = 3;\r\n\t\t\trenderer.render( scene, cameraNY, renderTarget );\r\n\t\r\n\t\t\trenderTarget.activeCubeFace = 4;\r\n\t\t\trenderer.render( scene, cameraPZ, renderTarget );\r\n\t\r\n\t\t\trenderTarget.texture.generateMipmaps = generateMipmaps;\r\n\t\r\n\t\t\trenderTarget.activeCubeFace = 5;\r\n\t\t\trenderer.render( scene, cameraNZ, renderTarget );\r\n\t\r\n\t\t\trenderer.setRenderTarget( null );\r\n\t\r\n\t\t};\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.CubeCamera.prototype = Object.create( THREE.Object3D.prototype );\r\n\tTHREE.CubeCamera.prototype.constructor = THREE.CubeCamera;\r\n\t\r\n\t// File:src/cameras/OrthographicCamera.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.OrthographicCamera = function ( left, right, top, bottom, near, far ) {\r\n\t\r\n\t\tTHREE.Camera.call( this );\r\n\t\r\n\t\tthis.type = 'OrthographicCamera';\r\n\t\r\n\t\tthis.zoom = 1;\r\n\t\r\n\t\tthis.left = left;\r\n\t\tthis.right = right;\r\n\t\tthis.top = top;\r\n\t\tthis.bottom = bottom;\r\n\t\r\n\t\tthis.near = ( near !== undefined ) ? near : 0.1;\r\n\t\tthis.far = ( far !== undefined ) ? far : 2000;\r\n\t\r\n\t\tthis.updateProjectionMatrix();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.OrthographicCamera.prototype = Object.create( THREE.Camera.prototype );\r\n\tTHREE.OrthographicCamera.prototype.constructor = THREE.OrthographicCamera;\r\n\t\r\n\tTHREE.OrthographicCamera.prototype.updateProjectionMatrix = function () {\r\n\t\r\n\t\tvar dx = ( this.right - this.left ) / ( 2 * this.zoom );\r\n\t\tvar dy = ( this.top - this.bottom ) / ( 2 * this.zoom );\r\n\t\tvar cx = ( this.right + this.left ) / 2;\r\n\t\tvar cy = ( this.top + this.bottom ) / 2;\r\n\t\r\n\t\tthis.projectionMatrix.makeOrthographic( cx - dx, cx + dx, cy + dy, cy - dy, this.near, this.far );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.OrthographicCamera.prototype.copy = function ( source ) {\r\n\t\r\n\t\tTHREE.Camera.prototype.copy.call( this, source );\r\n\t\r\n\t\tthis.left = source.left;\r\n\t\tthis.right = source.right;\r\n\t\tthis.top = source.top;\r\n\t\tthis.bottom = source.bottom;\r\n\t\tthis.near = source.near;\r\n\t\tthis.far = source.far;\r\n\t\r\n\t\tthis.zoom = source.zoom;\r\n\t\r\n\t\treturn this;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.OrthographicCamera.prototype.toJSON = function ( meta ) {\r\n\t\r\n\t\tvar data = THREE.Object3D.prototype.toJSON.call( this, meta );\r\n\t\r\n\t\tdata.object.zoom = this.zoom;\r\n\t\tdata.object.left = this.left;\r\n\t\tdata.object.right = this.right;\r\n\t\tdata.object.top = this.top;\r\n\t\tdata.object.bottom = this.bottom;\r\n\t\tdata.object.near = this.near;\r\n\t\tdata.object.far = this.far;\r\n\t\r\n\t\treturn data;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/cameras/PerspectiveCamera.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author greggman / http://games.greggman.com/\r\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\r\n\t * @author tschw\r\n\t */\r\n\t\r\n\tTHREE.PerspectiveCamera = function( fov, aspect, near, far ) {\r\n\t\r\n\t\tTHREE.Camera.call( this );\r\n\t\r\n\t\tthis.type = 'PerspectiveCamera';\r\n\t\r\n\t\tthis.fov = fov !== undefined ? fov : 50;\r\n\t\tthis.zoom = 1;\r\n\t\r\n\t\tthis.near = near !== undefined ? near : 0.1;\r\n\t\tthis.far = far !== undefined ? far : 2000;\r\n\t\tthis.focus = 10;\r\n\t\r\n\t\tthis.aspect = aspect !== undefined ? aspect : 1;\r\n\t\tthis.view = null;\r\n\t\r\n\t\tthis.filmGauge = 35;\t// width of the film (default in millimeters)\r\n\t\tthis.filmOffset = 0;\t// horizontal film offset (same unit as gauge)\r\n\t\r\n\t\tthis.updateProjectionMatrix();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.PerspectiveCamera.prototype = Object.create( THREE.Camera.prototype );\r\n\tTHREE.PerspectiveCamera.prototype.constructor = THREE.PerspectiveCamera;\r\n\t\r\n\t\r\n\t/**\r\n\t * Sets the FOV by focal length (DEPRECATED).\r\n\t *\r\n\t * Optionally also sets .filmGauge, otherwise uses it. See .setFocalLength.\r\n\t */\r\n\tTHREE.PerspectiveCamera.prototype.setLens = function( focalLength, filmGauge ) {\r\n\t\r\n\t\tconsole.warn( \"THREE.PerspectiveCamera.setLens is deprecated. \" +\r\n\t\t\t\t\"Use .setFocalLength and .filmGauge for a photographic setup.\" );\r\n\t\r\n\t\tif ( filmGauge !== undefined ) this.filmGauge = filmGauge;\r\n\t\tthis.setFocalLength( focalLength );\r\n\t\r\n\t};\r\n\t\r\n\t/**\r\n\t * Sets the FOV by focal length in respect to the current .filmGauge.\r\n\t *\r\n\t * The default film gauge is 35, so that the focal length can be specified for\r\n\t * a 35mm (full frame) camera.\r\n\t *\r\n\t * Values for focal length and film gauge must have the same unit.\r\n\t */\r\n\tTHREE.PerspectiveCamera.prototype.setFocalLength = function( focalLength ) {\r\n\t\r\n\t\t// see http://www.bobatkins.com/photography/technical/field_of_view.html\r\n\t\tvar vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;\r\n\t\r\n\t\tthis.fov = THREE.Math.RAD2DEG * 2 * Math.atan( vExtentSlope );\r\n\t\tthis.updateProjectionMatrix();\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\t/**\r\n\t * Calculates the focal length from the current .fov and .filmGauge.\r\n\t */\r\n\tTHREE.PerspectiveCamera.prototype.getFocalLength = function() {\r\n\t\r\n\t\tvar vExtentSlope = Math.tan( THREE.Math.DEG2RAD * 0.5 * this.fov );\r\n\t\r\n\t\treturn 0.5 * this.getFilmHeight() / vExtentSlope;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.PerspectiveCamera.prototype.getEffectiveFOV = function() {\r\n\t\r\n\t\treturn THREE.Math.RAD2DEG * 2 * Math.atan(\r\n\t\t\t\tMath.tan( THREE.Math.DEG2RAD * 0.5 * this.fov ) / this.zoom );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.PerspectiveCamera.prototype.getFilmWidth = function() {\r\n\t\r\n\t\t// film not completely covered in portrait format (aspect < 1)\r\n\t\treturn this.filmGauge * Math.min( this.aspect, 1 );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.PerspectiveCamera.prototype.getFilmHeight = function() {\r\n\t\r\n\t\t// film not completely covered in landscape format (aspect > 1)\r\n\t\treturn this.filmGauge / Math.max( this.aspect, 1 );\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\t\r\n\t/**\r\n\t * Sets an offset in a larger frustum. This is useful for multi-window or\r\n\t * multi-monitor/multi-machine setups.\r\n\t *\r\n\t * For example, if you have 3x2 monitors and each monitor is 1920x1080 and\r\n\t * the monitors are in grid like this\r\n\t *\r\n\t *   +---+---+---+\r\n\t *   | A | B | C |\r\n\t *   +---+---+---+\r\n\t *   | D | E | F |\r\n\t *   +---+---+---+\r\n\t *\r\n\t * then for each monitor you would call it like this\r\n\t *\r\n\t *   var w = 1920;\r\n\t *   var h = 1080;\r\n\t *   var fullWidth = w * 3;\r\n\t *   var fullHeight = h * 2;\r\n\t *\r\n\t *   --A--\r\n\t *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );\r\n\t *   --B--\r\n\t *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );\r\n\t *   --C--\r\n\t *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );\r\n\t *   --D--\r\n\t *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );\r\n\t *   --E--\r\n\t *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );\r\n\t *   --F--\r\n\t *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );\r\n\t *\r\n\t *   Note there is no reason monitors have to be the same size or in a grid.\r\n\t */\r\n\tTHREE.PerspectiveCamera.prototype.setViewOffset = function( fullWidth, fullHeight, x, y, width, height ) {\r\n\t\r\n\t\tthis.aspect = fullWidth / fullHeight;\r\n\t\r\n\t\tthis.view = {\r\n\t\t\tfullWidth: fullWidth,\r\n\t\t\tfullHeight: fullHeight,\r\n\t\t\toffsetX: x,\r\n\t\t\toffsetY: y,\r\n\t\t\twidth: width,\r\n\t\t\theight: height\r\n\t\t};\r\n\t\r\n\t\tthis.updateProjectionMatrix();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.PerspectiveCamera.prototype.updateProjectionMatrix = function() {\r\n\t\r\n\t\tvar near = this.near,\r\n\t\t\ttop = near * Math.tan(\r\n\t\t\t\t\tTHREE.Math.DEG2RAD * 0.5 * this.fov ) / this.zoom,\r\n\t\t\theight = 2 * top,\r\n\t\t\twidth = this.aspect * height,\r\n\t\t\tleft = - 0.5 * width,\r\n\t\t\tview = this.view;\r\n\t\r\n\t\tif ( view !== null ) {\r\n\t\r\n\t\t\tvar fullWidth = view.fullWidth,\r\n\t\t\t\tfullHeight = view.fullHeight;\r\n\t\r\n\t\t\tleft += view.offsetX * width / fullWidth;\r\n\t\t\ttop -= view.offsetY * height / fullHeight;\r\n\t\t\twidth *= view.width / fullWidth;\r\n\t\t\theight *= view.height / fullHeight;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar skew = this.filmOffset;\r\n\t\tif ( skew !== 0 ) left += near * skew / this.getFilmWidth();\r\n\t\r\n\t\tthis.projectionMatrix.makeFrustum(\r\n\t\t\t\tleft, left + width, top - height, top, near, this.far );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.PerspectiveCamera.prototype.copy = function( source ) {\r\n\t\r\n\t\tTHREE.Camera.prototype.copy.call( this, source );\r\n\t\r\n\t\tthis.fov = source.fov;\r\n\t\tthis.zoom = source.zoom;\r\n\t\r\n\t\tthis.near = source.near;\r\n\t\tthis.far = source.far;\r\n\t\tthis.focus = source.focus;\r\n\t\r\n\t\tthis.aspect = source.aspect;\r\n\t\tthis.view = source.view === null ? null : Object.assign( {}, source.view );\r\n\t\r\n\t\tthis.filmGauge = source.filmGauge;\r\n\t\tthis.filmOffset = source.filmOffset;\r\n\t\r\n\t\treturn this;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.PerspectiveCamera.prototype.toJSON = function( meta ) {\r\n\t\r\n\t\tvar data = THREE.Object3D.prototype.toJSON.call( this, meta );\r\n\t\r\n\t\tdata.object.fov = this.fov;\r\n\t\tdata.object.zoom = this.zoom;\r\n\t\r\n\t\tdata.object.near = this.near;\r\n\t\tdata.object.far = this.far;\r\n\t\tdata.object.focus = this.focus;\r\n\t\r\n\t\tdata.object.aspect = this.aspect;\r\n\t\r\n\t\tif ( this.view !== null ) data.object.view = Object.assign( {}, this.view );\r\n\t\r\n\t\tdata.object.filmGauge = this.filmGauge;\r\n\t\tdata.object.filmOffset = this.filmOffset;\r\n\t\r\n\t\treturn data;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/cameras/StereoCamera.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.StereoCamera = function () {\r\n\t\r\n\t\tthis.type = 'StereoCamera';\r\n\t\r\n\t\tthis.aspect = 1;\r\n\t\r\n\t\tthis.cameraL = new THREE.PerspectiveCamera();\r\n\t\tthis.cameraL.layers.enable( 1 );\r\n\t\tthis.cameraL.matrixAutoUpdate = false;\r\n\t\r\n\t\tthis.cameraR = new THREE.PerspectiveCamera();\r\n\t\tthis.cameraR.layers.enable( 2 );\r\n\t\tthis.cameraR.matrixAutoUpdate = false;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.StereoCamera.prototype = {\r\n\t\r\n\t\tconstructor: THREE.StereoCamera,\r\n\t\r\n\t\tupdate: ( function () {\r\n\t\r\n\t\t\tvar focus, fov, aspect, near, far;\r\n\t\r\n\t\t\tvar eyeRight = new THREE.Matrix4();\r\n\t\t\tvar eyeLeft = new THREE.Matrix4();\r\n\t\r\n\t\t\treturn function update ( camera ) {\r\n\t\r\n\t\t\t\tvar needsUpdate = focus !== camera.focus || fov !== camera.fov ||\r\n\t\t\t\t\t\t\t\t\t\t\t\t\taspect !== camera.aspect * this.aspect || near !== camera.near ||\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tfar !== camera.far;\r\n\t\r\n\t\t\t\tif ( needsUpdate ) {\r\n\t\r\n\t\t\t\t\tfocus = camera.focus;\r\n\t\t\t\t\tfov = camera.fov;\r\n\t\t\t\t\taspect = camera.aspect * this.aspect;\r\n\t\t\t\t\tnear = camera.near;\r\n\t\t\t\t\tfar = camera.far;\r\n\t\r\n\t\t\t\t\t// Off-axis stereoscopic effect based on\r\n\t\t\t\t\t// http://paulbourke.net/stereographics/stereorender/\r\n\t\r\n\t\t\t\t\tvar projectionMatrix = camera.projectionMatrix.clone();\r\n\t\t\t\t\tvar eyeSep = 0.064 / 2;\r\n\t\t\t\t\tvar eyeSepOnProjection = eyeSep * near / focus;\r\n\t\t\t\t\tvar ymax = near * Math.tan( THREE.Math.DEG2RAD * fov * 0.5 );\r\n\t\t\t\t\tvar xmin, xmax;\r\n\t\r\n\t\t\t\t\t// translate xOffset\r\n\t\r\n\t\t\t\t\teyeLeft.elements[ 12 ] = - eyeSep;\r\n\t\t\t\t\teyeRight.elements[ 12 ] = eyeSep;\r\n\t\r\n\t\t\t\t\t// for left eye\r\n\t\r\n\t\t\t\t\txmin = - ymax * aspect + eyeSepOnProjection;\r\n\t\t\t\t\txmax = ymax * aspect + eyeSepOnProjection;\r\n\t\r\n\t\t\t\t\tprojectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );\r\n\t\t\t\t\tprojectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );\r\n\t\r\n\t\t\t\t\tthis.cameraL.projectionMatrix.copy( projectionMatrix );\r\n\t\r\n\t\t\t\t\t// for right eye\r\n\t\r\n\t\t\t\t\txmin = - ymax * aspect - eyeSepOnProjection;\r\n\t\t\t\t\txmax = ymax * aspect - eyeSepOnProjection;\r\n\t\r\n\t\t\t\t\tprojectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );\r\n\t\t\t\t\tprojectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );\r\n\t\r\n\t\t\t\t\tthis.cameraR.projectionMatrix.copy( projectionMatrix );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tthis.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( eyeLeft );\r\n\t\t\t\tthis.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( eyeRight );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t} )()\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/lights/Light.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.Light = function ( color, intensity ) {\r\n\t\r\n\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\tthis.type = 'Light';\r\n\t\r\n\t\tthis.color = new THREE.Color( color );\r\n\t\tthis.intensity = intensity !== undefined ? intensity : 1;\r\n\t\r\n\t\tthis.receiveShadow = undefined;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Light.prototype = Object.create( THREE.Object3D.prototype );\r\n\tTHREE.Light.prototype.constructor = THREE.Light;\r\n\t\r\n\tTHREE.Light.prototype.copy = function ( source ) {\r\n\t\r\n\t\tTHREE.Object3D.prototype.copy.call( this, source );\r\n\t\r\n\t\tthis.color.copy( source.color );\r\n\t\tthis.intensity = source.intensity;\r\n\t\r\n\t\treturn this;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Light.prototype.toJSON = function ( meta ) {\r\n\t\r\n\t\tvar data = THREE.Object3D.prototype.toJSON.call( this, meta );\r\n\t\r\n\t\tdata.object.color = this.color.getHex();\r\n\t\tdata.object.intensity = this.intensity;\r\n\t\r\n\t\tif ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();\r\n\t\r\n\t\tif ( this.distance !== undefined ) data.object.distance = this.distance;\r\n\t\tif ( this.angle !== undefined ) data.object.angle = this.angle;\r\n\t\tif ( this.decay !== undefined ) data.object.decay = this.decay;\r\n\t\tif ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;\r\n\t\r\n\t\treturn data;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/lights/LightShadow.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.LightShadow = function ( camera ) {\r\n\t\r\n\t\tthis.camera = camera;\r\n\t\r\n\t\tthis.bias = 0;\r\n\t\tthis.radius = 1;\r\n\t\r\n\t\tthis.mapSize = new THREE.Vector2( 512, 512 );\r\n\t\r\n\t\tthis.map = null;\r\n\t\tthis.matrix = new THREE.Matrix4();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.LightShadow.prototype = {\r\n\t\r\n\t\tconstructor: THREE.LightShadow,\r\n\t\r\n\t\tcopy: function ( source ) {\r\n\t\r\n\t\t\tthis.camera = source.camera.clone();\r\n\t\r\n\t\t\tthis.bias = source.bias;\r\n\t\t\tthis.radius = source.radius;\r\n\t\r\n\t\t\tthis.mapSize.copy( source.mapSize );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new this.constructor().copy( this );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/lights/AmbientLight.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.AmbientLight = function ( color, intensity ) {\r\n\t\r\n\t\tTHREE.Light.call( this, color, intensity );\r\n\t\r\n\t\tthis.type = 'AmbientLight';\r\n\t\r\n\t\tthis.castShadow = undefined;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.AmbientLight.prototype = Object.create( THREE.Light.prototype );\r\n\tTHREE.AmbientLight.prototype.constructor = THREE.AmbientLight;\r\n\t\r\n\t// File:src/lights/DirectionalLight.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.DirectionalLight = function ( color, intensity ) {\r\n\t\r\n\t\tTHREE.Light.call( this, color, intensity );\r\n\t\r\n\t\tthis.type = 'DirectionalLight';\r\n\t\r\n\t\tthis.position.set( 0, 1, 0 );\r\n\t\tthis.updateMatrix();\r\n\t\r\n\t\tthis.target = new THREE.Object3D();\r\n\t\r\n\t\tthis.shadow = new THREE.DirectionalLightShadow();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.DirectionalLight.prototype = Object.create( THREE.Light.prototype );\r\n\tTHREE.DirectionalLight.prototype.constructor = THREE.DirectionalLight;\r\n\t\r\n\tTHREE.DirectionalLight.prototype.copy = function ( source ) {\r\n\t\r\n\t\tTHREE.Light.prototype.copy.call( this, source );\r\n\t\r\n\t\tthis.target = source.target.clone();\r\n\t\r\n\t\tthis.shadow = source.shadow.clone();\r\n\t\r\n\t\treturn this;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/lights/DirectionalLightShadow.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.DirectionalLightShadow = function ( light ) {\r\n\t\r\n\t\tTHREE.LightShadow.call( this, new THREE.OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.DirectionalLightShadow.prototype = Object.create( THREE.LightShadow.prototype );\r\n\tTHREE.DirectionalLightShadow.prototype.constructor = THREE.DirectionalLightShadow;\r\n\t\r\n\t// File:src/lights/HemisphereLight.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.HemisphereLight = function ( skyColor, groundColor, intensity ) {\r\n\t\r\n\t\tTHREE.Light.call( this, skyColor, intensity );\r\n\t\r\n\t\tthis.type = 'HemisphereLight';\r\n\t\r\n\t\tthis.castShadow = undefined;\r\n\t\r\n\t\tthis.position.set( 0, 1, 0 );\r\n\t\tthis.updateMatrix();\r\n\t\r\n\t\tthis.groundColor = new THREE.Color( groundColor );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.HemisphereLight.prototype = Object.create( THREE.Light.prototype );\r\n\tTHREE.HemisphereLight.prototype.constructor = THREE.HemisphereLight;\r\n\t\r\n\tTHREE.HemisphereLight.prototype.copy = function ( source ) {\r\n\t\r\n\t\tTHREE.Light.prototype.copy.call( this, source );\r\n\t\r\n\t\tthis.groundColor.copy( source.groundColor );\r\n\t\r\n\t\treturn this;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/lights/PointLight.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\t\r\n\tTHREE.PointLight = function ( color, intensity, distance, decay ) {\r\n\t\r\n\t\tTHREE.Light.call( this, color, intensity );\r\n\t\r\n\t\tthis.type = 'PointLight';\r\n\t\r\n\t\tthis.distance = ( distance !== undefined ) ? distance : 0;\r\n\t\tthis.decay = ( decay !== undefined ) ? decay : 1;\t// for physically correct lights, should be 2.\r\n\t\r\n\t\tthis.shadow = new THREE.LightShadow( new THREE.PerspectiveCamera( 90, 1, 0.5, 500 ) );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.PointLight.prototype = Object.create( THREE.Light.prototype );\r\n\tTHREE.PointLight.prototype.constructor = THREE.PointLight;\r\n\t\r\n\tObject.defineProperty( THREE.PointLight.prototype, \"power\", {\r\n\t\r\n\t\tget: function () {\r\n\t\r\n\t\t\t// intensity = power per solid angle.\r\n\t\t\t// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\r\n\t\t\treturn this.intensity * 4 * Math.PI;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tset: function ( power ) {\r\n\t\r\n\t\t\t// intensity = power per solid angle.\r\n\t\t\t// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\r\n\t\t\tthis.intensity = power / ( 4 * Math.PI );\r\n\t\r\n\t\t}\r\n\t\r\n\t} );\r\n\t\r\n\tTHREE.PointLight.prototype.copy = function ( source ) {\r\n\t\r\n\t\tTHREE.Light.prototype.copy.call( this, source );\r\n\t\r\n\t\tthis.distance = source.distance;\r\n\t\tthis.decay = source.decay;\r\n\t\r\n\t\tthis.shadow = source.shadow.clone();\r\n\t\r\n\t\treturn this;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/lights/SpotLight.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.SpotLight = function ( color, intensity, distance, angle, penumbra, decay ) {\r\n\t\r\n\t\tTHREE.Light.call( this, color, intensity );\r\n\t\r\n\t\tthis.type = 'SpotLight';\r\n\t\r\n\t\tthis.position.set( 0, 1, 0 );\r\n\t\tthis.updateMatrix();\r\n\t\r\n\t\tthis.target = new THREE.Object3D();\r\n\t\r\n\t\tthis.distance = ( distance !== undefined ) ? distance : 0;\r\n\t\tthis.angle = ( angle !== undefined ) ? angle : Math.PI / 3;\r\n\t\tthis.penumbra = ( penumbra !== undefined ) ? penumbra : 0;\r\n\t\tthis.decay = ( decay !== undefined ) ? decay : 1;\t// for physically correct lights, should be 2.\r\n\t\r\n\t\tthis.shadow = new THREE.SpotLightShadow();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.SpotLight.prototype = Object.create( THREE.Light.prototype );\r\n\tTHREE.SpotLight.prototype.constructor = THREE.SpotLight;\r\n\t\r\n\tObject.defineProperty( THREE.SpotLight.prototype, \"power\", {\r\n\t\r\n\t\tget: function () {\r\n\t\r\n\t\t\t// intensity = power per solid angle.\r\n\t\t\t// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\r\n\t\t\treturn this.intensity * Math.PI;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tset: function ( power ) {\r\n\t\r\n\t\t\t// intensity = power per solid angle.\r\n\t\t\t// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\r\n\t\t\tthis.intensity = power / Math.PI;\r\n\t\r\n\t\t}\r\n\t\r\n\t} );\r\n\t\r\n\tTHREE.SpotLight.prototype.copy = function ( source ) {\r\n\t\r\n\t\tTHREE.Light.prototype.copy.call( this, source );\r\n\t\r\n\t\tthis.distance = source.distance;\r\n\t\tthis.angle = source.angle;\r\n\t\tthis.penumbra = source.penumbra;\r\n\t\tthis.decay = source.decay;\r\n\t\r\n\t\tthis.target = source.target.clone();\r\n\t\r\n\t\tthis.shadow = source.shadow.clone();\r\n\t\r\n\t\treturn this;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/lights/SpotLightShadow.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.SpotLightShadow = function () {\r\n\t\r\n\t\tTHREE.LightShadow.call( this, new THREE.PerspectiveCamera( 50, 1, 0.5, 500 ) );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.SpotLightShadow.prototype = Object.create( THREE.LightShadow.prototype );\r\n\tTHREE.SpotLightShadow.prototype.constructor = THREE.SpotLightShadow;\r\n\t\r\n\tTHREE.SpotLightShadow.prototype.update = function ( light ) {\r\n\t\r\n\t\tvar fov = THREE.Math.RAD2DEG * 2 * light.angle;\r\n\t\tvar aspect = this.mapSize.width / this.mapSize.height;\r\n\t\tvar far = light.distance || 500;\r\n\t\r\n\t\tvar camera = this.camera;\r\n\t\r\n\t\tif ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {\r\n\t\r\n\t\t\tcamera.fov = fov;\r\n\t\t\tcamera.aspect = aspect;\r\n\t\t\tcamera.far = far;\r\n\t\t\tcamera.updateProjectionMatrix();\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/loaders/AudioLoader.js\r\n\t\r\n\t/**\r\n\t * @author Reece Aaron Lecrivain / http://reecenotes.com/\r\n\t */\r\n\t\r\n\tTHREE.AudioLoader = function ( manager ) {\r\n\t\r\n\t\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.AudioLoader.prototype = {\r\n\t\r\n\t\tconstructor: THREE.AudioLoader,\r\n\t\r\n\t\tload: function ( url, onLoad, onProgress, onError ) {\r\n\t\r\n\t\t\tvar loader = new THREE.XHRLoader( this.manager );\r\n\t\t\tloader.setResponseType( 'arraybuffer' );\r\n\t\t\tloader.load( url, function ( buffer ) {\r\n\t\r\n\t\t\t\tvar context = THREE.AudioContext;\r\n\t\r\n\t\t\t\tcontext.decodeAudioData( buffer, function ( audioBuffer ) {\r\n\t\r\n\t\t\t\t\tonLoad( audioBuffer );\r\n\t\r\n\t\t\t\t} );\r\n\t\r\n\t\t\t}, onProgress, onError );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/loaders/Cache.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.Cache = {\r\n\t\r\n\t\tenabled: false,\r\n\t\r\n\t\tfiles: {},\r\n\t\r\n\t\tadd: function ( key, file ) {\r\n\t\r\n\t\t\tif ( this.enabled === false ) return;\r\n\t\r\n\t\t\t// console.log( 'THREE.Cache', 'Adding key:', key );\r\n\t\r\n\t\t\tthis.files[ key ] = file;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tget: function ( key ) {\r\n\t\r\n\t\t\tif ( this.enabled === false ) return;\r\n\t\r\n\t\t\t// console.log( 'THREE.Cache', 'Checking key:', key );\r\n\t\r\n\t\t\treturn this.files[ key ];\r\n\t\r\n\t\t},\r\n\t\r\n\t\tremove: function ( key ) {\r\n\t\r\n\t\t\tdelete this.files[ key ];\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclear: function () {\r\n\t\r\n\t\t\tthis.files = {};\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/loaders/Loader.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.Loader = function () {\r\n\t\r\n\t\tthis.onLoadStart = function () {};\r\n\t\tthis.onLoadProgress = function () {};\r\n\t\tthis.onLoadComplete = function () {};\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Loader.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Loader,\r\n\t\r\n\t\tcrossOrigin: undefined,\r\n\t\r\n\t\textractUrlBase: function ( url ) {\r\n\t\r\n\t\t\tvar parts = url.split( '/' );\r\n\t\r\n\t\t\tif ( parts.length === 1 ) return './';\r\n\t\r\n\t\t\tparts.pop();\r\n\t\r\n\t\t\treturn parts.join( '/' ) + '/';\r\n\t\r\n\t\t},\r\n\t\r\n\t\tinitMaterials: function ( materials, texturePath, crossOrigin ) {\r\n\t\r\n\t\t\tvar array = [];\r\n\t\r\n\t\t\tfor ( var i = 0; i < materials.length; ++ i ) {\r\n\t\r\n\t\t\t\tarray[ i ] = this.createMaterial( materials[ i ], texturePath, crossOrigin );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn array;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcreateMaterial: ( function () {\r\n\t\r\n\t\t\tvar color, textureLoader, materialLoader;\r\n\t\r\n\t\t\treturn function ( m, texturePath, crossOrigin ) {\r\n\t\r\n\t\t\t\tif ( color === undefined ) color = new THREE.Color();\r\n\t\t\t\tif ( textureLoader === undefined ) textureLoader = new THREE.TextureLoader();\r\n\t\t\t\tif ( materialLoader === undefined ) materialLoader = new THREE.MaterialLoader();\r\n\t\r\n\t\t\t\t// convert from old material format\r\n\t\r\n\t\t\t\tvar textures = {};\r\n\t\r\n\t\t\t\tfunction loadTexture( path, repeat, offset, wrap, anisotropy ) {\r\n\t\r\n\t\t\t\t\tvar fullPath = texturePath + path;\r\n\t\t\t\t\tvar loader = THREE.Loader.Handlers.get( fullPath );\r\n\t\r\n\t\t\t\t\tvar texture;\r\n\t\r\n\t\t\t\t\tif ( loader !== null ) {\r\n\t\r\n\t\t\t\t\t\ttexture = loader.load( fullPath );\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\ttextureLoader.setCrossOrigin( crossOrigin );\r\n\t\t\t\t\t\ttexture = textureLoader.load( fullPath );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( repeat !== undefined ) {\r\n\t\r\n\t\t\t\t\t\ttexture.repeat.fromArray( repeat );\r\n\t\r\n\t\t\t\t\t\tif ( repeat[ 0 ] !== 1 ) texture.wrapS = THREE.RepeatWrapping;\r\n\t\t\t\t\t\tif ( repeat[ 1 ] !== 1 ) texture.wrapT = THREE.RepeatWrapping;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( offset !== undefined ) {\r\n\t\r\n\t\t\t\t\t\ttexture.offset.fromArray( offset );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( wrap !== undefined ) {\r\n\t\r\n\t\t\t\t\t\tif ( wrap[ 0 ] === 'repeat' ) texture.wrapS = THREE.RepeatWrapping;\r\n\t\t\t\t\t\tif ( wrap[ 0 ] === 'mirror' ) texture.wrapS = THREE.MirroredRepeatWrapping;\r\n\t\r\n\t\t\t\t\t\tif ( wrap[ 1 ] === 'repeat' ) texture.wrapT = THREE.RepeatWrapping;\r\n\t\t\t\t\t\tif ( wrap[ 1 ] === 'mirror' ) texture.wrapT = THREE.MirroredRepeatWrapping;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( anisotropy !== undefined ) {\r\n\t\r\n\t\t\t\t\t\ttexture.anisotropy = anisotropy;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tvar uuid = THREE.Math.generateUUID();\r\n\t\r\n\t\t\t\t\ttextures[ uuid ] = texture;\r\n\t\r\n\t\t\t\t\treturn uuid;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t//\r\n\t\r\n\t\t\t\tvar json = {\r\n\t\t\t\t\tuuid: THREE.Math.generateUUID(),\r\n\t\t\t\t\ttype: 'MeshLambertMaterial'\r\n\t\t\t\t};\r\n\t\r\n\t\t\t\tfor ( var name in m ) {\r\n\t\r\n\t\t\t\t\tvar value = m[ name ];\r\n\t\r\n\t\t\t\t\tswitch ( name ) {\r\n\t\t\t\t\t\tcase 'DbgColor':\r\n\t\t\t\t\t\tcase 'DbgIndex':\r\n\t\t\t\t\t\tcase 'opticalDensity':\r\n\t\t\t\t\t\tcase 'illumination':\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'DbgName':\r\n\t\t\t\t\t\t\tjson.name = value;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'blending':\r\n\t\t\t\t\t\t\tjson.blending = THREE[ value ];\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'colorAmbient':\r\n\t\t\t\t\t\tcase 'mapAmbient':\r\n\t\t\t\t\t\t\tconsole.warn( 'THREE.Loader.createMaterial:', name, 'is no longer supported.' );\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'colorDiffuse':\r\n\t\t\t\t\t\t\tjson.color = color.fromArray( value ).getHex();\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'colorSpecular':\r\n\t\t\t\t\t\t\tjson.specular = color.fromArray( value ).getHex();\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'colorEmissive':\r\n\t\t\t\t\t\t\tjson.emissive = color.fromArray( value ).getHex();\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'specularCoef':\r\n\t\t\t\t\t\t\tjson.shininess = value;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'shading':\r\n\t\t\t\t\t\t\tif ( value.toLowerCase() === 'basic' ) json.type = 'MeshBasicMaterial';\r\n\t\t\t\t\t\t\tif ( value.toLowerCase() === 'phong' ) json.type = 'MeshPhongMaterial';\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'mapDiffuse':\r\n\t\t\t\t\t\t\tjson.map = loadTexture( value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'mapDiffuseRepeat':\r\n\t\t\t\t\t\tcase 'mapDiffuseOffset':\r\n\t\t\t\t\t\tcase 'mapDiffuseWrap':\r\n\t\t\t\t\t\tcase 'mapDiffuseAnisotropy':\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'mapLight':\r\n\t\t\t\t\t\t\tjson.lightMap = loadTexture( value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'mapLightRepeat':\r\n\t\t\t\t\t\tcase 'mapLightOffset':\r\n\t\t\t\t\t\tcase 'mapLightWrap':\r\n\t\t\t\t\t\tcase 'mapLightAnisotropy':\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'mapAO':\r\n\t\t\t\t\t\t\tjson.aoMap = loadTexture( value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy );\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'mapAORepeat':\r\n\t\t\t\t\t\tcase 'mapAOOffset':\r\n\t\t\t\t\t\tcase 'mapAOWrap':\r\n\t\t\t\t\t\tcase 'mapAOAnisotropy':\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'mapBump':\r\n\t\t\t\t\t\t\tjson.bumpMap = loadTexture( value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'mapBumpScale':\r\n\t\t\t\t\t\t\tjson.bumpScale = value;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'mapBumpRepeat':\r\n\t\t\t\t\t\tcase 'mapBumpOffset':\r\n\t\t\t\t\t\tcase 'mapBumpWrap':\r\n\t\t\t\t\t\tcase 'mapBumpAnisotropy':\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'mapNormal':\r\n\t\t\t\t\t\t\tjson.normalMap = loadTexture( value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'mapNormalFactor':\r\n\t\t\t\t\t\t\tjson.normalScale = [ value, value ];\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'mapNormalRepeat':\r\n\t\t\t\t\t\tcase 'mapNormalOffset':\r\n\t\t\t\t\t\tcase 'mapNormalWrap':\r\n\t\t\t\t\t\tcase 'mapNormalAnisotropy':\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'mapSpecular':\r\n\t\t\t\t\t\t\tjson.specularMap = loadTexture( value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'mapSpecularRepeat':\r\n\t\t\t\t\t\tcase 'mapSpecularOffset':\r\n\t\t\t\t\t\tcase 'mapSpecularWrap':\r\n\t\t\t\t\t\tcase 'mapSpecularAnisotropy':\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'mapAlpha':\r\n\t\t\t\t\t\t\tjson.alphaMap = loadTexture( value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'mapAlphaRepeat':\r\n\t\t\t\t\t\tcase 'mapAlphaOffset':\r\n\t\t\t\t\t\tcase 'mapAlphaWrap':\r\n\t\t\t\t\t\tcase 'mapAlphaAnisotropy':\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'flipSided':\r\n\t\t\t\t\t\t\tjson.side = THREE.BackSide;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'doubleSided':\r\n\t\t\t\t\t\t\tjson.side = THREE.DoubleSide;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'transparency':\r\n\t\t\t\t\t\t\tconsole.warn( 'THREE.Loader.createMaterial: transparency has been renamed to opacity' );\r\n\t\t\t\t\t\t\tjson.opacity = value;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'depthTest':\r\n\t\t\t\t\t\tcase 'depthWrite':\r\n\t\t\t\t\t\tcase 'colorWrite':\r\n\t\t\t\t\t\tcase 'opacity':\r\n\t\t\t\t\t\tcase 'reflectivity':\r\n\t\t\t\t\t\tcase 'transparent':\r\n\t\t\t\t\t\tcase 'visible':\r\n\t\t\t\t\t\tcase 'wireframe':\r\n\t\t\t\t\t\t\tjson[ name ] = value;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'vertexColors':\r\n\t\t\t\t\t\t\tif ( value === true ) json.vertexColors = THREE.VertexColors;\r\n\t\t\t\t\t\t\tif ( value === 'face' ) json.vertexColors = THREE.FaceColors;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\tconsole.error( 'THREE.Loader.createMaterial: Unsupported', name, value );\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( json.type === 'MeshBasicMaterial' ) delete json.emissive;\r\n\t\t\t\tif ( json.type !== 'MeshPhongMaterial' ) delete json.specular;\r\n\t\r\n\t\t\t\tif ( json.opacity < 1 ) json.transparent = true;\r\n\t\r\n\t\t\t\tmaterialLoader.setTextures( textures );\r\n\t\r\n\t\t\t\treturn materialLoader.parse( json );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t} )()\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Loader.Handlers = {\r\n\t\r\n\t\thandlers: [],\r\n\t\r\n\t\tadd: function ( regex, loader ) {\r\n\t\r\n\t\t\tthis.handlers.push( regex, loader );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tget: function ( file ) {\r\n\t\r\n\t\t\tvar handlers = this.handlers;\r\n\t\r\n\t\t\tfor ( var i = 0, l = handlers.length; i < l; i += 2 ) {\r\n\t\r\n\t\t\t\tvar regex = handlers[ i ];\r\n\t\t\t\tvar loader  = handlers[ i + 1 ];\r\n\t\r\n\t\t\t\tif ( regex.test( file ) ) {\r\n\t\r\n\t\t\t\t\treturn loader;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn null;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/loaders/XHRLoader.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.XHRLoader = function ( manager ) {\r\n\t\r\n\t\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.XHRLoader.prototype = {\r\n\t\r\n\t\tconstructor: THREE.XHRLoader,\r\n\t\r\n\t\tload: function ( url, onLoad, onProgress, onError ) {\r\n\t\r\n\t\t\tif ( this.path !== undefined ) url = this.path + url;\r\n\t\r\n\t\t\tvar scope = this;\r\n\t\r\n\t\t\tvar cached = THREE.Cache.get( url );\r\n\t\r\n\t\t\tif ( cached !== undefined ) {\r\n\t\r\n\t\t\t\tif ( onLoad ) {\r\n\t\r\n\t\t\t\t\tsetTimeout( function () {\r\n\t\r\n\t\t\t\t\t\tonLoad( cached );\r\n\t\r\n\t\t\t\t\t}, 0 );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn cached;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar request = new XMLHttpRequest();\r\n\t\t\trequest.overrideMimeType( 'text/plain' );\r\n\t\t\trequest.open( 'GET', url, true );\r\n\t\r\n\t\t\trequest.addEventListener( 'load', function ( event ) {\r\n\t\r\n\t\t\t\tvar response = event.target.response;\r\n\t\r\n\t\t\t\tTHREE.Cache.add( url, response );\r\n\t\r\n\t\t\t\tif ( this.status === 200 ) {\r\n\t\r\n\t\t\t\t\tif ( onLoad ) onLoad( response );\r\n\t\r\n\t\t\t\t\tscope.manager.itemEnd( url );\r\n\t\r\n\t\t\t\t} else if ( this.status === 0 ) {\r\n\t\r\n\t\t\t\t\t// Some browsers return HTTP Status 0 when using non-http protocol\r\n\t\t\t\t\t// e.g. 'file://' or 'data://'. Handle as success.\r\n\t\r\n\t\t\t\t\tconsole.warn( 'THREE.XHRLoader: HTTP Status 0 received.' );\r\n\t\r\n\t\t\t\t\tif ( onLoad ) onLoad( response );\r\n\t\r\n\t\t\t\t\tscope.manager.itemEnd( url );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tif ( onError ) onError( event );\r\n\t\r\n\t\t\t\t\tscope.manager.itemError( url );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}, false );\r\n\t\r\n\t\t\tif ( onProgress !== undefined ) {\r\n\t\r\n\t\t\t\trequest.addEventListener( 'progress', function ( event ) {\r\n\t\r\n\t\t\t\t\tonProgress( event );\r\n\t\r\n\t\t\t\t}, false );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\trequest.addEventListener( 'error', function ( event ) {\r\n\t\r\n\t\t\t\tif ( onError ) onError( event );\r\n\t\r\n\t\t\t\tscope.manager.itemError( url );\r\n\t\r\n\t\t\t}, false );\r\n\t\r\n\t\t\tif ( this.responseType !== undefined ) request.responseType = this.responseType;\r\n\t\t\tif ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;\r\n\t\r\n\t\t\trequest.send( null );\r\n\t\r\n\t\t\tscope.manager.itemStart( url );\r\n\t\r\n\t\t\treturn request;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetPath: function ( value ) {\r\n\t\r\n\t\t\tthis.path = value;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetResponseType: function ( value ) {\r\n\t\r\n\t\t\tthis.responseType = value;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetWithCredentials: function ( value ) {\r\n\t\r\n\t\t\tthis.withCredentials = value;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/loaders/FontLoader.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.FontLoader = function ( manager ) {\r\n\t\r\n\t\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.FontLoader.prototype = {\r\n\t\r\n\t\tconstructor: THREE.FontLoader,\r\n\t\r\n\t\tload: function ( url, onLoad, onProgress, onError ) {\r\n\t\r\n\t\t\tvar loader = new THREE.XHRLoader( this.manager );\r\n\t\t\tloader.load( url, function ( text ) {\r\n\t\r\n\t\t\t\tonLoad( new THREE.Font( JSON.parse( text.substring( 65, text.length - 2 ) ) ) );\r\n\t\r\n\t\t\t}, onProgress, onError );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/loaders/ImageLoader.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.ImageLoader = function ( manager ) {\r\n\t\r\n\t\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.ImageLoader.prototype = {\r\n\t\r\n\t\tconstructor: THREE.ImageLoader,\r\n\t\r\n\t\tload: function ( url, onLoad, onProgress, onError ) {\r\n\t\r\n\t\t\tif ( this.path !== undefined ) url = this.path + url;\r\n\t\r\n\t\t\tvar scope = this;\r\n\t\r\n\t\t\tvar cached = THREE.Cache.get( url );\r\n\t\r\n\t\t\tif ( cached !== undefined ) {\r\n\t\r\n\t\t\t\tscope.manager.itemStart( url );\r\n\t\r\n\t\t\t\tif ( onLoad ) {\r\n\t\r\n\t\t\t\t\tsetTimeout( function () {\r\n\t\r\n\t\t\t\t\t\tonLoad( cached );\r\n\t\r\n\t\t\t\t\t\tscope.manager.itemEnd( url );\r\n\t\r\n\t\t\t\t\t}, 0 );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tscope.manager.itemEnd( url );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn cached;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar image = document.createElement( 'img' );\r\n\t\r\n\t\t\timage.addEventListener( 'load', function ( event ) {\r\n\t\r\n\t\t\t\tTHREE.Cache.add( url, this );\r\n\t\r\n\t\t\t\tif ( onLoad ) onLoad( this );\r\n\t\r\n\t\t\t\tscope.manager.itemEnd( url );\r\n\t\r\n\t\t\t}, false );\r\n\t\r\n\t\t\tif ( onProgress !== undefined ) {\r\n\t\r\n\t\t\t\timage.addEventListener( 'progress', function ( event ) {\r\n\t\r\n\t\t\t\t\tonProgress( event );\r\n\t\r\n\t\t\t\t}, false );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\timage.addEventListener( 'error', function ( event ) {\r\n\t\r\n\t\t\t\tif ( onError ) onError( event );\r\n\t\r\n\t\t\t\tscope.manager.itemError( url );\r\n\t\r\n\t\t\t}, false );\r\n\t\r\n\t\t\tif ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;\r\n\t\r\n\t\t\tscope.manager.itemStart( url );\r\n\t\r\n\t\t\timage.src = url;\r\n\t\r\n\t\t\treturn image;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetCrossOrigin: function ( value ) {\r\n\t\r\n\t\t\tthis.crossOrigin = value;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetPath: function ( value ) {\r\n\t\r\n\t\t\tthis.path = value;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/loaders/JSONLoader.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.JSONLoader = function ( manager ) {\r\n\t\r\n\t\tif ( typeof manager === 'boolean' ) {\r\n\t\r\n\t\t\tconsole.warn( 'THREE.JSONLoader: showStatus parameter has been removed from constructor.' );\r\n\t\t\tmanager = undefined;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\t\r\n\t\tthis.withCredentials = false;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.JSONLoader.prototype = {\r\n\t\r\n\t\tconstructor: THREE.JSONLoader,\r\n\t\r\n\t\t// Deprecated\r\n\t\r\n\t\tget statusDomElement () {\r\n\t\r\n\t\t\tif ( this._statusDomElement === undefined ) {\r\n\t\r\n\t\t\t\tthis._statusDomElement = document.createElement( 'div' );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tconsole.warn( 'THREE.JSONLoader: .statusDomElement has been removed.' );\r\n\t\t\treturn this._statusDomElement;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tload: function( url, onLoad, onProgress, onError ) {\r\n\t\r\n\t\t\tvar scope = this;\r\n\t\r\n\t\t\tvar texturePath = this.texturePath && ( typeof this.texturePath === \"string\" ) ? this.texturePath : THREE.Loader.prototype.extractUrlBase( url );\r\n\t\r\n\t\t\tvar loader = new THREE.XHRLoader( this.manager );\r\n\t\t\tloader.setWithCredentials( this.withCredentials );\r\n\t\t\tloader.load( url, function ( text ) {\r\n\t\r\n\t\t\t\tvar json = JSON.parse( text );\r\n\t\t\t\tvar metadata = json.metadata;\r\n\t\r\n\t\t\t\tif ( metadata !== undefined ) {\r\n\t\r\n\t\t\t\t\tvar type = metadata.type;\r\n\t\r\n\t\t\t\t\tif ( type !== undefined ) {\r\n\t\r\n\t\t\t\t\t\tif ( type.toLowerCase() === 'object' ) {\r\n\t\r\n\t\t\t\t\t\t\tconsole.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.' );\r\n\t\t\t\t\t\t\treturn;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tif ( type.toLowerCase() === 'scene' ) {\r\n\t\r\n\t\t\t\t\t\t\tconsole.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.SceneLoader instead.' );\r\n\t\t\t\t\t\t\treturn;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar object = scope.parse( json, texturePath );\r\n\t\t\t\tonLoad( object.geometry, object.materials );\r\n\t\r\n\t\t\t}, onProgress, onError );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetTexturePath: function ( value ) {\r\n\t\r\n\t\t\tthis.texturePath = value;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tparse: function ( json, texturePath ) {\r\n\t\r\n\t\t\tvar geometry = new THREE.Geometry(),\r\n\t\t\tscale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;\r\n\t\r\n\t\t\tparseModel( scale );\r\n\t\r\n\t\t\tparseSkin();\r\n\t\t\tparseMorphing( scale );\r\n\t\t\tparseAnimations();\r\n\t\r\n\t\t\tgeometry.computeFaceNormals();\r\n\t\t\tgeometry.computeBoundingSphere();\r\n\t\r\n\t\t\tfunction parseModel( scale ) {\r\n\t\r\n\t\t\t\tfunction isBitSet( value, position ) {\r\n\t\r\n\t\t\t\t\treturn value & ( 1 << position );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar i, j, fi,\r\n\t\r\n\t\t\t\toffset, zLength,\r\n\t\r\n\t\t\tcolorIndex, normalIndex, uvIndex, materialIndex,\r\n\t\r\n\t\t\t\ttype,\r\n\t\t\t\tisQuad,\r\n\t\t\t\thasMaterial,\r\n\t\t\t\thasFaceVertexUv,\r\n\t\t\t\thasFaceNormal, hasFaceVertexNormal,\r\n\t\t\t\thasFaceColor, hasFaceVertexColor,\r\n\t\r\n\t\t\tvertex, face, faceA, faceB, hex, normal,\r\n\t\r\n\t\t\t\tuvLayer, uv, u, v,\r\n\t\r\n\t\t\t\tfaces = json.faces,\r\n\t\t\t\tvertices = json.vertices,\r\n\t\t\t\tnormals = json.normals,\r\n\t\t\t\tcolors = json.colors,\r\n\t\r\n\t\t\t\tnUvLayers = 0;\r\n\t\r\n\t\t\t\tif ( json.uvs !== undefined ) {\r\n\t\r\n\t\t\t\t\t// disregard empty arrays\r\n\t\r\n\t\t\t\t\tfor ( i = 0; i < json.uvs.length; i ++ ) {\r\n\t\r\n\t\t\t\t\t\tif ( json.uvs[ i ].length ) nUvLayers ++;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\r\n\t\r\n\t\t\t\t\t\tgeometry.faceVertexUvs[ i ] = [];\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\toffset = 0;\r\n\t\t\t\tzLength = vertices.length;\r\n\t\r\n\t\t\t\twhile ( offset < zLength ) {\r\n\t\r\n\t\t\t\t\tvertex = new THREE.Vector3();\r\n\t\r\n\t\t\t\t\tvertex.x = vertices[ offset ++ ] * scale;\r\n\t\t\t\t\tvertex.y = vertices[ offset ++ ] * scale;\r\n\t\t\t\t\tvertex.z = vertices[ offset ++ ] * scale;\r\n\t\r\n\t\t\t\t\tgeometry.vertices.push( vertex );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\toffset = 0;\r\n\t\t\t\tzLength = faces.length;\r\n\t\r\n\t\t\t\twhile ( offset < zLength ) {\r\n\t\r\n\t\t\t\t\ttype = faces[ offset ++ ];\r\n\t\r\n\t\r\n\t\t\t\t\tisQuad              = isBitSet( type, 0 );\r\n\t\t\t\t\thasMaterial         = isBitSet( type, 1 );\r\n\t\t\t\t\thasFaceVertexUv     = isBitSet( type, 3 );\r\n\t\t\t\t\thasFaceNormal       = isBitSet( type, 4 );\r\n\t\t\t\t\thasFaceVertexNormal = isBitSet( type, 5 );\r\n\t\t\t\t\thasFaceColor\t     = isBitSet( type, 6 );\r\n\t\t\t\t\thasFaceVertexColor  = isBitSet( type, 7 );\r\n\t\r\n\t\t\t\t\t// console.log(\"type\", type, \"bits\", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);\r\n\t\r\n\t\t\t\t\tif ( isQuad ) {\r\n\t\r\n\t\t\t\t\t\tfaceA = new THREE.Face3();\r\n\t\t\t\t\t\tfaceA.a = faces[ offset ];\r\n\t\t\t\t\t\tfaceA.b = faces[ offset + 1 ];\r\n\t\t\t\t\t\tfaceA.c = faces[ offset + 3 ];\r\n\t\r\n\t\t\t\t\t\tfaceB = new THREE.Face3();\r\n\t\t\t\t\t\tfaceB.a = faces[ offset + 1 ];\r\n\t\t\t\t\t\tfaceB.b = faces[ offset + 2 ];\r\n\t\t\t\t\t\tfaceB.c = faces[ offset + 3 ];\r\n\t\r\n\t\t\t\t\t\toffset += 4;\r\n\t\r\n\t\t\t\t\t\tif ( hasMaterial ) {\r\n\t\r\n\t\t\t\t\t\t\tmaterialIndex = faces[ offset ++ ];\r\n\t\t\t\t\t\t\tfaceA.materialIndex = materialIndex;\r\n\t\t\t\t\t\t\tfaceB.materialIndex = materialIndex;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t// to get face <=> uv index correspondence\r\n\t\r\n\t\t\t\t\t\tfi = geometry.faces.length;\r\n\t\r\n\t\t\t\t\t\tif ( hasFaceVertexUv ) {\r\n\t\r\n\t\t\t\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\tuvLayer = json.uvs[ i ];\r\n\t\r\n\t\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ] = [];\r\n\t\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi + 1 ] = [];\r\n\t\r\n\t\t\t\t\t\t\t\tfor ( j = 0; j < 4; j ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\t\tuvIndex = faces[ offset ++ ];\r\n\t\r\n\t\t\t\t\t\t\t\t\tu = uvLayer[ uvIndex * 2 ];\r\n\t\t\t\t\t\t\t\t\tv = uvLayer[ uvIndex * 2 + 1 ];\r\n\t\r\n\t\t\t\t\t\t\t\t\tuv = new THREE.Vector2( u, v );\r\n\t\r\n\t\t\t\t\t\t\t\t\tif ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );\r\n\t\t\t\t\t\t\t\t\tif ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );\r\n\t\r\n\t\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tif ( hasFaceNormal ) {\r\n\t\r\n\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\r\n\t\r\n\t\t\t\t\t\t\tfaceA.normal.set(\r\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\t\tnormals[ normalIndex ]\r\n\t\t\t\t\t\t\t);\r\n\t\r\n\t\t\t\t\t\t\tfaceB.normal.copy( faceA.normal );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tif ( hasFaceVertexNormal ) {\r\n\t\r\n\t\t\t\t\t\t\tfor ( i = 0; i < 4; i ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\r\n\t\r\n\t\t\t\t\t\t\t\tnormal = new THREE.Vector3(\r\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ]\r\n\t\t\t\t\t\t\t\t);\r\n\t\r\n\t\r\n\t\t\t\t\t\t\t\tif ( i !== 2 ) faceA.vertexNormals.push( normal );\r\n\t\t\t\t\t\t\t\tif ( i !== 0 ) faceB.vertexNormals.push( normal );\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\r\n\t\t\t\t\t\tif ( hasFaceColor ) {\r\n\t\r\n\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\r\n\t\t\t\t\t\t\thex = colors[ colorIndex ];\r\n\t\r\n\t\t\t\t\t\t\tfaceA.color.setHex( hex );\r\n\t\t\t\t\t\t\tfaceB.color.setHex( hex );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\r\n\t\t\t\t\t\tif ( hasFaceVertexColor ) {\r\n\t\r\n\t\t\t\t\t\t\tfor ( i = 0; i < 4; i ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\r\n\t\t\t\t\t\t\t\thex = colors[ colorIndex ];\r\n\t\r\n\t\t\t\t\t\t\t\tif ( i !== 2 ) faceA.vertexColors.push( new THREE.Color( hex ) );\r\n\t\t\t\t\t\t\t\tif ( i !== 0 ) faceB.vertexColors.push( new THREE.Color( hex ) );\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tgeometry.faces.push( faceA );\r\n\t\t\t\t\t\tgeometry.faces.push( faceB );\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tface = new THREE.Face3();\r\n\t\t\t\t\t\tface.a = faces[ offset ++ ];\r\n\t\t\t\t\t\tface.b = faces[ offset ++ ];\r\n\t\t\t\t\t\tface.c = faces[ offset ++ ];\r\n\t\r\n\t\t\t\t\t\tif ( hasMaterial ) {\r\n\t\r\n\t\t\t\t\t\t\tmaterialIndex = faces[ offset ++ ];\r\n\t\t\t\t\t\t\tface.materialIndex = materialIndex;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t// to get face <=> uv index correspondence\r\n\t\r\n\t\t\t\t\t\tfi = geometry.faces.length;\r\n\t\r\n\t\t\t\t\t\tif ( hasFaceVertexUv ) {\r\n\t\r\n\t\t\t\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\tuvLayer = json.uvs[ i ];\r\n\t\r\n\t\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ] = [];\r\n\t\r\n\t\t\t\t\t\t\t\tfor ( j = 0; j < 3; j ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\t\tuvIndex = faces[ offset ++ ];\r\n\t\r\n\t\t\t\t\t\t\t\t\tu = uvLayer[ uvIndex * 2 ];\r\n\t\t\t\t\t\t\t\t\tv = uvLayer[ uvIndex * 2 + 1 ];\r\n\t\r\n\t\t\t\t\t\t\t\t\tuv = new THREE.Vector2( u, v );\r\n\t\r\n\t\t\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ].push( uv );\r\n\t\r\n\t\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tif ( hasFaceNormal ) {\r\n\t\r\n\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\r\n\t\r\n\t\t\t\t\t\t\tface.normal.set(\r\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\t\tnormals[ normalIndex ]\r\n\t\t\t\t\t\t\t);\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tif ( hasFaceVertexNormal ) {\r\n\t\r\n\t\t\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\r\n\t\r\n\t\t\t\t\t\t\t\tnormal = new THREE.Vector3(\r\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ]\r\n\t\t\t\t\t\t\t\t);\r\n\t\r\n\t\t\t\t\t\t\t\tface.vertexNormals.push( normal );\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\r\n\t\t\t\t\t\tif ( hasFaceColor ) {\r\n\t\r\n\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\r\n\t\t\t\t\t\t\tface.color.setHex( colors[ colorIndex ] );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\r\n\t\t\t\t\t\tif ( hasFaceVertexColor ) {\r\n\t\r\n\t\t\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\r\n\t\t\t\t\t\t\t\tface.vertexColors.push( new THREE.Color( colors[ colorIndex ] ) );\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tgeometry.faces.push( face );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t\tfunction parseSkin() {\r\n\t\r\n\t\t\t\tvar influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;\r\n\t\r\n\t\t\t\tif ( json.skinWeights ) {\r\n\t\r\n\t\t\t\t\tfor ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {\r\n\t\r\n\t\t\t\t\t\tvar x =                               json.skinWeights[ i ];\r\n\t\t\t\t\t\tvar y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;\r\n\t\t\t\t\t\tvar z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;\r\n\t\t\t\t\t\tvar w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;\r\n\t\r\n\t\t\t\t\t\tgeometry.skinWeights.push( new THREE.Vector4( x, y, z, w ) );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( json.skinIndices ) {\r\n\t\r\n\t\t\t\t\tfor ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {\r\n\t\r\n\t\t\t\t\t\tvar a =                               json.skinIndices[ i ];\r\n\t\t\t\t\t\tvar b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;\r\n\t\t\t\t\t\tvar c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;\r\n\t\t\t\t\t\tvar d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;\r\n\t\r\n\t\t\t\t\t\tgeometry.skinIndices.push( new THREE.Vector4( a, b, c, d ) );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tgeometry.bones = json.bones;\r\n\t\r\n\t\t\t\tif ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {\r\n\t\r\n\t\t\t\t\tconsole.warn( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +\r\n\t\t\t\t\t\tgeometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t\tfunction parseMorphing( scale ) {\r\n\t\r\n\t\t\t\tif ( json.morphTargets !== undefined ) {\r\n\t\r\n\t\t\t\t\tfor ( var i = 0, l = json.morphTargets.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\t\tgeometry.morphTargets[ i ] = {};\r\n\t\t\t\t\t\tgeometry.morphTargets[ i ].name = json.morphTargets[ i ].name;\r\n\t\t\t\t\t\tgeometry.morphTargets[ i ].vertices = [];\r\n\t\r\n\t\t\t\t\t\tvar dstVertices = geometry.morphTargets[ i ].vertices;\r\n\t\t\t\t\t\tvar srcVertices = json.morphTargets[ i ].vertices;\r\n\t\r\n\t\t\t\t\t\tfor ( var v = 0, vl = srcVertices.length; v < vl; v += 3 ) {\r\n\t\r\n\t\t\t\t\t\t\tvar vertex = new THREE.Vector3();\r\n\t\t\t\t\t\t\tvertex.x = srcVertices[ v ] * scale;\r\n\t\t\t\t\t\t\tvertex.y = srcVertices[ v + 1 ] * scale;\r\n\t\t\t\t\t\t\tvertex.z = srcVertices[ v + 2 ] * scale;\r\n\t\r\n\t\t\t\t\t\t\tdstVertices.push( vertex );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( json.morphColors !== undefined && json.morphColors.length > 0 ) {\r\n\t\r\n\t\t\t\t\tconsole.warn( 'THREE.JSONLoader: \"morphColors\" no longer supported. Using them as face colors.' );\r\n\t\r\n\t\t\t\t\tvar faces = geometry.faces;\r\n\t\t\t\t\tvar morphColors = json.morphColors[ 0 ].colors;\r\n\t\r\n\t\t\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\t\tfaces[ i ].color.fromArray( morphColors, i * 3 );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfunction parseAnimations() {\r\n\t\r\n\t\t\t\tvar outputAnimations = [];\r\n\t\r\n\t\t\t\t// parse old style Bone/Hierarchy animations\r\n\t\t\t\tvar animations = [];\r\n\t\r\n\t\t\t\tif ( json.animation !== undefined ) {\r\n\t\r\n\t\t\t\t\tanimations.push( json.animation );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( json.animations !== undefined ) {\r\n\t\r\n\t\t\t\t\tif ( json.animations.length ) {\r\n\t\r\n\t\t\t\t\t\tanimations = animations.concat( json.animations );\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tanimations.push( json.animations );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tfor ( var i = 0; i < animations.length; i ++ ) {\r\n\t\r\n\t\t\t\t\tvar clip = THREE.AnimationClip.parseAnimation( animations[ i ], geometry.bones );\r\n\t\t\t\t\tif ( clip ) outputAnimations.push( clip );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// parse implicit morph animations\r\n\t\t\t\tif ( geometry.morphTargets ) {\r\n\t\r\n\t\t\t\t\t// TODO: Figure out what an appropraite FPS is for morph target animations -- defaulting to 10, but really it is completely arbitrary.\r\n\t\t\t\t\tvar morphAnimationClips = THREE.AnimationClip.CreateClipsFromMorphTargetSequences( geometry.morphTargets, 10 );\r\n\t\t\t\t\toutputAnimations = outputAnimations.concat( morphAnimationClips );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( outputAnimations.length > 0 ) geometry.animations = outputAnimations;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t\tif ( json.materials === undefined || json.materials.length === 0 ) {\r\n\t\r\n\t\t\t\treturn { geometry: geometry };\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tvar materials = THREE.Loader.prototype.initMaterials( json.materials, texturePath, this.crossOrigin );\r\n\t\r\n\t\t\t\treturn { geometry: geometry, materials: materials };\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/loaders/LoadingManager.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.LoadingManager = function ( onLoad, onProgress, onError ) {\r\n\t\r\n\t\tvar scope = this;\r\n\t\r\n\t\tvar isLoading = false, itemsLoaded = 0, itemsTotal = 0;\r\n\t\r\n\t\tthis.onStart = undefined;\r\n\t\tthis.onLoad = onLoad;\r\n\t\tthis.onProgress = onProgress;\r\n\t\tthis.onError = onError;\r\n\t\r\n\t\tthis.itemStart = function ( url ) {\r\n\t\r\n\t\t\titemsTotal ++;\r\n\t\r\n\t\t\tif ( isLoading === false ) {\r\n\t\r\n\t\t\t\tif ( scope.onStart !== undefined ) {\r\n\t\r\n\t\t\t\t\tscope.onStart( url, itemsLoaded, itemsTotal );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tisLoading = true;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.itemEnd = function ( url ) {\r\n\t\r\n\t\t\titemsLoaded ++;\r\n\t\r\n\t\t\tif ( scope.onProgress !== undefined ) {\r\n\t\r\n\t\t\t\tscope.onProgress( url, itemsLoaded, itemsTotal );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( itemsLoaded === itemsTotal ) {\r\n\t\r\n\t\t\t\tisLoading = false;\r\n\t\r\n\t\t\t\tif ( scope.onLoad !== undefined ) {\r\n\t\r\n\t\t\t\t\tscope.onLoad();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.itemError = function ( url ) {\r\n\t\r\n\t\t\tif ( scope.onError !== undefined ) {\r\n\t\r\n\t\t\t\tscope.onError( url );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.DefaultLoadingManager = new THREE.LoadingManager();\r\n\t\r\n\t// File:src/loaders/BufferGeometryLoader.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.BufferGeometryLoader = function ( manager ) {\r\n\t\r\n\t\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.BufferGeometryLoader.prototype = {\r\n\t\r\n\t\tconstructor: THREE.BufferGeometryLoader,\r\n\t\r\n\t\tload: function ( url, onLoad, onProgress, onError ) {\r\n\t\r\n\t\t\tvar scope = this;\r\n\t\r\n\t\t\tvar loader = new THREE.XHRLoader( scope.manager );\r\n\t\t\tloader.load( url, function ( text ) {\r\n\t\r\n\t\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\r\n\t\r\n\t\t\t}, onProgress, onError );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tparse: function ( json ) {\r\n\t\r\n\t\t\tvar geometry = new THREE.BufferGeometry();\r\n\t\r\n\t\t\tvar index = json.data.index;\r\n\t\r\n\t\t\tvar TYPED_ARRAYS = {\r\n\t\t\t\t'Int8Array': Int8Array,\r\n\t\t\t\t'Uint8Array': Uint8Array,\r\n\t\t\t\t'Uint8ClampedArray': Uint8ClampedArray,\r\n\t\t\t\t'Int16Array': Int16Array,\r\n\t\t\t\t'Uint16Array': Uint16Array,\r\n\t\t\t\t'Int32Array': Int32Array,\r\n\t\t\t\t'Uint32Array': Uint32Array,\r\n\t\t\t\t'Float32Array': Float32Array,\r\n\t\t\t\t'Float64Array': Float64Array\r\n\t\t\t};\r\n\t\r\n\t\t\tif ( index !== undefined ) {\r\n\t\r\n\t\t\t\tvar typedArray = new TYPED_ARRAYS[ index.type ]( index.array );\r\n\t\t\t\tgeometry.setIndex( new THREE.BufferAttribute( typedArray, 1 ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar attributes = json.data.attributes;\r\n\t\r\n\t\t\tfor ( var key in attributes ) {\r\n\t\r\n\t\t\t\tvar attribute = attributes[ key ];\r\n\t\t\t\tvar typedArray = new TYPED_ARRAYS[ attribute.type ]( attribute.array );\r\n\t\r\n\t\t\t\tgeometry.addAttribute( key, new THREE.BufferAttribute( typedArray, attribute.itemSize, attribute.normalized ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar groups = json.data.groups || json.data.drawcalls || json.data.offsets;\r\n\t\r\n\t\t\tif ( groups !== undefined ) {\r\n\t\r\n\t\t\t\tfor ( var i = 0, n = groups.length; i !== n; ++ i ) {\r\n\t\r\n\t\t\t\t\tvar group = groups[ i ];\r\n\t\r\n\t\t\t\t\tgeometry.addGroup( group.start, group.count, group.materialIndex );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar boundingSphere = json.data.boundingSphere;\r\n\t\r\n\t\t\tif ( boundingSphere !== undefined ) {\r\n\t\r\n\t\t\t\tvar center = new THREE.Vector3();\r\n\t\r\n\t\t\t\tif ( boundingSphere.center !== undefined ) {\r\n\t\r\n\t\t\t\t\tcenter.fromArray( boundingSphere.center );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tgeometry.boundingSphere = new THREE.Sphere( center, boundingSphere.radius );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn geometry;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/loaders/MaterialLoader.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.MaterialLoader = function ( manager ) {\r\n\t\r\n\t\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\t\tthis.textures = {};\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MaterialLoader.prototype = {\r\n\t\r\n\t\tconstructor: THREE.MaterialLoader,\r\n\t\r\n\t\tload: function ( url, onLoad, onProgress, onError ) {\r\n\t\r\n\t\t\tvar scope = this;\r\n\t\r\n\t\t\tvar loader = new THREE.XHRLoader( scope.manager );\r\n\t\t\tloader.load( url, function ( text ) {\r\n\t\r\n\t\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\r\n\t\r\n\t\t\t}, onProgress, onError );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetTextures: function ( value ) {\r\n\t\r\n\t\t\tthis.textures = value;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetTexture: function ( name ) {\r\n\t\r\n\t\t\tvar textures = this.textures;\r\n\t\r\n\t\t\tif ( textures[ name ] === undefined ) {\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.MaterialLoader: Undefined texture', name );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn textures[ name ];\r\n\t\r\n\t\t},\r\n\t\r\n\t\tparse: function ( json ) {\r\n\t\r\n\t\t\tvar material = new THREE[ json.type ];\r\n\t\r\n\t\t\tif ( json.uuid !== undefined ) material.uuid = json.uuid;\r\n\t\t\tif ( json.name !== undefined ) material.name = json.name;\r\n\t\t\tif ( json.color !== undefined ) material.color.setHex( json.color );\r\n\t\t\tif ( json.roughness !== undefined ) material.roughness = json.roughness;\r\n\t\t\tif ( json.metalness !== undefined ) material.metalness = json.metalness;\r\n\t\t\tif ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );\r\n\t\t\tif ( json.specular !== undefined ) material.specular.setHex( json.specular );\r\n\t\t\tif ( json.shininess !== undefined ) material.shininess = json.shininess;\r\n\t\t\tif ( json.uniforms !== undefined ) material.uniforms = json.uniforms;\r\n\t\t\tif ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;\r\n\t\t\tif ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;\r\n\t\t\tif ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;\r\n\t\t\tif ( json.shading !== undefined ) material.shading = json.shading;\r\n\t\t\tif ( json.blending !== undefined ) material.blending = json.blending;\r\n\t\t\tif ( json.side !== undefined ) material.side = json.side;\r\n\t\t\tif ( json.opacity !== undefined ) material.opacity = json.opacity;\r\n\t\t\tif ( json.transparent !== undefined ) material.transparent = json.transparent;\r\n\t\t\tif ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;\r\n\t\t\tif ( json.depthTest !== undefined ) material.depthTest = json.depthTest;\r\n\t\t\tif ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;\r\n\t\t\tif ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;\r\n\t\t\tif ( json.wireframe !== undefined ) material.wireframe = json.wireframe;\r\n\t\t\tif ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;\r\n\t\r\n\t\t\t// for PointsMaterial\r\n\t\t\tif ( json.size !== undefined ) material.size = json.size;\r\n\t\t\tif ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;\r\n\t\r\n\t\t\t// maps\r\n\t\r\n\t\t\tif ( json.map !== undefined ) material.map = this.getTexture( json.map );\r\n\t\r\n\t\t\tif ( json.alphaMap !== undefined ) {\r\n\t\r\n\t\t\t\tmaterial.alphaMap = this.getTexture( json.alphaMap );\r\n\t\t\t\tmaterial.transparent = true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( json.bumpMap !== undefined ) material.bumpMap = this.getTexture( json.bumpMap );\r\n\t\t\tif ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;\r\n\t\r\n\t\t\tif ( json.normalMap !== undefined ) material.normalMap = this.getTexture( json.normalMap );\r\n\t\t\tif ( json.normalScale !== undefined ) {\r\n\t\r\n\t\t\t\tvar normalScale = json.normalScale;\r\n\t\r\n\t\t\t\tif ( Array.isArray( normalScale ) === false ) {\r\n\t\r\n\t\t\t\t\t// Blender exporter used to export a scalar. See #7459\r\n\t\r\n\t\t\t\t\tnormalScale = [ normalScale, normalScale ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tmaterial.normalScale = new THREE.Vector2().fromArray( normalScale );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( json.displacementMap !== undefined ) material.displacementMap = this.getTexture( json.displacementMap );\r\n\t\t\tif ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;\r\n\t\t\tif ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;\r\n\t\r\n\t\t\tif ( json.roughnessMap !== undefined ) material.roughnessMap = this.getTexture( json.roughnessMap );\r\n\t\t\tif ( json.metalnessMap !== undefined ) material.metalnessMap = this.getTexture( json.metalnessMap );\r\n\t\r\n\t\t\tif ( json.emissiveMap !== undefined ) material.emissiveMap = this.getTexture( json.emissiveMap );\r\n\t\t\tif ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;\r\n\t\r\n\t\t\tif ( json.specularMap !== undefined ) material.specularMap = this.getTexture( json.specularMap );\r\n\t\r\n\t\t\tif ( json.envMap !== undefined ) {\r\n\t\r\n\t\t\t\tmaterial.envMap = this.getTexture( json.envMap );\r\n\t\t\t\tmaterial.combine = THREE.MultiplyOperation;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( json.reflectivity ) material.reflectivity = json.reflectivity;\r\n\t\r\n\t\t\tif ( json.lightMap !== undefined ) material.lightMap = this.getTexture( json.lightMap );\r\n\t\t\tif ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;\r\n\t\r\n\t\t\tif ( json.aoMap !== undefined ) material.aoMap = this.getTexture( json.aoMap );\r\n\t\t\tif ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;\r\n\t\r\n\t\t\t// MultiMaterial\r\n\t\r\n\t\t\tif ( json.materials !== undefined ) {\r\n\t\r\n\t\t\t\tfor ( var i = 0, l = json.materials.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\tmaterial.materials.push( this.parse( json.materials[ i ] ) );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn material;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/loaders/ObjectLoader.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.ObjectLoader = function ( manager ) {\r\n\t\r\n\t\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\t\tthis.texturePath = '';\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.ObjectLoader.prototype = {\r\n\t\r\n\t\tconstructor: THREE.ObjectLoader,\r\n\t\r\n\t\tload: function ( url, onLoad, onProgress, onError ) {\r\n\t\r\n\t\t\tif ( this.texturePath === '' ) {\r\n\t\r\n\t\t\t\tthis.texturePath = url.substring( 0, url.lastIndexOf( '/' ) + 1 );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar scope = this;\r\n\t\r\n\t\t\tvar loader = new THREE.XHRLoader( scope.manager );\r\n\t\t\tloader.load( url, function ( text ) {\r\n\t\r\n\t\t\t\tscope.parse( JSON.parse( text ), onLoad );\r\n\t\r\n\t\t\t}, onProgress, onError );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetTexturePath: function ( value ) {\r\n\t\r\n\t\t\tthis.texturePath = value;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetCrossOrigin: function ( value ) {\r\n\t\r\n\t\t\tthis.crossOrigin = value;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tparse: function ( json, onLoad ) {\r\n\t\r\n\t\t\tvar geometries = this.parseGeometries( json.geometries );\r\n\t\r\n\t\t\tvar images = this.parseImages( json.images, function () {\r\n\t\r\n\t\t\t\tif ( onLoad !== undefined ) onLoad( object );\r\n\t\r\n\t\t\t} );\r\n\t\r\n\t\t\tvar textures  = this.parseTextures( json.textures, images );\r\n\t\t\tvar materials = this.parseMaterials( json.materials, textures );\r\n\t\r\n\t\t\tvar object = this.parseObject( json.object, geometries, materials );\r\n\t\r\n\t\t\tif ( json.animations ) {\r\n\t\r\n\t\t\t\tobject.animations = this.parseAnimations( json.animations );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( json.images === undefined || json.images.length === 0 ) {\r\n\t\r\n\t\t\t\tif ( onLoad !== undefined ) onLoad( object );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn object;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tparseGeometries: function ( json ) {\r\n\t\r\n\t\t\tvar geometries = {};\r\n\t\r\n\t\t\tif ( json !== undefined ) {\r\n\t\r\n\t\t\t\tvar geometryLoader = new THREE.JSONLoader();\r\n\t\t\t\tvar bufferGeometryLoader = new THREE.BufferGeometryLoader();\r\n\t\r\n\t\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\tvar geometry;\r\n\t\t\t\t\tvar data = json[ i ];\r\n\t\r\n\t\t\t\t\tswitch ( data.type ) {\r\n\t\r\n\t\t\t\t\t\tcase 'PlaneGeometry':\r\n\t\t\t\t\t\tcase 'PlaneBufferGeometry':\r\n\t\r\n\t\t\t\t\t\t\tgeometry = new THREE[ data.type ](\r\n\t\t\t\t\t\t\t\tdata.width,\r\n\t\t\t\t\t\t\t\tdata.height,\r\n\t\t\t\t\t\t\t\tdata.widthSegments,\r\n\t\t\t\t\t\t\t\tdata.heightSegments\r\n\t\t\t\t\t\t\t);\r\n\t\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tcase 'BoxGeometry':\r\n\t\t\t\t\t\tcase 'BoxBufferGeometry':\r\n\t\t\t\t\t\tcase 'CubeGeometry': // backwards compatible\r\n\t\r\n\t\t\t\t\t\t\tgeometry = new THREE[ data.type ](\r\n\t\t\t\t\t\t\t\tdata.width,\r\n\t\t\t\t\t\t\t\tdata.height,\r\n\t\t\t\t\t\t\t\tdata.depth,\r\n\t\t\t\t\t\t\t\tdata.widthSegments,\r\n\t\t\t\t\t\t\t\tdata.heightSegments,\r\n\t\t\t\t\t\t\t\tdata.depthSegments\r\n\t\t\t\t\t\t\t);\r\n\t\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tcase 'CircleGeometry':\r\n\t\t\t\t\t\tcase 'CircleBufferGeometry':\r\n\t\r\n\t\t\t\t\t\t\tgeometry = new THREE[ data.type ](\r\n\t\t\t\t\t\t\t\tdata.radius,\r\n\t\t\t\t\t\t\t\tdata.segments,\r\n\t\t\t\t\t\t\t\tdata.thetaStart,\r\n\t\t\t\t\t\t\t\tdata.thetaLength\r\n\t\t\t\t\t\t\t);\r\n\t\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tcase 'CylinderGeometry':\r\n\t\t\t\t\t\tcase 'CylinderBufferGeometry':\r\n\t\r\n\t\t\t\t\t\t\tgeometry = new THREE[ data.type ](\r\n\t\t\t\t\t\t\t\tdata.radiusTop,\r\n\t\t\t\t\t\t\t\tdata.radiusBottom,\r\n\t\t\t\t\t\t\t\tdata.height,\r\n\t\t\t\t\t\t\t\tdata.radialSegments,\r\n\t\t\t\t\t\t\t\tdata.heightSegments,\r\n\t\t\t\t\t\t\t\tdata.openEnded,\r\n\t\t\t\t\t\t\t\tdata.thetaStart,\r\n\t\t\t\t\t\t\t\tdata.thetaLength\r\n\t\t\t\t\t\t\t);\r\n\t\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tcase 'SphereGeometry':\r\n\t\t\t\t\t\tcase 'SphereBufferGeometry':\r\n\t\r\n\t\t\t\t\t\t\tgeometry = new THREE[ data.type ](\r\n\t\t\t\t\t\t\t\tdata.radius,\r\n\t\t\t\t\t\t\t\tdata.widthSegments,\r\n\t\t\t\t\t\t\t\tdata.heightSegments,\r\n\t\t\t\t\t\t\t\tdata.phiStart,\r\n\t\t\t\t\t\t\t\tdata.phiLength,\r\n\t\t\t\t\t\t\t\tdata.thetaStart,\r\n\t\t\t\t\t\t\t\tdata.thetaLength\r\n\t\t\t\t\t\t\t);\r\n\t\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tcase 'DodecahedronGeometry':\r\n\t\r\n\t\t\t\t\t\t\tgeometry = new THREE.DodecahedronGeometry(\r\n\t\t\t\t\t\t\t\tdata.radius,\r\n\t\t\t\t\t\t\t\tdata.detail\r\n\t\t\t\t\t\t\t);\r\n\t\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tcase 'IcosahedronGeometry':\r\n\t\r\n\t\t\t\t\t\t\tgeometry = new THREE.IcosahedronGeometry(\r\n\t\t\t\t\t\t\t\tdata.radius,\r\n\t\t\t\t\t\t\t\tdata.detail\r\n\t\t\t\t\t\t\t);\r\n\t\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tcase 'OctahedronGeometry':\r\n\t\r\n\t\t\t\t\t\t\tgeometry = new THREE.OctahedronGeometry(\r\n\t\t\t\t\t\t\t\tdata.radius,\r\n\t\t\t\t\t\t\t\tdata.detail\r\n\t\t\t\t\t\t\t);\r\n\t\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tcase 'TetrahedronGeometry':\r\n\t\r\n\t\t\t\t\t\t\tgeometry = new THREE.TetrahedronGeometry(\r\n\t\t\t\t\t\t\t\tdata.radius,\r\n\t\t\t\t\t\t\t\tdata.detail\r\n\t\t\t\t\t\t\t);\r\n\t\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tcase 'RingGeometry':\r\n\t\t\t\t\t\tcase 'RingBufferGeometry':\r\n\t\r\n\t\t\t\t\t\t\tgeometry = new THREE[ data.type ](\r\n\t\t\t\t\t\t\t\tdata.innerRadius,\r\n\t\t\t\t\t\t\t\tdata.outerRadius,\r\n\t\t\t\t\t\t\t\tdata.thetaSegments,\r\n\t\t\t\t\t\t\t\tdata.phiSegments,\r\n\t\t\t\t\t\t\t\tdata.thetaStart,\r\n\t\t\t\t\t\t\t\tdata.thetaLength\r\n\t\t\t\t\t\t\t);\r\n\t\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tcase 'TorusGeometry':\r\n\t\t\t\t\t\tcase 'TorusBufferGeometry':\r\n\t\r\n\t\t\t\t\t\t\tgeometry = new THREE[ data.type ](\r\n\t\t\t\t\t\t\t\tdata.radius,\r\n\t\t\t\t\t\t\t\tdata.tube,\r\n\t\t\t\t\t\t\t\tdata.radialSegments,\r\n\t\t\t\t\t\t\t\tdata.tubularSegments,\r\n\t\t\t\t\t\t\t\tdata.arc\r\n\t\t\t\t\t\t\t);\r\n\t\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tcase 'TorusKnotGeometry':\r\n\t\t\t\t\t\tcase 'TorusKnotBufferGeometry':\r\n\t\r\n\t\t\t\t\t\t\tgeometry = new THREE[ data.type ](\r\n\t\t\t\t\t\t\t\tdata.radius,\r\n\t\t\t\t\t\t\t\tdata.tube,\r\n\t\t\t\t\t\t\t\tdata.tubularSegments,\r\n\t\t\t\t\t\t\t\tdata.radialSegments,\r\n\t\t\t\t\t\t\t\tdata.p,\r\n\t\t\t\t\t\t\t\tdata.q\r\n\t\t\t\t\t\t\t);\r\n\t\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tcase 'LatheGeometry':\r\n\t\t\t\t\t\tcase 'LatheBufferGeometry':\r\n\t\r\n\t\t\t\t\t\t\tgeometry = new THREE[ data.type ](\r\n\t\t\t\t\t\t\t\tdata.points,\r\n\t\t\t\t\t\t\t\tdata.segments,\r\n\t\t\t\t\t\t\t\tdata.phiStart,\r\n\t\t\t\t\t\t\t\tdata.phiLength\r\n\t\t\t\t\t\t\t);\r\n\t\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tcase 'BufferGeometry':\r\n\t\r\n\t\t\t\t\t\t\tgeometry = bufferGeometryLoader.parse( data );\r\n\t\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tcase 'Geometry':\r\n\t\r\n\t\t\t\t\t\t\tgeometry = geometryLoader.parse( data.data, this.texturePath ).geometry;\r\n\t\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tdefault:\r\n\t\r\n\t\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Unsupported geometry type \"' + data.type + '\"' );\r\n\t\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tgeometry.uuid = data.uuid;\r\n\t\r\n\t\t\t\t\tif ( data.name !== undefined ) geometry.name = data.name;\r\n\t\r\n\t\t\t\t\tgeometries[ data.uuid ] = geometry;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn geometries;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tparseMaterials: function ( json, textures ) {\r\n\t\r\n\t\t\tvar materials = {};\r\n\t\r\n\t\t\tif ( json !== undefined ) {\r\n\t\r\n\t\t\t\tvar loader = new THREE.MaterialLoader();\r\n\t\t\t\tloader.setTextures( textures );\r\n\t\r\n\t\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\tvar material = loader.parse( json[ i ] );\r\n\t\t\t\t\tmaterials[ material.uuid ] = material;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn materials;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tparseAnimations: function ( json ) {\r\n\t\r\n\t\t\tvar animations = [];\r\n\t\r\n\t\t\tfor ( var i = 0; i < json.length; i ++ ) {\r\n\t\r\n\t\t\t\tvar clip = THREE.AnimationClip.parse( json[ i ] );\r\n\t\r\n\t\t\t\tanimations.push( clip );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn animations;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tparseImages: function ( json, onLoad ) {\r\n\t\r\n\t\t\tvar scope = this;\r\n\t\t\tvar images = {};\r\n\t\r\n\t\t\tfunction loadImage( url ) {\r\n\t\r\n\t\t\t\tscope.manager.itemStart( url );\r\n\t\r\n\t\t\t\treturn loader.load( url, function () {\r\n\t\r\n\t\t\t\t\tscope.manager.itemEnd( url );\r\n\t\r\n\t\t\t\t} );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( json !== undefined && json.length > 0 ) {\r\n\t\r\n\t\t\t\tvar manager = new THREE.LoadingManager( onLoad );\r\n\t\r\n\t\t\t\tvar loader = new THREE.ImageLoader( manager );\r\n\t\t\t\tloader.setCrossOrigin( this.crossOrigin );\r\n\t\r\n\t\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\tvar image = json[ i ];\r\n\t\t\t\t\tvar path = /^(\\/\\/)|([a-z]+:(\\/\\/)?)/i.test( image.url ) ? image.url : scope.texturePath + image.url;\r\n\t\r\n\t\t\t\t\timages[ image.uuid ] = loadImage( path );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn images;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tparseTextures: function ( json, images ) {\r\n\t\r\n\t\t\tfunction parseConstant( value ) {\r\n\t\r\n\t\t\t\tif ( typeof( value ) === 'number' ) return value;\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );\r\n\t\r\n\t\t\t\treturn THREE[ value ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar textures = {};\r\n\t\r\n\t\t\tif ( json !== undefined ) {\r\n\t\r\n\t\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\tvar data = json[ i ];\r\n\t\r\n\t\t\t\t\tif ( data.image === undefined ) {\r\n\t\r\n\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: No \"image\" specified for', data.uuid );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( images[ data.image ] === undefined ) {\r\n\t\r\n\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined image', data.image );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tvar texture = new THREE.Texture( images[ data.image ] );\r\n\t\t\t\t\ttexture.needsUpdate = true;\r\n\t\r\n\t\t\t\t\ttexture.uuid = data.uuid;\r\n\t\r\n\t\t\t\t\tif ( data.name !== undefined ) texture.name = data.name;\r\n\t\t\t\t\tif ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping );\r\n\t\t\t\t\tif ( data.offset !== undefined ) texture.offset = new THREE.Vector2( data.offset[ 0 ], data.offset[ 1 ] );\r\n\t\t\t\t\tif ( data.repeat !== undefined ) texture.repeat = new THREE.Vector2( data.repeat[ 0 ], data.repeat[ 1 ] );\r\n\t\t\t\t\tif ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter );\r\n\t\t\t\t\tif ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter );\r\n\t\t\t\t\tif ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;\r\n\t\t\t\t\tif ( Array.isArray( data.wrap ) ) {\r\n\t\r\n\t\t\t\t\t\ttexture.wrapS = parseConstant( data.wrap[ 0 ] );\r\n\t\t\t\t\t\ttexture.wrapT = parseConstant( data.wrap[ 1 ] );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\ttextures[ data.uuid ] = texture;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn textures;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tparseObject: function () {\r\n\t\r\n\t\t\tvar matrix = new THREE.Matrix4();\r\n\t\r\n\t\t\treturn function ( data, geometries, materials ) {\r\n\t\r\n\t\t\t\tvar object;\r\n\t\r\n\t\t\t\tfunction getGeometry( name ) {\r\n\t\r\n\t\t\t\t\tif ( geometries[ name ] === undefined ) {\r\n\t\r\n\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined geometry', name );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\treturn geometries[ name ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tfunction getMaterial( name ) {\r\n\t\r\n\t\t\t\t\tif ( name === undefined ) return undefined;\r\n\t\r\n\t\t\t\t\tif ( materials[ name ] === undefined ) {\r\n\t\r\n\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined material', name );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\treturn materials[ name ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tswitch ( data.type ) {\r\n\t\r\n\t\t\t\t\tcase 'Scene':\r\n\t\r\n\t\t\t\t\t\tobject = new THREE.Scene();\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'PerspectiveCamera':\r\n\t\r\n\t\t\t\t\t\tobject = new THREE.PerspectiveCamera(\r\n\t\t\t\t\t\t\t\tdata.fov, data.aspect, data.near, data.far );\r\n\t\r\n\t\t\t\t\t\tif ( data.focus !== undefined ) object.focus = data.focus;\r\n\t\t\t\t\t\tif ( data.zoom !== undefined ) object.zoom = data.zoom;\r\n\t\t\t\t\t\tif ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge;\r\n\t\t\t\t\t\tif ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset;\r\n\t\t\t\t\t\tif ( data.view !== undefined ) object.view = Object.assign( {}, data.view );\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'OrthographicCamera':\r\n\t\r\n\t\t\t\t\t\tobject = new THREE.OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'AmbientLight':\r\n\t\r\n\t\t\t\t\t\tobject = new THREE.AmbientLight( data.color, data.intensity );\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'DirectionalLight':\r\n\t\r\n\t\t\t\t\t\tobject = new THREE.DirectionalLight( data.color, data.intensity );\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'PointLight':\r\n\t\r\n\t\t\t\t\t\tobject = new THREE.PointLight( data.color, data.intensity, data.distance, data.decay );\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'SpotLight':\r\n\t\r\n\t\t\t\t\t\tobject = new THREE.SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'HemisphereLight':\r\n\t\r\n\t\t\t\t\t\tobject = new THREE.HemisphereLight( data.color, data.groundColor, data.intensity );\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'Mesh':\r\n\t\r\n\t\t\t\t\t\tvar geometry = getGeometry( data.geometry );\r\n\t\t\t\t\t\tvar material = getMaterial( data.material );\r\n\t\r\n\t\t\t\t\t\tif ( geometry.bones && geometry.bones.length > 0 ) {\r\n\t\r\n\t\t\t\t\t\t\tobject = new THREE.SkinnedMesh( geometry, material );\r\n\t\r\n\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\tobject = new THREE.Mesh( geometry, material );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'LOD':\r\n\t\r\n\t\t\t\t\t\tobject = new THREE.LOD();\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'Line':\r\n\t\r\n\t\t\t\t\t\tobject = new THREE.Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'PointCloud':\r\n\t\t\t\t\tcase 'Points':\r\n\t\r\n\t\t\t\t\t\tobject = new THREE.Points( getGeometry( data.geometry ), getMaterial( data.material ) );\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'Sprite':\r\n\t\r\n\t\t\t\t\t\tobject = new THREE.Sprite( getMaterial( data.material ) );\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'Group':\r\n\t\r\n\t\t\t\t\t\tobject = new THREE.Group();\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tdefault:\r\n\t\r\n\t\t\t\t\t\tobject = new THREE.Object3D();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tobject.uuid = data.uuid;\r\n\t\r\n\t\t\t\tif ( data.name !== undefined ) object.name = data.name;\r\n\t\t\t\tif ( data.matrix !== undefined ) {\r\n\t\r\n\t\t\t\t\tmatrix.fromArray( data.matrix );\r\n\t\t\t\t\tmatrix.decompose( object.position, object.quaternion, object.scale );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tif ( data.position !== undefined ) object.position.fromArray( data.position );\r\n\t\t\t\t\tif ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );\r\n\t\t\t\t\tif ( data.scale !== undefined ) object.scale.fromArray( data.scale );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( data.castShadow !== undefined ) object.castShadow = data.castShadow;\r\n\t\t\t\tif ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;\r\n\t\r\n\t\t\t\tif ( data.visible !== undefined ) object.visible = data.visible;\r\n\t\t\t\tif ( data.userData !== undefined ) object.userData = data.userData;\r\n\t\r\n\t\t\t\tif ( data.children !== undefined ) {\r\n\t\r\n\t\t\t\t\tfor ( var child in data.children ) {\r\n\t\r\n\t\t\t\t\t\tobject.add( this.parseObject( data.children[ child ], geometries, materials ) );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( data.type === 'LOD' ) {\r\n\t\r\n\t\t\t\t\tvar levels = data.levels;\r\n\t\r\n\t\t\t\t\tfor ( var l = 0; l < levels.length; l ++ ) {\r\n\t\r\n\t\t\t\t\t\tvar level = levels[ l ];\r\n\t\t\t\t\t\tvar child = object.getObjectByProperty( 'uuid', level.object );\r\n\t\r\n\t\t\t\t\t\tif ( child !== undefined ) {\r\n\t\r\n\t\t\t\t\t\t\tobject.addLevel( child, level.distance );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn object;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}()\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/loaders/TextureLoader.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.TextureLoader = function ( manager ) {\r\n\t\r\n\t\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.TextureLoader.prototype = {\r\n\t\r\n\t\tconstructor: THREE.TextureLoader,\r\n\t\r\n\t\tload: function ( url, onLoad, onProgress, onError ) {\r\n\t\r\n\t\t\tvar texture = new THREE.Texture();\r\n\t\r\n\t\t\tvar loader = new THREE.ImageLoader( this.manager );\r\n\t\t\tloader.setCrossOrigin( this.crossOrigin );\r\n\t\t\tloader.setPath( this.path );\r\n\t\t\tloader.load( url, function ( image ) {\r\n\t\r\n\t\t\t\ttexture.image = image;\r\n\t\t\t\ttexture.needsUpdate = true;\r\n\t\r\n\t\t\t\tif ( onLoad !== undefined ) {\r\n\t\r\n\t\t\t\t\tonLoad( texture );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}, onProgress, onError );\r\n\t\r\n\t\t\treturn texture;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetCrossOrigin: function ( value ) {\r\n\t\r\n\t\t\tthis.crossOrigin = value;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetPath: function ( value ) {\r\n\t\r\n\t\t\tthis.path = value;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/loaders/CubeTextureLoader.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.CubeTextureLoader = function ( manager ) {\r\n\t\r\n\t\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.CubeTextureLoader.prototype = {\r\n\t\r\n\t\tconstructor: THREE.CubeTextureLoader,\r\n\t\r\n\t\tload: function ( urls, onLoad, onProgress, onError ) {\r\n\t\r\n\t\t\tvar texture = new THREE.CubeTexture();\r\n\t\r\n\t\t\tvar loader = new THREE.ImageLoader( this.manager );\r\n\t\t\tloader.setCrossOrigin( this.crossOrigin );\r\n\t\t\tloader.setPath( this.path );\r\n\t\r\n\t\t\tvar loaded = 0;\r\n\t\r\n\t\t\tfunction loadTexture( i ) {\r\n\t\r\n\t\t\t\tloader.load( urls[ i ], function ( image ) {\r\n\t\r\n\t\t\t\t\ttexture.images[ i ] = image;\r\n\t\r\n\t\t\t\t\tloaded ++;\r\n\t\r\n\t\t\t\t\tif ( loaded === 6 ) {\r\n\t\r\n\t\t\t\t\t\ttexture.needsUpdate = true;\r\n\t\r\n\t\t\t\t\t\tif ( onLoad ) onLoad( texture );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}, undefined, onError );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( var i = 0; i < urls.length; ++ i ) {\r\n\t\r\n\t\t\t\tloadTexture( i );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn texture;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetCrossOrigin: function ( value ) {\r\n\t\r\n\t\t\tthis.crossOrigin = value;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetPath: function ( value ) {\r\n\t\r\n\t\t\tthis.path = value;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/loaders/BinaryTextureLoader.js\r\n\t\r\n\t/**\r\n\t * @author Nikos M. / https://github.com/foo123/\r\n\t *\r\n\t * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)\r\n\t */\r\n\t\r\n\tTHREE.DataTextureLoader = THREE.BinaryTextureLoader = function ( manager ) {\r\n\t\r\n\t\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\t\r\n\t\t// override in sub classes\r\n\t\tthis._parser = null;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.BinaryTextureLoader.prototype = {\r\n\t\r\n\t\tconstructor: THREE.BinaryTextureLoader,\r\n\t\r\n\t\tload: function ( url, onLoad, onProgress, onError ) {\r\n\t\r\n\t\t\tvar scope = this;\r\n\t\r\n\t\t\tvar texture = new THREE.DataTexture();\r\n\t\r\n\t\t\tvar loader = new THREE.XHRLoader( this.manager );\r\n\t\t\tloader.setResponseType( 'arraybuffer' );\r\n\t\r\n\t\t\tloader.load( url, function ( buffer ) {\r\n\t\r\n\t\t\t\tvar texData = scope._parser( buffer );\r\n\t\r\n\t\t\t\tif ( ! texData ) return;\r\n\t\r\n\t\t\t\tif ( undefined !== texData.image ) {\r\n\t\r\n\t\t\t\t\ttexture.image = texData.image;\r\n\t\r\n\t\t\t\t} else if ( undefined !== texData.data ) {\r\n\t\r\n\t\t\t\t\ttexture.image.width = texData.width;\r\n\t\t\t\t\ttexture.image.height = texData.height;\r\n\t\t\t\t\ttexture.image.data = texData.data;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\ttexture.wrapS = undefined !== texData.wrapS ? texData.wrapS : THREE.ClampToEdgeWrapping;\r\n\t\t\t\ttexture.wrapT = undefined !== texData.wrapT ? texData.wrapT : THREE.ClampToEdgeWrapping;\r\n\t\r\n\t\t\t\ttexture.magFilter = undefined !== texData.magFilter ? texData.magFilter : THREE.LinearFilter;\r\n\t\t\t\ttexture.minFilter = undefined !== texData.minFilter ? texData.minFilter : THREE.LinearMipMapLinearFilter;\r\n\t\r\n\t\t\t\ttexture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;\r\n\t\r\n\t\t\t\tif ( undefined !== texData.format ) {\r\n\t\r\n\t\t\t\t\ttexture.format = texData.format;\r\n\t\r\n\t\t\t\t}\r\n\t\t\t\tif ( undefined !== texData.type ) {\r\n\t\r\n\t\t\t\t\ttexture.type = texData.type;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( undefined !== texData.mipmaps ) {\r\n\t\r\n\t\t\t\t\ttexture.mipmaps = texData.mipmaps;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( 1 === texData.mipmapCount ) {\r\n\t\r\n\t\t\t\t\ttexture.minFilter = THREE.LinearFilter;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\ttexture.needsUpdate = true;\r\n\t\r\n\t\t\t\tif ( onLoad ) onLoad( texture, texData );\r\n\t\r\n\t\t\t}, onProgress, onError );\r\n\t\r\n\t\r\n\t\t\treturn texture;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/loaders/CompressedTextureLoader.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t *\r\n\t * Abstract Base class to block based textures loader (dds, pvr, ...)\r\n\t */\r\n\t\r\n\tTHREE.CompressedTextureLoader = function ( manager ) {\r\n\t\r\n\t\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\t\r\n\t\t// override in sub classes\r\n\t\tthis._parser = null;\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\tTHREE.CompressedTextureLoader.prototype = {\r\n\t\r\n\t\tconstructor: THREE.CompressedTextureLoader,\r\n\t\r\n\t\tload: function ( url, onLoad, onProgress, onError ) {\r\n\t\r\n\t\t\tvar scope = this;\r\n\t\r\n\t\t\tvar images = [];\r\n\t\r\n\t\t\tvar texture = new THREE.CompressedTexture();\r\n\t\t\ttexture.image = images;\r\n\t\r\n\t\t\tvar loader = new THREE.XHRLoader( this.manager );\r\n\t\t\tloader.setPath( this.path );\r\n\t\t\tloader.setResponseType( 'arraybuffer' );\r\n\t\r\n\t\t\tfunction loadTexture( i ) {\r\n\t\r\n\t\t\t\tloader.load( url[ i ], function ( buffer ) {\r\n\t\r\n\t\t\t\t\tvar texDatas = scope._parser( buffer, true );\r\n\t\r\n\t\t\t\t\timages[ i ] = {\r\n\t\t\t\t\t\twidth: texDatas.width,\r\n\t\t\t\t\t\theight: texDatas.height,\r\n\t\t\t\t\t\tformat: texDatas.format,\r\n\t\t\t\t\t\tmipmaps: texDatas.mipmaps\r\n\t\t\t\t\t};\r\n\t\r\n\t\t\t\t\tloaded += 1;\r\n\t\r\n\t\t\t\t\tif ( loaded === 6 ) {\r\n\t\r\n\t\t\t\t\t\tif ( texDatas.mipmapCount === 1 )\r\n\t\t\t\t\t\t\ttexture.minFilter = THREE.LinearFilter;\r\n\t\r\n\t\t\t\t\t\ttexture.format = texDatas.format;\r\n\t\t\t\t\t\ttexture.needsUpdate = true;\r\n\t\r\n\t\t\t\t\t\tif ( onLoad ) onLoad( texture );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}, onProgress, onError );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( Array.isArray( url ) ) {\r\n\t\r\n\t\t\t\tvar loaded = 0;\r\n\t\r\n\t\t\t\tfor ( var i = 0, il = url.length; i < il; ++ i ) {\r\n\t\r\n\t\t\t\t\tloadTexture( i );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\t// compressed cubemap texture stored in a single DDS file\r\n\t\r\n\t\t\t\tloader.load( url, function ( buffer ) {\r\n\t\r\n\t\t\t\t\tvar texDatas = scope._parser( buffer, true );\r\n\t\r\n\t\t\t\t\tif ( texDatas.isCubemap ) {\r\n\t\r\n\t\t\t\t\t\tvar faces = texDatas.mipmaps.length / texDatas.mipmapCount;\r\n\t\r\n\t\t\t\t\t\tfor ( var f = 0; f < faces; f ++ ) {\r\n\t\r\n\t\t\t\t\t\t\timages[ f ] = { mipmaps : [] };\r\n\t\r\n\t\t\t\t\t\t\tfor ( var i = 0; i < texDatas.mipmapCount; i ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\timages[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );\r\n\t\t\t\t\t\t\t\timages[ f ].format = texDatas.format;\r\n\t\t\t\t\t\t\t\timages[ f ].width = texDatas.width;\r\n\t\t\t\t\t\t\t\timages[ f ].height = texDatas.height;\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\ttexture.image.width = texDatas.width;\r\n\t\t\t\t\t\ttexture.image.height = texDatas.height;\r\n\t\t\t\t\t\ttexture.mipmaps = texDatas.mipmaps;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( texDatas.mipmapCount === 1 ) {\r\n\t\r\n\t\t\t\t\t\ttexture.minFilter = THREE.LinearFilter;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\ttexture.format = texDatas.format;\r\n\t\t\t\t\ttexture.needsUpdate = true;\r\n\t\r\n\t\t\t\t\tif ( onLoad ) onLoad( texture );\r\n\t\r\n\t\t\t\t}, onProgress, onError );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn texture;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetPath: function ( value ) {\r\n\t\r\n\t\t\tthis.path = value;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/materials/Material.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.Material = function () {\r\n\t\r\n\t\tObject.defineProperty( this, 'id', { value: THREE.MaterialIdCount ++ } );\r\n\t\r\n\t\tthis.uuid = THREE.Math.generateUUID();\r\n\t\r\n\t\tthis.name = '';\r\n\t\tthis.type = 'Material';\r\n\t\r\n\t\tthis.side = THREE.FrontSide;\r\n\t\r\n\t\tthis.opacity = 1;\r\n\t\tthis.transparent = false;\r\n\t\r\n\t\tthis.blending = THREE.NormalBlending;\r\n\t\r\n\t\tthis.blendSrc = THREE.SrcAlphaFactor;\r\n\t\tthis.blendDst = THREE.OneMinusSrcAlphaFactor;\r\n\t\tthis.blendEquation = THREE.AddEquation;\r\n\t\tthis.blendSrcAlpha = null;\r\n\t\tthis.blendDstAlpha = null;\r\n\t\tthis.blendEquationAlpha = null;\r\n\t\r\n\t\tthis.depthFunc = THREE.LessEqualDepth;\r\n\t\tthis.depthTest = true;\r\n\t\tthis.depthWrite = true;\r\n\t\r\n\t\tthis.clippingPlanes = null;\r\n\t\tthis.clipShadows = false;\r\n\t\r\n\t\tthis.colorWrite = true;\r\n\t\r\n\t\tthis.precision = null; // override the renderer's default precision for this material\r\n\t\r\n\t\tthis.polygonOffset = false;\r\n\t\tthis.polygonOffsetFactor = 0;\r\n\t\tthis.polygonOffsetUnits = 0;\r\n\t\r\n\t\tthis.alphaTest = 0;\r\n\t\tthis.premultipliedAlpha = false;\r\n\t\r\n\t\tthis.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer\r\n\t\r\n\t\tthis.visible = true;\r\n\t\r\n\t\tthis._needsUpdate = true;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Material.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Material,\r\n\t\r\n\t\tget needsUpdate () {\r\n\t\r\n\t\t\treturn this._needsUpdate;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tset needsUpdate ( value ) {\r\n\t\r\n\t\t\tif ( value === true ) this.update();\r\n\t\r\n\t\t\tthis._needsUpdate = value;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetValues: function ( values ) {\r\n\t\r\n\t\t\tif ( values === undefined ) return;\r\n\t\r\n\t\t\tfor ( var key in values ) {\r\n\t\r\n\t\t\t\tvar newValue = values[ key ];\r\n\t\r\n\t\t\t\tif ( newValue === undefined ) {\r\n\t\r\n\t\t\t\t\tconsole.warn( \"THREE.Material: '\" + key + \"' parameter is undefined.\" );\r\n\t\t\t\t\tcontinue;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar currentValue = this[ key ];\r\n\t\r\n\t\t\t\tif ( currentValue === undefined ) {\r\n\t\r\n\t\t\t\t\tconsole.warn( \"THREE.\" + this.type + \": '\" + key + \"' is not a property of this material.\" );\r\n\t\t\t\t\tcontinue;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( currentValue instanceof THREE.Color ) {\r\n\t\r\n\t\t\t\t\tcurrentValue.set( newValue );\r\n\t\r\n\t\t\t\t} else if ( currentValue instanceof THREE.Vector3 && newValue instanceof THREE.Vector3 ) {\r\n\t\r\n\t\t\t\t\tcurrentValue.copy( newValue );\r\n\t\r\n\t\t\t\t} else if ( key === 'overdraw' ) {\r\n\t\r\n\t\t\t\t\t// ensure overdraw is backwards-compatible with legacy boolean type\r\n\t\t\t\t\tthis[ key ] = Number( newValue );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tthis[ key ] = newValue;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttoJSON: function ( meta ) {\r\n\t\r\n\t\t\tvar isRoot = meta === undefined;\r\n\t\r\n\t\t\tif ( isRoot ) {\r\n\t\r\n\t\t\t\tmeta = {\r\n\t\t\t\t\ttextures: {},\r\n\t\t\t\t\timages: {}\r\n\t\t\t\t};\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar data = {\r\n\t\t\t\tmetadata: {\r\n\t\t\t\t\tversion: 4.4,\r\n\t\t\t\t\ttype: 'Material',\r\n\t\t\t\t\tgenerator: 'Material.toJSON'\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\r\n\t\t\t// standard Material serialization\r\n\t\t\tdata.uuid = this.uuid;\r\n\t\t\tdata.type = this.type;\r\n\t\t\tif ( this.name !== '' ) data.name = this.name;\r\n\t\r\n\t\t\tif ( this.color instanceof THREE.Color ) data.color = this.color.getHex();\r\n\t\r\n\t\t\tif ( this.roughness !== 0.5 ) data.roughness = this.roughness;\r\n\t\t\tif ( this.metalness !== 0.5 ) data.metalness = this.metalness;\r\n\t\r\n\t\t\tif ( this.emissive instanceof THREE.Color ) data.emissive = this.emissive.getHex();\r\n\t\t\tif ( this.specular instanceof THREE.Color ) data.specular = this.specular.getHex();\r\n\t\t\tif ( this.shininess !== undefined ) data.shininess = this.shininess;\r\n\t\r\n\t\t\tif ( this.map instanceof THREE.Texture ) data.map = this.map.toJSON( meta ).uuid;\r\n\t\t\tif ( this.alphaMap instanceof THREE.Texture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;\r\n\t\t\tif ( this.lightMap instanceof THREE.Texture ) data.lightMap = this.lightMap.toJSON( meta ).uuid;\r\n\t\t\tif ( this.bumpMap instanceof THREE.Texture ) {\r\n\t\r\n\t\t\t\tdata.bumpMap = this.bumpMap.toJSON( meta ).uuid;\r\n\t\t\t\tdata.bumpScale = this.bumpScale;\r\n\t\r\n\t\t\t}\r\n\t\t\tif ( this.normalMap instanceof THREE.Texture ) {\r\n\t\r\n\t\t\t\tdata.normalMap = this.normalMap.toJSON( meta ).uuid;\r\n\t\t\t\tdata.normalScale = this.normalScale.toArray();\r\n\t\r\n\t\t\t}\r\n\t\t\tif ( this.displacementMap instanceof THREE.Texture ) {\r\n\t\r\n\t\t\t\tdata.displacementMap = this.displacementMap.toJSON( meta ).uuid;\r\n\t\t\t\tdata.displacementScale = this.displacementScale;\r\n\t\t\t\tdata.displacementBias = this.displacementBias;\r\n\t\r\n\t\t\t}\r\n\t\t\tif ( this.roughnessMap instanceof THREE.Texture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;\r\n\t\t\tif ( this.metalnessMap instanceof THREE.Texture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;\r\n\t\r\n\t\t\tif ( this.emissiveMap instanceof THREE.Texture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;\r\n\t\t\tif ( this.specularMap instanceof THREE.Texture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;\r\n\t\r\n\t\t\tif ( this.envMap instanceof THREE.Texture ) {\r\n\t\r\n\t\t\t\tdata.envMap = this.envMap.toJSON( meta ).uuid;\r\n\t\t\t\tdata.reflectivity = this.reflectivity; // Scale behind envMap\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( this.size !== undefined ) data.size = this.size;\r\n\t\t\tif ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;\r\n\t\r\n\t\t\tif ( this.vertexColors !== undefined && this.vertexColors !== THREE.NoColors ) data.vertexColors = this.vertexColors;\r\n\t\t\tif ( this.shading !== undefined && this.shading !== THREE.SmoothShading ) data.shading = this.shading;\r\n\t\t\tif ( this.blending !== undefined && this.blending !== THREE.NormalBlending ) data.blending = this.blending;\r\n\t\t\tif ( this.side !== undefined && this.side !== THREE.FrontSide ) data.side = this.side;\r\n\t\r\n\t\t\tif ( this.opacity < 1 ) data.opacity = this.opacity;\r\n\t\t\tif ( this.transparent === true ) data.transparent = this.transparent;\r\n\t\t\tif ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;\r\n\t\t\tif ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;\r\n\t\t\tif ( this.wireframe === true ) data.wireframe = this.wireframe;\r\n\t\t\tif ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;\r\n\t\r\n\t\t\t// TODO: Copied from Object3D.toJSON\r\n\t\r\n\t\t\tfunction extractFromCache ( cache ) {\r\n\t\r\n\t\t\t\tvar values = [];\r\n\t\r\n\t\t\t\tfor ( var key in cache ) {\r\n\t\r\n\t\t\t\t\tvar data = cache[ key ];\r\n\t\t\t\t\tdelete data.metadata;\r\n\t\t\t\t\tvalues.push( data );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn values;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( isRoot ) {\r\n\t\r\n\t\t\t\tvar textures = extractFromCache( meta.textures );\r\n\t\t\t\tvar images = extractFromCache( meta.images );\r\n\t\r\n\t\t\t\tif ( textures.length > 0 ) data.textures = textures;\r\n\t\t\t\tif ( images.length > 0 ) data.images = images;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn data;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new this.constructor().copy( this );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( source ) {\r\n\t\r\n\t\t\tthis.name = source.name;\r\n\t\r\n\t\t\tthis.side = source.side;\r\n\t\r\n\t\t\tthis.opacity = source.opacity;\r\n\t\t\tthis.transparent = source.transparent;\r\n\t\r\n\t\t\tthis.blending = source.blending;\r\n\t\r\n\t\t\tthis.blendSrc = source.blendSrc;\r\n\t\t\tthis.blendDst = source.blendDst;\r\n\t\t\tthis.blendEquation = source.blendEquation;\r\n\t\t\tthis.blendSrcAlpha = source.blendSrcAlpha;\r\n\t\t\tthis.blendDstAlpha = source.blendDstAlpha;\r\n\t\t\tthis.blendEquationAlpha = source.blendEquationAlpha;\r\n\t\r\n\t\t\tthis.depthFunc = source.depthFunc;\r\n\t\t\tthis.depthTest = source.depthTest;\r\n\t\t\tthis.depthWrite = source.depthWrite;\r\n\t\r\n\t\t\tthis.colorWrite = source.colorWrite;\r\n\t\r\n\t\t\tthis.precision = source.precision;\r\n\t\r\n\t\t\tthis.polygonOffset = source.polygonOffset;\r\n\t\t\tthis.polygonOffsetFactor = source.polygonOffsetFactor;\r\n\t\t\tthis.polygonOffsetUnits = source.polygonOffsetUnits;\r\n\t\r\n\t\t\tthis.alphaTest = source.alphaTest;\r\n\t\r\n\t\t\tthis.premultipliedAlpha = source.premultipliedAlpha;\r\n\t\r\n\t\t\tthis.overdraw = source.overdraw;\r\n\t\r\n\t\t\tthis.visible = source.visible;\r\n\t\t\tthis.clipShadows = source.clipShadows;\r\n\t\r\n\t\t\tvar srcPlanes = source.clippingPlanes,\r\n\t\t\t\tdstPlanes = null;\r\n\t\r\n\t\t\tif ( srcPlanes !== null ) {\r\n\t\r\n\t\t\t\tvar n = srcPlanes.length;\r\n\t\t\t\tdstPlanes = new Array( n );\r\n\t\r\n\t\t\t\tfor ( var i = 0; i !== n; ++ i )\r\n\t\t\t\t\tdstPlanes[ i ] = srcPlanes[ i ].clone();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.clippingPlanes = dstPlanes;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tupdate: function () {\r\n\t\r\n\t\t\tthis.dispatchEvent( { type: 'update' } );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdispose: function () {\r\n\t\r\n\t\t\tthis.dispatchEvent( { type: 'dispose' } );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.EventDispatcher.prototype.apply( THREE.Material.prototype );\r\n\t\r\n\tTHREE.MaterialIdCount = 0;\r\n\t\r\n\t// File:src/materials/LineBasicMaterial.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t *\r\n\t * parameters = {\r\n\t *  color: <hex>,\r\n\t *  opacity: <float>,\r\n\t *\r\n\t *  linewidth: <float>,\r\n\t *  linecap: \"round\",\r\n\t *  linejoin: \"round\",\r\n\t *\r\n\t *  blending: THREE.NormalBlending,\r\n\t *  depthTest: <bool>,\r\n\t *  depthWrite: <bool>,\r\n\t *\r\n\t *  vertexColors: <bool>\r\n\t *\r\n\t *  fog: <bool>\r\n\t * }\r\n\t */\r\n\t\r\n\tTHREE.LineBasicMaterial = function ( parameters ) {\r\n\t\r\n\t\tTHREE.Material.call( this );\r\n\t\r\n\t\tthis.type = 'LineBasicMaterial';\r\n\t\r\n\t\tthis.color = new THREE.Color( 0xffffff );\r\n\t\r\n\t\tthis.linewidth = 1;\r\n\t\tthis.linecap = 'round';\r\n\t\tthis.linejoin = 'round';\r\n\t\r\n\t\tthis.blending = THREE.NormalBlending;\r\n\t\r\n\t\tthis.vertexColors = THREE.NoColors;\r\n\t\r\n\t\tthis.fog = true;\r\n\t\r\n\t\tthis.setValues( parameters );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.LineBasicMaterial.prototype = Object.create( THREE.Material.prototype );\r\n\tTHREE.LineBasicMaterial.prototype.constructor = THREE.LineBasicMaterial;\r\n\t\r\n\tTHREE.LineBasicMaterial.prototype.copy = function ( source ) {\r\n\t\r\n\t\tTHREE.Material.prototype.copy.call( this, source );\r\n\t\r\n\t\tthis.color.copy( source.color );\r\n\t\r\n\t\tthis.linewidth = source.linewidth;\r\n\t\tthis.linecap = source.linecap;\r\n\t\tthis.linejoin = source.linejoin;\r\n\t\r\n\t\tthis.vertexColors = source.vertexColors;\r\n\t\r\n\t\tthis.fog = source.fog;\r\n\t\r\n\t\treturn this;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/materials/LineDashedMaterial.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t *\r\n\t * parameters = {\r\n\t *  color: <hex>,\r\n\t *  opacity: <float>,\r\n\t *\r\n\t *  linewidth: <float>,\r\n\t *\r\n\t *  scale: <float>,\r\n\t *  dashSize: <float>,\r\n\t *  gapSize: <float>,\r\n\t *\r\n\t *  blending: THREE.NormalBlending,\r\n\t *  depthTest: <bool>,\r\n\t *  depthWrite: <bool>,\r\n\t *\r\n\t *  vertexColors: THREE.NoColors / THREE.FaceColors / THREE.VertexColors\r\n\t *\r\n\t *  fog: <bool>\r\n\t * }\r\n\t */\r\n\t\r\n\tTHREE.LineDashedMaterial = function ( parameters ) {\r\n\t\r\n\t\tTHREE.Material.call( this );\r\n\t\r\n\t\tthis.type = 'LineDashedMaterial';\r\n\t\r\n\t\tthis.color = new THREE.Color( 0xffffff );\r\n\t\r\n\t\tthis.linewidth = 1;\r\n\t\r\n\t\tthis.scale = 1;\r\n\t\tthis.dashSize = 3;\r\n\t\tthis.gapSize = 1;\r\n\t\r\n\t\tthis.blending = THREE.NormalBlending;\r\n\t\r\n\t\tthis.vertexColors = THREE.NoColors;\r\n\t\r\n\t\tthis.fog = true;\r\n\t\r\n\t\tthis.setValues( parameters );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.LineDashedMaterial.prototype = Object.create( THREE.Material.prototype );\r\n\tTHREE.LineDashedMaterial.prototype.constructor = THREE.LineDashedMaterial;\r\n\t\r\n\tTHREE.LineDashedMaterial.prototype.copy = function ( source ) {\r\n\t\r\n\t\tTHREE.Material.prototype.copy.call( this, source );\r\n\t\r\n\t\tthis.color.copy( source.color );\r\n\t\r\n\t\tthis.linewidth = source.linewidth;\r\n\t\r\n\t\tthis.scale = source.scale;\r\n\t\tthis.dashSize = source.dashSize;\r\n\t\tthis.gapSize = source.gapSize;\r\n\t\r\n\t\tthis.vertexColors = source.vertexColors;\r\n\t\r\n\t\tthis.fog = source.fog;\r\n\t\r\n\t\treturn this;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/materials/MeshBasicMaterial.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t *\r\n\t * parameters = {\r\n\t *  color: <hex>,\r\n\t *  opacity: <float>,\r\n\t *  map: new THREE.Texture( <Image> ),\r\n\t *\r\n\t *  aoMap: new THREE.Texture( <Image> ),\r\n\t *  aoMapIntensity: <float>\r\n\t *\r\n\t *  specularMap: new THREE.Texture( <Image> ),\r\n\t *\r\n\t *  alphaMap: new THREE.Texture( <Image> ),\r\n\t *\r\n\t *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\r\n\t *  combine: THREE.Multiply,\r\n\t *  reflectivity: <float>,\r\n\t *  refractionRatio: <float>,\r\n\t *\r\n\t *  shading: THREE.SmoothShading,\r\n\t *  blending: THREE.NormalBlending,\r\n\t *  depthTest: <bool>,\r\n\t *  depthWrite: <bool>,\r\n\t *\r\n\t *  wireframe: <boolean>,\r\n\t *  wireframeLinewidth: <float>,\r\n\t *\r\n\t *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,\r\n\t *\r\n\t *  skinning: <bool>,\r\n\t *  morphTargets: <bool>,\r\n\t *\r\n\t *  fog: <bool>\r\n\t * }\r\n\t */\r\n\t\r\n\tTHREE.MeshBasicMaterial = function ( parameters ) {\r\n\t\r\n\t\tTHREE.Material.call( this );\r\n\t\r\n\t\tthis.type = 'MeshBasicMaterial';\r\n\t\r\n\t\tthis.color = new THREE.Color( 0xffffff ); // emissive\r\n\t\r\n\t\tthis.map = null;\r\n\t\r\n\t\tthis.aoMap = null;\r\n\t\tthis.aoMapIntensity = 1.0;\r\n\t\r\n\t\tthis.specularMap = null;\r\n\t\r\n\t\tthis.alphaMap = null;\r\n\t\r\n\t\tthis.envMap = null;\r\n\t\tthis.combine = THREE.MultiplyOperation;\r\n\t\tthis.reflectivity = 1;\r\n\t\tthis.refractionRatio = 0.98;\r\n\t\r\n\t\tthis.fog = true;\r\n\t\r\n\t\tthis.shading = THREE.SmoothShading;\r\n\t\tthis.blending = THREE.NormalBlending;\r\n\t\r\n\t\tthis.wireframe = false;\r\n\t\tthis.wireframeLinewidth = 1;\r\n\t\tthis.wireframeLinecap = 'round';\r\n\t\tthis.wireframeLinejoin = 'round';\r\n\t\r\n\t\tthis.vertexColors = THREE.NoColors;\r\n\t\r\n\t\tthis.skinning = false;\r\n\t\tthis.morphTargets = false;\r\n\t\r\n\t\tthis.setValues( parameters );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MeshBasicMaterial.prototype = Object.create( THREE.Material.prototype );\r\n\tTHREE.MeshBasicMaterial.prototype.constructor = THREE.MeshBasicMaterial;\r\n\t\r\n\tTHREE.MeshBasicMaterial.prototype.copy = function ( source ) {\r\n\t\r\n\t\tTHREE.Material.prototype.copy.call( this, source );\r\n\t\r\n\t\tthis.color.copy( source.color );\r\n\t\r\n\t\tthis.map = source.map;\r\n\t\r\n\t\tthis.aoMap = source.aoMap;\r\n\t\tthis.aoMapIntensity = source.aoMapIntensity;\r\n\t\r\n\t\tthis.specularMap = source.specularMap;\r\n\t\r\n\t\tthis.alphaMap = source.alphaMap;\r\n\t\r\n\t\tthis.envMap = source.envMap;\r\n\t\tthis.combine = source.combine;\r\n\t\tthis.reflectivity = source.reflectivity;\r\n\t\tthis.refractionRatio = source.refractionRatio;\r\n\t\r\n\t\tthis.fog = source.fog;\r\n\t\r\n\t\tthis.shading = source.shading;\r\n\t\r\n\t\tthis.wireframe = source.wireframe;\r\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\r\n\t\tthis.wireframeLinecap = source.wireframeLinecap;\r\n\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\r\n\t\r\n\t\tthis.vertexColors = source.vertexColors;\r\n\t\r\n\t\tthis.skinning = source.skinning;\r\n\t\tthis.morphTargets = source.morphTargets;\r\n\t\r\n\t\treturn this;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/materials/MeshDepthMaterial.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author bhouston / https://clara.io\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t *\r\n\t * parameters = {\r\n\t *\r\n\t *  opacity: <float>,\r\n\t *\r\n\t *  map: new THREE.Texture( <Image> ),\r\n\t *\r\n\t *  alphaMap: new THREE.Texture( <Image> ),\r\n\t *\r\n\t *  displacementMap: new THREE.Texture( <Image> ),\r\n\t *  displacementScale: <float>,\r\n\t *  displacementBias: <float>,\r\n\t *\r\n\t *  wireframe: <boolean>,\r\n\t *  wireframeLinewidth: <float>\r\n\t * }\r\n\t */\r\n\t\r\n\tTHREE.MeshDepthMaterial = function ( parameters ) {\r\n\t\r\n\t\tTHREE.Material.call( this );\r\n\t\r\n\t\tthis.type = 'MeshDepthMaterial';\r\n\t\r\n\t\tthis.depthPacking = THREE.BasicDepthPacking;\r\n\t\r\n\t\tthis.skinning = false;\r\n\t\tthis.morphTargets = false;\r\n\t\r\n\t\tthis.map = null;\r\n\t\r\n\t\tthis.alphaMap = null;\r\n\t\r\n\t\tthis.displacementMap = null;\r\n\t\tthis.displacementScale = 1;\r\n\t\tthis.displacementBias = 0;\r\n\t\r\n\t\tthis.wireframe = false;\r\n\t\tthis.wireframeLinewidth = 1;\r\n\t\r\n\t\tthis.setValues( parameters );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MeshDepthMaterial.prototype = Object.create( THREE.Material.prototype );\r\n\tTHREE.MeshDepthMaterial.prototype.constructor = THREE.MeshDepthMaterial;\r\n\t\r\n\tTHREE.MeshDepthMaterial.prototype.copy = function ( source ) {\r\n\t\r\n\t\tTHREE.Material.prototype.copy.call( this, source );\r\n\t\r\n\t\tthis.depthPacking = source.depthPacking;\r\n\t\r\n\t\tthis.skinning = source.skinning;\r\n\t\tthis.morphTargets = source.morphTargets;\r\n\t\r\n\t\tthis.map = source.map;\r\n\t\r\n\t\tthis.alphaMap = source.alphaMap;\r\n\t\r\n\t\tthis.displacementMap = source.displacementMap;\r\n\t\tthis.displacementScale = source.displacementScale;\r\n\t\tthis.displacementBias = source.displacementBias;\r\n\t\r\n\t\tthis.wireframe = source.wireframe;\r\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\r\n\t\r\n\t\treturn this;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/materials/MeshLambertMaterial.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t *\r\n\t * parameters = {\r\n\t *  color: <hex>,\r\n\t *  opacity: <float>,\r\n\t *\r\n\t *  map: new THREE.Texture( <Image> ),\r\n\t *\r\n\t *  lightMap: new THREE.Texture( <Image> ),\r\n\t *  lightMapIntensity: <float>\r\n\t *\r\n\t *  aoMap: new THREE.Texture( <Image> ),\r\n\t *  aoMapIntensity: <float>\r\n\t *\r\n\t *  emissive: <hex>,\r\n\t *  emissiveIntensity: <float>\r\n\t *  emissiveMap: new THREE.Texture( <Image> ),\r\n\t *\r\n\t *  specularMap: new THREE.Texture( <Image> ),\r\n\t *\r\n\t *  alphaMap: new THREE.Texture( <Image> ),\r\n\t *\r\n\t *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\r\n\t *  combine: THREE.Multiply,\r\n\t *  reflectivity: <float>,\r\n\t *  refractionRatio: <float>,\r\n\t *\r\n\t *  blending: THREE.NormalBlending,\r\n\t *  depthTest: <bool>,\r\n\t *  depthWrite: <bool>,\r\n\t *\r\n\t *  wireframe: <boolean>,\r\n\t *  wireframeLinewidth: <float>,\r\n\t *\r\n\t *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,\r\n\t *\r\n\t *  skinning: <bool>,\r\n\t *  morphTargets: <bool>,\r\n\t *  morphNormals: <bool>,\r\n\t *\r\n\t *\tfog: <bool>\r\n\t * }\r\n\t */\r\n\t\r\n\tTHREE.MeshLambertMaterial = function ( parameters ) {\r\n\t\r\n\t\tTHREE.Material.call( this );\r\n\t\r\n\t\tthis.type = 'MeshLambertMaterial';\r\n\t\r\n\t\tthis.color = new THREE.Color( 0xffffff ); // diffuse\r\n\t\r\n\t\tthis.map = null;\r\n\t\r\n\t\tthis.lightMap = null;\r\n\t\tthis.lightMapIntensity = 1.0;\r\n\t\r\n\t\tthis.aoMap = null;\r\n\t\tthis.aoMapIntensity = 1.0;\r\n\t\r\n\t\tthis.emissive = new THREE.Color( 0x000000 );\r\n\t\tthis.emissiveIntensity = 1.0;\r\n\t\tthis.emissiveMap = null;\r\n\t\r\n\t\tthis.specularMap = null;\r\n\t\r\n\t\tthis.alphaMap = null;\r\n\t\r\n\t\tthis.envMap = null;\r\n\t\tthis.combine = THREE.MultiplyOperation;\r\n\t\tthis.reflectivity = 1;\r\n\t\tthis.refractionRatio = 0.98;\r\n\t\r\n\t\tthis.fog = true;\r\n\t\r\n\t\tthis.blending = THREE.NormalBlending;\r\n\t\r\n\t\tthis.wireframe = false;\r\n\t\tthis.wireframeLinewidth = 1;\r\n\t\tthis.wireframeLinecap = 'round';\r\n\t\tthis.wireframeLinejoin = 'round';\r\n\t\r\n\t\tthis.vertexColors = THREE.NoColors;\r\n\t\r\n\t\tthis.skinning = false;\r\n\t\tthis.morphTargets = false;\r\n\t\tthis.morphNormals = false;\r\n\t\r\n\t\tthis.setValues( parameters );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MeshLambertMaterial.prototype = Object.create( THREE.Material.prototype );\r\n\tTHREE.MeshLambertMaterial.prototype.constructor = THREE.MeshLambertMaterial;\r\n\t\r\n\tTHREE.MeshLambertMaterial.prototype.copy = function ( source ) {\r\n\t\r\n\t\tTHREE.Material.prototype.copy.call( this, source );\r\n\t\r\n\t\tthis.color.copy( source.color );\r\n\t\r\n\t\tthis.map = source.map;\r\n\t\r\n\t\tthis.lightMap = source.lightMap;\r\n\t\tthis.lightMapIntensity = source.lightMapIntensity;\r\n\t\r\n\t\tthis.aoMap = source.aoMap;\r\n\t\tthis.aoMapIntensity = source.aoMapIntensity;\r\n\t\r\n\t\tthis.emissive.copy( source.emissive );\r\n\t\tthis.emissiveMap = source.emissiveMap;\r\n\t\tthis.emissiveIntensity = source.emissiveIntensity;\r\n\t\r\n\t\tthis.specularMap = source.specularMap;\r\n\t\r\n\t\tthis.alphaMap = source.alphaMap;\r\n\t\r\n\t\tthis.envMap = source.envMap;\r\n\t\tthis.combine = source.combine;\r\n\t\tthis.reflectivity = source.reflectivity;\r\n\t\tthis.refractionRatio = source.refractionRatio;\r\n\t\r\n\t\tthis.fog = source.fog;\r\n\t\r\n\t\tthis.wireframe = source.wireframe;\r\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\r\n\t\tthis.wireframeLinecap = source.wireframeLinecap;\r\n\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\r\n\t\r\n\t\tthis.vertexColors = source.vertexColors;\r\n\t\r\n\t\tthis.skinning = source.skinning;\r\n\t\tthis.morphTargets = source.morphTargets;\r\n\t\tthis.morphNormals = source.morphNormals;\r\n\t\r\n\t\treturn this;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/materials/MeshNormalMaterial.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t *\r\n\t * parameters = {\r\n\t *  opacity: <float>,\r\n\t *\r\n\t *  wireframe: <boolean>,\r\n\t *  wireframeLinewidth: <float>\r\n\t * }\r\n\t */\r\n\t\r\n\tTHREE.MeshNormalMaterial = function ( parameters ) {\r\n\t\r\n\t\tTHREE.Material.call( this, parameters );\r\n\t\r\n\t\tthis.type = 'MeshNormalMaterial';\r\n\t\r\n\t\tthis.wireframe = false;\r\n\t\tthis.wireframeLinewidth = 1;\r\n\t\r\n\t\tthis.morphTargets = false;\r\n\t\r\n\t\tthis.setValues( parameters );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MeshNormalMaterial.prototype = Object.create( THREE.Material.prototype );\r\n\tTHREE.MeshNormalMaterial.prototype.constructor = THREE.MeshNormalMaterial;\r\n\t\r\n\tTHREE.MeshNormalMaterial.prototype.copy = function ( source ) {\r\n\t\r\n\t\tTHREE.Material.prototype.copy.call( this, source );\r\n\t\r\n\t\tthis.wireframe = source.wireframe;\r\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\r\n\t\r\n\t\treturn this;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/materials/MeshPhongMaterial.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t *\r\n\t * parameters = {\r\n\t *  color: <hex>,\r\n\t *  specular: <hex>,\r\n\t *  shininess: <float>,\r\n\t *  opacity: <float>,\r\n\t *\r\n\t *  map: new THREE.Texture( <Image> ),\r\n\t *\r\n\t *  lightMap: new THREE.Texture( <Image> ),\r\n\t *  lightMapIntensity: <float>\r\n\t *\r\n\t *  aoMap: new THREE.Texture( <Image> ),\r\n\t *  aoMapIntensity: <float>\r\n\t *\r\n\t *  emissive: <hex>,\r\n\t *  emissiveIntensity: <float>\r\n\t *  emissiveMap: new THREE.Texture( <Image> ),\r\n\t *\r\n\t *  bumpMap: new THREE.Texture( <Image> ),\r\n\t *  bumpScale: <float>,\r\n\t *\r\n\t *  normalMap: new THREE.Texture( <Image> ),\r\n\t *  normalScale: <Vector2>,\r\n\t *\r\n\t *  displacementMap: new THREE.Texture( <Image> ),\r\n\t *  displacementScale: <float>,\r\n\t *  displacementBias: <float>,\r\n\t *\r\n\t *  specularMap: new THREE.Texture( <Image> ),\r\n\t *\r\n\t *  alphaMap: new THREE.Texture( <Image> ),\r\n\t *\r\n\t *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\r\n\t *  combine: THREE.Multiply,\r\n\t *  reflectivity: <float>,\r\n\t *  refractionRatio: <float>,\r\n\t *\r\n\t *  shading: THREE.SmoothShading,\r\n\t *  blending: THREE.NormalBlending,\r\n\t *  depthTest: <bool>,\r\n\t *  depthWrite: <bool>,\r\n\t *\r\n\t *  wireframe: <boolean>,\r\n\t *  wireframeLinewidth: <float>,\r\n\t *\r\n\t *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,\r\n\t *\r\n\t *  skinning: <bool>,\r\n\t *  morphTargets: <bool>,\r\n\t *  morphNormals: <bool>,\r\n\t *\r\n\t *\tfog: <bool>\r\n\t * }\r\n\t */\r\n\t\r\n\tTHREE.MeshPhongMaterial = function ( parameters ) {\r\n\t\r\n\t\tTHREE.Material.call( this );\r\n\t\r\n\t\tthis.type = 'MeshPhongMaterial';\r\n\t\r\n\t\tthis.color = new THREE.Color( 0xffffff ); // diffuse\r\n\t\tthis.specular = new THREE.Color( 0x111111 );\r\n\t\tthis.shininess = 30;\r\n\t\r\n\t\tthis.map = null;\r\n\t\r\n\t\tthis.lightMap = null;\r\n\t\tthis.lightMapIntensity = 1.0;\r\n\t\r\n\t\tthis.aoMap = null;\r\n\t\tthis.aoMapIntensity = 1.0;\r\n\t\r\n\t\tthis.emissive = new THREE.Color( 0x000000 );\r\n\t\tthis.emissiveIntensity = 1.0;\r\n\t\tthis.emissiveMap = null;\r\n\t\r\n\t\tthis.bumpMap = null;\r\n\t\tthis.bumpScale = 1;\r\n\t\r\n\t\tthis.normalMap = null;\r\n\t\tthis.normalScale = new THREE.Vector2( 1, 1 );\r\n\t\r\n\t\tthis.displacementMap = null;\r\n\t\tthis.displacementScale = 1;\r\n\t\tthis.displacementBias = 0;\r\n\t\r\n\t\tthis.specularMap = null;\r\n\t\r\n\t\tthis.alphaMap = null;\r\n\t\r\n\t\tthis.envMap = null;\r\n\t\tthis.combine = THREE.MultiplyOperation;\r\n\t\tthis.reflectivity = 1;\r\n\t\tthis.refractionRatio = 0.98;\r\n\t\r\n\t\tthis.fog = true;\r\n\t\r\n\t\tthis.shading = THREE.SmoothShading;\r\n\t\tthis.blending = THREE.NormalBlending;\r\n\t\r\n\t\tthis.wireframe = false;\r\n\t\tthis.wireframeLinewidth = 1;\r\n\t\tthis.wireframeLinecap = 'round';\r\n\t\tthis.wireframeLinejoin = 'round';\r\n\t\r\n\t\tthis.vertexColors = THREE.NoColors;\r\n\t\r\n\t\tthis.skinning = false;\r\n\t\tthis.morphTargets = false;\r\n\t\tthis.morphNormals = false;\r\n\t\r\n\t\tthis.setValues( parameters );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MeshPhongMaterial.prototype = Object.create( THREE.Material.prototype );\r\n\tTHREE.MeshPhongMaterial.prototype.constructor = THREE.MeshPhongMaterial;\r\n\t\r\n\tTHREE.MeshPhongMaterial.prototype.copy = function ( source ) {\r\n\t\r\n\t\tTHREE.Material.prototype.copy.call( this, source );\r\n\t\r\n\t\tthis.color.copy( source.color );\r\n\t\tthis.specular.copy( source.specular );\r\n\t\tthis.shininess = source.shininess;\r\n\t\r\n\t\tthis.map = source.map;\r\n\t\r\n\t\tthis.lightMap = source.lightMap;\r\n\t\tthis.lightMapIntensity = source.lightMapIntensity;\r\n\t\r\n\t\tthis.aoMap = source.aoMap;\r\n\t\tthis.aoMapIntensity = source.aoMapIntensity;\r\n\t\r\n\t\tthis.emissive.copy( source.emissive );\r\n\t\tthis.emissiveMap = source.emissiveMap;\r\n\t\tthis.emissiveIntensity = source.emissiveIntensity;\r\n\t\r\n\t\tthis.bumpMap = source.bumpMap;\r\n\t\tthis.bumpScale = source.bumpScale;\r\n\t\r\n\t\tthis.normalMap = source.normalMap;\r\n\t\tthis.normalScale.copy( source.normalScale );\r\n\t\r\n\t\tthis.displacementMap = source.displacementMap;\r\n\t\tthis.displacementScale = source.displacementScale;\r\n\t\tthis.displacementBias = source.displacementBias;\r\n\t\r\n\t\tthis.specularMap = source.specularMap;\r\n\t\r\n\t\tthis.alphaMap = source.alphaMap;\r\n\t\r\n\t\tthis.envMap = source.envMap;\r\n\t\tthis.combine = source.combine;\r\n\t\tthis.reflectivity = source.reflectivity;\r\n\t\tthis.refractionRatio = source.refractionRatio;\r\n\t\r\n\t\tthis.fog = source.fog;\r\n\t\r\n\t\tthis.shading = source.shading;\r\n\t\r\n\t\tthis.wireframe = source.wireframe;\r\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\r\n\t\tthis.wireframeLinecap = source.wireframeLinecap;\r\n\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\r\n\t\r\n\t\tthis.vertexColors = source.vertexColors;\r\n\t\r\n\t\tthis.skinning = source.skinning;\r\n\t\tthis.morphTargets = source.morphTargets;\r\n\t\tthis.morphNormals = source.morphNormals;\r\n\t\r\n\t\treturn this;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/materials/MeshStandardMaterial.js\r\n\t\r\n\t/**\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t *\r\n\t * parameters = {\r\n\t *  color: <hex>,\r\n\t *  roughness: <float>,\r\n\t *  metalness: <float>,\r\n\t *  opacity: <float>,\r\n\t *\r\n\t *  map: new THREE.Texture( <Image> ),\r\n\t *\r\n\t *  lightMap: new THREE.Texture( <Image> ),\r\n\t *  lightMapIntensity: <float>\r\n\t *\r\n\t *  aoMap: new THREE.Texture( <Image> ),\r\n\t *  aoMapIntensity: <float>\r\n\t *\r\n\t *  emissive: <hex>,\r\n\t *  emissiveIntensity: <float>\r\n\t *  emissiveMap: new THREE.Texture( <Image> ),\r\n\t *\r\n\t *  bumpMap: new THREE.Texture( <Image> ),\r\n\t *  bumpScale: <float>,\r\n\t *\r\n\t *  normalMap: new THREE.Texture( <Image> ),\r\n\t *  normalScale: <Vector2>,\r\n\t *\r\n\t *  displacementMap: new THREE.Texture( <Image> ),\r\n\t *  displacementScale: <float>,\r\n\t *  displacementBias: <float>,\r\n\t *\r\n\t *  roughnessMap: new THREE.Texture( <Image> ),\r\n\t *\r\n\t *  metalnessMap: new THREE.Texture( <Image> ),\r\n\t *\r\n\t *  alphaMap: new THREE.Texture( <Image> ),\r\n\t *\r\n\t *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),\r\n\t *  envMapIntensity: <float>\r\n\t *\r\n\t *  refractionRatio: <float>,\r\n\t *\r\n\t *  shading: THREE.SmoothShading,\r\n\t *  blending: THREE.NormalBlending,\r\n\t *  depthTest: <bool>,\r\n\t *  depthWrite: <bool>,\r\n\t *\r\n\t *  wireframe: <boolean>,\r\n\t *  wireframeLinewidth: <float>,\r\n\t *\r\n\t *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,\r\n\t *\r\n\t *  skinning: <bool>,\r\n\t *  morphTargets: <bool>,\r\n\t *  morphNormals: <bool>,\r\n\t *\r\n\t *\tfog: <bool>\r\n\t * }\r\n\t */\r\n\t\r\n\tTHREE.MeshStandardMaterial = function ( parameters ) {\r\n\t\r\n\t\tTHREE.Material.call( this );\r\n\t\r\n\t\tthis.defines = { 'STANDARD': '' };\r\n\t\r\n\t\tthis.type = 'MeshStandardMaterial';\r\n\t\r\n\t\tthis.color = new THREE.Color( 0xffffff ); // diffuse\r\n\t\tthis.roughness = 0.5;\r\n\t\tthis.metalness = 0.5;\r\n\t\r\n\t\tthis.map = null;\r\n\t\r\n\t\tthis.lightMap = null;\r\n\t\tthis.lightMapIntensity = 1.0;\r\n\t\r\n\t\tthis.aoMap = null;\r\n\t\tthis.aoMapIntensity = 1.0;\r\n\t\r\n\t\tthis.emissive = new THREE.Color( 0x000000 );\r\n\t\tthis.emissiveIntensity = 1.0;\r\n\t\tthis.emissiveMap = null;\r\n\t\r\n\t\tthis.bumpMap = null;\r\n\t\tthis.bumpScale = 1;\r\n\t\r\n\t\tthis.normalMap = null;\r\n\t\tthis.normalScale = new THREE.Vector2( 1, 1 );\r\n\t\r\n\t\tthis.displacementMap = null;\r\n\t\tthis.displacementScale = 1;\r\n\t\tthis.displacementBias = 0;\r\n\t\r\n\t\tthis.roughnessMap = null;\r\n\t\r\n\t\tthis.metalnessMap = null;\r\n\t\r\n\t\tthis.alphaMap = null;\r\n\t\r\n\t\tthis.envMap = null;\r\n\t\tthis.envMapIntensity = 1.0;\r\n\t\r\n\t\tthis.refractionRatio = 0.98;\r\n\t\r\n\t\tthis.fog = true;\r\n\t\r\n\t\tthis.shading = THREE.SmoothShading;\r\n\t\tthis.blending = THREE.NormalBlending;\r\n\t\r\n\t\tthis.wireframe = false;\r\n\t\tthis.wireframeLinewidth = 1;\r\n\t\tthis.wireframeLinecap = 'round';\r\n\t\tthis.wireframeLinejoin = 'round';\r\n\t\r\n\t\tthis.vertexColors = THREE.NoColors;\r\n\t\r\n\t\tthis.skinning = false;\r\n\t\tthis.morphTargets = false;\r\n\t\tthis.morphNormals = false;\r\n\t\r\n\t\tthis.setValues( parameters );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MeshStandardMaterial.prototype = Object.create( THREE.Material.prototype );\r\n\tTHREE.MeshStandardMaterial.prototype.constructor = THREE.MeshStandardMaterial;\r\n\t\r\n\tTHREE.MeshStandardMaterial.prototype.copy = function ( source ) {\r\n\t\r\n\t\tTHREE.Material.prototype.copy.call( this, source );\r\n\t\r\n\t\tthis.defines = { 'STANDARD': '' };\r\n\t\r\n\t\tthis.color.copy( source.color );\r\n\t\tthis.roughness = source.roughness;\r\n\t\tthis.metalness = source.metalness;\r\n\t\r\n\t\tthis.map = source.map;\r\n\t\r\n\t\tthis.lightMap = source.lightMap;\r\n\t\tthis.lightMapIntensity = source.lightMapIntensity;\r\n\t\r\n\t\tthis.aoMap = source.aoMap;\r\n\t\tthis.aoMapIntensity = source.aoMapIntensity;\r\n\t\r\n\t\tthis.emissive.copy( source.emissive );\r\n\t\tthis.emissiveMap = source.emissiveMap;\r\n\t\tthis.emissiveIntensity = source.emissiveIntensity;\r\n\t\r\n\t\tthis.bumpMap = source.bumpMap;\r\n\t\tthis.bumpScale = source.bumpScale;\r\n\t\r\n\t\tthis.normalMap = source.normalMap;\r\n\t\tthis.normalScale.copy( source.normalScale );\r\n\t\r\n\t\tthis.displacementMap = source.displacementMap;\r\n\t\tthis.displacementScale = source.displacementScale;\r\n\t\tthis.displacementBias = source.displacementBias;\r\n\t\r\n\t\tthis.roughnessMap = source.roughnessMap;\r\n\t\r\n\t\tthis.metalnessMap = source.metalnessMap;\r\n\t\r\n\t\tthis.alphaMap = source.alphaMap;\r\n\t\r\n\t\tthis.envMap = source.envMap;\r\n\t\tthis.envMapIntensity = source.envMapIntensity;\r\n\t\r\n\t\tthis.refractionRatio = source.refractionRatio;\r\n\t\r\n\t\tthis.fog = source.fog;\r\n\t\r\n\t\tthis.shading = source.shading;\r\n\t\r\n\t\tthis.wireframe = source.wireframe;\r\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\r\n\t\tthis.wireframeLinecap = source.wireframeLinecap;\r\n\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\r\n\t\r\n\t\tthis.vertexColors = source.vertexColors;\r\n\t\r\n\t\tthis.skinning = source.skinning;\r\n\t\tthis.morphTargets = source.morphTargets;\r\n\t\tthis.morphNormals = source.morphNormals;\r\n\t\r\n\t\treturn this;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/materials/MeshPhysicalMaterial.js\r\n\t\r\n\t/**\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t *\r\n\t * parameters = {\r\n\t *  reflectivity: <float>\r\n\t * }\r\n\t */\r\n\t\r\n\tTHREE.MeshPhysicalMaterial = function ( parameters ) {\r\n\t\r\n\t\tTHREE.MeshStandardMaterial.call( this );\r\n\t\r\n\t\tthis.defines = { 'PHYSICAL': '' };\r\n\t\r\n\t\tthis.type = 'MeshPhysicalMaterial';\r\n\t\r\n\t\tthis.reflectivity = 0.5; // maps to F0 = 0.04\r\n\t\r\n\t\tthis.setValues( parameters );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MeshPhysicalMaterial.prototype = Object.create( THREE.MeshStandardMaterial.prototype );\r\n\tTHREE.MeshPhysicalMaterial.prototype.constructor = THREE.MeshPhysicalMaterial;\r\n\t\r\n\tTHREE.MeshPhysicalMaterial.prototype.copy = function ( source ) {\r\n\t\r\n\t\tTHREE.MeshStandardMaterial.prototype.copy.call( this, source );\r\n\t\r\n\t\tthis.defines = { 'PHYSICAL': '' };\r\n\t\r\n\t\tthis.reflectivity = source.reflectivity;\r\n\t\r\n\t\treturn this;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/materials/MultiMaterial.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.MultiMaterial = function ( materials ) {\r\n\t\r\n\t\tthis.uuid = THREE.Math.generateUUID();\r\n\t\r\n\t\tthis.type = 'MultiMaterial';\r\n\t\r\n\t\tthis.materials = materials instanceof Array ? materials : [];\r\n\t\r\n\t\tthis.visible = true;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MultiMaterial.prototype = {\r\n\t\r\n\t\tconstructor: THREE.MultiMaterial,\r\n\t\r\n\t\ttoJSON: function ( meta ) {\r\n\t\r\n\t\t\tvar output = {\r\n\t\t\t\tmetadata: {\r\n\t\t\t\t\tversion: 4.2,\r\n\t\t\t\t\ttype: 'material',\r\n\t\t\t\t\tgenerator: 'MaterialExporter'\r\n\t\t\t\t},\r\n\t\t\t\tuuid: this.uuid,\r\n\t\t\t\ttype: this.type,\r\n\t\t\t\tmaterials: []\r\n\t\t\t};\r\n\t\r\n\t\t\tvar materials = this.materials;\r\n\t\r\n\t\t\tfor ( var i = 0, l = materials.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tvar material = materials[ i ].toJSON( meta );\r\n\t\t\t\tdelete material.metadata;\r\n\t\r\n\t\t\t\toutput.materials.push( material );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\toutput.visible = this.visible;\r\n\t\r\n\t\t\treturn output;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\tvar material = new this.constructor();\r\n\t\r\n\t\t\tfor ( var i = 0; i < this.materials.length; i ++ ) {\r\n\t\r\n\t\t\t\tmaterial.materials.push( this.materials[ i ].clone() );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tmaterial.visible = this.visible;\r\n\t\r\n\t\t\treturn material;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/materials/PointsMaterial.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t *\r\n\t * parameters = {\r\n\t *  color: <hex>,\r\n\t *  opacity: <float>,\r\n\t *  map: new THREE.Texture( <Image> ),\r\n\t *\r\n\t *  size: <float>,\r\n\t *  sizeAttenuation: <bool>,\r\n\t *\r\n\t *  blending: THREE.NormalBlending,\r\n\t *  depthTest: <bool>,\r\n\t *  depthWrite: <bool>,\r\n\t *\r\n\t *  vertexColors: <bool>,\r\n\t *\r\n\t *  fog: <bool>\r\n\t * }\r\n\t */\r\n\t\r\n\tTHREE.PointsMaterial = function ( parameters ) {\r\n\t\r\n\t\tTHREE.Material.call( this );\r\n\t\r\n\t\tthis.type = 'PointsMaterial';\r\n\t\r\n\t\tthis.color = new THREE.Color( 0xffffff );\r\n\t\r\n\t\tthis.map = null;\r\n\t\r\n\t\tthis.size = 1;\r\n\t\tthis.sizeAttenuation = true;\r\n\t\r\n\t\tthis.blending = THREE.NormalBlending;\r\n\t\r\n\t\tthis.vertexColors = THREE.NoColors;\r\n\t\r\n\t\tthis.fog = true;\r\n\t\r\n\t\tthis.setValues( parameters );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.PointsMaterial.prototype = Object.create( THREE.Material.prototype );\r\n\tTHREE.PointsMaterial.prototype.constructor = THREE.PointsMaterial;\r\n\t\r\n\tTHREE.PointsMaterial.prototype.copy = function ( source ) {\r\n\t\r\n\t\tTHREE.Material.prototype.copy.call( this, source );\r\n\t\r\n\t\tthis.color.copy( source.color );\r\n\t\r\n\t\tthis.map = source.map;\r\n\t\r\n\t\tthis.size = source.size;\r\n\t\tthis.sizeAttenuation = source.sizeAttenuation;\r\n\t\r\n\t\tthis.vertexColors = source.vertexColors;\r\n\t\r\n\t\tthis.fog = source.fog;\r\n\t\r\n\t\treturn this;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/materials/ShaderMaterial.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t *\r\n\t * parameters = {\r\n\t *  defines: { \"label\" : \"value\" },\r\n\t *  uniforms: { \"parameter1\": { type: \"1f\", value: 1.0 }, \"parameter2\": { type: \"1i\" value2: 2 } },\r\n\t *\r\n\t *  fragmentShader: <string>,\r\n\t *  vertexShader: <string>,\r\n\t *\r\n\t *  shading: THREE.SmoothShading,\r\n\t *\r\n\t *  wireframe: <boolean>,\r\n\t *  wireframeLinewidth: <float>,\r\n\t *\r\n\t *  lights: <bool>,\r\n\t *\r\n\t *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,\r\n\t *\r\n\t *  skinning: <bool>,\r\n\t *  morphTargets: <bool>,\r\n\t *  morphNormals: <bool>,\r\n\t *\r\n\t *\tfog: <bool>\r\n\t * }\r\n\t */\r\n\t\r\n\tTHREE.ShaderMaterial = function ( parameters ) {\r\n\t\r\n\t\tTHREE.Material.call( this );\r\n\t\r\n\t\tthis.type = 'ShaderMaterial';\r\n\t\r\n\t\tthis.defines = {};\r\n\t\tthis.uniforms = {};\r\n\t\r\n\t\tthis.vertexShader = 'void main() {\\n\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}';\r\n\t\tthis.fragmentShader = 'void main() {\\n\\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\\n}';\r\n\t\r\n\t\tthis.shading = THREE.SmoothShading;\r\n\t\r\n\t\tthis.linewidth = 1;\r\n\t\r\n\t\tthis.wireframe = false;\r\n\t\tthis.wireframeLinewidth = 1;\r\n\t\r\n\t\tthis.fog = false; // set to use scene fog\r\n\t\r\n\t\tthis.lights = false; // set to use scene lights\r\n\t\tthis.clipping = false; // set to use user-defined clipping planes\r\n\t\r\n\t\tthis.vertexColors = THREE.NoColors; // set to use \"color\" attribute stream\r\n\t\r\n\t\tthis.skinning = false; // set to use skinning attribute streams\r\n\t\r\n\t\tthis.morphTargets = false; // set to use morph targets\r\n\t\tthis.morphNormals = false; // set to use morph normals\r\n\t\r\n\t\tthis.extensions = {\r\n\t\t\tderivatives: false, // set to use derivatives\r\n\t\t\tfragDepth: false, // set to use fragment depth values\r\n\t\t\tdrawBuffers: false, // set to use draw buffers\r\n\t\t\tshaderTextureLOD: false // set to use shader texture LOD\r\n\t\t};\r\n\t\r\n\t\t// When rendered geometry doesn't include these attributes but the material does,\r\n\t\t// use these default values in WebGL. This avoids errors when buffer data is missing.\r\n\t\tthis.defaultAttributeValues = {\r\n\t\t\t'color': [ 1, 1, 1 ],\r\n\t\t\t'uv': [ 0, 0 ],\r\n\t\t\t'uv2': [ 0, 0 ]\r\n\t\t};\r\n\t\r\n\t\tthis.index0AttributeName = undefined;\r\n\t\r\n\t\tif ( parameters !== undefined ) {\r\n\t\r\n\t\t\tif ( parameters.attributes !== undefined ) {\r\n\t\r\n\t\t\t\tconsole.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.setValues( parameters );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.ShaderMaterial.prototype = Object.create( THREE.Material.prototype );\r\n\tTHREE.ShaderMaterial.prototype.constructor = THREE.ShaderMaterial;\r\n\t\r\n\tTHREE.ShaderMaterial.prototype.copy = function ( source ) {\r\n\t\r\n\t\tTHREE.Material.prototype.copy.call( this, source );\r\n\t\r\n\t\tthis.fragmentShader = source.fragmentShader;\r\n\t\tthis.vertexShader = source.vertexShader;\r\n\t\r\n\t\tthis.uniforms = THREE.UniformsUtils.clone( source.uniforms );\r\n\t\r\n\t\tthis.defines = source.defines;\r\n\t\r\n\t\tthis.shading = source.shading;\r\n\t\r\n\t\tthis.wireframe = source.wireframe;\r\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\r\n\t\r\n\t\tthis.fog = source.fog;\r\n\t\r\n\t\tthis.lights = source.lights;\r\n\t\tthis.clipping = source.clipping;\r\n\t\r\n\t\tthis.vertexColors = source.vertexColors;\r\n\t\r\n\t\tthis.skinning = source.skinning;\r\n\t\r\n\t\tthis.morphTargets = source.morphTargets;\r\n\t\tthis.morphNormals = source.morphNormals;\r\n\t\r\n\t\tthis.extensions = source.extensions;\r\n\t\r\n\t\treturn this;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.ShaderMaterial.prototype.toJSON = function ( meta ) {\r\n\t\r\n\t\tvar data = THREE.Material.prototype.toJSON.call( this, meta );\r\n\t\r\n\t\tdata.uniforms = this.uniforms;\r\n\t\tdata.vertexShader = this.vertexShader;\r\n\t\tdata.fragmentShader = this.fragmentShader;\r\n\t\r\n\t\treturn data;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/materials/RawShaderMaterial.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.RawShaderMaterial = function ( parameters ) {\r\n\t\r\n\t\tTHREE.ShaderMaterial.call( this, parameters );\r\n\t\r\n\t\tthis.type = 'RawShaderMaterial';\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.RawShaderMaterial.prototype = Object.create( THREE.ShaderMaterial.prototype );\r\n\tTHREE.RawShaderMaterial.prototype.constructor = THREE.RawShaderMaterial;\r\n\t\r\n\t// File:src/materials/SpriteMaterial.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t *\r\n\t * parameters = {\r\n\t *  color: <hex>,\r\n\t *  opacity: <float>,\r\n\t *  map: new THREE.Texture( <Image> ),\r\n\t *\r\n\t *\tuvOffset: new THREE.Vector2(),\r\n\t *\tuvScale: new THREE.Vector2(),\r\n\t *\r\n\t *  fog: <bool>\r\n\t * }\r\n\t */\r\n\t\r\n\tTHREE.SpriteMaterial = function ( parameters ) {\r\n\t\r\n\t\tTHREE.Material.call( this );\r\n\t\r\n\t\tthis.type = 'SpriteMaterial';\r\n\t\r\n\t\tthis.color = new THREE.Color( 0xffffff );\r\n\t\tthis.map = null;\r\n\t\r\n\t\tthis.rotation = 0;\r\n\t\r\n\t\tthis.fog = false;\r\n\t\r\n\t\t// set parameters\r\n\t\r\n\t\tthis.setValues( parameters );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.SpriteMaterial.prototype = Object.create( THREE.Material.prototype );\r\n\tTHREE.SpriteMaterial.prototype.constructor = THREE.SpriteMaterial;\r\n\t\r\n\tTHREE.SpriteMaterial.prototype.copy = function ( source ) {\r\n\t\r\n\t\tTHREE.Material.prototype.copy.call( this, source );\r\n\t\r\n\t\tthis.color.copy( source.color );\r\n\t\tthis.map = source.map;\r\n\t\r\n\t\tthis.rotation = source.rotation;\r\n\t\r\n\t\tthis.fog = source.fog;\r\n\t\r\n\t\treturn this;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/textures/Texture.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author szimek / https://github.com/szimek/\r\n\t */\r\n\t\r\n\tTHREE.Texture = function ( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {\r\n\t\r\n\t\tObject.defineProperty( this, 'id', { value: THREE.TextureIdCount ++ } );\r\n\t\r\n\t\tthis.uuid = THREE.Math.generateUUID();\r\n\t\r\n\t\tthis.name = '';\r\n\t\tthis.sourceFile = '';\r\n\t\r\n\t\tthis.image = image !== undefined ? image : THREE.Texture.DEFAULT_IMAGE;\r\n\t\tthis.mipmaps = [];\r\n\t\r\n\t\tthis.mapping = mapping !== undefined ? mapping : THREE.Texture.DEFAULT_MAPPING;\r\n\t\r\n\t\tthis.wrapS = wrapS !== undefined ? wrapS : THREE.ClampToEdgeWrapping;\r\n\t\tthis.wrapT = wrapT !== undefined ? wrapT : THREE.ClampToEdgeWrapping;\r\n\t\r\n\t\tthis.magFilter = magFilter !== undefined ? magFilter : THREE.LinearFilter;\r\n\t\tthis.minFilter = minFilter !== undefined ? minFilter : THREE.LinearMipMapLinearFilter;\r\n\t\r\n\t\tthis.anisotropy = anisotropy !== undefined ? anisotropy : 1;\r\n\t\r\n\t\tthis.format = format !== undefined ? format : THREE.RGBAFormat;\r\n\t\tthis.type = type !== undefined ? type : THREE.UnsignedByteType;\r\n\t\r\n\t\tthis.offset = new THREE.Vector2( 0, 0 );\r\n\t\tthis.repeat = new THREE.Vector2( 1, 1 );\r\n\t\r\n\t\tthis.generateMipmaps = true;\r\n\t\tthis.premultiplyAlpha = false;\r\n\t\tthis.flipY = true;\r\n\t\tthis.unpackAlignment = 4;\t// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)\r\n\t\r\n\t\r\n\t\t// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.\r\n\t\t//\r\n\t\t// Also changing the encoding after already used by a Material will not automatically make the Material\r\n\t\t// update.  You need to explicitly call Material.needsUpdate to trigger it to recompile.\r\n\t\tthis.encoding = encoding !== undefined ? encoding :  THREE.LinearEncoding;\r\n\t\r\n\t\tthis.version = 0;\r\n\t\tthis.onUpdate = null;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Texture.DEFAULT_IMAGE = undefined;\r\n\tTHREE.Texture.DEFAULT_MAPPING = THREE.UVMapping;\r\n\t\r\n\tTHREE.Texture.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Texture,\r\n\t\r\n\t\tset needsUpdate ( value ) {\r\n\t\r\n\t\t\tif ( value === true ) this.version ++;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new this.constructor().copy( this );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( source ) {\r\n\t\r\n\t\t\tthis.image = source.image;\r\n\t\t\tthis.mipmaps = source.mipmaps.slice( 0 );\r\n\t\r\n\t\t\tthis.mapping = source.mapping;\r\n\t\r\n\t\t\tthis.wrapS = source.wrapS;\r\n\t\t\tthis.wrapT = source.wrapT;\r\n\t\r\n\t\t\tthis.magFilter = source.magFilter;\r\n\t\t\tthis.minFilter = source.minFilter;\r\n\t\r\n\t\t\tthis.anisotropy = source.anisotropy;\r\n\t\r\n\t\t\tthis.format = source.format;\r\n\t\t\tthis.type = source.type;\r\n\t\r\n\t\t\tthis.offset.copy( source.offset );\r\n\t\t\tthis.repeat.copy( source.repeat );\r\n\t\r\n\t\t\tthis.generateMipmaps = source.generateMipmaps;\r\n\t\t\tthis.premultiplyAlpha = source.premultiplyAlpha;\r\n\t\t\tthis.flipY = source.flipY;\r\n\t\t\tthis.unpackAlignment = source.unpackAlignment;\r\n\t\t\tthis.encoding = source.encoding;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttoJSON: function ( meta ) {\r\n\t\r\n\t\t\tif ( meta.textures[ this.uuid ] !== undefined ) {\r\n\t\r\n\t\t\t\treturn meta.textures[ this.uuid ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfunction getDataURL( image ) {\r\n\t\r\n\t\t\t\tvar canvas;\r\n\t\r\n\t\t\t\tif ( image.toDataURL !== undefined ) {\r\n\t\r\n\t\t\t\t\tcanvas = image;\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tcanvas = document.createElement( 'canvas' );\r\n\t\t\t\t\tcanvas.width = image.width;\r\n\t\t\t\t\tcanvas.height = image.height;\r\n\t\r\n\t\t\t\t\tcanvas.getContext( '2d' ).drawImage( image, 0, 0, image.width, image.height );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( canvas.width > 2048 || canvas.height > 2048 ) {\r\n\t\r\n\t\t\t\t\treturn canvas.toDataURL( 'image/jpeg', 0.6 );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\treturn canvas.toDataURL( 'image/png' );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar output = {\r\n\t\t\t\tmetadata: {\r\n\t\t\t\t\tversion: 4.4,\r\n\t\t\t\t\ttype: 'Texture',\r\n\t\t\t\t\tgenerator: 'Texture.toJSON'\r\n\t\t\t\t},\r\n\t\r\n\t\t\t\tuuid: this.uuid,\r\n\t\t\t\tname: this.name,\r\n\t\r\n\t\t\t\tmapping: this.mapping,\r\n\t\r\n\t\t\t\trepeat: [ this.repeat.x, this.repeat.y ],\r\n\t\t\t\toffset: [ this.offset.x, this.offset.y ],\r\n\t\t\t\twrap: [ this.wrapS, this.wrapT ],\r\n\t\r\n\t\t\t\tminFilter: this.minFilter,\r\n\t\t\t\tmagFilter: this.magFilter,\r\n\t\t\t\tanisotropy: this.anisotropy\r\n\t\t\t};\r\n\t\r\n\t\t\tif ( this.image !== undefined ) {\r\n\t\r\n\t\t\t\t// TODO: Move to THREE.Image\r\n\t\r\n\t\t\t\tvar image = this.image;\r\n\t\r\n\t\t\t\tif ( image.uuid === undefined ) {\r\n\t\r\n\t\t\t\t\timage.uuid = THREE.Math.generateUUID(); // UGH\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( meta.images[ image.uuid ] === undefined ) {\r\n\t\r\n\t\t\t\t\tmeta.images[ image.uuid ] = {\r\n\t\t\t\t\t\tuuid: image.uuid,\r\n\t\t\t\t\t\turl: getDataURL( image )\r\n\t\t\t\t\t};\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\toutput.image = image.uuid;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tmeta.textures[ this.uuid ] = output;\r\n\t\r\n\t\t\treturn output;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdispose: function () {\r\n\t\r\n\t\t\tthis.dispatchEvent( { type: 'dispose' } );\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttransformUv: function ( uv ) {\r\n\t\r\n\t\t\tif ( this.mapping !== THREE.UVMapping )  return;\r\n\t\r\n\t\t\tuv.multiply( this.repeat );\r\n\t\t\tuv.add( this.offset );\r\n\t\r\n\t\t\tif ( uv.x < 0 || uv.x > 1 ) {\r\n\t\r\n\t\t\t\tswitch ( this.wrapS ) {\r\n\t\r\n\t\t\t\t\tcase THREE.RepeatWrapping:\r\n\t\r\n\t\t\t\t\t\tuv.x = uv.x - Math.floor( uv.x );\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase THREE.ClampToEdgeWrapping:\r\n\t\r\n\t\t\t\t\t\tuv.x = uv.x < 0 ? 0 : 1;\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase THREE.MirroredRepeatWrapping:\r\n\t\r\n\t\t\t\t\t\tif ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {\r\n\t\r\n\t\t\t\t\t\t\tuv.x = Math.ceil( uv.x ) - uv.x;\r\n\t\r\n\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\tuv.x = uv.x - Math.floor( uv.x );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( uv.y < 0 || uv.y > 1 ) {\r\n\t\r\n\t\t\t\tswitch ( this.wrapT ) {\r\n\t\r\n\t\t\t\t\tcase THREE.RepeatWrapping:\r\n\t\r\n\t\t\t\t\t\tuv.y = uv.y - Math.floor( uv.y );\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase THREE.ClampToEdgeWrapping:\r\n\t\r\n\t\t\t\t\t\tuv.y = uv.y < 0 ? 0 : 1;\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase THREE.MirroredRepeatWrapping:\r\n\t\r\n\t\t\t\t\t\tif ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {\r\n\t\r\n\t\t\t\t\t\t\tuv.y = Math.ceil( uv.y ) - uv.y;\r\n\t\r\n\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\tuv.y = uv.y - Math.floor( uv.y );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( this.flipY ) {\r\n\t\r\n\t\t\t\tuv.y = 1 - uv.y;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.EventDispatcher.prototype.apply( THREE.Texture.prototype );\r\n\t\r\n\tTHREE.TextureIdCount = 0;\r\n\t\r\n\t// File:src/textures/DepthTexture.js\r\n\t\r\n\t/**\r\n\t * @author Matt DesLauriers / @mattdesl\r\n\t */\r\n\t\r\n\tTHREE.DepthTexture = function ( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {\r\n\t\r\n\t  THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, THREE.DepthFormat, type, anisotropy );\r\n\t\r\n\t  this.image = { width: width, height: height };\r\n\t\r\n\t  this.type = type !== undefined ? type : THREE.UnsignedShortType;\r\n\t\r\n\t  this.magFilter = magFilter !== undefined ? magFilter : THREE.NearestFilter;\r\n\t  this.minFilter = minFilter !== undefined ? minFilter : THREE.NearestFilter;\r\n\t\r\n\t  this.flipY = false;\r\n\t  this.generateMipmaps  = false;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.DepthTexture.prototype = Object.create( THREE.Texture.prototype );\r\n\tTHREE.DepthTexture.prototype.constructor = THREE.DepthTexture;\r\n\t\r\n\t// File:src/textures/CanvasTexture.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.CanvasTexture = function ( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\r\n\t\r\n\t\tTHREE.Texture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\r\n\t\r\n\t\tthis.needsUpdate = true;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.CanvasTexture.prototype = Object.create( THREE.Texture.prototype );\r\n\tTHREE.CanvasTexture.prototype.constructor = THREE.CanvasTexture;\r\n\t\r\n\t// File:src/textures/CubeTexture.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.CubeTexture = function ( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {\r\n\t\r\n\t\timages = images !== undefined ? images : [];\r\n\t\tmapping = mapping !== undefined ? mapping : THREE.CubeReflectionMapping;\r\n\t\r\n\t\tTHREE.Texture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\r\n\t\r\n\t\tthis.flipY = false;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.CubeTexture.prototype = Object.create( THREE.Texture.prototype );\r\n\tTHREE.CubeTexture.prototype.constructor = THREE.CubeTexture;\r\n\t\r\n\tObject.defineProperty( THREE.CubeTexture.prototype, 'images', {\r\n\t\r\n\t\tget: function () {\r\n\t\r\n\t\t\treturn this.image;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tset: function ( value ) {\r\n\t\r\n\t\t\tthis.image = value;\r\n\t\r\n\t\t}\r\n\t\r\n\t} );\r\n\t\r\n\t// File:src/textures/CompressedTexture.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.CompressedTexture = function ( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {\r\n\t\r\n\t\tTHREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\r\n\t\r\n\t\tthis.image = { width: width, height: height };\r\n\t\tthis.mipmaps = mipmaps;\r\n\t\r\n\t\t// no flipping for cube textures\r\n\t\t// (also flipping doesn't work for compressed textures )\r\n\t\r\n\t\tthis.flipY = false;\r\n\t\r\n\t\t// can't generate mipmaps for compressed textures\r\n\t\t// mips must be embedded in DDS files\r\n\t\r\n\t\tthis.generateMipmaps = false;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.CompressedTexture.prototype = Object.create( THREE.Texture.prototype );\r\n\tTHREE.CompressedTexture.prototype.constructor = THREE.CompressedTexture;\r\n\t\r\n\t// File:src/textures/DataTexture.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.DataTexture = function ( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {\r\n\t\r\n\t\tTHREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\r\n\t\r\n\t\tthis.image = { data: data, width: width, height: height };\r\n\t\r\n\t\tthis.magFilter = magFilter !== undefined ? magFilter : THREE.NearestFilter;\r\n\t\tthis.minFilter = minFilter !== undefined ? minFilter : THREE.NearestFilter;\r\n\t\r\n\t\tthis.flipY = false;\r\n\t\tthis.generateMipmaps  = false;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.DataTexture.prototype = Object.create( THREE.Texture.prototype );\r\n\tTHREE.DataTexture.prototype.constructor = THREE.DataTexture;\r\n\t\r\n\t// File:src/textures/VideoTexture.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.VideoTexture = function ( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\r\n\t\r\n\t\tTHREE.Texture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\r\n\t\r\n\t\tthis.generateMipmaps = false;\r\n\t\r\n\t\tvar scope = this;\r\n\t\r\n\t\tfunction update() {\r\n\t\r\n\t\t\trequestAnimationFrame( update );\r\n\t\r\n\t\t\tif ( video.readyState >= video.HAVE_CURRENT_DATA ) {\r\n\t\r\n\t\t\t\tscope.needsUpdate = true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tupdate();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.VideoTexture.prototype = Object.create( THREE.Texture.prototype );\r\n\tTHREE.VideoTexture.prototype.constructor = THREE.VideoTexture;\r\n\t\r\n\t// File:src/objects/Group.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.Group = function () {\r\n\t\r\n\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\tthis.type = 'Group';\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Group.prototype = Object.create( THREE.Object3D.prototype );\r\n\tTHREE.Group.prototype.constructor = THREE.Group;\r\n\t\r\n\t// File:src/objects/Points.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.Points = function ( geometry, material ) {\r\n\t\r\n\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\tthis.type = 'Points';\r\n\t\r\n\t\tthis.geometry = geometry !== undefined ? geometry : new THREE.Geometry();\r\n\t\tthis.material = material !== undefined ? material : new THREE.PointsMaterial( { color: Math.random() * 0xffffff } );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Points.prototype = Object.create( THREE.Object3D.prototype );\r\n\tTHREE.Points.prototype.constructor = THREE.Points;\r\n\t\r\n\tTHREE.Points.prototype.raycast = ( function () {\r\n\t\r\n\t\tvar inverseMatrix = new THREE.Matrix4();\r\n\t\tvar ray = new THREE.Ray();\r\n\t\tvar sphere = new THREE.Sphere();\r\n\t\r\n\t\treturn function raycast( raycaster, intersects ) {\r\n\t\r\n\t\t\tvar object = this;\r\n\t\t\tvar geometry = this.geometry;\r\n\t\t\tvar matrixWorld = this.matrixWorld;\r\n\t\t\tvar threshold = raycaster.params.Points.threshold;\r\n\t\r\n\t\t\t// Checking boundingSphere distance to ray\r\n\t\r\n\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\r\n\t\r\n\t\t\tsphere.copy( geometry.boundingSphere );\r\n\t\t\tsphere.applyMatrix4( matrixWorld );\r\n\t\r\n\t\t\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\r\n\t\r\n\t\t\t//\r\n\t\r\n\t\t\tinverseMatrix.getInverse( matrixWorld );\r\n\t\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\r\n\t\r\n\t\t\tvar localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );\r\n\t\t\tvar localThresholdSq = localThreshold * localThreshold;\r\n\t\t\tvar position = new THREE.Vector3();\r\n\t\r\n\t\t\tfunction testPoint( point, index ) {\r\n\t\r\n\t\t\t\tvar rayPointDistanceSq = ray.distanceSqToPoint( point );\r\n\t\r\n\t\t\t\tif ( rayPointDistanceSq < localThresholdSq ) {\r\n\t\r\n\t\t\t\t\tvar intersectPoint = ray.closestPointToPoint( point );\r\n\t\t\t\t\tintersectPoint.applyMatrix4( matrixWorld );\r\n\t\r\n\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( intersectPoint );\r\n\t\r\n\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) return;\r\n\t\r\n\t\t\t\t\tintersects.push( {\r\n\t\r\n\t\t\t\t\t\tdistance: distance,\r\n\t\t\t\t\t\tdistanceToRay: Math.sqrt( rayPointDistanceSq ),\r\n\t\t\t\t\t\tpoint: intersectPoint.clone(),\r\n\t\t\t\t\t\tindex: index,\r\n\t\t\t\t\t\tface: null,\r\n\t\t\t\t\t\tobject: object\r\n\t\r\n\t\t\t\t\t} );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\r\n\t\r\n\t\t\t\tvar index = geometry.index;\r\n\t\t\t\tvar attributes = geometry.attributes;\r\n\t\t\t\tvar positions = attributes.position.array;\r\n\t\r\n\t\t\t\tif ( index !== null ) {\r\n\t\r\n\t\t\t\t\tvar indices = index.array;\r\n\t\r\n\t\t\t\t\tfor ( var i = 0, il = indices.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\t\tvar a = indices[ i ];\r\n\t\r\n\t\t\t\t\t\tposition.fromArray( positions, a * 3 );\r\n\t\r\n\t\t\t\t\t\ttestPoint( position, a );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tfor ( var i = 0, l = positions.length / 3; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\t\tposition.fromArray( positions, i * 3 );\r\n\t\r\n\t\t\t\t\t\ttestPoint( position, i );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tvar vertices = geometry.vertices;\r\n\t\r\n\t\t\t\tfor ( var i = 0, l = vertices.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\ttestPoint( vertices[ i ], i );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t}() );\r\n\t\r\n\tTHREE.Points.prototype.clone = function () {\r\n\t\r\n\t\treturn new this.constructor( this.geometry, this.material ).copy( this );\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/objects/Line.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.Line = function ( geometry, material, mode ) {\r\n\t\r\n\t\tif ( mode === 1 ) {\r\n\t\r\n\t\t\tconsole.warn( 'THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.' );\r\n\t\t\treturn new THREE.LineSegments( geometry, material );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\tthis.type = 'Line';\r\n\t\r\n\t\tthis.geometry = geometry !== undefined ? geometry : new THREE.Geometry();\r\n\t\tthis.material = material !== undefined ? material : new THREE.LineBasicMaterial( { color: Math.random() * 0xffffff } );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Line.prototype = Object.create( THREE.Object3D.prototype );\r\n\tTHREE.Line.prototype.constructor = THREE.Line;\r\n\t\r\n\tTHREE.Line.prototype.raycast = ( function () {\r\n\t\r\n\t\tvar inverseMatrix = new THREE.Matrix4();\r\n\t\tvar ray = new THREE.Ray();\r\n\t\tvar sphere = new THREE.Sphere();\r\n\t\r\n\t\treturn function raycast( raycaster, intersects ) {\r\n\t\r\n\t\t\tvar precision = raycaster.linePrecision;\r\n\t\t\tvar precisionSq = precision * precision;\r\n\t\r\n\t\t\tvar geometry = this.geometry;\r\n\t\t\tvar matrixWorld = this.matrixWorld;\r\n\t\r\n\t\t\t// Checking boundingSphere distance to ray\r\n\t\r\n\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\r\n\t\r\n\t\t\tsphere.copy( geometry.boundingSphere );\r\n\t\t\tsphere.applyMatrix4( matrixWorld );\r\n\t\r\n\t\t\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\r\n\t\r\n\t\t\t//\r\n\t\r\n\t\t\tinverseMatrix.getInverse( matrixWorld );\r\n\t\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\r\n\t\r\n\t\t\tvar vStart = new THREE.Vector3();\r\n\t\t\tvar vEnd = new THREE.Vector3();\r\n\t\t\tvar interSegment = new THREE.Vector3();\r\n\t\t\tvar interRay = new THREE.Vector3();\r\n\t\t\tvar step = this instanceof THREE.LineSegments ? 2 : 1;\r\n\t\r\n\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\r\n\t\r\n\t\t\t\tvar index = geometry.index;\r\n\t\t\t\tvar attributes = geometry.attributes;\r\n\t\t\t\tvar positions = attributes.position.array;\r\n\t\r\n\t\t\t\tif ( index !== null ) {\r\n\t\r\n\t\t\t\t\tvar indices = index.array;\r\n\t\r\n\t\t\t\t\tfor ( var i = 0, l = indices.length - 1; i < l; i += step ) {\r\n\t\r\n\t\t\t\t\t\tvar a = indices[ i ];\r\n\t\t\t\t\t\tvar b = indices[ i + 1 ];\r\n\t\r\n\t\t\t\t\t\tvStart.fromArray( positions, a * 3 );\r\n\t\t\t\t\t\tvEnd.fromArray( positions, b * 3 );\r\n\t\r\n\t\t\t\t\t\tvar distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\r\n\t\r\n\t\t\t\t\t\tif ( distSq > precisionSq ) continue;\r\n\t\r\n\t\t\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\r\n\t\r\n\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( interRay );\r\n\t\r\n\t\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\r\n\t\r\n\t\t\t\t\t\tintersects.push( {\r\n\t\r\n\t\t\t\t\t\t\tdistance: distance,\r\n\t\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\r\n\t\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\r\n\t\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\r\n\t\t\t\t\t\t\tindex: i,\r\n\t\t\t\t\t\t\tface: null,\r\n\t\t\t\t\t\t\tfaceIndex: null,\r\n\t\t\t\t\t\t\tobject: this\r\n\t\r\n\t\t\t\t\t\t} );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tfor ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) {\r\n\t\r\n\t\t\t\t\t\tvStart.fromArray( positions, 3 * i );\r\n\t\t\t\t\t\tvEnd.fromArray( positions, 3 * i + 3 );\r\n\t\r\n\t\t\t\t\t\tvar distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\r\n\t\r\n\t\t\t\t\t\tif ( distSq > precisionSq ) continue;\r\n\t\r\n\t\t\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\r\n\t\r\n\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( interRay );\r\n\t\r\n\t\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\r\n\t\r\n\t\t\t\t\t\tintersects.push( {\r\n\t\r\n\t\t\t\t\t\t\tdistance: distance,\r\n\t\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\r\n\t\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\r\n\t\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\r\n\t\t\t\t\t\t\tindex: i,\r\n\t\t\t\t\t\t\tface: null,\r\n\t\t\t\t\t\t\tfaceIndex: null,\r\n\t\t\t\t\t\t\tobject: this\r\n\t\r\n\t\t\t\t\t\t} );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else if ( geometry instanceof THREE.Geometry ) {\r\n\t\r\n\t\t\t\tvar vertices = geometry.vertices;\r\n\t\t\t\tvar nbVertices = vertices.length;\r\n\t\r\n\t\t\t\tfor ( var i = 0; i < nbVertices - 1; i += step ) {\r\n\t\r\n\t\t\t\t\tvar distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );\r\n\t\r\n\t\t\t\t\tif ( distSq > precisionSq ) continue;\r\n\t\r\n\t\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\r\n\t\r\n\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( interRay );\r\n\t\r\n\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\r\n\t\r\n\t\t\t\t\tintersects.push( {\r\n\t\r\n\t\t\t\t\t\tdistance: distance,\r\n\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\r\n\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\r\n\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\r\n\t\t\t\t\t\tindex: i,\r\n\t\t\t\t\t\tface: null,\r\n\t\t\t\t\t\tfaceIndex: null,\r\n\t\t\t\t\t\tobject: this\r\n\t\r\n\t\t\t\t\t} );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t}() );\r\n\t\r\n\tTHREE.Line.prototype.clone = function () {\r\n\t\r\n\t\treturn new this.constructor( this.geometry, this.material ).copy( this );\r\n\t\r\n\t};\r\n\t\r\n\t// DEPRECATED\r\n\t\r\n\tTHREE.LineStrip = 0;\r\n\tTHREE.LinePieces = 1;\r\n\t\r\n\t// File:src/objects/LineSegments.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.LineSegments = function ( geometry, material ) {\r\n\t\r\n\t\tTHREE.Line.call( this, geometry, material );\r\n\t\r\n\t\tthis.type = 'LineSegments';\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.LineSegments.prototype = Object.create( THREE.Line.prototype );\r\n\tTHREE.LineSegments.prototype.constructor = THREE.LineSegments;\r\n\t\r\n\t// File:src/objects/Mesh.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t * @author jonobr1 / http://jonobr1.com/\r\n\t */\r\n\t\r\n\tTHREE.Mesh = function ( geometry, material ) {\r\n\t\r\n\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\tthis.type = 'Mesh';\r\n\t\r\n\t\tthis.geometry = geometry !== undefined ? geometry : new THREE.Geometry();\r\n\t\tthis.material = material !== undefined ? material : new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff } );\r\n\t\r\n\t\tthis.drawMode = THREE.TrianglesDrawMode;\r\n\t\r\n\t\tthis.updateMorphTargets();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Mesh.prototype = Object.create( THREE.Object3D.prototype );\r\n\tTHREE.Mesh.prototype.constructor = THREE.Mesh;\r\n\t\r\n\tTHREE.Mesh.prototype.setDrawMode = function ( value ) {\r\n\t\r\n\t\tthis.drawMode = value;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Mesh.prototype.updateMorphTargets = function () {\r\n\t\r\n\t\tif ( this.geometry.morphTargets !== undefined && this.geometry.morphTargets.length > 0 ) {\r\n\t\r\n\t\t\tthis.morphTargetBase = - 1;\r\n\t\t\tthis.morphTargetInfluences = [];\r\n\t\t\tthis.morphTargetDictionary = {};\r\n\t\r\n\t\t\tfor ( var m = 0, ml = this.geometry.morphTargets.length; m < ml; m ++ ) {\r\n\t\r\n\t\t\t\tthis.morphTargetInfluences.push( 0 );\r\n\t\t\t\tthis.morphTargetDictionary[ this.geometry.morphTargets[ m ].name ] = m;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Mesh.prototype.getMorphTargetIndexByName = function ( name ) {\r\n\t\r\n\t\tif ( this.morphTargetDictionary[ name ] !== undefined ) {\r\n\t\r\n\t\t\treturn this.morphTargetDictionary[ name ];\r\n\t\r\n\t\t}\r\n\t\r\n\t\tconsole.warn( 'THREE.Mesh.getMorphTargetIndexByName: morph target ' + name + ' does not exist. Returning 0.' );\r\n\t\r\n\t\treturn 0;\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\tTHREE.Mesh.prototype.raycast = ( function () {\r\n\t\r\n\t\tvar inverseMatrix = new THREE.Matrix4();\r\n\t\tvar ray = new THREE.Ray();\r\n\t\tvar sphere = new THREE.Sphere();\r\n\t\r\n\t\tvar vA = new THREE.Vector3();\r\n\t\tvar vB = new THREE.Vector3();\r\n\t\tvar vC = new THREE.Vector3();\r\n\t\r\n\t\tvar tempA = new THREE.Vector3();\r\n\t\tvar tempB = new THREE.Vector3();\r\n\t\tvar tempC = new THREE.Vector3();\r\n\t\r\n\t\tvar uvA = new THREE.Vector2();\r\n\t\tvar uvB = new THREE.Vector2();\r\n\t\tvar uvC = new THREE.Vector2();\r\n\t\r\n\t\tvar barycoord = new THREE.Vector3();\r\n\t\r\n\t\tvar intersectionPoint = new THREE.Vector3();\r\n\t\tvar intersectionPointWorld = new THREE.Vector3();\r\n\t\r\n\t\tfunction uvIntersection( point, p1, p2, p3, uv1, uv2, uv3 ) {\r\n\t\r\n\t\t\tTHREE.Triangle.barycoordFromPoint( point, p1, p2, p3, barycoord );\r\n\t\r\n\t\t\tuv1.multiplyScalar( barycoord.x );\r\n\t\t\tuv2.multiplyScalar( barycoord.y );\r\n\t\t\tuv3.multiplyScalar( barycoord.z );\r\n\t\r\n\t\t\tuv1.add( uv2 ).add( uv3 );\r\n\t\r\n\t\t\treturn uv1.clone();\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction checkIntersection( object, raycaster, ray, pA, pB, pC, point ) {\r\n\t\r\n\t\t\tvar intersect;\r\n\t\t\tvar material = object.material;\r\n\t\r\n\t\t\tif ( material.side === THREE.BackSide ) {\r\n\t\r\n\t\t\t\tintersect = ray.intersectTriangle( pC, pB, pA, true, point );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tintersect = ray.intersectTriangle( pA, pB, pC, material.side !== THREE.DoubleSide, point );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( intersect === null ) return null;\r\n\t\r\n\t\t\tintersectionPointWorld.copy( point );\r\n\t\t\tintersectionPointWorld.applyMatrix4( object.matrixWorld );\r\n\t\r\n\t\t\tvar distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );\r\n\t\r\n\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) return null;\r\n\t\r\n\t\t\treturn {\r\n\t\t\t\tdistance: distance,\r\n\t\t\t\tpoint: intersectionPointWorld.clone(),\r\n\t\t\t\tobject: object\r\n\t\t\t};\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction checkBufferGeometryIntersection( object, raycaster, ray, positions, uvs, a, b, c ) {\r\n\t\r\n\t\t\tvA.fromArray( positions, a * 3 );\r\n\t\t\tvB.fromArray( positions, b * 3 );\r\n\t\t\tvC.fromArray( positions, c * 3 );\r\n\t\r\n\t\t\tvar intersection = checkIntersection( object, raycaster, ray, vA, vB, vC, intersectionPoint );\r\n\t\r\n\t\t\tif ( intersection ) {\r\n\t\r\n\t\t\t\tif ( uvs ) {\r\n\t\r\n\t\t\t\t\tuvA.fromArray( uvs, a * 2 );\r\n\t\t\t\t\tuvB.fromArray( uvs, b * 2 );\r\n\t\t\t\t\tuvC.fromArray( uvs, c * 2 );\r\n\t\r\n\t\t\t\t\tintersection.uv = uvIntersection( intersectionPoint,  vA, vB, vC,  uvA, uvB, uvC );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tintersection.face = new THREE.Face3( a, b, c, THREE.Triangle.normal( vA, vB, vC ) );\r\n\t\t\t\tintersection.faceIndex = a;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn intersection;\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn function raycast( raycaster, intersects ) {\r\n\t\r\n\t\t\tvar geometry = this.geometry;\r\n\t\t\tvar material = this.material;\r\n\t\t\tvar matrixWorld = this.matrixWorld;\r\n\t\r\n\t\t\tif ( material === undefined ) return;\r\n\t\r\n\t\t\t// Checking boundingSphere distance to ray\r\n\t\r\n\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\r\n\t\r\n\t\t\tsphere.copy( geometry.boundingSphere );\r\n\t\t\tsphere.applyMatrix4( matrixWorld );\r\n\t\r\n\t\t\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\r\n\t\r\n\t\t\t//\r\n\t\r\n\t\t\tinverseMatrix.getInverse( matrixWorld );\r\n\t\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\r\n\t\r\n\t\t\t// Check boundingBox before continuing\r\n\t\r\n\t\t\tif ( geometry.boundingBox !== null ) {\r\n\t\r\n\t\t\t\tif ( ray.intersectsBox( geometry.boundingBox ) === false ) return;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar uvs, intersection;\r\n\t\r\n\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\r\n\t\r\n\t\t\t\tvar a, b, c;\r\n\t\t\t\tvar index = geometry.index;\r\n\t\t\t\tvar attributes = geometry.attributes;\r\n\t\t\t\tvar positions = attributes.position.array;\r\n\t\r\n\t\t\t\tif ( attributes.uv !== undefined ) {\r\n\t\r\n\t\t\t\t\tuvs = attributes.uv.array;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( index !== null ) {\r\n\t\r\n\t\t\t\t\tvar indices = index.array;\r\n\t\r\n\t\t\t\t\tfor ( var i = 0, l = indices.length; i < l; i += 3 ) {\r\n\t\r\n\t\t\t\t\t\ta = indices[ i ];\r\n\t\t\t\t\t\tb = indices[ i + 1 ];\r\n\t\t\t\t\t\tc = indices[ i + 2 ];\r\n\t\r\n\t\t\t\t\t\tintersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );\r\n\t\r\n\t\t\t\t\t\tif ( intersection ) {\r\n\t\r\n\t\t\t\t\t\t\tintersection.faceIndex = Math.floor( i / 3 ); // triangle number in indices buffer semantics\r\n\t\t\t\t\t\t\tintersects.push( intersection );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\r\n\t\t\t\t\tfor ( var i = 0, l = positions.length; i < l; i += 9 ) {\r\n\t\r\n\t\t\t\t\t\ta = i / 3;\r\n\t\t\t\t\t\tb = a + 1;\r\n\t\t\t\t\t\tc = a + 2;\r\n\t\r\n\t\t\t\t\t\tintersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );\r\n\t\r\n\t\t\t\t\t\tif ( intersection ) {\r\n\t\r\n\t\t\t\t\t\t\tintersection.index = a; // triangle number in positions buffer semantics\r\n\t\t\t\t\t\t\tintersects.push( intersection );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else if ( geometry instanceof THREE.Geometry ) {\r\n\t\r\n\t\t\t\tvar fvA, fvB, fvC;\r\n\t\t\t\tvar isFaceMaterial = material instanceof THREE.MultiMaterial;\r\n\t\t\t\tvar materials = isFaceMaterial === true ? material.materials : null;\r\n\t\r\n\t\t\t\tvar vertices = geometry.vertices;\r\n\t\t\t\tvar faces = geometry.faces;\r\n\t\t\t\tvar faceVertexUvs = geometry.faceVertexUvs[ 0 ];\r\n\t\t\t\tif ( faceVertexUvs.length > 0 ) uvs = faceVertexUvs;\r\n\t\r\n\t\t\t\tfor ( var f = 0, fl = faces.length; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\t\tvar face = faces[ f ];\r\n\t\t\t\t\tvar faceMaterial = isFaceMaterial === true ? materials[ face.materialIndex ] : material;\r\n\t\r\n\t\t\t\t\tif ( faceMaterial === undefined ) continue;\r\n\t\r\n\t\t\t\t\tfvA = vertices[ face.a ];\r\n\t\t\t\t\tfvB = vertices[ face.b ];\r\n\t\t\t\t\tfvC = vertices[ face.c ];\r\n\t\r\n\t\t\t\t\tif ( faceMaterial.morphTargets === true ) {\r\n\t\r\n\t\t\t\t\t\tvar morphTargets = geometry.morphTargets;\r\n\t\t\t\t\t\tvar morphInfluences = this.morphTargetInfluences;\r\n\t\r\n\t\t\t\t\t\tvA.set( 0, 0, 0 );\r\n\t\t\t\t\t\tvB.set( 0, 0, 0 );\r\n\t\t\t\t\t\tvC.set( 0, 0, 0 );\r\n\t\r\n\t\t\t\t\t\tfor ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {\r\n\t\r\n\t\t\t\t\t\t\tvar influence = morphInfluences[ t ];\r\n\t\r\n\t\t\t\t\t\t\tif ( influence === 0 ) continue;\r\n\t\r\n\t\t\t\t\t\t\tvar targets = morphTargets[ t ].vertices;\r\n\t\r\n\t\t\t\t\t\t\tvA.addScaledVector( tempA.subVectors( targets[ face.a ], fvA ), influence );\r\n\t\t\t\t\t\t\tvB.addScaledVector( tempB.subVectors( targets[ face.b ], fvB ), influence );\r\n\t\t\t\t\t\t\tvC.addScaledVector( tempC.subVectors( targets[ face.c ], fvC ), influence );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tvA.add( fvA );\r\n\t\t\t\t\t\tvB.add( fvB );\r\n\t\t\t\t\t\tvC.add( fvC );\r\n\t\r\n\t\t\t\t\t\tfvA = vA;\r\n\t\t\t\t\t\tfvB = vB;\r\n\t\t\t\t\t\tfvC = vC;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tintersection = checkIntersection( this, raycaster, ray, fvA, fvB, fvC, intersectionPoint );\r\n\t\r\n\t\t\t\t\tif ( intersection ) {\r\n\t\r\n\t\t\t\t\t\tif ( uvs ) {\r\n\t\r\n\t\t\t\t\t\t\tvar uvs_f = uvs[ f ];\r\n\t\t\t\t\t\t\tuvA.copy( uvs_f[ 0 ] );\r\n\t\t\t\t\t\t\tuvB.copy( uvs_f[ 1 ] );\r\n\t\t\t\t\t\t\tuvC.copy( uvs_f[ 2 ] );\r\n\t\r\n\t\t\t\t\t\t\tintersection.uv = uvIntersection( intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tintersection.face = face;\r\n\t\t\t\t\t\tintersection.faceIndex = f;\r\n\t\t\t\t\t\tintersects.push( intersection );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t}() );\r\n\t\r\n\tTHREE.Mesh.prototype.clone = function () {\r\n\t\r\n\t\treturn new this.constructor( this.geometry, this.material ).copy( this );\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/objects/Bone.js\r\n\t\r\n\t/**\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author ikerr / http://verold.com\r\n\t */\r\n\t\r\n\tTHREE.Bone = function ( skin ) {\r\n\t\r\n\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\tthis.type = 'Bone';\r\n\t\r\n\t\tthis.skin = skin;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Bone.prototype = Object.create( THREE.Object3D.prototype );\r\n\tTHREE.Bone.prototype.constructor = THREE.Bone;\r\n\t\r\n\tTHREE.Bone.prototype.copy = function ( source ) {\r\n\t\r\n\t\tTHREE.Object3D.prototype.copy.call( this, source );\r\n\t\r\n\t\tthis.skin = source.skin;\r\n\t\r\n\t\treturn this;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/objects/Skeleton.js\r\n\t\r\n\t/**\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author michael guerrero / http://realitymeltdown.com\r\n\t * @author ikerr / http://verold.com\r\n\t */\r\n\t\r\n\tTHREE.Skeleton = function ( bones, boneInverses, useVertexTexture ) {\r\n\t\r\n\t\tthis.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;\r\n\t\r\n\t\tthis.identityMatrix = new THREE.Matrix4();\r\n\t\r\n\t\t// copy the bone array\r\n\t\r\n\t\tbones = bones || [];\r\n\t\r\n\t\tthis.bones = bones.slice( 0 );\r\n\t\r\n\t\t// create a bone texture or an array of floats\r\n\t\r\n\t\tif ( this.useVertexTexture ) {\r\n\t\r\n\t\t\t// layout (1 matrix = 4 pixels)\r\n\t\t\t//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)\r\n\t\t\t//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)\r\n\t\t\t//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)\r\n\t\t\t//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)\r\n\t\t\t//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)\r\n\t\r\n\t\t\t\r\n\t\t\tvar size = Math.sqrt( this.bones.length * 4 ); // 4 pixels needed for 1 matrix\r\n\t\t\tsize = THREE.Math.nextPowerOfTwo( Math.ceil( size ) );\r\n\t\t\tsize = Math.max( size, 4 );\r\n\t\r\n\t\t\tthis.boneTextureWidth = size;\r\n\t\t\tthis.boneTextureHeight = size;\r\n\t\r\n\t\t\tthis.boneMatrices = new Float32Array( this.boneTextureWidth * this.boneTextureHeight * 4 ); // 4 floats per RGBA pixel\r\n\t\t\tthis.boneTexture = new THREE.DataTexture( this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType );\r\n\t\r\n\t\t} else {\r\n\t\r\n\t\t\tthis.boneMatrices = new Float32Array( 16 * this.bones.length );\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// use the supplied bone inverses or calculate the inverses\r\n\t\r\n\t\tif ( boneInverses === undefined ) {\r\n\t\r\n\t\t\tthis.calculateInverses();\r\n\t\r\n\t\t} else {\r\n\t\r\n\t\t\tif ( this.bones.length === boneInverses.length ) {\r\n\t\r\n\t\t\t\tthis.boneInverses = boneInverses.slice( 0 );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.Skeleton bonInverses is the wrong length.' );\r\n\t\r\n\t\t\t\tthis.boneInverses = [];\r\n\t\r\n\t\t\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\r\n\t\r\n\t\t\t\t\tthis.boneInverses.push( new THREE.Matrix4() );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Skeleton.prototype.calculateInverses = function () {\r\n\t\r\n\t\tthis.boneInverses = [];\r\n\t\r\n\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\r\n\t\r\n\t\t\tvar inverse = new THREE.Matrix4();\r\n\t\r\n\t\t\tif ( this.bones[ b ] ) {\r\n\t\r\n\t\t\t\tinverse.getInverse( this.bones[ b ].matrixWorld );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.boneInverses.push( inverse );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Skeleton.prototype.pose = function () {\r\n\t\r\n\t\tvar bone;\r\n\t\r\n\t\t// recover the bind-time world matrices\r\n\t\r\n\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\r\n\t\r\n\t\t\tbone = this.bones[ b ];\r\n\t\r\n\t\t\tif ( bone ) {\r\n\t\r\n\t\t\t\tbone.matrixWorld.getInverse( this.boneInverses[ b ] );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// compute the local matrices, positions, rotations and scales\r\n\t\r\n\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\r\n\t\r\n\t\t\tbone = this.bones[ b ];\r\n\t\r\n\t\t\tif ( bone ) {\r\n\t\r\n\t\t\t\tif ( bone.parent ) {\r\n\t\r\n\t\t\t\t\tbone.matrix.getInverse( bone.parent.matrixWorld );\r\n\t\t\t\t\tbone.matrix.multiply( bone.matrixWorld );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tbone.matrix.copy( bone.matrixWorld );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Skeleton.prototype.update = ( function () {\r\n\t\r\n\t\tvar offsetMatrix = new THREE.Matrix4();\r\n\t\r\n\t\treturn function update() {\r\n\t\r\n\t\t\t// flatten bone matrices to array\r\n\t\r\n\t\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\r\n\t\r\n\t\t\t\t// compute the offset between the current and the original transform\r\n\t\r\n\t\t\t\tvar matrix = this.bones[ b ] ? this.bones[ b ].matrixWorld : this.identityMatrix;\r\n\t\r\n\t\t\t\toffsetMatrix.multiplyMatrices( matrix, this.boneInverses[ b ] );\r\n\t\t\t\toffsetMatrix.toArray( this.boneMatrices, b * 16 );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( this.useVertexTexture ) {\r\n\t\r\n\t\t\t\tthis.boneTexture.needsUpdate = true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t} )();\r\n\t\r\n\tTHREE.Skeleton.prototype.clone = function () {\r\n\t\r\n\t\treturn new THREE.Skeleton( this.bones, this.boneInverses, this.useVertexTexture );\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/objects/SkinnedMesh.js\r\n\t\r\n\t/**\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author ikerr / http://verold.com\r\n\t */\r\n\t\r\n\tTHREE.SkinnedMesh = function ( geometry, material, useVertexTexture ) {\r\n\t\r\n\t\tTHREE.Mesh.call( this, geometry, material );\r\n\t\r\n\t\tthis.type = 'SkinnedMesh';\r\n\t\r\n\t\tthis.bindMode = \"attached\";\r\n\t\tthis.bindMatrix = new THREE.Matrix4();\r\n\t\tthis.bindMatrixInverse = new THREE.Matrix4();\r\n\t\r\n\t\t// init bones\r\n\t\r\n\t\t// TODO: remove bone creation as there is no reason (other than\r\n\t\t// convenience) for THREE.SkinnedMesh to do this.\r\n\t\r\n\t\tvar bones = [];\r\n\t\r\n\t\tif ( this.geometry && this.geometry.bones !== undefined ) {\r\n\t\r\n\t\t\tvar bone, gbone;\r\n\t\r\n\t\t\tfor ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {\r\n\t\r\n\t\t\t\tgbone = this.geometry.bones[ b ];\r\n\t\r\n\t\t\t\tbone = new THREE.Bone( this );\r\n\t\t\t\tbones.push( bone );\r\n\t\r\n\t\t\t\tbone.name = gbone.name;\r\n\t\t\t\tbone.position.fromArray( gbone.pos );\r\n\t\t\t\tbone.quaternion.fromArray( gbone.rotq );\r\n\t\t\t\tif ( gbone.scl !== undefined ) bone.scale.fromArray( gbone.scl );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {\r\n\t\r\n\t\t\t\tgbone = this.geometry.bones[ b ];\r\n\t\r\n\t\t\t\tif ( gbone.parent !== - 1 && gbone.parent !== null &&\r\n\t\t\t\t\t\tbones[ gbone.parent ] !== undefined ) {\r\n\t\r\n\t\t\t\t\tbones[ gbone.parent ].add( bones[ b ] );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tthis.add( bones[ b ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.normalizeSkinWeights();\r\n\t\r\n\t\tthis.updateMatrixWorld( true );\r\n\t\tthis.bind( new THREE.Skeleton( bones, undefined, useVertexTexture ), this.matrixWorld );\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\tTHREE.SkinnedMesh.prototype = Object.create( THREE.Mesh.prototype );\r\n\tTHREE.SkinnedMesh.prototype.constructor = THREE.SkinnedMesh;\r\n\t\r\n\tTHREE.SkinnedMesh.prototype.bind = function( skeleton, bindMatrix ) {\r\n\t\r\n\t\tthis.skeleton = skeleton;\r\n\t\r\n\t\tif ( bindMatrix === undefined ) {\r\n\t\r\n\t\t\tthis.updateMatrixWorld( true );\r\n\t\r\n\t\t\tthis.skeleton.calculateInverses();\r\n\t\r\n\t\t\tbindMatrix = this.matrixWorld;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.bindMatrix.copy( bindMatrix );\r\n\t\tthis.bindMatrixInverse.getInverse( bindMatrix );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.SkinnedMesh.prototype.pose = function () {\r\n\t\r\n\t\tthis.skeleton.pose();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.SkinnedMesh.prototype.normalizeSkinWeights = function () {\r\n\t\r\n\t\tif ( this.geometry instanceof THREE.Geometry ) {\r\n\t\r\n\t\t\tfor ( var i = 0; i < this.geometry.skinWeights.length; i ++ ) {\r\n\t\r\n\t\t\t\tvar sw = this.geometry.skinWeights[ i ];\r\n\t\r\n\t\t\t\tvar scale = 1.0 / sw.lengthManhattan();\r\n\t\r\n\t\t\t\tif ( scale !== Infinity ) {\r\n\t\r\n\t\t\t\t\tsw.multiplyScalar( scale );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tsw.set( 1, 0, 0, 0 ); // do something reasonable\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t} else if ( this.geometry instanceof THREE.BufferGeometry ) {\r\n\t\r\n\t\t\tvar vec = new THREE.Vector4();\r\n\t\r\n\t\t\tvar skinWeight = this.geometry.attributes.skinWeight;\r\n\t\r\n\t\t\tfor ( var i = 0; i < skinWeight.count; i ++ ) {\r\n\t\r\n\t\t\t\tvec.x = skinWeight.getX( i );\r\n\t\t\t\tvec.y = skinWeight.getY( i );\r\n\t\t\t\tvec.z = skinWeight.getZ( i );\r\n\t\t\t\tvec.w = skinWeight.getW( i );\r\n\t\r\n\t\t\t\tvar scale = 1.0 / vec.lengthManhattan();\r\n\t\r\n\t\t\t\tif ( scale !== Infinity ) {\r\n\t\r\n\t\t\t\t\tvec.multiplyScalar( scale );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tvec.set( 1, 0, 0, 0 ); // do something reasonable\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tskinWeight.setXYZW( i, vec.x, vec.y, vec.z, vec.w );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.SkinnedMesh.prototype.updateMatrixWorld = function( force ) {\r\n\t\r\n\t\tTHREE.Mesh.prototype.updateMatrixWorld.call( this, true );\r\n\t\r\n\t\tif ( this.bindMode === \"attached\" ) {\r\n\t\r\n\t\t\tthis.bindMatrixInverse.getInverse( this.matrixWorld );\r\n\t\r\n\t\t} else if ( this.bindMode === \"detached\" ) {\r\n\t\r\n\t\t\tthis.bindMatrixInverse.getInverse( this.bindMatrix );\r\n\t\r\n\t\t} else {\r\n\t\r\n\t\t\tconsole.warn( 'THREE.SkinnedMesh unrecognized bindMode: ' + this.bindMode );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.SkinnedMesh.prototype.clone = function() {\r\n\t\r\n\t\treturn new this.constructor( this.geometry, this.material, this.useVertexTexture ).copy( this );\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/objects/LOD.js\r\n\t\r\n\t/**\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.LOD = function () {\r\n\t\r\n\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\tthis.type = 'LOD';\r\n\t\r\n\t\tObject.defineProperties( this, {\r\n\t\t\tlevels: {\r\n\t\t\t\tenumerable: true,\r\n\t\t\t\tvalue: []\r\n\t\t\t}\r\n\t\t} );\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\tTHREE.LOD.prototype = Object.create( THREE.Object3D.prototype );\r\n\tTHREE.LOD.prototype.constructor = THREE.LOD;\r\n\t\r\n\tTHREE.LOD.prototype.addLevel = function ( object, distance ) {\r\n\t\r\n\t\tif ( distance === undefined ) distance = 0;\r\n\t\r\n\t\tdistance = Math.abs( distance );\r\n\t\r\n\t\tvar levels = this.levels;\r\n\t\r\n\t\tfor ( var l = 0; l < levels.length; l ++ ) {\r\n\t\r\n\t\t\tif ( distance < levels[ l ].distance ) {\r\n\t\r\n\t\t\t\tbreak;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tlevels.splice( l, 0, { distance: distance, object: object } );\r\n\t\r\n\t\tthis.add( object );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.LOD.prototype.getObjectForDistance = function ( distance ) {\r\n\t\r\n\t\tvar levels = this.levels;\r\n\t\r\n\t\tfor ( var i = 1, l = levels.length; i < l; i ++ ) {\r\n\t\r\n\t\t\tif ( distance < levels[ i ].distance ) {\r\n\t\r\n\t\t\t\tbreak;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn levels[ i - 1 ].object;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.LOD.prototype.raycast = ( function () {\r\n\t\r\n\t\tvar matrixPosition = new THREE.Vector3();\r\n\t\r\n\t\treturn function raycast( raycaster, intersects ) {\r\n\t\r\n\t\t\tmatrixPosition.setFromMatrixPosition( this.matrixWorld );\r\n\t\r\n\t\t\tvar distance = raycaster.ray.origin.distanceTo( matrixPosition );\r\n\t\r\n\t\t\tthis.getObjectForDistance( distance ).raycast( raycaster, intersects );\r\n\t\r\n\t\t};\r\n\t\r\n\t}() );\r\n\t\r\n\tTHREE.LOD.prototype.update = function () {\r\n\t\r\n\t\tvar v1 = new THREE.Vector3();\r\n\t\tvar v2 = new THREE.Vector3();\r\n\t\r\n\t\treturn function update( camera ) {\r\n\t\r\n\t\t\tvar levels = this.levels;\r\n\t\r\n\t\t\tif ( levels.length > 1 ) {\r\n\t\r\n\t\t\t\tv1.setFromMatrixPosition( camera.matrixWorld );\r\n\t\t\t\tv2.setFromMatrixPosition( this.matrixWorld );\r\n\t\r\n\t\t\t\tvar distance = v1.distanceTo( v2 );\r\n\t\r\n\t\t\t\tlevels[ 0 ].object.visible = true;\r\n\t\r\n\t\t\t\tfor ( var i = 1, l = levels.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\tif ( distance >= levels[ i ].distance ) {\r\n\t\r\n\t\t\t\t\t\tlevels[ i - 1 ].object.visible = false;\r\n\t\t\t\t\t\tlevels[ i ].object.visible = true;\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tfor ( ; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\tlevels[ i ].object.visible = false;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t}();\r\n\t\r\n\tTHREE.LOD.prototype.copy = function ( source ) {\r\n\t\r\n\t\tTHREE.Object3D.prototype.copy.call( this, source, false );\r\n\t\r\n\t\tvar levels = source.levels;\r\n\t\r\n\t\tfor ( var i = 0, l = levels.length; i < l; i ++ ) {\r\n\t\r\n\t\t\tvar level = levels[ i ];\r\n\t\r\n\t\t\tthis.addLevel( level.object.clone(), level.distance );\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn this;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.LOD.prototype.toJSON = function ( meta ) {\r\n\t\r\n\t\tvar data = THREE.Object3D.prototype.toJSON.call( this, meta );\r\n\t\r\n\t\tdata.object.levels = [];\r\n\t\r\n\t\tvar levels = this.levels;\r\n\t\r\n\t\tfor ( var i = 0, l = levels.length; i < l; i ++ ) {\r\n\t\r\n\t\t\tvar level = levels[ i ];\r\n\t\r\n\t\t\tdata.object.levels.push( {\r\n\t\t\t\tobject: level.object.uuid,\r\n\t\t\t\tdistance: level.distance\r\n\t\t\t} );\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn data;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/objects/Sprite.js\r\n\t\r\n\t/**\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.Sprite = ( function () {\r\n\t\r\n\t\tvar indices = new Uint16Array( [ 0, 1, 2,  0, 2, 3 ] );\r\n\t\tvar vertices = new Float32Array( [ - 0.5, - 0.5, 0,   0.5, - 0.5, 0,   0.5, 0.5, 0,   - 0.5, 0.5, 0 ] );\r\n\t\tvar uvs = new Float32Array( [ 0, 0,   1, 0,   1, 1,   0, 1 ] );\r\n\t\r\n\t\tvar geometry = new THREE.BufferGeometry();\r\n\t\tgeometry.setIndex( new THREE.BufferAttribute( indices, 1 ) );\r\n\t\tgeometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\r\n\t\tgeometry.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );\r\n\t\r\n\t\treturn function Sprite( material ) {\r\n\t\r\n\t\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\t\tthis.type = 'Sprite';\r\n\t\r\n\t\t\tthis.geometry = geometry;\r\n\t\t\tthis.material = ( material !== undefined ) ? material : new THREE.SpriteMaterial();\r\n\t\r\n\t\t};\r\n\t\r\n\t} )();\r\n\t\r\n\tTHREE.Sprite.prototype = Object.create( THREE.Object3D.prototype );\r\n\tTHREE.Sprite.prototype.constructor = THREE.Sprite;\r\n\t\r\n\tTHREE.Sprite.prototype.raycast = ( function () {\r\n\t\r\n\t\tvar matrixPosition = new THREE.Vector3();\r\n\t\r\n\t\treturn function raycast( raycaster, intersects ) {\r\n\t\r\n\t\t\tmatrixPosition.setFromMatrixPosition( this.matrixWorld );\r\n\t\r\n\t\t\tvar distanceSq = raycaster.ray.distanceSqToPoint( matrixPosition );\r\n\t\t\tvar guessSizeSq = this.scale.x * this.scale.y / 4;\r\n\t\r\n\t\t\tif ( distanceSq > guessSizeSq ) {\r\n\t\r\n\t\t\t\treturn;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tintersects.push( {\r\n\t\r\n\t\t\t\tdistance: Math.sqrt( distanceSq ),\r\n\t\t\t\tpoint: this.position,\r\n\t\t\t\tface: null,\r\n\t\t\t\tobject: this\r\n\t\r\n\t\t\t} );\r\n\t\r\n\t\t};\r\n\t\r\n\t}() );\r\n\t\r\n\tTHREE.Sprite.prototype.clone = function () {\r\n\t\r\n\t\treturn new this.constructor( this.material ).copy( this );\r\n\t\r\n\t};\r\n\t\r\n\t// Backwards compatibility\r\n\t\r\n\tTHREE.Particle = THREE.Sprite;\r\n\t\r\n\t// File:src/objects/LensFlare.js\r\n\t\r\n\t/**\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.LensFlare = function ( texture, size, distance, blending, color ) {\r\n\t\r\n\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\tthis.lensFlares = [];\r\n\t\r\n\t\tthis.positionScreen = new THREE.Vector3();\r\n\t\tthis.customUpdateCallback = undefined;\r\n\t\r\n\t\tif ( texture !== undefined ) {\r\n\t\r\n\t\t\tthis.add( texture, size, distance, blending, color );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.LensFlare.prototype = Object.create( THREE.Object3D.prototype );\r\n\tTHREE.LensFlare.prototype.constructor = THREE.LensFlare;\r\n\t\r\n\t\r\n\t/*\r\n\t * Add: adds another flare\r\n\t */\r\n\t\r\n\tTHREE.LensFlare.prototype.add = function ( texture, size, distance, blending, color, opacity ) {\r\n\t\r\n\t\tif ( size === undefined ) size = - 1;\r\n\t\tif ( distance === undefined ) distance = 0;\r\n\t\tif ( opacity === undefined ) opacity = 1;\r\n\t\tif ( color === undefined ) color = new THREE.Color( 0xffffff );\r\n\t\tif ( blending === undefined ) blending = THREE.NormalBlending;\r\n\t\r\n\t\tdistance = Math.min( distance, Math.max( 0, distance ) );\r\n\t\r\n\t\tthis.lensFlares.push( {\r\n\t\t\ttexture: texture,\t// THREE.Texture\r\n\t\t\tsize: size, \t\t// size in pixels (-1 = use texture.width)\r\n\t\t\tdistance: distance, \t// distance (0-1) from light source (0=at light source)\r\n\t\t\tx: 0, y: 0, z: 0,\t// screen position (-1 => 1) z = 0 is in front z = 1 is back\r\n\t\t\tscale: 1, \t\t// scale\r\n\t\t\trotation: 0, \t\t// rotation\r\n\t\t\topacity: opacity,\t// opacity\r\n\t\t\tcolor: color,\t\t// color\r\n\t\t\tblending: blending\t// blending\r\n\t\t} );\r\n\t\r\n\t};\r\n\t\r\n\t/*\r\n\t * Update lens flares update positions on all flares based on the screen position\r\n\t * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.\r\n\t */\r\n\t\r\n\tTHREE.LensFlare.prototype.updateLensFlares = function () {\r\n\t\r\n\t\tvar f, fl = this.lensFlares.length;\r\n\t\tvar flare;\r\n\t\tvar vecX = - this.positionScreen.x * 2;\r\n\t\tvar vecY = - this.positionScreen.y * 2;\r\n\t\r\n\t\tfor ( f = 0; f < fl; f ++ ) {\r\n\t\r\n\t\t\tflare = this.lensFlares[ f ];\r\n\t\r\n\t\t\tflare.x = this.positionScreen.x + vecX * flare.distance;\r\n\t\t\tflare.y = this.positionScreen.y + vecY * flare.distance;\r\n\t\r\n\t\t\tflare.wantedRotation = flare.x * Math.PI * 0.25;\r\n\t\t\tflare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.LensFlare.prototype.copy = function ( source ) {\r\n\t\r\n\t\tTHREE.Object3D.prototype.copy.call( this, source );\r\n\t\r\n\t\tthis.positionScreen.copy( source.positionScreen );\r\n\t\tthis.customUpdateCallback = source.customUpdateCallback;\r\n\t\r\n\t\tfor ( var i = 0, l = source.lensFlares.length; i < l; i ++ ) {\r\n\t\r\n\t\t\tthis.lensFlares.push( source.lensFlares[ i ] );\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn this;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/scenes/Scene.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.Scene = function () {\r\n\t\r\n\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\tthis.type = 'Scene';\r\n\t\r\n\t\tthis.fog = null;\r\n\t\tthis.overrideMaterial = null;\r\n\t\r\n\t\tthis.autoUpdate = true; // checked by the renderer\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Scene.prototype = Object.create( THREE.Object3D.prototype );\r\n\tTHREE.Scene.prototype.constructor = THREE.Scene;\r\n\t\r\n\tTHREE.Scene.prototype.copy = function ( source, recursive ) {\r\n\t\r\n\t\tTHREE.Object3D.prototype.copy.call( this, source, recursive );\r\n\t\r\n\t\tif ( source.fog !== null ) this.fog = source.fog.clone();\r\n\t\tif ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();\r\n\t\r\n\t\tthis.autoUpdate = source.autoUpdate;\r\n\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\r\n\t\r\n\t\treturn this;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/scenes/Fog.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.Fog = function ( color, near, far ) {\r\n\t\r\n\t\tthis.name = '';\r\n\t\r\n\t\tthis.color = new THREE.Color( color );\r\n\t\r\n\t\tthis.near = ( near !== undefined ) ? near : 1;\r\n\t\tthis.far = ( far !== undefined ) ? far : 1000;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Fog.prototype.clone = function () {\r\n\t\r\n\t\treturn new THREE.Fog( this.color.getHex(), this.near, this.far );\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/scenes/FogExp2.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.FogExp2 = function ( color, density ) {\r\n\t\r\n\t\tthis.name = '';\r\n\t\r\n\t\tthis.color = new THREE.Color( color );\r\n\t\tthis.density = ( density !== undefined ) ? density : 0.00025;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.FogExp2.prototype.clone = function () {\r\n\t\r\n\t\treturn new THREE.FogExp2( this.color.getHex(), this.density );\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk.js\r\n\t\r\n\tTHREE.ShaderChunk = {};\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/alphamap_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'alphamap_fragment' ] = \"#ifdef USE_ALPHAMAP\\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/alphamap_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'alphamap_pars_fragment' ] = \"#ifdef USE_ALPHAMAP\\n\tuniform sampler2D alphaMap;\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/alphatest_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'alphatest_fragment' ] = \"#ifdef ALPHATEST\\n\tif ( diffuseColor.a < ALPHATEST ) discard;\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/aomap_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'aomap_fragment' ] = \"#ifdef USE_AOMAP\\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\\n\t#endif\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/aomap_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'aomap_pars_fragment' ] = \"#ifdef USE_AOMAP\\n\tuniform sampler2D aoMap;\\n\tuniform float aoMapIntensity;\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/begin_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'begin_vertex' ] = \"\\nvec3 transformed = vec3( position );\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/beginnormal_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'beginnormal_vertex' ] = \"\\nvec3 objectNormal = vec3( normal );\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/bsdfs.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'bsdfs' ] = \"bool testLightInRange( const in float lightDistance, const in float cutoffDistance ) {\\n\treturn any( bvec2( cutoffDistance == 0.0, lightDistance < cutoffDistance ) );\\n}\\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\\n\t\tif( decayExponent > 0.0 ) {\\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\\n\t\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\\n\t\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\\n\t\t\treturn distanceFalloff * maxDistanceCutoffFactor;\\n#else\\n\t\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\\n#endif\\n\t\t}\\n\t\treturn 1.0;\\n}\\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\\n\treturn RECIPROCAL_PI * diffuseColor;\\n}\\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\\n}\\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\tfloat a2 = pow2( alpha );\\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\treturn 1.0 / ( gl * gv );\\n}\\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\tfloat a2 = pow2( alpha );\\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\treturn 0.5 / max( gv + gl, EPSILON );\\n}\\nfloat D_GGX( const in float alpha, const in float dotNH ) {\\n\tfloat a2 = pow2( alpha );\\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\\n}\\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\\n\tfloat alpha = pow2( roughness );\\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n\tvec3 F = F_Schlick( specularColor, dotLH );\\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\\n\tfloat D = D_GGX( alpha, dotNH );\\n\treturn F * ( G * D );\\n}\\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\\n\tvec4 r = roughness * c0 + c1;\\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\\n\treturn specularColor * AB.x + AB.y;\\n}\\nfloat G_BlinnPhong_Implicit( ) {\\n\treturn 0.25;\\n}\\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\\n}\\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n\tvec3 F = F_Schlick( specularColor, dotLH );\\n\tfloat G = G_BlinnPhong_Implicit( );\\n\tfloat D = D_BlinnPhong( shininess, dotNH );\\n\treturn F * ( G * D );\\n}\\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\\n}\\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/bumpmap_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'bumpmap_pars_fragment' ] = \"#ifdef USE_BUMPMAP\\n\tuniform sampler2D bumpMap;\\n\tuniform float bumpScale;\\n\tvec2 dHdxy_fwd() {\\n\t\tvec2 dSTdx = dFdx( vUv );\\n\t\tvec2 dSTdy = dFdy( vUv );\\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\\n\t\treturn vec2( dBx, dBy );\\n\t}\\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\\n\t\tvec3 vSigmaX = dFdx( surf_pos );\\n\t\tvec3 vSigmaY = dFdy( surf_pos );\\n\t\tvec3 vN = surf_norm;\\n\t\tvec3 R1 = cross( vSigmaY, vN );\\n\t\tvec3 R2 = cross( vN, vSigmaX );\\n\t\tfloat fDet = dot( vSigmaX, R1 );\\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\\n\t}\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/clipping_planes_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'clipping_planes_fragment' ] = \"#if NUM_CLIPPING_PLANES > 0\\n\tfor ( int i = 0; i < NUM_CLIPPING_PLANES; ++ i ) {\\n\t\tvec4 plane = clippingPlanes[ i ];\\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\\n\t}\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/clipping_planes_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'clipping_planes_pars_fragment' ] = \"#if NUM_CLIPPING_PLANES > 0\\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\\n\t\tvarying vec3 vViewPosition;\\n\t#endif\\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/clipping_planes_pars_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'clipping_planes_pars_vertex' ] = \"#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\\n\tvarying vec3 vViewPosition;\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/clipping_planes_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'clipping_planes_vertex' ] = \"#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\\n\tvViewPosition = - mvPosition.xyz;\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/color_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'color_fragment' ] = \"#ifdef USE_COLOR\\n\tdiffuseColor.rgb *= vColor;\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/color_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'color_pars_fragment' ] = \"#ifdef USE_COLOR\\n\tvarying vec3 vColor;\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/color_pars_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'color_pars_vertex' ] = \"#ifdef USE_COLOR\\n\tvarying vec3 vColor;\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/color_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'color_vertex' ] = \"#ifdef USE_COLOR\\n\tvColor.xyz = color.xyz;\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/common.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'common' ] = \"#define PI 3.14159265359\\n#define PI2 6.28318530718\\n#define RECIPROCAL_PI 0.31830988618\\n#define RECIPROCAL_PI2 0.15915494\\n#define LOG2 1.442695\\n#define EPSILON 1e-6\\n#define saturate(a) clamp( a, 0.0, 1.0 )\\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\\nfloat pow2( const in float x ) { return x*x; }\\nfloat pow3( const in float x ) { return x*x*x; }\\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\\nhighp float rand( const in vec2 uv ) {\\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\\n\treturn fract(sin(sn) * c);\\n}\\nstruct IncidentLight {\\n\tvec3 color;\\n\tvec3 direction;\\n\tbool visible;\\n};\\nstruct ReflectedLight {\\n\tvec3 directDiffuse;\\n\tvec3 directSpecular;\\n\tvec3 indirectDiffuse;\\n\tvec3 indirectSpecular;\\n};\\nstruct GeometricContext {\\n\tvec3 position;\\n\tvec3 normal;\\n\tvec3 viewDir;\\n};\\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\\n}\\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\\n}\\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\\n\treturn - distance * planeNormal + point;\\n}\\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\\n}\\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/cube_uv_reflection_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'cube_uv_reflection_fragment' ] = \"#ifdef ENVMAP_TYPE_CUBE_UV\\nconst float cubeUV_textureSize = 1024.0;\\nint getFaceFromDirection(vec3 direction) {\\n\tvec3 absDirection = abs(direction);\\n\tint face = -1;\\n\tif( absDirection.x > absDirection.z ) {\\n\t\tif(absDirection.x > absDirection.y )\\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\\n\t\telse\\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\\n\t}\\n\telse {\\n\t\tif(absDirection.z > absDirection.y )\\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\\n\t\telse\\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\\n\t}\\n\treturn face;\\n}\\nfloat cubeUV_maxLods1 = log2(cubeUV_textureSize*0.25) - 1.0;\\nfloat cubeUV_rangeClamp = exp2((6.0 - 1.0) * 2.0);\\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\\n\tfloat dxRoughness = dFdx(roughness);\\n\tfloat dyRoughness = dFdy(roughness);\\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\\n\tfloat mipLevel = 0.5 * log2(d);\\n\treturn vec2(floor(mipLevel), fract(mipLevel));\\n}\\nfloat cubeUV_maxLods2 = log2(cubeUV_textureSize*0.25) - 2.0;\\nconst float cubeUV_rcpTextureSize = 1.0 / cubeUV_textureSize;\\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\\n\tbool bRes = mipLevel == 0.0;\\n\tscale =  bRes && (scale < a) ? a : scale;\\n\tvec3 r;\\n\tvec2 offset;\\n\tint face = getFaceFromDirection(direction);\\n\tfloat rcpPowScale = 1.0 / powScale;\\n\tif( face == 0) {\\n\t\tr = vec3(direction.x, -direction.z, direction.y);\\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\\n\t}\\n\telse if( face == 1) {\\n\t\tr = vec3(direction.y, direction.x, direction.z);\\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\\n\t}\\n\telse if( face == 2) {\\n\t\tr = vec3(direction.z, direction.x, direction.y);\\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\\n\t}\\n\telse if( face == 3) {\\n\t\tr = vec3(direction.x, direction.z, direction.y);\\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\\n\t}\\n\telse if( face == 4) {\\n\t\tr = vec3(direction.y, direction.x, -direction.z);\\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\\n\t}\\n\telse {\\n\t\tr = vec3(direction.z, -direction.x, direction.y);\\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\\n\t}\\n\tr = normalize(r);\\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\\n\tvec2 base = offset + vec2( texelOffset );\\n\treturn base + s * ( scale - 2.0 * texelOffset );\\n}\\nfloat cubeUV_maxLods3 = log2(cubeUV_textureSize*0.25) - 3.0;\\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\\n\tfloat r1 = floor(roughnessVal);\\n\tfloat r2 = r1 + 1.0;\\n\tfloat t = fract(roughnessVal);\\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\\n\tfloat s = mipInfo.y;\\n\tfloat level0 = mipInfo.x;\\n\tfloat level1 = level0 + 1.0;\\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\\n\tvec4 result = mix(color10, color20, t);\\n\treturn vec4(result.rgb, 1.0);\\n}\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/defaultnormal_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'defaultnormal_vertex' ] = \"#ifdef FLIP_SIDED\\n\tobjectNormal = -objectNormal;\\n#endif\\nvec3 transformedNormal = normalMatrix * objectNormal;\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/displacementmap_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'displacementmap_vertex' ] = \"#ifdef USE_DISPLACEMENTMAP\\n\ttransformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/displacementmap_pars_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'displacementmap_pars_vertex' ] = \"#ifdef USE_DISPLACEMENTMAP\\n\tuniform sampler2D displacementMap;\\n\tuniform float displacementScale;\\n\tuniform float displacementBias;\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/emissivemap_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'emissivemap_fragment' ] = \"#ifdef USE_EMISSIVEMAP\\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/emissivemap_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'emissivemap_pars_fragment' ] = \"#ifdef USE_EMISSIVEMAP\\n\tuniform sampler2D emissiveMap;\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/encodings_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'encodings_pars_fragment' ] = \"\\nvec4 LinearToLinear( in vec4 value ) {\\n  return value;\\n}\\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\\n  return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\\n}\\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\\n  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\\n}\\nvec4 sRGBToLinear( in vec4 value ) {\\n  return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\\n}\\nvec4 LinearTosRGB( in vec4 value ) {\\n  return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\\n}\\nvec4 RGBEToLinear( in vec4 value ) {\\n  return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\\n}\\nvec4 LinearToRGBE( in vec4 value ) {\\n  float maxComponent = max( max( value.r, value.g ), value.b );\\n  float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\\n  return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\\n}\\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\\n  return vec4( value.xyz * value.w * maxRange, 1.0 );\\n}\\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\\n  float maxRGB = max( value.x, max( value.g, value.b ) );\\n  float M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\\n  M            = ceil( M * 255.0 ) / 255.0;\\n  return vec4( value.rgb / ( M * maxRange ), M );\\n}\\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\\n    return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\\n}\\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\\n    float maxRGB = max( value.x, max( value.g, value.b ) );\\n    float D      = max( maxRange / maxRGB, 1.0 );\\n    D            = min( floor( D ) / 255.0, 1.0 );\\n    return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\\n}\\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\\nvec4 LinearToLogLuv( in vec4 value )  {\\n  vec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\\n  Xp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\\n  vec4 vResult;\\n  vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\\n  float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\\n  vResult.w = fract(Le);\\n  vResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\\n  return vResult;\\n}\\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\\nvec4 LogLuvToLinear( in vec4 value ) {\\n  float Le = value.z * 255.0 + value.w;\\n  vec3 Xp_Y_XYZp;\\n  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\\n  Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\\n  Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\\n  vec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\\n  return vec4( max(vRGB, 0.0), 1.0 );\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/encodings_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'encodings_fragment' ] = \"  gl_FragColor = linearToOutputTexel( gl_FragColor );\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/envmap_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'envmap_fragment' ] = \"#ifdef USE_ENVMAP\\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\\n\t\t#ifdef ENVMAP_MODE_REFLECTION\\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\\n\t\t#else\\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\\n\t\t#endif\\n\t#else\\n\t\tvec3 reflectVec = vReflect;\\n\t#endif\\n\t#ifdef DOUBLE_SIDED\\n\t\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\n\t#else\\n\t\tfloat flipNormal = 1.0;\\n\t#endif\\n\t#ifdef ENVMAP_TYPE_CUBE\\n\t\tvec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\\n\t\tvec2 sampleUV;\\n\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\\n\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\\n\t#elif defined( ENVMAP_TYPE_SPHERE )\\n\t\tvec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\\n\t#endif\\n\tenvColor = envMapTexelToLinear( envColor );\\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\\n\t#elif defined( ENVMAP_BLENDING_MIX )\\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\\n\t#elif defined( ENVMAP_BLENDING_ADD )\\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\\n\t#endif\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/envmap_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'envmap_pars_fragment' ] = \"#if defined( USE_ENVMAP ) || defined( PHYSICAL )\\n\tuniform float reflectivity;\\n\tuniform float envMapIntenstiy;\\n#endif\\n#ifdef USE_ENVMAP\\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\\n\t\tvarying vec3 vWorldPosition;\\n\t#endif\\n\t#ifdef ENVMAP_TYPE_CUBE\\n\t\tuniform samplerCube envMap;\\n\t#else\\n\t\tuniform sampler2D envMap;\\n\t#endif\\n\tuniform float flipEnvMap;\\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\\n\t\tuniform float refractionRatio;\\n\t#else\\n\t\tvarying vec3 vReflect;\\n\t#endif\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/envmap_pars_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'envmap_pars_vertex' ] = \"#ifdef USE_ENVMAP\\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\t\tvarying vec3 vWorldPosition;\\n\t#else\\n\t\tvarying vec3 vReflect;\\n\t\tuniform float refractionRatio;\\n\t#endif\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/envmap_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'envmap_vertex' ] = \"#ifdef USE_ENVMAP\\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\t\tvWorldPosition = worldPosition.xyz;\\n\t#else\\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\\n\t\t#ifdef ENVMAP_MODE_REFLECTION\\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\\n\t\t#else\\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\\n\t\t#endif\\n\t#endif\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/fog_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'fog_fragment' ] = \"#ifdef USE_FOG\\n\t#ifdef USE_LOGDEPTHBUF_EXT\\n\t\tfloat depth = gl_FragDepthEXT / gl_FragCoord.w;\\n\t#else\\n\t\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\\n\t#endif\\n\t#ifdef FOG_EXP2\\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );\\n\t#else\\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, depth );\\n\t#endif\\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/fog_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'fog_pars_fragment' ] = \"#ifdef USE_FOG\\n\tuniform vec3 fogColor;\\n\t#ifdef FOG_EXP2\\n\t\tuniform float fogDensity;\\n\t#else\\n\t\tuniform float fogNear;\\n\t\tuniform float fogFar;\\n\t#endif\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/lightmap_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'lightmap_fragment' ] = \"#ifdef USE_LIGHTMAP\\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/lightmap_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'lightmap_pars_fragment' ] = \"#ifdef USE_LIGHTMAP\\n\tuniform sampler2D lightMap;\\n\tuniform float lightMapIntensity;\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/lights_lambert_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'lights_lambert_vertex' ] = \"vec3 diffuse = vec3( 1.0 );\\nGeometricContext geometry;\\ngeometry.position = mvPosition.xyz;\\ngeometry.normal = normalize( transformedNormal );\\ngeometry.viewDir = normalize( -mvPosition.xyz );\\nGeometricContext backGeometry;\\nbackGeometry.position = geometry.position;\\nbackGeometry.normal = -geometry.normal;\\nbackGeometry.viewDir = geometry.viewDir;\\nvLightFront = vec3( 0.0 );\\n#ifdef DOUBLE_SIDED\\n\tvLightBack = vec3( 0.0 );\\n#endif\\nIncidentLight directLight;\\nfloat dotNL;\\nvec3 directLightColor_Diffuse;\\n#if NUM_POINT_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\\n\t\tdotNL = dot( geometry.normal, directLight.direction );\\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\t\t#ifdef DOUBLE_SIDED\\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\t\t#endif\\n\t}\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\\n\t\tdotNL = dot( geometry.normal, directLight.direction );\\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\t\t#ifdef DOUBLE_SIDED\\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\t\t#endif\\n\t}\\n#endif\\n#if NUM_DIR_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\\n\t\tdotNL = dot( geometry.normal, directLight.direction );\\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\t\t#ifdef DOUBLE_SIDED\\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\t\t#endif\\n\t}\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n\t\t#ifdef DOUBLE_SIDED\\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\\n\t\t#endif\\n\t}\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/lights_pars.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'lights_pars' ] = \"uniform vec3 ambientLightColor;\\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\\n\tvec3 irradiance = ambientLightColor;\\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\t\tirradiance *= PI;\\n\t#endif\\n\treturn irradiance;\\n}\\n#if NUM_DIR_LIGHTS > 0\\n\tstruct DirectionalLight {\\n\t\tvec3 direction;\\n\t\tvec3 color;\\n\t\tint shadow;\\n\t\tfloat shadowBias;\\n\t\tfloat shadowRadius;\\n\t\tvec2 shadowMapSize;\\n\t};\\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\t\tdirectLight.color = directionalLight.color;\\n\t\tdirectLight.direction = directionalLight.direction;\\n\t\tdirectLight.visible = true;\\n\t}\\n#endif\\n#if NUM_POINT_LIGHTS > 0\\n\tstruct PointLight {\\n\t\tvec3 position;\\n\t\tvec3 color;\\n\t\tfloat distance;\\n\t\tfloat decay;\\n\t\tint shadow;\\n\t\tfloat shadowBias;\\n\t\tfloat shadowRadius;\\n\t\tvec2 shadowMapSize;\\n\t};\\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\t\tvec3 lVector = pointLight.position - geometry.position;\\n\t\tdirectLight.direction = normalize( lVector );\\n\t\tfloat lightDistance = length( lVector );\\n\t\tif ( testLightInRange( lightDistance, pointLight.distance ) ) {\\n\t\t\tdirectLight.color = pointLight.color;\\n\t\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\\n\t\t\tdirectLight.visible = true;\\n\t\t} else {\\n\t\t\tdirectLight.color = vec3( 0.0 );\\n\t\t\tdirectLight.visible = false;\\n\t\t}\\n\t}\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\tstruct SpotLight {\\n\t\tvec3 position;\\n\t\tvec3 direction;\\n\t\tvec3 color;\\n\t\tfloat distance;\\n\t\tfloat decay;\\n\t\tfloat coneCos;\\n\t\tfloat penumbraCos;\\n\t\tint shadow;\\n\t\tfloat shadowBias;\\n\t\tfloat shadowRadius;\\n\t\tvec2 shadowMapSize;\\n\t};\\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\\n\t\tvec3 lVector = spotLight.position - geometry.position;\\n\t\tdirectLight.direction = normalize( lVector );\\n\t\tfloat lightDistance = length( lVector );\\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\\n\t\tif ( all( bvec2( angleCos > spotLight.coneCos, testLightInRange( lightDistance, spotLight.distance ) ) ) ) {\\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\\n\t\t\tdirectLight.color = spotLight.color;\\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\\n\t\t\tdirectLight.visible = true;\\n\t\t} else {\\n\t\t\tdirectLight.color = vec3( 0.0 );\\n\t\t\tdirectLight.visible = false;\\n\t\t}\\n\t}\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\tstruct HemisphereLight {\\n\t\tvec3 direction;\\n\t\tvec3 skyColor;\\n\t\tvec3 groundColor;\\n\t};\\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\t\t\tirradiance *= PI;\\n\t\t#endif\\n\t\treturn irradiance;\\n\t}\\n#endif\\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\\n\t\t#ifdef DOUBLE_SIDED\\n\t\t\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\n\t\t#else\\n\t\t\tfloat flipNormal = 1.0;\\n\t\t#endif\\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\\n\t\t#ifdef ENVMAP_TYPE_CUBE\\n\t\t\tvec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\\n\t\t\t#ifdef TEXTURE_LOD_EXT\\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\\n\t\t\t#else\\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\\n\t\t\t#endif\\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\t\t\tvec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\\n\t\t#else\\n\t\t\tvec4 envMapColor = vec4( 0.0 );\\n\t\t#endif\\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\\n\t}\\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\\n\t}\\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\\n\t\t#ifdef ENVMAP_MODE_REFLECTION\\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\\n\t\t#else\\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\\n\t\t#endif\\n\t\t#ifdef DOUBLE_SIDED\\n\t\t\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\n\t\t#else\\n\t\t\tfloat flipNormal = 1.0;\\n\t\t#endif\\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\\n\t\t#ifdef ENVMAP_TYPE_CUBE\\n\t\t\tvec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\\n\t\t\t#ifdef TEXTURE_LOD_EXT\\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\\n\t\t\t#else\\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\\n\t\t\t#endif\\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\t\t\tvec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\\n\t\t\tvec2 sampleUV;\\n\t\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\\n\t\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\\n\t\t\t#ifdef TEXTURE_LOD_EXT\\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\\n\t\t\t#else\\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\\n\t\t\t#endif\\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\\n\t\t\tvec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\\n\t\t\t#ifdef TEXTURE_LOD_EXT\\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\\n\t\t\t#else\\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\\n\t\t\t#endif\\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\t\t#endif\\n\t\treturn envMapColor.rgb * envMapIntensity;\\n\t}\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/lights_phong_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'lights_phong_fragment' ] = \"BlinnPhongMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb;\\nmaterial.specularColor = specular;\\nmaterial.specularShininess = shininess;\\nmaterial.specularStrength = specularStrength;\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'lights_phong_pars_fragment' ] = \"varying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\tvarying vec3 vNormal;\\n#endif\\nstruct BlinnPhongMaterial {\\n\tvec3\tdiffuseColor;\\n\tvec3\tspecularColor;\\n\tfloat\tspecularShininess;\\n\tfloat\tspecularStrength;\\n};\\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\tvec3 irradiance = dotNL * directLight.color;\\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\t\tirradiance *= PI;\\n\t#endif\\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\\n}\\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\\n#define Material_LightProbeLOD( material )\t(0)\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/lights_physical_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'lights_physical_fragment' ] = \"PhysicalMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\\n#ifdef STANDARD\\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\\n#else\\n\tmaterial.specularColor = mix( vec3( 0.16 * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/lights_physical_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'lights_physical_pars_fragment' ] = \"struct PhysicalMaterial {\\n\tvec3\tdiffuseColor;\\n\tfloat\tspecularRoughness;\\n\tvec3\tspecularColor;\\n\t#ifndef STANDARD\\n\t#endif\\n};\\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\tvec3 irradiance = dotNL * directLight.color;\\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\t\tirradiance *= PI;\\n\t#endif\\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\\n}\\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\treflectedLight.indirectSpecular += radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\\n}\\n#define RE_Direct\t\t\t\tRE_Direct_Physical\\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/lights_template.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'lights_template' ] = \"\\nGeometricContext geometry;\\ngeometry.position = - vViewPosition;\\ngeometry.normal = normal;\\ngeometry.viewDir = normalize( vViewPosition );\\nIncidentLight directLight;\\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\\n\tPointLight pointLight;\\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\t\tpointLight = pointLights[ i ];\\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\\n\t\t#ifdef USE_SHADOWMAP\\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\\n\t\t#endif\\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\t}\\n#endif\\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\\n\tSpotLight spotLight;\\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\t\tspotLight = spotLights[ i ];\\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\\n\t\t#ifdef USE_SHADOWMAP\\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\t\t#endif\\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\t}\\n#endif\\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\\n\tDirectionalLight directionalLight;\\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\t\tdirectionalLight = directionalLights[ i ];\\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\\n\t\t#ifdef USE_SHADOWMAP\\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\t\t#endif\\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\t}\\n#endif\\n#if defined( RE_IndirectDiffuse )\\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\\n\t#ifdef USE_LIGHTMAP\\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\t\t\tlightMapIrradiance *= PI;\\n\t\t#endif\\n\t\tirradiance += lightMapIrradiance;\\n\t#endif\\n\t#if ( NUM_HEMI_LIGHTS > 0 )\\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n\t\t}\\n\t#endif\\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\\n\t \tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\\n\t#endif\\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\\n#endif\\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\\n\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\\n\tRE_IndirectSpecular( radiance, geometry, material, reflectedLight );\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/logdepthbuf_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'logdepthbuf_fragment' ] = \"#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\\n\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'logdepthbuf_pars_fragment' ] = \"#ifdef USE_LOGDEPTHBUF\\n\tuniform float logDepthBufFC;\\n\t#ifdef USE_LOGDEPTHBUF_EXT\\n\t\tvarying float vFragDepth;\\n\t#endif\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'logdepthbuf_pars_vertex' ] = \"#ifdef USE_LOGDEPTHBUF\\n\t#ifdef USE_LOGDEPTHBUF_EXT\\n\t\tvarying float vFragDepth;\\n\t#endif\\n\tuniform float logDepthBufFC;\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/logdepthbuf_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'logdepthbuf_vertex' ] = \"#ifdef USE_LOGDEPTHBUF\\n\tgl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\\n\t#ifdef USE_LOGDEPTHBUF_EXT\\n\t\tvFragDepth = 1.0 + gl_Position.w;\\n\t#else\\n\t\tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\\n\t#endif\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/map_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'map_fragment' ] = \"#ifdef USE_MAP\\n\tvec4 texelColor = texture2D( map, vUv );\\n\ttexelColor = mapTexelToLinear( texelColor );\\n\tdiffuseColor *= texelColor;\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/map_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'map_pars_fragment' ] = \"#ifdef USE_MAP\\n\tuniform sampler2D map;\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/map_particle_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'map_particle_fragment' ] = \"#ifdef USE_MAP\\n\tvec4 mapTexel = texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/map_particle_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'map_particle_pars_fragment' ] = \"#ifdef USE_MAP\\n\tuniform vec4 offsetRepeat;\\n\tuniform sampler2D map;\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/metalnessmap_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'metalnessmap_fragment' ] = \"float metalnessFactor = metalness;\\n#ifdef USE_METALNESSMAP\\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\\n\tmetalnessFactor *= texelMetalness.r;\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/metalnessmap_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'metalnessmap_pars_fragment' ] = \"#ifdef USE_METALNESSMAP\\n\tuniform sampler2D metalnessMap;\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/morphnormal_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'morphnormal_vertex' ] = \"#ifdef USE_MORPHNORMALS\\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/morphtarget_pars_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'morphtarget_pars_vertex' ] = \"#ifdef USE_MORPHTARGETS\\n\t#ifndef USE_MORPHNORMALS\\n\tuniform float morphTargetInfluences[ 8 ];\\n\t#else\\n\tuniform float morphTargetInfluences[ 4 ];\\n\t#endif\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/morphtarget_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'morphtarget_vertex' ] = \"#ifdef USE_MORPHTARGETS\\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\\n\t#ifndef USE_MORPHNORMALS\\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\\n\t#endif\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/normal_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'normal_fragment' ] = \"#ifdef FLAT_SHADED\\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\\n\tvec3 normal = normalize( cross( fdx, fdy ) );\\n#else\\n\tvec3 normal = normalize( vNormal );\\n\t#ifdef DOUBLE_SIDED\\n\t\tnormal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\\n\t#endif\\n#endif\\n#ifdef USE_NORMALMAP\\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\\n#elif defined( USE_BUMPMAP )\\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/normalmap_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'normalmap_pars_fragment' ] = \"#ifdef USE_NORMALMAP\\n\tuniform sampler2D normalMap;\\n\tuniform vec2 normalScale;\\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\\n\t\tvec2 st0 = dFdx( vUv.st );\\n\t\tvec2 st1 = dFdy( vUv.st );\\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\\n\t\tvec3 N = normalize( surf_norm );\\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\\n\t\tmapN.xy = normalScale * mapN.xy;\\n\t\tmat3 tsn = mat3( S, T, N );\\n\t\treturn normalize( tsn * mapN );\\n\t}\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/packing.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'packing' ] = \"vec3 packNormalToRGB( const in vec3 normal ) {\\n  return normalize( normal ) * 0.5 + 0.5;\\n}\\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\\n  return 1.0 - 2.0 * rgb.xyz;\\n}\\nvec4 packDepthToRGBA( const in float value ) {\\n\tconst vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );\\n\tconst vec4 bit_mask = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );\\n\tvec4 res = mod( value * bit_shift * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );\\n\tres -= res.xxyz * bit_mask;\\n\treturn res;\\n}\\nfloat unpackRGBAToDepth( const in vec4 rgba ) {\\n\tconst vec4 bitSh = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\\n\treturn dot( rgba, bitSh );\\n}\\nfloat viewZToOrthoDepth( const in float viewZ, const in float near, const in float far ) {\\n  return ( viewZ + near ) / ( near - far );\\n}\\nfloat OrthoDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\\n  return linearClipZ * ( near - far ) - near;\\n}\\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\\n  return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\\n}\\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\\n  return ( near * far ) / ( ( far - near ) * invClipZ - far );\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/premultiplied_alpha_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'premultiplied_alpha_fragment' ] = \"#ifdef PREMULTIPLIED_ALPHA\\n\tgl_FragColor.rgb *= gl_FragColor.a;\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/project_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'project_vertex' ] = \"#ifdef USE_SKINNING\\n\tvec4 mvPosition = modelViewMatrix * skinned;\\n#else\\n\tvec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\\n#endif\\ngl_Position = projectionMatrix * mvPosition;\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/roughnessmap_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'roughnessmap_fragment' ] = \"float roughnessFactor = roughness;\\n#ifdef USE_ROUGHNESSMAP\\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\\n\troughnessFactor *= texelRoughness.r;\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/roughnessmap_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'roughnessmap_pars_fragment' ] = \"#ifdef USE_ROUGHNESSMAP\\n\tuniform sampler2D roughnessMap;\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'shadowmap_pars_fragment' ] = \"#ifdef USE_SHADOWMAP\\n\t#if NUM_DIR_LIGHTS > 0\\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\\n\t#endif\\n\t#if NUM_SPOT_LIGHTS > 0\\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\\n\t#endif\\n\t#if NUM_POINT_LIGHTS > 0\\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\\n\t#endif\\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\\n\t}\\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\\n\t\tvec2 f = fract( uv * size + 0.5 );\\n\t\tfloat a = mix( lb, lt, f.y );\\n\t\tfloat b = mix( rb, rt, f.y );\\n\t\tfloat c = mix( a, b, f.x );\\n\t\treturn c;\\n\t}\\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\\n\t\tshadowCoord.xyz /= shadowCoord.w;\\n\t\tshadowCoord.z += shadowBias;\\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\\n\t\tbool inFrustum = all( inFrustumVec );\\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\\n\t\tbool frustumTest = all( frustumTestVec );\\n\t\tif ( frustumTest ) {\\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\\n\t\t\treturn (\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\n\t\t\t) * ( 1.0 / 9.0 );\\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\\n\t\t\treturn (\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\n\t\t\t) * ( 1.0 / 9.0 );\\n\t\t#else\\n\t\t\treturn texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\\n\t\t#endif\\n\t\t}\\n\t\treturn 1.0;\\n\t}\\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\\n\t\tvec3 absV = abs( v );\\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\\n\t\tabsV *= scaleToCube;\\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\\n\t\tvec2 planar = v.xy;\\n\t\tfloat almostATexel = 1.5 * texelSizeY;\\n\t\tfloat almostOne = 1.0 - almostATexel;\\n\t\tif ( absV.z >= almostOne ) {\\n\t\t\tif ( v.z > 0.0 )\\n\t\t\t\tplanar.x = 4.0 - v.x;\\n\t\t} else if ( absV.x >= almostOne ) {\\n\t\t\tfloat signX = sign( v.x );\\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\\n\t\t} else if ( absV.y >= almostOne ) {\\n\t\t\tfloat signY = sign( v.y );\\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\\n\t\t\tplanar.y = v.z * signY - 2.0;\\n\t\t}\\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\\n\t}\\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\\n\t\tvec3 lightToPosition = shadowCoord.xyz;\\n\t\tvec3 bd3D = normalize( lightToPosition );\\n\t\tfloat dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\\n\t\t\treturn (\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\\n\t\t\t) * ( 1.0 / 9.0 );\\n\t\t#else\\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\\n\t\t#endif\\n\t}\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'shadowmap_pars_vertex' ] = \"#ifdef USE_SHADOWMAP\\n\t#if NUM_DIR_LIGHTS > 0\\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\\n\t#endif\\n\t#if NUM_SPOT_LIGHTS > 0\\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\\n\t#endif\\n\t#if NUM_POINT_LIGHTS > 0\\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\\n\t#endif\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/shadowmap_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'shadowmap_vertex' ] = \"#ifdef USE_SHADOWMAP\\n\t#if NUM_DIR_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\\n\t}\\n\t#endif\\n\t#if NUM_SPOT_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\\n\t}\\n\t#endif\\n\t#if NUM_POINT_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\\n\t}\\n\t#endif\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/shadowmask_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'shadowmask_pars_fragment' ] = \"float getShadowMask() {\\n\tfloat shadow = 1.0;\\n\t#ifdef USE_SHADOWMAP\\n\t#if NUM_DIR_LIGHTS > 0\\n\tDirectionalLight directionalLight;\\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\t\tdirectionalLight = directionalLights[ i ];\\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\t}\\n\t#endif\\n\t#if NUM_SPOT_LIGHTS > 0\\n\tSpotLight spotLight;\\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\t\tspotLight = spotLights[ i ];\\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\t}\\n\t#endif\\n\t#if NUM_POINT_LIGHTS > 0\\n\tPointLight pointLight;\\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\t\tpointLight = pointLights[ i ];\\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\\n\t}\\n\t#endif\\n\t#endif\\n\treturn shadow;\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/skinbase_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'skinbase_vertex' ] = \"#ifdef USE_SKINNING\\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/skinning_pars_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'skinning_pars_vertex' ] = \"#ifdef USE_SKINNING\\n\tuniform mat4 bindMatrix;\\n\tuniform mat4 bindMatrixInverse;\\n\t#ifdef BONE_TEXTURE\\n\t\tuniform sampler2D boneTexture;\\n\t\tuniform int boneTextureWidth;\\n\t\tuniform int boneTextureHeight;\\n\t\tmat4 getBoneMatrix( const in float i ) {\\n\t\t\tfloat j = i * 4.0;\\n\t\t\tfloat x = mod( j, float( boneTextureWidth ) );\\n\t\t\tfloat y = floor( j / float( boneTextureWidth ) );\\n\t\t\tfloat dx = 1.0 / float( boneTextureWidth );\\n\t\t\tfloat dy = 1.0 / float( boneTextureHeight );\\n\t\t\ty = dy * ( y + 0.5 );\\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\\n\t\t\treturn bone;\\n\t\t}\\n\t#else\\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\\n\t\tmat4 getBoneMatrix( const in float i ) {\\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\\n\t\t\treturn bone;\\n\t\t}\\n\t#endif\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/skinning_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'skinning_vertex' ] = \"#ifdef USE_SKINNING\\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\\n\tvec4 skinned = vec4( 0.0 );\\n\tskinned += boneMatX * skinVertex * skinWeight.x;\\n\tskinned += boneMatY * skinVertex * skinWeight.y;\\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\\n\tskinned += boneMatW * skinVertex * skinWeight.w;\\n\tskinned  = bindMatrixInverse * skinned;\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/skinnormal_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'skinnormal_vertex' ] = \"#ifdef USE_SKINNING\\n\tmat4 skinMatrix = mat4( 0.0 );\\n\tskinMatrix += skinWeight.x * boneMatX;\\n\tskinMatrix += skinWeight.y * boneMatY;\\n\tskinMatrix += skinWeight.z * boneMatZ;\\n\tskinMatrix += skinWeight.w * boneMatW;\\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/specularmap_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'specularmap_fragment' ] = \"float specularStrength;\\n#ifdef USE_SPECULARMAP\\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\\n\tspecularStrength = texelSpecular.r;\\n#else\\n\tspecularStrength = 1.0;\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/specularmap_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'specularmap_pars_fragment' ] = \"#ifdef USE_SPECULARMAP\\n\tuniform sampler2D specularMap;\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/tonemapping_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'tonemapping_fragment' ] = \"#if defined( TONE_MAPPING )\\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/tonemapping_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'tonemapping_pars_fragment' ] = \"#define saturate(a) clamp( a, 0.0, 1.0 )\\nuniform float toneMappingExposure;\\nuniform float toneMappingWhitePoint;\\nvec3 LinearToneMapping( vec3 color ) {\\n  return toneMappingExposure * color;\\n}\\nvec3 ReinhardToneMapping( vec3 color ) {\\n  color *= toneMappingExposure;\\n  return saturate( color / ( vec3( 1.0 ) + color ) );\\n}\\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\\nvec3 Uncharted2ToneMapping( vec3 color ) {\\n  color *= toneMappingExposure;\\n  return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\\n}\\nvec3 OptimizedCineonToneMapping( vec3 color ) {\\n  color *= toneMappingExposure;\\n  color = max( vec3( 0.0 ), color - 0.004 );\\n  return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/uv2_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'uv2_pars_fragment' ] = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\tvarying vec2 vUv2;\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/uv2_pars_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'uv2_pars_vertex' ] = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\tattribute vec2 uv2;\\n\tvarying vec2 vUv2;\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/uv2_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'uv2_vertex' ] = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\tvUv2 = uv2;\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/uv_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'uv_pars_fragment' ] = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\tvarying vec2 vUv;\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/uv_pars_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'uv_pars_vertex' ] = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\tvarying vec2 vUv;\\n\tuniform vec4 offsetRepeat;\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/uv_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'uv_vertex' ] = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/worldpos_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'worldpos_vertex' ] = \"#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( PHYSICAL ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\\n\t#ifdef USE_SKINNING\\n\t\tvec4 worldPosition = modelMatrix * skinned;\\n\t#else\\n\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\\n\t#endif\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/UniformsUtils.js\r\n\t\r\n\t/**\r\n\t * Uniform Utilities\r\n\t */\r\n\t\r\n\tTHREE.UniformsUtils = {\r\n\t\r\n\t\tmerge: function ( uniforms ) {\r\n\t\r\n\t\t\tvar merged = {};\r\n\t\r\n\t\t\tfor ( var u = 0; u < uniforms.length; u ++ ) {\r\n\t\r\n\t\t\t\tvar tmp = this.clone( uniforms[ u ] );\r\n\t\r\n\t\t\t\tfor ( var p in tmp ) {\r\n\t\r\n\t\t\t\t\tmerged[ p ] = tmp[ p ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn merged;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function ( uniforms_src ) {\r\n\t\r\n\t\t\tvar uniforms_dst = {};\r\n\t\r\n\t\t\tfor ( var u in uniforms_src ) {\r\n\t\r\n\t\t\t\tuniforms_dst[ u ] = {};\r\n\t\r\n\t\t\t\tfor ( var p in uniforms_src[ u ] ) {\r\n\t\r\n\t\t\t\t\tvar parameter_src = uniforms_src[ u ][ p ];\r\n\t\r\n\t\t\t\t\tif ( parameter_src instanceof THREE.Color ||\r\n\t\t\t\t\t\t parameter_src instanceof THREE.Vector2 ||\r\n\t\t\t\t\t\t parameter_src instanceof THREE.Vector3 ||\r\n\t\t\t\t\t\t parameter_src instanceof THREE.Vector4 ||\r\n\t\t\t\t\t\t parameter_src instanceof THREE.Matrix3 ||\r\n\t\t\t\t\t\t parameter_src instanceof THREE.Matrix4 ||\r\n\t\t\t\t\t\t parameter_src instanceof THREE.Texture ) {\r\n\t\r\n\t\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src.clone();\r\n\t\r\n\t\t\t\t\t} else if ( Array.isArray( parameter_src ) ) {\r\n\t\r\n\t\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src.slice();\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn uniforms_dst;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/renderers/shaders/UniformsLib.js\r\n\t\r\n\t/**\r\n\t * Uniforms library for shared webgl shaders\r\n\t */\r\n\t\r\n\tTHREE.UniformsLib = {\r\n\t\r\n\t\tcommon: {\r\n\t\r\n\t\t\t\"diffuse\": { type: \"c\", value: new THREE.Color( 0xeeeeee ) },\r\n\t\t\t\"opacity\": { type: \"1f\", value: 1.0 },\r\n\t\r\n\t\t\t\"map\": { type: \"t\", value: null },\r\n\t\t\t\"offsetRepeat\": { type: \"v4\", value: new THREE.Vector4( 0, 0, 1, 1 ) },\r\n\t\r\n\t\t\t\"specularMap\": { type: \"t\", value: null },\r\n\t\t\t\"alphaMap\": { type: \"t\", value: null },\r\n\t\r\n\t\t\t\"envMap\": { type: \"t\", value: null },\r\n\t\t\t\"flipEnvMap\": { type: \"1f\", value: - 1 },\r\n\t\t\t\"reflectivity\": { type: \"1f\", value: 1.0 },\r\n\t\t\t\"refractionRatio\": { type: \"1f\", value: 0.98 }\r\n\t\r\n\t\t},\r\n\t\r\n\t\taomap: {\r\n\t\r\n\t\t\t\"aoMap\": { type: \"t\", value: null },\r\n\t\t\t\"aoMapIntensity\": { type: \"1f\", value: 1 }\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlightmap: {\r\n\t\r\n\t\t\t\"lightMap\": { type: \"t\", value: null },\r\n\t\t\t\"lightMapIntensity\": { type: \"1f\", value: 1 }\r\n\t\r\n\t\t},\r\n\t\r\n\t\temissivemap: {\r\n\t\r\n\t\t\t\"emissiveMap\": { type: \"t\", value: null }\r\n\t\r\n\t\t},\r\n\t\r\n\t\tbumpmap: {\r\n\t\r\n\t\t\t\"bumpMap\": { type: \"t\", value: null },\r\n\t\t\t\"bumpScale\": { type: \"1f\", value: 1 }\r\n\t\r\n\t\t},\r\n\t\r\n\t\tnormalmap: {\r\n\t\r\n\t\t\t\"normalMap\": { type: \"t\", value: null },\r\n\t\t\t\"normalScale\": { type: \"v2\", value: new THREE.Vector2( 1, 1 ) }\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdisplacementmap: {\r\n\t\r\n\t\t\t\"displacementMap\": { type: \"t\", value: null },\r\n\t\t\t\"displacementScale\": { type: \"1f\", value: 1 },\r\n\t\t\t\"displacementBias\": { type: \"1f\", value: 0 }\r\n\t\r\n\t\t},\r\n\t\r\n\t\troughnessmap: {\r\n\t\r\n\t\t\t\"roughnessMap\": { type: \"t\", value: null }\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmetalnessmap: {\r\n\t\r\n\t\t\t\"metalnessMap\": { type: \"t\", value: null }\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfog: {\r\n\t\r\n\t\t\t\"fogDensity\": { type: \"1f\", value: 0.00025 },\r\n\t\t\t\"fogNear\": { type: \"1f\", value: 1 },\r\n\t\t\t\"fogFar\": { type: \"1f\", value: 2000 },\r\n\t\t\t\"fogColor\": { type: \"c\", value: new THREE.Color( 0xffffff ) }\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlights: {\r\n\t\r\n\t\t\t\"ambientLightColor\": { type: \"3fv\", value: [] },\r\n\t\r\n\t\t\t\"directionalLights\": { type: \"sa\", value: [], properties: {\r\n\t\t\t\t\"direction\": { type: \"v3\" },\r\n\t\t\t\t\"color\": { type: \"c\" },\r\n\t\r\n\t\t\t\t\"shadow\": { type: \"1i\" },\r\n\t\t\t\t\"shadowBias\": { type: \"1f\" },\r\n\t\t\t\t\"shadowRadius\": { type: \"1f\" },\r\n\t\t\t\t\"shadowMapSize\": { type: \"v2\" }\r\n\t\t\t} },\r\n\t\r\n\t\t\t\"directionalShadowMap\": { type: \"tv\", value: [] },\r\n\t\t\t\"directionalShadowMatrix\": { type: \"m4v\", value: [] },\r\n\t\r\n\t\t\t\"spotLights\": { type: \"sa\", value: [], properties: {\r\n\t\t\t\t\"color\": { type: \"c\" },\r\n\t\t\t\t\"position\": { type: \"v3\" },\r\n\t\t\t\t\"direction\": { type: \"v3\" },\r\n\t\t\t\t\"distance\": { type: \"1f\" },\r\n\t\t\t\t\"coneCos\": { type: \"1f\" },\r\n\t\t\t\t\"penumbraCos\": { type: \"1f\" },\r\n\t\t\t\t\"decay\": { type: \"1f\" },\r\n\t\r\n\t\t\t\t\"shadow\": { type: \"1i\" },\r\n\t\t\t\t\"shadowBias\": { type: \"1f\" },\r\n\t\t\t\t\"shadowRadius\": { type: \"1f\" },\r\n\t\t\t\t\"shadowMapSize\": { type: \"v2\" }\r\n\t\t\t} },\r\n\t\r\n\t\t\t\"spotShadowMap\": { type: \"tv\", value: [] },\r\n\t\t\t\"spotShadowMatrix\": { type: \"m4v\", value: [] },\r\n\t\r\n\t\t\t\"pointLights\": { type: \"sa\", value: [], properties: {\r\n\t\t\t\t\"color\": { type: \"c\" },\r\n\t\t\t\t\"position\": { type: \"v3\" },\r\n\t\t\t\t\"decay\": { type: \"1f\" },\r\n\t\t\t\t\"distance\": { type: \"1f\" },\r\n\t\r\n\t\t\t\t\"shadow\": { type: \"1i\" },\r\n\t\t\t\t\"shadowBias\": { type: \"1f\" },\r\n\t\t\t\t\"shadowRadius\": { type: \"1f\" },\r\n\t\t\t\t\"shadowMapSize\": { type: \"v2\" }\r\n\t\t\t} },\r\n\t\r\n\t\t\t\"pointShadowMap\": { type: \"tv\", value: [] },\r\n\t\t\t\"pointShadowMatrix\": { type: \"m4v\", value: [] },\r\n\t\r\n\t\t\t\"hemisphereLights\": { type: \"sa\", value: [], properties: {\r\n\t\t\t\t\"direction\": { type: \"v3\" },\r\n\t\t\t\t\"skyColor\": { type: \"c\" },\r\n\t\t\t\t\"groundColor\": { type: \"c\" }\r\n\t\t\t} }\r\n\t\r\n\t\t},\r\n\t\r\n\t\tpoints: {\r\n\t\r\n\t\t\t\"diffuse\": { type: \"c\", value: new THREE.Color( 0xeeeeee ) },\r\n\t\t\t\"opacity\": { type: \"1f\", value: 1.0 },\r\n\t\t\t\"size\": { type: \"1f\", value: 1.0 },\r\n\t\t\t\"scale\": { type: \"1f\", value: 1.0 },\r\n\t\t\t\"map\": { type: \"t\", value: null },\r\n\t\t\t\"offsetRepeat\": { type: \"v4\", value: new THREE.Vector4( 0, 0, 1, 1 ) }\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/renderers/shaders/ShaderLib/cube_frag.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'cube_frag' ] = \"uniform samplerCube tCube;\\nuniform float tFlip;\\nvarying vec3 vWorldPosition;\\n#include <common>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\\n\t#include <logdepthbuf_fragment>\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderLib/cube_vert.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'cube_vert' ] = \"varying vec3 vWorldPosition;\\n#include <common>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\tvWorldPosition = transformDirection( position, modelMatrix );\\n\t#include <begin_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderLib/depth_frag.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'depth_frag' ] = \"#if DEPTH_PACKING == 3200\\n\tuniform float opacity;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec4 diffuseColor = vec4( 1.0 );\\n\t#if DEPTH_PACKING == 3200\\n\t\tdiffuseColor.a = opacity;\\n\t#endif\\n\t#include <map_fragment>\\n\t#include <alphamap_fragment>\\n\t#include <alphatest_fragment>\\n\t#include <logdepthbuf_fragment>\\n\t#if DEPTH_PACKING == 3200\\n\t\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\\n\t#elif DEPTH_PACKING == 3201\\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\\n\t#endif\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderLib/depth_vert.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'depth_vert' ] = \"#include <common>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <uv_vertex>\\n\t#include <skinbase_vertex>\\n\t#include <begin_vertex>\\n\t#include <displacementmap_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderLib/distanceRGBA_frag.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'distanceRGBA_frag' ] = \"uniform vec3 lightPos;\\nvarying vec4 vWorldPosition;\\n#include <common>\\n#include <packing>\\n#include <clipping_planes_pars_fragment>\\nvoid main () {\\n\t#include <clipping_planes_fragment>\\n\tgl_FragColor = packDepthToRGBA( length( vWorldPosition.xyz - lightPos.xyz ) / 1000.0 );\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderLib/distanceRGBA_vert.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'distanceRGBA_vert' ] = \"varying vec4 vWorldPosition;\\n#include <common>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <skinbase_vertex>\\n\t#include <begin_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <project_vertex>\\n\t#include <worldpos_vertex>\\n\t#include <clipping_planes_vertex>\\n\tvWorldPosition = worldPosition;\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderLib/equirect_frag.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'equirect_frag' ] = \"uniform sampler2D tEquirect;\\nuniform float tFlip;\\nvarying vec3 vWorldPosition;\\n#include <common>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec3 direction = normalize( vWorldPosition );\\n\tvec2 sampleUV;\\n\tsampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\\n\t#include <logdepthbuf_fragment>\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderLib/equirect_vert.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'equirect_vert' ] = \"varying vec3 vWorldPosition;\\n#include <common>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\tvWorldPosition = transformDirection( position, modelMatrix );\\n\t#include <begin_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderLib/linedashed_frag.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'linedashed_frag' ] = \"uniform vec3 diffuse;\\nuniform float opacity;\\nuniform float dashSize;\\nuniform float totalSize;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\\n\t\tdiscard;\\n\t}\\n\tvec3 outgoingLight = vec3( 0.0 );\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\t#include <logdepthbuf_fragment>\\n\t#include <color_fragment>\\n\toutgoingLight = diffuseColor.rgb;\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderLib/linedashed_vert.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'linedashed_vert' ] = \"uniform float scale;\\nattribute float lineDistance;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <color_vertex>\\n\tvLineDistance = scale * lineDistance;\\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\\n\tgl_Position = projectionMatrix * mvPosition;\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderLib/meshbasic_frag.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'meshbasic_frag' ] = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#ifndef FLAT_SHADED\\n\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\t#include <logdepthbuf_fragment>\\n\t#include <map_fragment>\\n\t#include <color_fragment>\\n\t#include <alphamap_fragment>\\n\t#include <alphatest_fragment>\\n\t#include <specularmap_fragment>\\n\tReflectedLight reflectedLight;\\n\treflectedLight.directDiffuse = vec3( 0.0 );\\n\treflectedLight.directSpecular = vec3( 0.0 );\\n\treflectedLight.indirectDiffuse = diffuseColor.rgb;\\n\treflectedLight.indirectSpecular = vec3( 0.0 );\\n\t#include <aomap_fragment>\\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\\n\t#include <envmap_fragment>\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderLib/meshbasic_vert.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'meshbasic_vert' ] = \"#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <uv_vertex>\\n\t#include <uv2_vertex>\\n\t#include <color_vertex>\\n\t#include <skinbase_vertex>\\n\t#ifdef USE_ENVMAP\\n\t#include <beginnormal_vertex>\\n\t#include <morphnormal_vertex>\\n\t#include <skinnormal_vertex>\\n\t#include <defaultnormal_vertex>\\n\t#endif\\n\t#include <begin_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <worldpos_vertex>\\n\t#include <clipping_planes_vertex>\\n\t#include <envmap_vertex>\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderLib/meshlambert_frag.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'meshlambert_frag' ] = \"uniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float opacity;\\nvarying vec3 vLightFront;\\n#ifdef DOUBLE_SIDED\\n\tvarying vec3 vLightBack;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <fog_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <shadowmask_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\tvec3 totalEmissiveRadiance = emissive;\\n\t#include <logdepthbuf_fragment>\\n\t#include <map_fragment>\\n\t#include <color_fragment>\\n\t#include <alphamap_fragment>\\n\t#include <alphatest_fragment>\\n\t#include <specularmap_fragment>\\n\t#include <emissivemap_fragment>\\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\\n\t#include <lightmap_fragment>\\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\\n\t#ifdef DOUBLE_SIDED\\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\\n\t#else\\n\t\treflectedLight.directDiffuse = vLightFront;\\n\t#endif\\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\\n\t#include <aomap_fragment>\\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\\n\t#include <envmap_fragment>\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderLib/meshlambert_vert.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'meshlambert_vert' ] = \"#define LAMBERT\\nvarying vec3 vLightFront;\\n#ifdef DOUBLE_SIDED\\n\tvarying vec3 vLightBack;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <color_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <uv_vertex>\\n\t#include <uv2_vertex>\\n\t#include <color_vertex>\\n\t#include <beginnormal_vertex>\\n\t#include <morphnormal_vertex>\\n\t#include <skinbase_vertex>\\n\t#include <skinnormal_vertex>\\n\t#include <defaultnormal_vertex>\\n\t#include <begin_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n\t#include <worldpos_vertex>\\n\t#include <envmap_vertex>\\n\t#include <lights_lambert_vertex>\\n\t#include <shadowmap_vertex>\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderLib/meshphong_frag.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'meshphong_frag' ] = \"#define PHONG\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform vec3 specular;\\nuniform float shininess;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <lights_phong_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\tvec3 totalEmissiveRadiance = emissive;\\n\t#include <logdepthbuf_fragment>\\n\t#include <map_fragment>\\n\t#include <color_fragment>\\n\t#include <alphamap_fragment>\\n\t#include <alphatest_fragment>\\n\t#include <specularmap_fragment>\\n\t#include <normal_fragment>\\n\t#include <emissivemap_fragment>\\n\t#include <lights_phong_fragment>\\n\t#include <lights_template>\\n\t#include <aomap_fragment>\\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\t#include <envmap_fragment>\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderLib/meshphong_vert.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'meshphong_vert' ] = \"#define PHONG\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <uv_vertex>\\n\t#include <uv2_vertex>\\n\t#include <color_vertex>\\n\t#include <beginnormal_vertex>\\n\t#include <morphnormal_vertex>\\n\t#include <skinbase_vertex>\\n\t#include <skinnormal_vertex>\\n\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\tvNormal = normalize( transformedNormal );\\n#endif\\n\t#include <begin_vertex>\\n\t#include <displacementmap_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n\tvViewPosition = - mvPosition.xyz;\\n\t#include <worldpos_vertex>\\n\t#include <envmap_vertex>\\n\t#include <shadowmap_vertex>\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderLib/meshphysical_frag.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'meshphysical_frag' ] = \"#define PHYSICAL\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float roughness;\\nuniform float metalness;\\nuniform float opacity;\\nuniform float envMapIntensity;\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <cube_uv_reflection_fragment>\\n#include <lights_pars>\\n#include <lights_physical_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <roughnessmap_pars_fragment>\\n#include <metalnessmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\tvec3 totalEmissiveRadiance = emissive;\\n\t#include <logdepthbuf_fragment>\\n\t#include <map_fragment>\\n\t#include <color_fragment>\\n\t#include <alphamap_fragment>\\n\t#include <alphatest_fragment>\\n\t#include <specularmap_fragment>\\n\t#include <roughnessmap_fragment>\\n\t#include <metalnessmap_fragment>\\n\t#include <normal_fragment>\\n\t#include <emissivemap_fragment>\\n\t#include <lights_physical_fragment>\\n\t#include <lights_template>\\n\t#include <aomap_fragment>\\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderLib/meshphysical_vert.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'meshphysical_vert' ] = \"#define PHYSICAL\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <uv_vertex>\\n\t#include <uv2_vertex>\\n\t#include <color_vertex>\\n\t#include <beginnormal_vertex>\\n\t#include <morphnormal_vertex>\\n\t#include <skinbase_vertex>\\n\t#include <skinnormal_vertex>\\n\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\tvNormal = normalize( transformedNormal );\\n#endif\\n\t#include <begin_vertex>\\n\t#include <displacementmap_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n\tvViewPosition = - mvPosition.xyz;\\n\t#include <worldpos_vertex>\\n\t#include <shadowmap_vertex>\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderLib/normal_frag.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'normal_frag' ] = \"uniform float opacity;\\nvarying vec3 vNormal;\\n#include <common>\\n#include <packing>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tgl_FragColor = vec4( packNormalToRGB( vNormal ), opacity );\\n\t#include <logdepthbuf_fragment>\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderLib/normal_vert.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'normal_vert' ] = \"varying vec3 vNormal;\\n#include <common>\\n#include <morphtarget_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\tvNormal = normalize( normalMatrix * normal );\\n\t#include <begin_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderLib/points_frag.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'points_frag' ] = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#include <common>\\n#include <color_pars_fragment>\\n#include <map_particle_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec3 outgoingLight = vec3( 0.0 );\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\t#include <logdepthbuf_fragment>\\n\t#include <map_particle_fragment>\\n\t#include <color_fragment>\\n\t#include <alphatest_fragment>\\n\toutgoingLight = diffuseColor.rgb;\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderLib/points_vert.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'points_vert' ] = \"uniform float size;\\nuniform float scale;\\n#include <common>\\n#include <color_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <color_vertex>\\n\t#include <begin_vertex>\\n\t#include <project_vertex>\\n\t#ifdef USE_SIZEATTENUATION\\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\\n\t#else\\n\t\tgl_PointSize = size;\\n\t#endif\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n\t#include <worldpos_vertex>\\n\t#include <shadowmap_vertex>\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderLib.js\r\n\t\r\n\t/**\r\n\t * Webgl Shader Library for three.js\r\n\t *\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t */\r\n\t\r\n\t\r\n\tTHREE.ShaderLib = {\r\n\t\r\n\t\t'basic': {\r\n\t\r\n\t\t\tuniforms: THREE.UniformsUtils.merge( [\r\n\t\r\n\t\t\t\tTHREE.UniformsLib[ 'common' ],\r\n\t\t\t\tTHREE.UniformsLib[ 'aomap' ],\r\n\t\t\t\tTHREE.UniformsLib[ 'fog' ]\r\n\t\r\n\t\t\t] ),\r\n\t\r\n\t\t\tvertexShader: THREE.ShaderChunk[ 'meshbasic_vert' ],\r\n\t\t\tfragmentShader: THREE.ShaderChunk[ 'meshbasic_frag' ]\r\n\t\r\n\t\t},\r\n\t\r\n\t\t'lambert': {\r\n\t\r\n\t\t\tuniforms: THREE.UniformsUtils.merge( [\r\n\t\r\n\t\t\t\tTHREE.UniformsLib[ 'common' ],\r\n\t\t\t\tTHREE.UniformsLib[ 'aomap' ],\r\n\t\t\t\tTHREE.UniformsLib[ 'lightmap' ],\r\n\t\t\t\tTHREE.UniformsLib[ 'emissivemap' ],\r\n\t\t\t\tTHREE.UniformsLib[ 'fog' ],\r\n\t\t\t\tTHREE.UniformsLib[ 'lights' ],\r\n\t\r\n\t\t\t\t{\r\n\t\t\t\t\t\"emissive\" : { type: \"c\", value: new THREE.Color( 0x000000 ) }\r\n\t\t\t\t}\r\n\t\r\n\t\t\t] ),\r\n\t\r\n\t\t\tvertexShader: THREE.ShaderChunk[ 'meshlambert_vert' ],\r\n\t\t\tfragmentShader: THREE.ShaderChunk[ 'meshlambert_frag' ]\r\n\t\r\n\t\t},\r\n\t\r\n\t\t'phong': {\r\n\t\r\n\t\t\tuniforms: THREE.UniformsUtils.merge( [\r\n\t\r\n\t\t\t\tTHREE.UniformsLib[ 'common' ],\r\n\t\t\t\tTHREE.UniformsLib[ 'aomap' ],\r\n\t\t\t\tTHREE.UniformsLib[ 'lightmap' ],\r\n\t\t\t\tTHREE.UniformsLib[ 'emissivemap' ],\r\n\t\t\t\tTHREE.UniformsLib[ 'bumpmap' ],\r\n\t\t\t\tTHREE.UniformsLib[ 'normalmap' ],\r\n\t\t\t\tTHREE.UniformsLib[ 'displacementmap' ],\r\n\t\t\t\tTHREE.UniformsLib[ 'fog' ],\r\n\t\t\t\tTHREE.UniformsLib[ 'lights' ],\r\n\t\r\n\t\t\t\t{\r\n\t\t\t\t\t\"emissive\" : { type: \"c\", value: new THREE.Color( 0x000000 ) },\r\n\t\t\t\t\t\"specular\" : { type: \"c\", value: new THREE.Color( 0x111111 ) },\r\n\t\t\t\t\t\"shininess\": { type: \"1f\", value: 30 }\r\n\t\t\t\t}\r\n\t\r\n\t\t\t] ),\r\n\t\r\n\t\t\tvertexShader: THREE.ShaderChunk[ 'meshphong_vert' ],\r\n\t\t\tfragmentShader: THREE.ShaderChunk[ 'meshphong_frag' ]\r\n\t\r\n\t\t},\r\n\t\r\n\t\t'standard': {\r\n\t\r\n\t\t\tuniforms: THREE.UniformsUtils.merge( [\r\n\t\r\n\t\t\t\tTHREE.UniformsLib[ 'common' ],\r\n\t\t\t\tTHREE.UniformsLib[ 'aomap' ],\r\n\t\t\t\tTHREE.UniformsLib[ 'lightmap' ],\r\n\t\t\t\tTHREE.UniformsLib[ 'emissivemap' ],\r\n\t\t\t\tTHREE.UniformsLib[ 'bumpmap' ],\r\n\t\t\t\tTHREE.UniformsLib[ 'normalmap' ],\r\n\t\t\t\tTHREE.UniformsLib[ 'displacementmap' ],\r\n\t\t\t\tTHREE.UniformsLib[ 'roughnessmap' ],\r\n\t\t\t\tTHREE.UniformsLib[ 'metalnessmap' ],\r\n\t\t\t\tTHREE.UniformsLib[ 'fog' ],\r\n\t\t\t\tTHREE.UniformsLib[ 'lights' ],\r\n\t\r\n\t\t\t\t{\r\n\t\t\t\t\t\"emissive\" : { type: \"c\", value: new THREE.Color( 0x000000 ) },\r\n\t\t\t\t\t\"roughness\": { type: \"1f\", value: 0.5 },\r\n\t\t\t\t\t\"metalness\": { type: \"1f\", value: 0 },\r\n\t\t\t\t\t\"envMapIntensity\" : { type: \"1f\", value: 1 } // temporary\r\n\t\t\t\t}\r\n\t\r\n\t\t\t] ),\r\n\t\r\n\t\t\tvertexShader: THREE.ShaderChunk[ 'meshphysical_vert' ],\r\n\t\t\tfragmentShader: THREE.ShaderChunk[ 'meshphysical_frag' ]\r\n\t\r\n\t\t},\r\n\t\r\n\t\t'points': {\r\n\t\r\n\t\t\tuniforms: THREE.UniformsUtils.merge( [\r\n\t\r\n\t\t\t\tTHREE.UniformsLib[ 'points' ],\r\n\t\t\t\tTHREE.UniformsLib[ 'fog' ]\r\n\t\r\n\t\t\t] ),\r\n\t\r\n\t\t\tvertexShader: THREE.ShaderChunk[ 'points_vert' ],\r\n\t\t\tfragmentShader: THREE.ShaderChunk[ 'points_frag' ]\r\n\t\r\n\t\t},\r\n\t\r\n\t\t'dashed': {\r\n\t\r\n\t\t\tuniforms: THREE.UniformsUtils.merge( [\r\n\t\r\n\t\t\t\tTHREE.UniformsLib[ 'common' ],\r\n\t\t\t\tTHREE.UniformsLib[ 'fog' ],\r\n\t\r\n\t\t\t\t{\r\n\t\t\t\t\t\"scale\"    : { type: \"1f\", value: 1 },\r\n\t\t\t\t\t\"dashSize\" : { type: \"1f\", value: 1 },\r\n\t\t\t\t\t\"totalSize\": { type: \"1f\", value: 2 }\r\n\t\t\t\t}\r\n\t\r\n\t\t\t] ),\r\n\t\r\n\t\t\tvertexShader: THREE.ShaderChunk[ 'linedashed_vert' ],\r\n\t\t\tfragmentShader: THREE.ShaderChunk[ 'linedashed_frag' ]\r\n\t\r\n\t\t},\r\n\t\r\n\t\t'depth': {\r\n\t\r\n\t\t\tuniforms: THREE.UniformsUtils.merge( [\r\n\t\r\n\t\t\t\tTHREE.UniformsLib[ 'common' ],\r\n\t\t\t\tTHREE.UniformsLib[ 'displacementmap' ]\r\n\t\r\n\t\t\t] ),\r\n\t\r\n\t\t\tvertexShader: THREE.ShaderChunk[ 'depth_vert' ],\r\n\t\t\tfragmentShader: THREE.ShaderChunk[ 'depth_frag' ]\r\n\t\r\n\t\t},\r\n\t\r\n\t\t'normal': {\r\n\t\r\n\t\t\tuniforms: {\r\n\t\r\n\t\t\t\t\"opacity\" : { type: \"1f\", value: 1.0 }\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t\tvertexShader: THREE.ShaderChunk[ 'normal_vert' ],\r\n\t\t\tfragmentShader: THREE.ShaderChunk[ 'normal_frag' ]\r\n\t\r\n\t\t},\r\n\t\r\n\t\t/* -------------------------------------------------------------------------\r\n\t\t//\tCube map shader\r\n\t\t ------------------------------------------------------------------------- */\r\n\t\r\n\t\t'cube': {\r\n\t\r\n\t\t\tuniforms: {\r\n\t\t\t\t\"tCube\": { type: \"t\", value: null },\r\n\t\t\t\t\"tFlip\": { type: \"1f\", value: - 1 }\r\n\t\t\t},\r\n\t\r\n\t\t\tvertexShader: THREE.ShaderChunk[ 'cube_vert' ],\r\n\t\t\tfragmentShader: THREE.ShaderChunk[ 'cube_frag' ]\r\n\t\r\n\t\t},\r\n\t\r\n\t\t/* -------------------------------------------------------------------------\r\n\t\t//\tCube map shader\r\n\t\t ------------------------------------------------------------------------- */\r\n\t\r\n\t\t'equirect': {\r\n\t\r\n\t\t\tuniforms: {\r\n\t\t\t\t\"tEquirect\": { type: \"t\", value: null },\r\n\t\t\t\t\"tFlip\": { type: \"1f\", value: - 1 }\r\n\t\t\t},\r\n\t\r\n\t\t\tvertexShader: THREE.ShaderChunk[ 'equirect_vert' ],\r\n\t\t\tfragmentShader: THREE.ShaderChunk[ 'equirect_frag' ]\r\n\t\r\n\t\t},\r\n\t\r\n\t\t'distanceRGBA': {\r\n\t\r\n\t\t\tuniforms: {\r\n\t\r\n\t\t\t\t\"lightPos\": { type: \"v3\", value: new THREE.Vector3() }\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t\tvertexShader: THREE.ShaderChunk[ 'distanceRGBA_vert' ],\r\n\t\t\tfragmentShader: THREE.ShaderChunk[ 'distanceRGBA_frag' ]\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.ShaderLib[ 'physical' ] = {\r\n\t\r\n\t\tuniforms: THREE.UniformsUtils.merge( [\r\n\t\r\n\t\t\tTHREE.ShaderLib[ 'standard' ].uniforms,\r\n\t\r\n\t\t\t{\r\n\t\t\t\t// future\r\n\t\t\t}\r\n\t\r\n\t\t] ),\r\n\t\r\n\t\tvertexShader: THREE.ShaderChunk[ 'meshphysical_vert' ],\r\n\t\tfragmentShader: THREE.ShaderChunk[ 'meshphysical_frag' ]\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\t// File:src/renderers/WebGLRenderer.js\r\n\t\r\n\t/**\r\n\t * @author supereggbert / http://www.paulbrunt.co.uk/\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author szimek / https://github.com/szimek/\r\n\t * @author tschw\r\n\t */\r\n\t\r\n\tTHREE.WebGLRenderer = function ( parameters ) {\r\n\t\r\n\t\tconsole.log( 'THREE.WebGLRenderer', THREE.REVISION );\r\n\t\r\n\t\tparameters = parameters || {};\r\n\t\r\n\t\tvar _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElement( 'canvas' ),\r\n\t\t_context = parameters.context !== undefined ? parameters.context : null,\r\n\t\r\n\t\t_alpha = parameters.alpha !== undefined ? parameters.alpha : false,\r\n\t\t_depth = parameters.depth !== undefined ? parameters.depth : true,\r\n\t\t_stencil = parameters.stencil !== undefined ? parameters.stencil : true,\r\n\t\t_antialias = parameters.antialias !== undefined ? parameters.antialias : false,\r\n\t\t_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,\r\n\t\t_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false;\r\n\t\r\n\t\tvar lights = [];\r\n\t\r\n\t\tvar opaqueObjects = [];\r\n\t\tvar opaqueObjectsLastIndex = - 1;\r\n\t\tvar transparentObjects = [];\r\n\t\tvar transparentObjectsLastIndex = - 1;\r\n\t\r\n\t\tvar morphInfluences = new Float32Array( 8 );\r\n\t\r\n\t\tvar sprites = [];\r\n\t\tvar lensFlares = [];\r\n\t\r\n\t\t// public properties\r\n\t\r\n\t\tthis.domElement = _canvas;\r\n\t\tthis.context = null;\r\n\t\r\n\t\t// clearing\r\n\t\r\n\t\tthis.autoClear = true;\r\n\t\tthis.autoClearColor = true;\r\n\t\tthis.autoClearDepth = true;\r\n\t\tthis.autoClearStencil = true;\r\n\t\r\n\t\t// scene graph\r\n\t\r\n\t\tthis.sortObjects = true;\r\n\t\r\n\t\t// user-defined clipping\r\n\t\r\n\t\tthis.clippingPlanes = [];\r\n\t\tthis.localClippingEnabled = false;\r\n\t\r\n\t\t// physically based shading\r\n\t\r\n\t\tthis.gammaFactor = 2.0;\t// for backwards compatibility\r\n\t\tthis.gammaInput = false;\r\n\t\tthis.gammaOutput = false;\r\n\t\r\n\t\t// physical lights\r\n\t\r\n\t\tthis.physicallyCorrectLights = false;\r\n\t\r\n\t\t// tone mapping\r\n\t\r\n\t\tthis.toneMapping = THREE.LinearToneMapping;\r\n\t\tthis.toneMappingExposure = 1.0;\r\n\t\tthis.toneMappingWhitePoint = 1.0;\r\n\t\r\n\t\t// morphs\r\n\t\r\n\t\tthis.maxMorphTargets = 8;\r\n\t\tthis.maxMorphNormals = 4;\r\n\t\r\n\t\t// flags\r\n\t\r\n\t\tthis.autoScaleCubemaps = true;\r\n\t\r\n\t\t// internal properties\r\n\t\r\n\t\tvar _this = this,\r\n\t\r\n\t\t// internal state cache\r\n\t\r\n\t\t_currentProgram = null,\r\n\t\t_currentRenderTarget = null,\r\n\t\t_currentFramebuffer = null,\r\n\t\t_currentMaterialId = - 1,\r\n\t\t_currentGeometryProgram = '',\r\n\t\t_currentCamera = null,\r\n\t\r\n\t\t_currentScissor = new THREE.Vector4(),\r\n\t\t_currentScissorTest = null,\r\n\t\r\n\t\t_currentViewport = new THREE.Vector4(),\r\n\t\r\n\t\t//\r\n\t\r\n\t\t_usedTextureUnits = 0,\r\n\t\r\n\t\t//\r\n\t\r\n\t\t_clearColor = new THREE.Color( 0x000000 ),\r\n\t\t_clearAlpha = 0,\r\n\t\r\n\t\t_width = _canvas.width,\r\n\t\t_height = _canvas.height,\r\n\t\r\n\t\t_pixelRatio = 1,\r\n\t\r\n\t\t_scissor = new THREE.Vector4( 0, 0, _width, _height ),\r\n\t\t_scissorTest = false,\r\n\t\r\n\t\t_viewport = new THREE.Vector4( 0, 0, _width, _height ),\r\n\t\r\n\t\t// frustum\r\n\t\r\n\t\t_frustum = new THREE.Frustum(),\r\n\t\r\n\t\t// clipping\r\n\t\r\n\t\t_clippingEnabled = false,\r\n\t\t_localClippingEnabled = false,\r\n\t\t_clipRenderingShadows = false,\r\n\t\r\n\t\t_numClippingPlanes = 0,\r\n\t\t_clippingPlanesUniform = {\r\n\t\t\t\ttype: '4fv', value: null, needsUpdate: false },\r\n\t\r\n\t\t_globalClippingState = null,\r\n\t\t_numGlobalClippingPlanes = 0,\r\n\t\r\n\t\t_matrix3 = new THREE.Matrix3(),\r\n\t\t_sphere = new THREE.Sphere(),\r\n\t\t_plane = new THREE.Plane(),\r\n\t\r\n\t\r\n\t\t// camera matrices cache\r\n\t\r\n\t\t_projScreenMatrix = new THREE.Matrix4(),\r\n\t\r\n\t\t_vector3 = new THREE.Vector3(),\r\n\t\r\n\t\t// light arrays cache\r\n\t\r\n\t\t_lights = {\r\n\t\r\n\t\t\thash: '',\r\n\t\r\n\t\t\tambient: [ 0, 0, 0 ],\r\n\t\t\tdirectional: [],\r\n\t\t\tdirectionalShadowMap: [],\r\n\t\t\tdirectionalShadowMatrix: [],\r\n\t\t\tspot: [],\r\n\t\t\tspotShadowMap: [],\r\n\t\t\tspotShadowMatrix: [],\r\n\t\t\tpoint: [],\r\n\t\t\tpointShadowMap: [],\r\n\t\t\tpointShadowMatrix: [],\r\n\t\t\themi: [],\r\n\t\r\n\t\t\tshadows: []\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// info\r\n\t\r\n\t\t_infoMemory = {\r\n\t\r\n\t\t\tgeometries: 0,\r\n\t\t\ttextures: 0\r\n\t\r\n\t\t},\r\n\t\r\n\t\t_infoRender = {\r\n\t\r\n\t\t\tcalls: 0,\r\n\t\t\tvertices: 0,\r\n\t\t\tfaces: 0,\r\n\t\t\tpoints: 0\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.info = {\r\n\t\r\n\t\t\trender: _infoRender,\r\n\t\t\tmemory: _infoMemory,\r\n\t\t\tprograms: null\r\n\t\r\n\t\t};\r\n\t\r\n\t\r\n\t\t// initialize\r\n\t\r\n\t\tvar _gl;\r\n\t\r\n\t\ttry {\r\n\t\r\n\t\t\tvar attributes = {\r\n\t\t\t\talpha: _alpha,\r\n\t\t\t\tdepth: _depth,\r\n\t\t\t\tstencil: _stencil,\r\n\t\t\t\tantialias: _antialias,\r\n\t\t\t\tpremultipliedAlpha: _premultipliedAlpha,\r\n\t\t\t\tpreserveDrawingBuffer: _preserveDrawingBuffer\r\n\t\t\t};\r\n\t\r\n\t\t\t_gl = _context || _canvas.getContext( 'webgl', attributes ) || _canvas.getContext( 'experimental-webgl', attributes );\r\n\t\r\n\t\t\tif ( _gl === null ) {\r\n\t\r\n\t\t\t\tif ( _canvas.getContext( 'webgl' ) !== null ) {\r\n\t\r\n\t\t\t\t\tthrow 'Error creating WebGL context with your selected attributes.';\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tthrow 'Error creating WebGL context.';\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// Some experimental-webgl implementations do not have getShaderPrecisionFormat\r\n\t\r\n\t\t\tif ( _gl.getShaderPrecisionFormat === undefined ) {\r\n\t\r\n\t\t\t\t_gl.getShaderPrecisionFormat = function () {\r\n\t\r\n\t\t\t\t\treturn { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };\r\n\t\r\n\t\t\t\t};\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t_canvas.addEventListener( 'webglcontextlost', onContextLost, false );\r\n\t\r\n\t\t} catch ( error ) {\r\n\t\r\n\t\t\tconsole.error( 'THREE.WebGLRenderer: ' + error );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar _isWebGL2 = (typeof WebGL2RenderingContext !== 'undefined' && _gl instanceof WebGL2RenderingContext);\r\n\t\tvar extensions = new THREE.WebGLExtensions( _gl );\r\n\t\r\n\t\textensions.get( 'WEBGL_depth_texture' );\r\n\t\textensions.get( 'OES_texture_float' );\r\n\t\textensions.get( 'OES_texture_float_linear' );\r\n\t\textensions.get( 'OES_texture_half_float' );\r\n\t\textensions.get( 'OES_texture_half_float_linear' );\r\n\t\textensions.get( 'OES_standard_derivatives' );\r\n\t\textensions.get( 'ANGLE_instanced_arrays' );\r\n\t\r\n\t\tif ( extensions.get( 'OES_element_index_uint' ) ) {\r\n\t\r\n\t\t\tTHREE.BufferGeometry.MaxIndex = 4294967296;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar capabilities = new THREE.WebGLCapabilities( _gl, extensions, parameters );\r\n\t\r\n\t\tvar state = new THREE.WebGLState( _gl, extensions, paramThreeToGL );\r\n\t\tvar properties = new THREE.WebGLProperties();\r\n\t\tvar objects = new THREE.WebGLObjects( _gl, properties, this.info );\r\n\t\tvar programCache = new THREE.WebGLPrograms( this, capabilities );\r\n\t\tvar lightCache = new THREE.WebGLLights();\r\n\t\r\n\t\tthis.info.programs = programCache.programs;\r\n\t\r\n\t\tvar bufferRenderer = new THREE.WebGLBufferRenderer( _gl, extensions, _infoRender );\r\n\t\tvar indexedBufferRenderer = new THREE.WebGLIndexedBufferRenderer( _gl, extensions, _infoRender );\r\n\t\r\n\t\t//\r\n\t\r\n\t\tfunction getTargetPixelRatio() {\r\n\t\r\n\t\t\treturn _currentRenderTarget === null ? _pixelRatio : 1;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction glClearColor( r, g, b, a ) {\r\n\t\r\n\t\t\tif ( _premultipliedAlpha === true ) {\r\n\t\r\n\t\t\t\tr *= a; g *= a; b *= a;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tstate.clearColor( r, g, b, a );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction setDefaultGLState() {\r\n\t\r\n\t\t\tstate.init();\r\n\t\r\n\t\t\tstate.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );\r\n\t\t\tstate.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );\r\n\t\r\n\t\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction resetGLState() {\r\n\t\r\n\t\t\t_currentProgram = null;\r\n\t\t\t_currentCamera = null;\r\n\t\r\n\t\t\t_currentGeometryProgram = '';\r\n\t\t\t_currentMaterialId = - 1;\r\n\t\r\n\t\t\tstate.reset();\r\n\t\r\n\t\t}\r\n\t\r\n\t\tsetDefaultGLState();\r\n\t\r\n\t\tthis.context = _gl;\r\n\t\tthis.capabilities = capabilities;\r\n\t\tthis.extensions = extensions;\r\n\t\tthis.properties = properties;\r\n\t\tthis.state = state;\r\n\t\r\n\t\t// shadow map\r\n\t\r\n\t\tvar shadowMap = new THREE.WebGLShadowMap( this, _lights, objects );\r\n\t\r\n\t\tthis.shadowMap = shadowMap;\r\n\t\r\n\t\r\n\t\t// Plugins\r\n\t\r\n\t\tvar spritePlugin = new THREE.SpritePlugin( this, sprites );\r\n\t\tvar lensFlarePlugin = new THREE.LensFlarePlugin( this, lensFlares );\r\n\t\r\n\t\t// API\r\n\t\r\n\t\tthis.getContext = function () {\r\n\t\r\n\t\t\treturn _gl;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.getContextAttributes = function () {\r\n\t\r\n\t\t\treturn _gl.getContextAttributes();\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.forceContextLoss = function () {\r\n\t\r\n\t\t\textensions.get( 'WEBGL_lose_context' ).loseContext();\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.getMaxAnisotropy = ( function () {\r\n\t\r\n\t\t\tvar value;\r\n\t\r\n\t\t\treturn function getMaxAnisotropy() {\r\n\t\r\n\t\t\t\tif ( value !== undefined ) return value;\r\n\t\r\n\t\t\t\tvar extension = extensions.get( 'EXT_texture_filter_anisotropic' );\r\n\t\r\n\t\t\t\tif ( extension !== null ) {\r\n\t\r\n\t\t\t\t\tvalue = _gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tvalue = 0;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn value;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t} )();\r\n\t\r\n\t\tthis.getPrecision = function () {\r\n\t\r\n\t\t\treturn capabilities.precision;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.getPixelRatio = function () {\r\n\t\r\n\t\t\treturn _pixelRatio;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setPixelRatio = function ( value ) {\r\n\t\r\n\t\t\tif ( value === undefined ) return;\r\n\t\r\n\t\t\t_pixelRatio = value;\r\n\t\r\n\t\t\tthis.setSize( _viewport.z, _viewport.w, false );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.getSize = function () {\r\n\t\r\n\t\t\treturn {\r\n\t\t\t\twidth: _width,\r\n\t\t\t\theight: _height\r\n\t\t\t};\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setSize = function ( width, height, updateStyle ) {\r\n\t\r\n\t\t\t_width = width;\r\n\t\t\t_height = height;\r\n\t\r\n\t\t\t_canvas.width = width * _pixelRatio;\r\n\t\t\t_canvas.height = height * _pixelRatio;\r\n\t\r\n\t\t\tif ( updateStyle !== false ) {\r\n\t\r\n\t\t\t\t_canvas.style.width = width + 'px';\r\n\t\t\t\t_canvas.style.height = height + 'px';\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.setViewport( 0, 0, width, height );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setViewport = function ( x, y, width, height ) {\r\n\t\r\n\t\t\tstate.viewport( _viewport.set( x, y, width, height ) );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setScissor = function ( x, y, width, height ) {\r\n\t\r\n\t\t\tstate.scissor( _scissor.set( x, y, width, height ) );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setScissorTest = function ( boolean ) {\r\n\t\r\n\t\t\tstate.setScissorTest( _scissorTest = boolean );\r\n\t\r\n\t\t};\r\n\t\r\n\t\t// Clearing\r\n\t\r\n\t\tthis.getClearColor = function () {\r\n\t\r\n\t\t\treturn _clearColor;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setClearColor = function ( color, alpha ) {\r\n\t\r\n\t\t\t_clearColor.set( color );\r\n\t\r\n\t\t\t_clearAlpha = alpha !== undefined ? alpha : 1;\r\n\t\r\n\t\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.getClearAlpha = function () {\r\n\t\r\n\t\t\treturn _clearAlpha;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setClearAlpha = function ( alpha ) {\r\n\t\r\n\t\t\t_clearAlpha = alpha;\r\n\t\r\n\t\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.clear = function ( color, depth, stencil ) {\r\n\t\r\n\t\t\tvar bits = 0;\r\n\t\r\n\t\t\tif ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;\r\n\t\t\tif ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;\r\n\t\t\tif ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;\r\n\t\r\n\t\t\t_gl.clear( bits );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.clearColor = function () {\r\n\t\r\n\t\t\tthis.clear( true, false, false );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.clearDepth = function () {\r\n\t\r\n\t\t\tthis.clear( false, true, false );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.clearStencil = function () {\r\n\t\r\n\t\t\tthis.clear( false, false, true );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.clearTarget = function ( renderTarget, color, depth, stencil ) {\r\n\t\r\n\t\t\tthis.setRenderTarget( renderTarget );\r\n\t\t\tthis.clear( color, depth, stencil );\r\n\t\r\n\t\t};\r\n\t\r\n\t\t// Reset\r\n\t\r\n\t\tthis.resetGLState = resetGLState;\r\n\t\r\n\t\tthis.dispose = function() {\r\n\t\r\n\t\t\t_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );\r\n\t\r\n\t\t};\r\n\t\r\n\t\t// Events\r\n\t\r\n\t\tfunction onContextLost( event ) {\r\n\t\r\n\t\t\tevent.preventDefault();\r\n\t\r\n\t\t\tresetGLState();\r\n\t\t\tsetDefaultGLState();\r\n\t\r\n\t\t\tproperties.clear();\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction onTextureDispose( event ) {\r\n\t\r\n\t\t\tvar texture = event.target;\r\n\t\r\n\t\t\ttexture.removeEventListener( 'dispose', onTextureDispose );\r\n\t\r\n\t\t\tdeallocateTexture( texture );\r\n\t\r\n\t\t\t_infoMemory.textures --;\r\n\t\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction onRenderTargetDispose( event ) {\r\n\t\r\n\t\t\tvar renderTarget = event.target;\r\n\t\r\n\t\t\trenderTarget.removeEventListener( 'dispose', onRenderTargetDispose );\r\n\t\r\n\t\t\tdeallocateRenderTarget( renderTarget );\r\n\t\r\n\t\t\t_infoMemory.textures --;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction onMaterialDispose( event ) {\r\n\t\r\n\t\t\tvar material = event.target;\r\n\t\r\n\t\t\tmaterial.removeEventListener( 'dispose', onMaterialDispose );\r\n\t\r\n\t\t\tdeallocateMaterial( material );\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Buffer deallocation\r\n\t\r\n\t\tfunction deallocateTexture( texture ) {\r\n\t\r\n\t\t\tvar textureProperties = properties.get( texture );\r\n\t\r\n\t\t\tif ( texture.image && textureProperties.__image__webglTextureCube ) {\r\n\t\r\n\t\t\t\t// cube texture\r\n\t\r\n\t\t\t\t_gl.deleteTexture( textureProperties.__image__webglTextureCube );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\t// 2D texture\r\n\t\r\n\t\t\t\tif ( textureProperties.__webglInit === undefined ) return;\r\n\t\r\n\t\t\t\t_gl.deleteTexture( textureProperties.__webglTexture );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// remove all webgl properties\r\n\t\t\tproperties.delete( texture );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction deallocateRenderTarget( renderTarget ) {\r\n\t\r\n\t\t\tvar renderTargetProperties = properties.get( renderTarget );\r\n\t\t\tvar textureProperties = properties.get( renderTarget.texture );\r\n\t\r\n\t\t\tif ( ! renderTarget ) return;\r\n\t\r\n\t\t\tif ( textureProperties.__webglTexture !== undefined ) {\r\n\t\r\n\t\t\t\t_gl.deleteTexture( textureProperties.__webglTexture );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( renderTarget.depthTexture ) {\r\n\t\r\n\t\t\t\trenderTarget.depthTexture.dispose();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {\r\n\t\r\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\t\r\n\t\t\t\t\t_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );\r\n\t\t\t\t\tif ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\t_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );\r\n\t\t\t\tif ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tproperties.delete( renderTarget.texture );\r\n\t\t\tproperties.delete( renderTarget );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction deallocateMaterial( material ) {\r\n\t\r\n\t\t\treleaseMaterialProgramReference( material );\r\n\t\r\n\t\t\tproperties.delete( material );\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t\tfunction releaseMaterialProgramReference( material ) {\r\n\t\r\n\t\t\tvar programInfo = properties.get( material ).program;\r\n\t\r\n\t\t\tmaterial.program = undefined;\r\n\t\r\n\t\t\tif ( programInfo !== undefined ) {\r\n\t\r\n\t\t\t\tprogramCache.releaseProgram( programInfo );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Buffer rendering\r\n\t\r\n\t\tthis.renderBufferImmediate = function ( object, program, material ) {\r\n\t\r\n\t\t\tstate.initAttributes();\r\n\t\r\n\t\t\tvar buffers = properties.get( object );\r\n\t\r\n\t\t\tif ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();\r\n\t\t\tif ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();\r\n\t\t\tif ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();\r\n\t\t\tif ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();\r\n\t\r\n\t\t\tvar attributes = program.getAttributes();\r\n\t\r\n\t\t\tif ( object.hasPositions ) {\r\n\t\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.position );\r\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );\r\n\t\r\n\t\t\t\tstate.enableAttribute( attributes.position );\r\n\t\t\t\t_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( object.hasNormals ) {\r\n\t\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.normal );\r\n\t\r\n\t\t\t\tif ( material.type !== 'MeshPhongMaterial' && material.type !== 'MeshStandardMaterial' && material.type !== 'MeshPhysicalMaterial' && material.shading === THREE.FlatShading ) {\r\n\t\r\n\t\t\t\t\tfor ( var i = 0, l = object.count * 3; i < l; i += 9 ) {\r\n\t\r\n\t\t\t\t\t\tvar array = object.normalArray;\r\n\t\r\n\t\t\t\t\t\tvar nx = ( array[ i + 0 ] + array[ i + 3 ] + array[ i + 6 ] ) / 3;\r\n\t\t\t\t\t\tvar ny = ( array[ i + 1 ] + array[ i + 4 ] + array[ i + 7 ] ) / 3;\r\n\t\t\t\t\t\tvar nz = ( array[ i + 2 ] + array[ i + 5 ] + array[ i + 8 ] ) / 3;\r\n\t\r\n\t\t\t\t\t\tarray[ i + 0 ] = nx;\r\n\t\t\t\t\t\tarray[ i + 1 ] = ny;\r\n\t\t\t\t\t\tarray[ i + 2 ] = nz;\r\n\t\r\n\t\t\t\t\t\tarray[ i + 3 ] = nx;\r\n\t\t\t\t\t\tarray[ i + 4 ] = ny;\r\n\t\t\t\t\t\tarray[ i + 5 ] = nz;\r\n\t\r\n\t\t\t\t\t\tarray[ i + 6 ] = nx;\r\n\t\t\t\t\t\tarray[ i + 7 ] = ny;\r\n\t\t\t\t\t\tarray[ i + 8 ] = nz;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );\r\n\t\r\n\t\t\t\tstate.enableAttribute( attributes.normal );\r\n\t\r\n\t\t\t\t_gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( object.hasUvs && material.map ) {\r\n\t\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.uv );\r\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );\r\n\t\r\n\t\t\t\tstate.enableAttribute( attributes.uv );\r\n\t\r\n\t\t\t\t_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( object.hasColors && material.vertexColors !== THREE.NoColors ) {\r\n\t\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.color );\r\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );\r\n\t\r\n\t\t\t\tstate.enableAttribute( attributes.color );\r\n\t\r\n\t\t\t\t_gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tstate.disableUnusedAttributes();\r\n\t\r\n\t\t\t_gl.drawArrays( _gl.TRIANGLES, 0, object.count );\r\n\t\r\n\t\t\tobject.count = 0;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.renderBufferDirect = function ( camera, fog, geometry, material, object, group ) {\r\n\t\r\n\t\t\tsetMaterial( material );\r\n\t\r\n\t\t\tvar program = setProgram( camera, fog, material, object );\r\n\t\r\n\t\t\tvar updateBuffers = false;\r\n\t\t\tvar geometryProgram = geometry.id + '_' + program.id + '_' + material.wireframe;\r\n\t\r\n\t\t\tif ( geometryProgram !== _currentGeometryProgram ) {\r\n\t\r\n\t\t\t\t_currentGeometryProgram = geometryProgram;\r\n\t\t\t\tupdateBuffers = true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// morph targets\r\n\t\r\n\t\t\tvar morphTargetInfluences = object.morphTargetInfluences;\r\n\t\r\n\t\t\tif ( morphTargetInfluences !== undefined ) {\r\n\t\r\n\t\t\t\tvar activeInfluences = [];\r\n\t\r\n\t\t\t\tfor ( var i = 0, l = morphTargetInfluences.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\tvar influence = morphTargetInfluences[ i ];\r\n\t\t\t\t\tactiveInfluences.push( [ influence, i ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tactiveInfluences.sort( absNumericalSort );\r\n\t\r\n\t\t\t\tif ( activeInfluences.length > 8 ) {\r\n\t\r\n\t\t\t\t\tactiveInfluences.length = 8;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar morphAttributes = geometry.morphAttributes;\r\n\t\r\n\t\t\t\tfor ( var i = 0, l = activeInfluences.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\tvar influence = activeInfluences[ i ];\r\n\t\t\t\t\tmorphInfluences[ i ] = influence[ 0 ];\r\n\t\r\n\t\t\t\t\tif ( influence[ 0 ] !== 0 ) {\r\n\t\r\n\t\t\t\t\t\tvar index = influence[ 1 ];\r\n\t\r\n\t\t\t\t\t\tif ( material.morphTargets === true && morphAttributes.position ) geometry.addAttribute( 'morphTarget' + i, morphAttributes.position[ index ] );\r\n\t\t\t\t\t\tif ( material.morphNormals === true && morphAttributes.normal ) geometry.addAttribute( 'morphNormal' + i, morphAttributes.normal[ index ] );\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tif ( material.morphTargets === true ) geometry.removeAttribute( 'morphTarget' + i );\r\n\t\t\t\t\t\tif ( material.morphNormals === true ) geometry.removeAttribute( 'morphNormal' + i );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tprogram.getUniforms().setValue(\r\n\t\t\t\t\t\t_gl, 'morphTargetInfluences', morphInfluences );\r\n\t\r\n\t\t\t\tupdateBuffers = true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t//\r\n\t\r\n\t\t\tvar index = geometry.index;\r\n\t\t\tvar position = geometry.attributes.position;\r\n\t\r\n\t\t\tif ( material.wireframe === true ) {\r\n\t\r\n\t\t\t\tindex = objects.getWireframeAttribute( geometry );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar renderer;\r\n\t\r\n\t\t\tif ( index !== null ) {\r\n\t\r\n\t\t\t\trenderer = indexedBufferRenderer;\r\n\t\t\t\trenderer.setIndex( index );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\trenderer = bufferRenderer;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( updateBuffers ) {\r\n\t\r\n\t\t\t\tsetupVertexAttributes( material, program, geometry );\r\n\t\r\n\t\t\t\tif ( index !== null ) {\r\n\t\r\n\t\t\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, objects.getAttributeBuffer( index ) );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t//\r\n\t\r\n\t\t\tvar dataStart = 0;\r\n\t\t\tvar dataCount = Infinity;\r\n\t\r\n\t\t\tif ( index !== null ) {\r\n\t\r\n\t\t\t\tdataCount = index.count;\r\n\t\r\n\t\t\t} else if ( position !== undefined ) {\r\n\t\r\n\t\t\t\tdataCount = position.count;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar rangeStart = geometry.drawRange.start;\r\n\t\t\tvar rangeCount = geometry.drawRange.count;\r\n\t\r\n\t\t\tvar groupStart = group !== null ? group.start : 0;\r\n\t\t\tvar groupCount = group !== null ? group.count : Infinity;\r\n\t\r\n\t\t\tvar drawStart = Math.max( dataStart, rangeStart, groupStart );\r\n\t\t\tvar drawEnd = Math.min( dataStart + dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;\r\n\t\r\n\t\t\tvar drawCount = Math.max( 0, drawEnd - drawStart + 1 );\r\n\t\r\n\t\t\t//\r\n\t\r\n\t\t\tif ( object instanceof THREE.Mesh ) {\r\n\t\r\n\t\t\t\tif ( material.wireframe === true ) {\r\n\t\r\n\t\t\t\t\tstate.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );\r\n\t\t\t\t\trenderer.setMode( _gl.LINES );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tswitch ( object.drawMode ) {\r\n\t\r\n\t\t\t\t\t\tcase THREE.TrianglesDrawMode:\r\n\t\t\t\t\t\t\trenderer.setMode( _gl.TRIANGLES );\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tcase THREE.TriangleStripDrawMode:\r\n\t\t\t\t\t\t\trenderer.setMode( _gl.TRIANGLE_STRIP );\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tcase THREE.TriangleFanDrawMode:\r\n\t\t\t\t\t\t\trenderer.setMode( _gl.TRIANGLE_FAN );\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\r\n\t\t\t} else if ( object instanceof THREE.Line ) {\r\n\t\r\n\t\t\t\tvar lineWidth = material.linewidth;\r\n\t\r\n\t\t\t\tif ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material\r\n\t\r\n\t\t\t\tstate.setLineWidth( lineWidth * getTargetPixelRatio() );\r\n\t\r\n\t\t\t\tif ( object instanceof THREE.LineSegments ) {\r\n\t\r\n\t\t\t\t\trenderer.setMode( _gl.LINES );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\trenderer.setMode( _gl.LINE_STRIP );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else if ( object instanceof THREE.Points ) {\r\n\t\r\n\t\t\t\trenderer.setMode( _gl.POINTS );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( geometry instanceof THREE.InstancedBufferGeometry ) {\r\n\t\r\n\t\t\t\tif ( geometry.maxInstancedCount > 0 ) {\r\n\t\r\n\t\t\t\t\trenderer.renderInstances( geometry, drawStart, drawCount );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\trenderer.render( drawStart, drawCount );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tfunction setupVertexAttributes( material, program, geometry, startIndex ) {\r\n\t\r\n\t\t\tvar extension;\r\n\t\r\n\t\t\tif ( geometry instanceof THREE.InstancedBufferGeometry ) {\r\n\t\r\n\t\t\t\textension = extensions.get( 'ANGLE_instanced_arrays' );\r\n\t\r\n\t\t\t\tif ( extension === null ) {\r\n\t\r\n\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\r\n\t\t\t\t\treturn;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( startIndex === undefined ) startIndex = 0;\r\n\t\r\n\t\t\tstate.initAttributes();\r\n\t\r\n\t\t\tvar geometryAttributes = geometry.attributes;\r\n\t\r\n\t\t\tvar programAttributes = program.getAttributes();\r\n\t\r\n\t\t\tvar materialDefaultAttributeValues = material.defaultAttributeValues;\r\n\t\r\n\t\t\tfor ( var name in programAttributes ) {\r\n\t\r\n\t\t\t\tvar programAttribute = programAttributes[ name ];\r\n\t\r\n\t\t\t\tif ( programAttribute >= 0 ) {\r\n\t\r\n\t\t\t\t\tvar geometryAttribute = geometryAttributes[ name ];\r\n\t\r\n\t\t\t\t\tif ( geometryAttribute !== undefined ) {\r\n\t\r\n\t\t\t\t\t\tvar type = _gl.FLOAT;\r\n\t\t\t\t\t\tvar array = geometryAttribute.array;\r\n\t\t\t\t\t\tvar normalized = geometryAttribute.normalized;\r\n\t\r\n\t\t\t\t\t\tif ( array instanceof Float32Array ) {\r\n\t\r\n\t\t\t\t\t\t\ttype = _gl.FLOAT;\r\n\t\r\n\t\t\t\t\t\t} else if ( array instanceof Float64Array ) {\r\n\t\r\n\t\t\t\t\t\t\tconsole.warn(\"Unsupported data buffer format: Float64Array\");\r\n\t\r\n\t\t\t\t\t\t} else if ( array instanceof Uint16Array ) {\r\n\t\r\n\t\t\t\t\t\t\ttype = _gl.UNSIGNED_SHORT;\r\n\t\r\n\t\t\t\t\t\t} else if ( array instanceof Int16Array ) {\r\n\t\r\n\t\t\t\t\t\t\ttype = _gl.SHORT;\r\n\t\r\n\t\t\t\t\t\t} else if ( array instanceof Uint32Array ) {\r\n\t\r\n\t\t\t\t\t\t\ttype = _gl.UNSIGNED_INT;\r\n\t\r\n\t\t\t\t\t\t} else if ( array instanceof Int32Array ) {\r\n\t\r\n\t\t\t\t\t\t\ttype = _gl.INT;\r\n\t\r\n\t\t\t\t\t\t} else if ( array instanceof Int8Array ) {\r\n\t\r\n\t\t\t\t\t\t\ttype = _gl.BYTE;\r\n\t\r\n\t\t\t\t\t\t} else if ( array instanceof Uint8Array ) {\r\n\t\r\n\t\t\t\t\t\t\ttype = _gl.UNSIGNED_BYTE;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tvar size = geometryAttribute.itemSize;\r\n\t\t\t\t\t\tvar buffer = objects.getAttributeBuffer( geometryAttribute );\r\n\t\r\n\t\t\t\t\t\tif ( geometryAttribute instanceof THREE.InterleavedBufferAttribute ) {\r\n\t\r\n\t\t\t\t\t\t\tvar data = geometryAttribute.data;\r\n\t\t\t\t\t\t\tvar stride = data.stride;\r\n\t\t\t\t\t\t\tvar offset = geometryAttribute.offset;\r\n\t\r\n\t\t\t\t\t\t\tif ( data instanceof THREE.InstancedInterleavedBuffer ) {\r\n\t\r\n\t\t\t\t\t\t\t\tstate.enableAttributeAndDivisor( programAttribute, data.meshPerAttribute, extension );\r\n\t\r\n\t\t\t\t\t\t\t\tif ( geometry.maxInstancedCount === undefined ) {\r\n\t\r\n\t\t\t\t\t\t\t\t\tgeometry.maxInstancedCount = data.meshPerAttribute * data.count;\r\n\t\r\n\t\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\t\tstate.enableAttribute( programAttribute );\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );\r\n\t\t\t\t\t\t\t_gl.vertexAttribPointer( programAttribute, size, type, normalized, stride * data.array.BYTES_PER_ELEMENT, ( startIndex * stride + offset ) * data.array.BYTES_PER_ELEMENT );\r\n\t\r\n\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\tif ( geometryAttribute instanceof THREE.InstancedBufferAttribute ) {\r\n\t\r\n\t\t\t\t\t\t\t\tstate.enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute, extension );\r\n\t\r\n\t\t\t\t\t\t\t\tif ( geometry.maxInstancedCount === undefined ) {\r\n\t\r\n\t\t\t\t\t\t\t\t\tgeometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;\r\n\t\r\n\t\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\t\tstate.enableAttribute( programAttribute );\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );\r\n\t\t\t\t\t\t\t_gl.vertexAttribPointer( programAttribute, size, type, normalized, 0, startIndex * size * geometryAttribute.array.BYTES_PER_ELEMENT );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t} else if ( materialDefaultAttributeValues !== undefined ) {\r\n\t\r\n\t\t\t\t\t\tvar value = materialDefaultAttributeValues[ name ];\r\n\t\r\n\t\t\t\t\t\tif ( value !== undefined ) {\r\n\t\r\n\t\t\t\t\t\t\tswitch ( value.length ) {\r\n\t\r\n\t\t\t\t\t\t\t\tcase 2:\r\n\t\t\t\t\t\t\t\t\t_gl.vertexAttrib2fv( programAttribute, value );\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\t\t\tcase 3:\r\n\t\t\t\t\t\t\t\t\t_gl.vertexAttrib3fv( programAttribute, value );\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\t\t\tcase 4:\r\n\t\t\t\t\t\t\t\t\t_gl.vertexAttrib4fv( programAttribute, value );\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\t\t\t_gl.vertexAttrib1fv( programAttribute, value );\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tstate.disableUnusedAttributes();\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Sorting\r\n\t\r\n\t\tfunction absNumericalSort( a, b ) {\r\n\t\r\n\t\t\treturn Math.abs( b[ 0 ] ) - Math.abs( a[ 0 ] );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction painterSortStable ( a, b ) {\r\n\t\r\n\t\t\tif ( a.object.renderOrder !== b.object.renderOrder ) {\r\n\t\r\n\t\t\t\treturn a.object.renderOrder - b.object.renderOrder;\r\n\t\r\n\t\t\t} else if ( a.material.id !== b.material.id ) {\r\n\t\r\n\t\t\t\treturn a.material.id - b.material.id;\r\n\t\r\n\t\t\t} else if ( a.z !== b.z ) {\r\n\t\r\n\t\t\t\treturn a.z - b.z;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\treturn a.id - b.id;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction reversePainterSortStable ( a, b ) {\r\n\t\r\n\t\t\tif ( a.object.renderOrder !== b.object.renderOrder ) {\r\n\t\r\n\t\t\t\treturn a.object.renderOrder - b.object.renderOrder;\r\n\t\r\n\t\t\t} if ( a.z !== b.z ) {\r\n\t\r\n\t\t\t\treturn b.z - a.z;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\treturn a.id - b.id;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Rendering\r\n\t\r\n\t\tthis.render = function ( scene, camera, renderTarget, forceClear ) {\r\n\t\r\n\t\t\tif ( camera instanceof THREE.Camera === false ) {\r\n\t\r\n\t\t\t\tconsole.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );\r\n\t\t\t\treturn;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar fog = scene.fog;\r\n\t\r\n\t\t\t// reset caching for this frame\r\n\t\r\n\t\t\t_currentGeometryProgram = '';\r\n\t\t\t_currentMaterialId = - 1;\r\n\t\t\t_currentCamera = null;\r\n\t\r\n\t\t\t// update scene graph\r\n\t\r\n\t\t\tif ( scene.autoUpdate === true ) scene.updateMatrixWorld();\r\n\t\r\n\t\t\t// update camera matrices and frustum\r\n\t\r\n\t\t\tif ( camera.parent === null ) camera.updateMatrixWorld();\r\n\t\r\n\t\t\tcamera.matrixWorldInverse.getInverse( camera.matrixWorld );\r\n\t\r\n\t\t\t_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\r\n\t\t\t_frustum.setFromMatrix( _projScreenMatrix );\r\n\t\r\n\t\t\tlights.length = 0;\r\n\t\r\n\t\t\topaqueObjectsLastIndex = - 1;\r\n\t\t\ttransparentObjectsLastIndex = - 1;\r\n\t\r\n\t\t\tsprites.length = 0;\r\n\t\t\tlensFlares.length = 0;\r\n\t\r\n\t\t\tsetupGlobalClippingPlanes( this.clippingPlanes, camera );\r\n\t\r\n\t\t\tprojectObject( scene, camera );\r\n\t\r\n\t\r\n\t\t\topaqueObjects.length = opaqueObjectsLastIndex + 1;\r\n\t\t\ttransparentObjects.length = transparentObjectsLastIndex + 1;\r\n\t\r\n\t\t\tif ( _this.sortObjects === true ) {\r\n\t\r\n\t\t\t\topaqueObjects.sort( painterSortStable );\r\n\t\t\t\ttransparentObjects.sort( reversePainterSortStable );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t//\r\n\t\r\n\t\t\tif ( _clippingEnabled ) {\r\n\t\r\n\t\t\t\t_clipRenderingShadows = true;\r\n\t\t\t\tsetupClippingPlanes( null );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tsetupShadows( lights );\r\n\t\r\n\t\t\tshadowMap.render( scene, camera );\r\n\t\r\n\t\t\tsetupLights( lights, camera );\r\n\t\r\n\t\t\tif ( _clippingEnabled ) {\r\n\t\r\n\t\t\t\t_clipRenderingShadows = false;\r\n\t\t\t\tresetGlobalClippingState();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t//\r\n\t\r\n\t\t\t_infoRender.calls = 0;\r\n\t\t\t_infoRender.vertices = 0;\r\n\t\t\t_infoRender.faces = 0;\r\n\t\t\t_infoRender.points = 0;\r\n\t\r\n\t\t\tif ( renderTarget === undefined ) {\r\n\t\r\n\t\t\t\trenderTarget = null;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.setRenderTarget( renderTarget );\r\n\t\r\n\t\t\tif ( this.autoClear || forceClear ) {\r\n\t\r\n\t\t\t\tthis.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t//\r\n\t\r\n\t\t\tif ( scene.overrideMaterial ) {\r\n\t\r\n\t\t\t\tvar overrideMaterial = scene.overrideMaterial;\r\n\t\r\n\t\t\t\trenderObjects( opaqueObjects, camera, fog, overrideMaterial );\r\n\t\t\t\trenderObjects( transparentObjects, camera, fog, overrideMaterial );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\t// opaque pass (front-to-back order)\r\n\t\r\n\t\t\t\tstate.setBlending( THREE.NoBlending );\r\n\t\t\t\trenderObjects( opaqueObjects, camera, fog );\r\n\t\r\n\t\t\t\t// transparent pass (back-to-front order)\r\n\t\r\n\t\t\t\trenderObjects( transparentObjects, camera, fog );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// custom render plugins (post pass)\r\n\t\r\n\t\t\tspritePlugin.render( scene, camera );\r\n\t\t\tlensFlarePlugin.render( scene, camera, _currentViewport );\r\n\t\r\n\t\t\t// Generate mipmap if we're using any kind of mipmap filtering\r\n\t\r\n\t\t\tif ( renderTarget ) {\r\n\t\r\n\t\t\t\tvar texture = renderTarget.texture;\r\n\t\r\n\t\t\t\tif ( texture.generateMipmaps && isPowerOfTwo( renderTarget ) &&\r\n\t\t\t\t\t\ttexture.minFilter !== THREE.NearestFilter &&\r\n\t\t\t\t\t\ttexture.minFilter !== THREE.LinearFilter ) {\r\n\t\r\n\t\t\t\t\tupdateRenderTargetMipmap( renderTarget );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// Ensure depth buffer writing is enabled so it can be cleared on next render\r\n\t\r\n\t\t\tstate.setDepthTest( true );\r\n\t\t\tstate.setDepthWrite( true );\r\n\t\t\tstate.setColorWrite( true );\r\n\t\r\n\t\t\t// _gl.finish();\r\n\t\r\n\t\t};\r\n\t\r\n\t\tfunction pushRenderItem( object, geometry, material, z, group ) {\r\n\t\r\n\t\t\tvar array, index;\r\n\t\r\n\t\t\t// allocate the next position in the appropriate array\r\n\t\r\n\t\t\tif ( material.transparent ) {\r\n\t\r\n\t\t\t\tarray = transparentObjects;\r\n\t\t\t\tindex = ++ transparentObjectsLastIndex;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tarray = opaqueObjects;\r\n\t\t\t\tindex = ++ opaqueObjectsLastIndex;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// recycle existing render item or grow the array\r\n\t\r\n\t\t\tvar renderItem = array[ index ];\r\n\t\r\n\t\t\tif ( renderItem !== undefined ) {\r\n\t\r\n\t\t\t\trenderItem.id = object.id;\r\n\t\t\t\trenderItem.object = object;\r\n\t\t\t\trenderItem.geometry = geometry;\r\n\t\t\t\trenderItem.material = material;\r\n\t\t\t\trenderItem.z = _vector3.z;\r\n\t\t\t\trenderItem.group = group;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\trenderItem = {\r\n\t\t\t\t\tid: object.id,\r\n\t\t\t\t\tobject: object,\r\n\t\t\t\t\tgeometry: geometry,\r\n\t\t\t\t\tmaterial: material,\r\n\t\t\t\t\tz: _vector3.z,\r\n\t\t\t\t\tgroup: group\r\n\t\t\t\t};\r\n\t\r\n\t\t\t\t// assert( index === array.length );\r\n\t\t\t\tarray.push( renderItem );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction isObjectViewable( object ) {\r\n\t\r\n\t\t\tvar geometry = object.geometry;\r\n\t\r\n\t\t\tif ( geometry.boundingSphere === null )\r\n\t\t\t\tgeometry.computeBoundingSphere();\r\n\t\r\n\t\t\tvar sphere = _sphere.\r\n\t\t\t\t\tcopy( geometry.boundingSphere ).\r\n\t\t\t\t\tapplyMatrix4( object.matrixWorld );\r\n\t\r\n\t\t\tif ( ! _frustum.intersectsSphere( sphere ) ) return false;\r\n\t\t\tif ( _numClippingPlanes === 0 ) return true;\r\n\t\r\n\t\t\tvar planes = _this.clippingPlanes,\r\n\t\r\n\t\t\t\tcenter = sphere.center,\r\n\t\t\t\tnegRad = - sphere.radius,\r\n\t\t\t\ti = 0;\r\n\t\r\n\t\t\tdo {\r\n\t\r\n\t\t\t\t// out when deeper than radius in the negative halfspace\r\n\t\t\t\tif ( planes[ i ].distanceToPoint( center ) < negRad ) return false;\r\n\t\r\n\t\t\t} while ( ++ i !== _numClippingPlanes );\r\n\t\r\n\t\t\treturn true;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction projectObject( object, camera ) {\r\n\t\r\n\t\t\tif ( object.visible === false ) return;\r\n\t\r\n\t\t\tif ( object.layers.test( camera.layers ) ) {\r\n\t\r\n\t\t\t\tif ( object instanceof THREE.Light ) {\r\n\t\r\n\t\t\t\t\tlights.push( object );\r\n\t\r\n\t\t\t\t} else if ( object instanceof THREE.Sprite ) {\r\n\t\r\n\t\t\t\t\tif ( object.frustumCulled === false || isObjectViewable( object ) === true ) {\r\n\t\r\n\t\t\t\t\t\tsprites.push( object );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else if ( object instanceof THREE.LensFlare ) {\r\n\t\r\n\t\t\t\t\tlensFlares.push( object );\r\n\t\r\n\t\t\t\t} else if ( object instanceof THREE.ImmediateRenderObject ) {\r\n\t\r\n\t\t\t\t\tif ( _this.sortObjects === true ) {\r\n\t\r\n\t\t\t\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld );\r\n\t\t\t\t\t\t_vector3.applyProjection( _projScreenMatrix );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tpushRenderItem( object, null, object.material, _vector3.z, null );\r\n\t\r\n\t\t\t\t} else if ( object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Points ) {\r\n\t\r\n\t\t\t\t\tif ( object instanceof THREE.SkinnedMesh ) {\r\n\t\r\n\t\t\t\t\t\tobject.skeleton.update();\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( object.frustumCulled === false || isObjectViewable( object ) === true ) {\r\n\t\r\n\t\t\t\t\t\tvar material = object.material;\r\n\t\r\n\t\t\t\t\t\tif ( material.visible === true ) {\r\n\t\r\n\t\t\t\t\t\t\tif ( _this.sortObjects === true ) {\r\n\t\r\n\t\t\t\t\t\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld );\r\n\t\t\t\t\t\t\t\t_vector3.applyProjection( _projScreenMatrix );\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\tvar geometry = objects.update( object );\r\n\t\r\n\t\t\t\t\t\t\tif ( material instanceof THREE.MultiMaterial ) {\r\n\t\r\n\t\t\t\t\t\t\t\tvar groups = geometry.groups;\r\n\t\t\t\t\t\t\t\tvar materials = material.materials;\r\n\t\r\n\t\t\t\t\t\t\t\tfor ( var i = 0, l = groups.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\t\tvar group = groups[ i ];\r\n\t\t\t\t\t\t\t\t\tvar groupMaterial = materials[ group.materialIndex ];\r\n\t\r\n\t\t\t\t\t\t\t\t\tif ( groupMaterial.visible === true ) {\r\n\t\r\n\t\t\t\t\t\t\t\t\t\tpushRenderItem( object, geometry, groupMaterial, _vector3.z, group );\r\n\t\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\t\tpushRenderItem( object, geometry, material, _vector3.z, null );\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar children = object.children;\r\n\t\r\n\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tprojectObject( children[ i ], camera );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction renderObjects( renderList, camera, fog, overrideMaterial ) {\r\n\t\r\n\t\t\tfor ( var i = 0, l = renderList.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tvar renderItem = renderList[ i ];\r\n\t\r\n\t\t\t\tvar object = renderItem.object;\r\n\t\t\t\tvar geometry = renderItem.geometry;\r\n\t\t\t\tvar material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;\r\n\t\t\t\tvar group = renderItem.group;\r\n\t\r\n\t\t\t\tobject.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );\r\n\t\t\t\tobject.normalMatrix.getNormalMatrix( object.modelViewMatrix );\r\n\t\r\n\t\t\t\tif ( object instanceof THREE.ImmediateRenderObject ) {\r\n\t\r\n\t\t\t\t\tsetMaterial( material );\r\n\t\r\n\t\t\t\t\tvar program = setProgram( camera, fog, material, object );\r\n\t\r\n\t\t\t\t\t_currentGeometryProgram = '';\r\n\t\r\n\t\t\t\t\tobject.render( function ( object ) {\r\n\t\r\n\t\t\t\t\t\t_this.renderBufferImmediate( object, program, material );\r\n\t\r\n\t\t\t\t\t} );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t_this.renderBufferDirect( camera, fog, geometry, material, object, group );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction initMaterial( material, fog, object ) {\r\n\t\r\n\t\t\tvar materialProperties = properties.get( material );\r\n\t\r\n\t\t\tvar parameters = programCache.getParameters(\r\n\t\t\t\t\tmaterial, _lights, fog, _numClippingPlanes, object );\r\n\t\r\n\t\t\tvar code = programCache.getProgramCode( material, parameters );\r\n\t\r\n\t\t\tvar program = materialProperties.program;\r\n\t\t\tvar programChange = true;\r\n\t\r\n\t\t\tif ( program === undefined ) {\r\n\t\r\n\t\t\t\t// new material\r\n\t\t\t\tmaterial.addEventListener( 'dispose', onMaterialDispose );\r\n\t\r\n\t\t\t} else if ( program.code !== code ) {\r\n\t\r\n\t\t\t\t// changed glsl or parameters\r\n\t\t\t\treleaseMaterialProgramReference( material );\r\n\t\r\n\t\t\t} else if ( parameters.shaderID !== undefined ) {\r\n\t\r\n\t\t\t\t// same glsl and uniform list\r\n\t\t\t\treturn;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\t// only rebuild uniform list\r\n\t\t\t\tprogramChange = false;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( programChange ) {\r\n\t\r\n\t\t\t\tif ( parameters.shaderID ) {\r\n\t\r\n\t\t\t\t\tvar shader = THREE.ShaderLib[ parameters.shaderID ];\r\n\t\r\n\t\t\t\t\tmaterialProperties.__webglShader = {\r\n\t\t\t\t\t\tname: material.type,\r\n\t\t\t\t\t\tuniforms: THREE.UniformsUtils.clone( shader.uniforms ),\r\n\t\t\t\t\t\tvertexShader: shader.vertexShader,\r\n\t\t\t\t\t\tfragmentShader: shader.fragmentShader\r\n\t\t\t\t\t};\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tmaterialProperties.__webglShader = {\r\n\t\t\t\t\t\tname: material.type,\r\n\t\t\t\t\t\tuniforms: material.uniforms,\r\n\t\t\t\t\t\tvertexShader: material.vertexShader,\r\n\t\t\t\t\t\tfragmentShader: material.fragmentShader\r\n\t\t\t\t\t};\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tmaterial.__webglShader = materialProperties.__webglShader;\r\n\t\r\n\t\t\t\tprogram = programCache.acquireProgram( material, parameters, code );\r\n\t\r\n\t\t\t\tmaterialProperties.program = program;\r\n\t\t\t\tmaterial.program = program;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar attributes = program.getAttributes();\r\n\t\r\n\t\t\tif ( material.morphTargets ) {\r\n\t\r\n\t\t\t\tmaterial.numSupportedMorphTargets = 0;\r\n\t\r\n\t\t\t\tfor ( var i = 0; i < _this.maxMorphTargets; i ++ ) {\r\n\t\r\n\t\t\t\t\tif ( attributes[ 'morphTarget' + i ] >= 0 ) {\r\n\t\r\n\t\t\t\t\t\tmaterial.numSupportedMorphTargets ++;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( material.morphNormals ) {\r\n\t\r\n\t\t\t\tmaterial.numSupportedMorphNormals = 0;\r\n\t\r\n\t\t\t\tfor ( var i = 0; i < _this.maxMorphNormals; i ++ ) {\r\n\t\r\n\t\t\t\t\tif ( attributes[ 'morphNormal' + i ] >= 0 ) {\r\n\t\r\n\t\t\t\t\t\tmaterial.numSupportedMorphNormals ++;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar uniforms = materialProperties.__webglShader.uniforms;\r\n\t\r\n\t\t\tif ( ! ( material instanceof THREE.ShaderMaterial ) &&\r\n\t\t\t\t\t! ( material instanceof THREE.RawShaderMaterial ) ||\r\n\t\t\t\t\tmaterial.clipping === true ) {\r\n\t\r\n\t\t\t\tmaterialProperties.numClippingPlanes = _numClippingPlanes;\r\n\t\t\t\tuniforms.clippingPlanes = _clippingPlanesUniform;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( material instanceof THREE.MeshPhongMaterial ||\r\n\t\t\t\t\tmaterial instanceof THREE.MeshLambertMaterial ||\r\n\t\t\t\t\tmaterial instanceof THREE.MeshStandardMaterial ||\r\n\t\t\t\t\tmaterial.lights ) {\r\n\t\r\n\t\t\t\t// store the light setup it was created for\r\n\t\r\n\t\t\t\tmaterialProperties.lightsHash = _lights.hash;\r\n\t\r\n\t\t\t\t// wire up the material to this renderer's lighting state\r\n\t\r\n\t\t\t\tuniforms.ambientLightColor.value = _lights.ambient;\r\n\t\t\t\tuniforms.directionalLights.value = _lights.directional;\r\n\t\t\t\tuniforms.spotLights.value = _lights.spot;\r\n\t\t\t\tuniforms.pointLights.value = _lights.point;\r\n\t\t\t\tuniforms.hemisphereLights.value = _lights.hemi;\r\n\t\r\n\t\t\t\tuniforms.directionalShadowMap.value = _lights.directionalShadowMap;\r\n\t\t\t\tuniforms.directionalShadowMatrix.value = _lights.directionalShadowMatrix;\r\n\t\t\t\tuniforms.spotShadowMap.value = _lights.spotShadowMap;\r\n\t\t\t\tuniforms.spotShadowMatrix.value = _lights.spotShadowMatrix;\r\n\t\t\t\tuniforms.pointShadowMap.value = _lights.pointShadowMap;\r\n\t\t\t\tuniforms.pointShadowMatrix.value = _lights.pointShadowMatrix;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar progUniforms = materialProperties.program.getUniforms(),\r\n\t\t\t\tuniformsList =\r\n\t\t\t\t\t\tTHREE.WebGLUniforms.seqWithValue( progUniforms.seq, uniforms );\r\n\t\r\n\t\t\tmaterialProperties.uniformsList = uniformsList;\r\n\t\t\tmaterialProperties.dynamicUniforms =\r\n\t\t\t\t\tTHREE.WebGLUniforms.splitDynamic( uniformsList, uniforms );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction setMaterial( material ) {\r\n\t\r\n\t\t\tsetMaterialFaces( material );\r\n\t\r\n\t\t\tif ( material.transparent === true ) {\r\n\t\r\n\t\t\t\tstate.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tstate.setBlending( THREE.NoBlending );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tstate.setDepthFunc( material.depthFunc );\r\n\t\t\tstate.setDepthTest( material.depthTest );\r\n\t\t\tstate.setDepthWrite( material.depthWrite );\r\n\t\t\tstate.setColorWrite( material.colorWrite );\r\n\t\t\tstate.setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction setMaterialFaces( material ) {\r\n\t\r\n\t\t\tmaterial.side !== THREE.DoubleSide ? state.enable( _gl.CULL_FACE ) : state.disable( _gl.CULL_FACE );\r\n\t\t\tstate.setFlipSided( material.side === THREE.BackSide );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction setProgram( camera, fog, material, object ) {\r\n\t\r\n\t\t\t_usedTextureUnits = 0;\r\n\t\r\n\t\t\tvar materialProperties = properties.get( material );\r\n\t\r\n\t\t\tif ( _clippingEnabled ) {\r\n\t\r\n\t\t\t\tif ( _localClippingEnabled || camera !== _currentCamera ) {\r\n\t\r\n\t\t\t\t\tvar useCache =\r\n\t\t\t\t\t\t\tcamera === _currentCamera &&\r\n\t\t\t\t\t\t\tmaterial.id === _currentMaterialId;\r\n\t\r\n\t\t\t\t\t// we might want to call this function with some ClippingGroup\r\n\t\t\t\t\t// object instead of the material, once it becomes feasible\r\n\t\t\t\t\t// (#8465, #8379)\r\n\t\t\t\t\tsetClippingState(\r\n\t\t\t\t\t\t\tmaterial.clippingPlanes, material.clipShadows,\r\n\t\t\t\t\t\t\tcamera, materialProperties, useCache );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( materialProperties.numClippingPlanes !== undefined &&\r\n\t\t\t\t\tmaterialProperties.numClippingPlanes !== _numClippingPlanes ) {\r\n\t\r\n\t\t\t\t\tmaterial.needsUpdate = true;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( materialProperties.program === undefined ) {\r\n\t\r\n\t\t\t\tmaterial.needsUpdate = true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( materialProperties.lightsHash !== undefined &&\r\n\t\t\t\tmaterialProperties.lightsHash !== _lights.hash ) {\r\n\t\r\n\t\t\t\tmaterial.needsUpdate = true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( material.needsUpdate ) {\r\n\t\r\n\t\t\t\tinitMaterial( material, fog, object );\r\n\t\t\t\tmaterial.needsUpdate = false;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar refreshProgram = false;\r\n\t\t\tvar refreshMaterial = false;\r\n\t\t\tvar refreshLights = false;\r\n\t\r\n\t\t\tvar program = materialProperties.program,\r\n\t\t\t\tp_uniforms = program.getUniforms(),\r\n\t\t\t\tm_uniforms = materialProperties.__webglShader.uniforms;\r\n\t\r\n\t\t\tif ( program.id !== _currentProgram ) {\r\n\t\r\n\t\t\t\t_gl.useProgram( program.program );\r\n\t\t\t\t_currentProgram = program.id;\r\n\t\r\n\t\t\t\trefreshProgram = true;\r\n\t\t\t\trefreshMaterial = true;\r\n\t\t\t\trefreshLights = true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( material.id !== _currentMaterialId ) {\r\n\t\r\n\t\t\t\t_currentMaterialId = material.id;\r\n\t\r\n\t\t\t\trefreshMaterial = true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( refreshProgram || camera !== _currentCamera ) {\r\n\t\r\n\t\t\t\tp_uniforms.set( _gl, camera, 'projectionMatrix' );\r\n\t\r\n\t\t\t\tif ( capabilities.logarithmicDepthBuffer ) {\r\n\t\r\n\t\t\t\t\tp_uniforms.setValue( _gl, 'logDepthBufFC',\r\n\t\t\t\t\t\t\t2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\r\n\t\t\t\tif ( camera !== _currentCamera ) {\r\n\t\r\n\t\t\t\t\t_currentCamera = camera;\r\n\t\r\n\t\t\t\t\t// lighting uniforms depend on the camera so enforce an update\r\n\t\t\t\t\t// now, in case this material supports lights - or later, when\r\n\t\t\t\t\t// the next material that does gets activated:\r\n\t\r\n\t\t\t\t\trefreshMaterial = true;\t\t// set to true on material change\r\n\t\t\t\t\trefreshLights = true;\t\t// remains set until update done\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// load material specific uniforms\r\n\t\t\t\t// (shader material also gets them for the sake of genericity)\r\n\t\r\n\t\t\t\tif ( material instanceof THREE.ShaderMaterial ||\r\n\t\t\t\t\t material instanceof THREE.MeshPhongMaterial ||\r\n\t\t\t\t\t material instanceof THREE.MeshStandardMaterial ||\r\n\t\t\t\t\t material.envMap ) {\r\n\t\r\n\t\t\t\t\tvar uCamPos = p_uniforms.map.cameraPosition;\r\n\t\r\n\t\t\t\t\tif ( uCamPos !== undefined ) {\r\n\t\r\n\t\t\t\t\t\tuCamPos.setValue( _gl,\r\n\t\t\t\t\t\t\t\t_vector3.setFromMatrixPosition( camera.matrixWorld ) );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( material instanceof THREE.MeshPhongMaterial ||\r\n\t\t\t\t\t material instanceof THREE.MeshLambertMaterial ||\r\n\t\t\t\t\t material instanceof THREE.MeshBasicMaterial ||\r\n\t\t\t\t\t material instanceof THREE.MeshStandardMaterial ||\r\n\t\t\t\t\t material instanceof THREE.ShaderMaterial ||\r\n\t\t\t\t\t material.skinning ) {\r\n\t\r\n\t\t\t\t\tp_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tp_uniforms.set( _gl, _this, 'toneMappingExposure' );\r\n\t\t\t\tp_uniforms.set( _gl, _this, 'toneMappingWhitePoint' );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// skinning uniforms must be set even if material didn't change\r\n\t\t\t// auto-setting of texture unit for bone texture must go before other textures\r\n\t\t\t// not sure why, but otherwise weird things happen\r\n\t\r\n\t\t\tif ( material.skinning ) {\r\n\t\r\n\t\t\t\tp_uniforms.setOptional( _gl, object, 'bindMatrix' );\r\n\t\t\t\tp_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );\r\n\t\r\n\t\t\t\tvar skeleton = object.skeleton;\r\n\t\r\n\t\t\t\tif ( skeleton ) {\r\n\t\r\n\t\t\t\t\tif ( capabilities.floatVertexTextures && skeleton.useVertexTexture ) {\r\n\t\r\n\t\t\t\t\t\tp_uniforms.set( _gl, skeleton, 'boneTexture' );\r\n\t\t\t\t\t\tp_uniforms.set( _gl, skeleton, 'boneTextureWidth' );\r\n\t\t\t\t\t\tp_uniforms.set( _gl, skeleton, 'boneTextureHeight' );\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tp_uniforms.setOptional( _gl, skeleton, 'boneMatrices' );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( refreshMaterial ) {\r\n\t\r\n\t\t\t\tif ( material instanceof THREE.MeshPhongMaterial ||\r\n\t\t\t\t\t material instanceof THREE.MeshLambertMaterial ||\r\n\t\t\t\t\t material instanceof THREE.MeshStandardMaterial ||\r\n\t\t\t\t\t material.lights ) {\r\n\t\r\n\t\t\t\t\t// the current material requires lighting info\r\n\t\r\n\t\t\t\t\t// note: all lighting uniforms are always set correctly\r\n\t\t\t\t\t// they simply reference the renderer's state for their\r\n\t\t\t\t\t// values\r\n\t\t\t\t\t//\r\n\t\t\t\t\t// use the current material's .needsUpdate flags to set\r\n\t\t\t\t\t// the GL state when required\r\n\t\r\n\t\t\t\t\tmarkUniformsLightsNeedsUpdate( m_uniforms, refreshLights );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// refresh uniforms common to several materials\r\n\t\r\n\t\t\t\tif ( fog && material.fog ) {\r\n\t\r\n\t\t\t\t\trefreshUniformsFog( m_uniforms, fog );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( material instanceof THREE.MeshBasicMaterial ||\r\n\t\t\t\t\t material instanceof THREE.MeshLambertMaterial ||\r\n\t\t\t\t\t material instanceof THREE.MeshPhongMaterial ||\r\n\t\t\t\t\t material instanceof THREE.MeshStandardMaterial ||\r\n\t\t\t\t\t material instanceof THREE.MeshDepthMaterial ) {\r\n\t\r\n\t\t\t\t\trefreshUniformsCommon( m_uniforms, material );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// refresh single material specific uniforms\r\n\t\r\n\t\t\t\tif ( material instanceof THREE.LineBasicMaterial ) {\r\n\t\r\n\t\t\t\t\trefreshUniformsLine( m_uniforms, material );\r\n\t\r\n\t\t\t\t} else if ( material instanceof THREE.LineDashedMaterial ) {\r\n\t\r\n\t\t\t\t\trefreshUniformsLine( m_uniforms, material );\r\n\t\t\t\t\trefreshUniformsDash( m_uniforms, material );\r\n\t\r\n\t\t\t\t} else if ( material instanceof THREE.PointsMaterial ) {\r\n\t\r\n\t\t\t\t\trefreshUniformsPoints( m_uniforms, material );\r\n\t\r\n\t\t\t\t} else if ( material instanceof THREE.MeshLambertMaterial ) {\r\n\t\r\n\t\t\t\t\trefreshUniformsLambert( m_uniforms, material );\r\n\t\r\n\t\t\t\t} else if ( material instanceof THREE.MeshPhongMaterial ) {\r\n\t\r\n\t\t\t\t\trefreshUniformsPhong( m_uniforms, material );\r\n\t\r\n\t\t\t\t} else if ( material instanceof THREE.MeshPhysicalMaterial ) {\r\n\t\r\n\t\t\t\t\trefreshUniformsPhysical( m_uniforms, material );\r\n\t\r\n\t\t\t\t} else if ( material instanceof THREE.MeshStandardMaterial ) {\r\n\t\r\n\t\t\t\t\trefreshUniformsStandard( m_uniforms, material );\r\n\t\r\n\t\t\t\t} else if ( material instanceof THREE.MeshDepthMaterial ) {\r\n\t\r\n\t\t\t\t\tif ( material.displacementMap ) {\r\n\t\r\n\t\t\t\t\t\tm_uniforms.displacementMap.value = material.displacementMap;\r\n\t\t\t\t\t\tm_uniforms.displacementScale.value = material.displacementScale;\r\n\t\t\t\t\t\tm_uniforms.displacementBias.value = material.displacementBias;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else if ( material instanceof THREE.MeshNormalMaterial ) {\r\n\t\r\n\t\t\t\t\tm_uniforms.opacity.value = material.opacity;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tTHREE.WebGLUniforms.upload(\r\n\t\t\t\t\t\t_gl, materialProperties.uniformsList, m_uniforms, _this );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\r\n\t\t\t// common matrices\r\n\t\r\n\t\t\tp_uniforms.set( _gl, object, 'modelViewMatrix' );\r\n\t\t\tp_uniforms.set( _gl, object, 'normalMatrix' );\r\n\t\t\tp_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );\r\n\t\r\n\t\r\n\t\t\t// dynamic uniforms\r\n\t\r\n\t\t\tvar dynUniforms = materialProperties.dynamicUniforms;\r\n\t\r\n\t\t\tif ( dynUniforms !== null ) {\r\n\t\r\n\t\t\t\tTHREE.WebGLUniforms.evalDynamic(\r\n\t\t\t\t\t\tdynUniforms, m_uniforms, object, camera );\r\n\t\r\n\t\t\t\tTHREE.WebGLUniforms.upload( _gl, dynUniforms, m_uniforms, _this );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn program;\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Uniforms (refresh uniforms objects)\r\n\t\r\n\t\tfunction refreshUniformsCommon ( uniforms, material ) {\r\n\t\r\n\t\t\tuniforms.opacity.value = material.opacity;\r\n\t\r\n\t\t\tuniforms.diffuse.value = material.color;\r\n\t\r\n\t\t\tif ( material.emissive ) {\r\n\t\r\n\t\t\t\tuniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tuniforms.map.value = material.map;\r\n\t\t\tuniforms.specularMap.value = material.specularMap;\r\n\t\t\tuniforms.alphaMap.value = material.alphaMap;\r\n\t\r\n\t\t\tif ( material.aoMap ) {\r\n\t\r\n\t\t\t\tuniforms.aoMap.value = material.aoMap;\r\n\t\t\t\tuniforms.aoMapIntensity.value = material.aoMapIntensity;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// uv repeat and offset setting priorities\r\n\t\t\t// 1. color map\r\n\t\t\t// 2. specular map\r\n\t\t\t// 3. normal map\r\n\t\t\t// 4. bump map\r\n\t\t\t// 5. alpha map\r\n\t\t\t// 6. emissive map\r\n\t\r\n\t\t\tvar uvScaleMap;\r\n\t\r\n\t\t\tif ( material.map ) {\r\n\t\r\n\t\t\t\tuvScaleMap = material.map;\r\n\t\r\n\t\t\t} else if ( material.specularMap ) {\r\n\t\r\n\t\t\t\tuvScaleMap = material.specularMap;\r\n\t\r\n\t\t\t} else if ( material.displacementMap ) {\r\n\t\r\n\t\t\t\tuvScaleMap = material.displacementMap;\r\n\t\r\n\t\t\t} else if ( material.normalMap ) {\r\n\t\r\n\t\t\t\tuvScaleMap = material.normalMap;\r\n\t\r\n\t\t\t} else if ( material.bumpMap ) {\r\n\t\r\n\t\t\t\tuvScaleMap = material.bumpMap;\r\n\t\r\n\t\t\t} else if ( material.roughnessMap ) {\r\n\t\r\n\t\t\t\tuvScaleMap = material.roughnessMap;\r\n\t\r\n\t\t\t} else if ( material.metalnessMap ) {\r\n\t\r\n\t\t\t\tuvScaleMap = material.metalnessMap;\r\n\t\r\n\t\t\t} else if ( material.alphaMap ) {\r\n\t\r\n\t\t\t\tuvScaleMap = material.alphaMap;\r\n\t\r\n\t\t\t} else if ( material.emissiveMap ) {\r\n\t\r\n\t\t\t\tuvScaleMap = material.emissiveMap;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( uvScaleMap !== undefined ) {\r\n\t\r\n\t\t\t\tif ( uvScaleMap instanceof THREE.WebGLRenderTarget ) {\r\n\t\r\n\t\t\t\t\tuvScaleMap = uvScaleMap.texture;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar offset = uvScaleMap.offset;\r\n\t\t\t\tvar repeat = uvScaleMap.repeat;\r\n\t\r\n\t\t\t\tuniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tuniforms.envMap.value = material.envMap;\r\n\t\t\tuniforms.flipEnvMap.value = ( material.envMap instanceof THREE.WebGLRenderTargetCube ) ? 1 : - 1;\r\n\t\r\n\t\t\tuniforms.reflectivity.value = material.reflectivity;\r\n\t\t\tuniforms.refractionRatio.value = material.refractionRatio;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction refreshUniformsLine ( uniforms, material ) {\r\n\t\r\n\t\t\tuniforms.diffuse.value = material.color;\r\n\t\t\tuniforms.opacity.value = material.opacity;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction refreshUniformsDash ( uniforms, material ) {\r\n\t\r\n\t\t\tuniforms.dashSize.value = material.dashSize;\r\n\t\t\tuniforms.totalSize.value = material.dashSize + material.gapSize;\r\n\t\t\tuniforms.scale.value = material.scale;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction refreshUniformsPoints ( uniforms, material ) {\r\n\t\r\n\t\t\tuniforms.diffuse.value = material.color;\r\n\t\t\tuniforms.opacity.value = material.opacity;\r\n\t\t\tuniforms.size.value = material.size * _pixelRatio;\r\n\t\t\tuniforms.scale.value = _canvas.clientHeight * 0.5;\r\n\t\r\n\t\t\tuniforms.map.value = material.map;\r\n\t\r\n\t\t\tif ( material.map !== null ) {\r\n\t\r\n\t\t\t\tvar offset = material.map.offset;\r\n\t\t\t\tvar repeat = material.map.repeat;\r\n\t\r\n\t\t\t\tuniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction refreshUniformsFog ( uniforms, fog ) {\r\n\t\r\n\t\t\tuniforms.fogColor.value = fog.color;\r\n\t\r\n\t\t\tif ( fog instanceof THREE.Fog ) {\r\n\t\r\n\t\t\t\tuniforms.fogNear.value = fog.near;\r\n\t\t\t\tuniforms.fogFar.value = fog.far;\r\n\t\r\n\t\t\t} else if ( fog instanceof THREE.FogExp2 ) {\r\n\t\r\n\t\t\t\tuniforms.fogDensity.value = fog.density;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction refreshUniformsLambert ( uniforms, material ) {\r\n\t\r\n\t\t\tif ( material.lightMap ) {\r\n\t\r\n\t\t\t\tuniforms.lightMap.value = material.lightMap;\r\n\t\t\t\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( material.emissiveMap ) {\r\n\t\r\n\t\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction refreshUniformsPhong ( uniforms, material ) {\r\n\t\r\n\t\t\tuniforms.specular.value = material.specular;\r\n\t\t\tuniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )\r\n\t\r\n\t\t\tif ( material.lightMap ) {\r\n\t\r\n\t\t\t\tuniforms.lightMap.value = material.lightMap;\r\n\t\t\t\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( material.emissiveMap ) {\r\n\t\r\n\t\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( material.bumpMap ) {\r\n\t\r\n\t\t\t\tuniforms.bumpMap.value = material.bumpMap;\r\n\t\t\t\tuniforms.bumpScale.value = material.bumpScale;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( material.normalMap ) {\r\n\t\r\n\t\t\t\tuniforms.normalMap.value = material.normalMap;\r\n\t\t\t\tuniforms.normalScale.value.copy( material.normalScale );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( material.displacementMap ) {\r\n\t\r\n\t\t\t\tuniforms.displacementMap.value = material.displacementMap;\r\n\t\t\t\tuniforms.displacementScale.value = material.displacementScale;\r\n\t\t\t\tuniforms.displacementBias.value = material.displacementBias;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction refreshUniformsStandard ( uniforms, material ) {\r\n\t\r\n\t\t\tuniforms.roughness.value = material.roughness;\r\n\t\t\tuniforms.metalness.value = material.metalness;\r\n\t\r\n\t\t\tif ( material.roughnessMap ) {\r\n\t\r\n\t\t\t\tuniforms.roughnessMap.value = material.roughnessMap;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( material.metalnessMap ) {\r\n\t\r\n\t\t\t\tuniforms.metalnessMap.value = material.metalnessMap;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( material.lightMap ) {\r\n\t\r\n\t\t\t\tuniforms.lightMap.value = material.lightMap;\r\n\t\t\t\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( material.emissiveMap ) {\r\n\t\r\n\t\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( material.bumpMap ) {\r\n\t\r\n\t\t\t\tuniforms.bumpMap.value = material.bumpMap;\r\n\t\t\t\tuniforms.bumpScale.value = material.bumpScale;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( material.normalMap ) {\r\n\t\r\n\t\t\t\tuniforms.normalMap.value = material.normalMap;\r\n\t\t\t\tuniforms.normalScale.value.copy( material.normalScale );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( material.displacementMap ) {\r\n\t\r\n\t\t\t\tuniforms.displacementMap.value = material.displacementMap;\r\n\t\t\t\tuniforms.displacementScale.value = material.displacementScale;\r\n\t\t\t\tuniforms.displacementBias.value = material.displacementBias;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( material.envMap ) {\r\n\t\r\n\t\t\t\t//uniforms.envMap.value = material.envMap; // part of uniforms common\r\n\t\t\t\tuniforms.envMapIntensity.value = material.envMapIntensity;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction refreshUniformsPhysical ( uniforms, material ) {\r\n\t\r\n\t\t\trefreshUniformsStandard( uniforms, material );\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// If uniforms are marked as clean, they don't need to be loaded to the GPU.\r\n\t\r\n\t\tfunction markUniformsLightsNeedsUpdate ( uniforms, value ) {\r\n\t\r\n\t\t\tuniforms.ambientLightColor.needsUpdate = value;\r\n\t\r\n\t\t\tuniforms.directionalLights.needsUpdate = value;\r\n\t\t\tuniforms.pointLights.needsUpdate = value;\r\n\t\t\tuniforms.spotLights.needsUpdate = value;\r\n\t\t\tuniforms.hemisphereLights.needsUpdate = value;\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Lighting\r\n\t\r\n\t\tfunction setupShadows ( lights ) {\r\n\t\r\n\t\t\tvar lightShadowsLength = 0;\r\n\t\r\n\t\t\tfor ( var i = 0, l = lights.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tvar light = lights[ i ];\r\n\t\r\n\t\t\t\tif ( light.castShadow ) {\r\n\t\r\n\t\t\t\t\t_lights.shadows[ lightShadowsLength ++ ] = light;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t_lights.shadows.length = lightShadowsLength;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction setupLights ( lights, camera ) {\r\n\t\r\n\t\t\tvar l, ll, light,\r\n\t\t\tr = 0, g = 0, b = 0,\r\n\t\t\tcolor,\r\n\t\t\tintensity,\r\n\t\t\tdistance,\r\n\t\r\n\t\t\tviewMatrix = camera.matrixWorldInverse,\r\n\t\r\n\t\t\tdirectionalLength = 0,\r\n\t\t\tpointLength = 0,\r\n\t\t\tspotLength = 0,\r\n\t\t\themiLength = 0;\r\n\t\r\n\t\t\tfor ( l = 0, ll = lights.length; l < ll; l ++ ) {\r\n\t\r\n\t\t\t\tlight = lights[ l ];\r\n\t\r\n\t\t\t\tcolor = light.color;\r\n\t\t\t\tintensity = light.intensity;\r\n\t\t\t\tdistance = light.distance;\r\n\t\r\n\t\t\t\tif ( light instanceof THREE.AmbientLight ) {\r\n\t\r\n\t\t\t\t\tr += color.r * intensity;\r\n\t\t\t\t\tg += color.g * intensity;\r\n\t\t\t\t\tb += color.b * intensity;\r\n\t\r\n\t\t\t\t} else if ( light instanceof THREE.DirectionalLight ) {\r\n\t\r\n\t\t\t\t\tvar uniforms = lightCache.get( light );\r\n\t\r\n\t\t\t\t\tuniforms.color.copy( light.color ).multiplyScalar( light.intensity );\r\n\t\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\r\n\t\t\t\t\t_vector3.setFromMatrixPosition( light.target.matrixWorld );\r\n\t\t\t\t\tuniforms.direction.sub( _vector3 );\r\n\t\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\r\n\t\r\n\t\t\t\t\tuniforms.shadow = light.castShadow;\r\n\t\r\n\t\t\t\t\tif ( light.castShadow ) {\r\n\t\r\n\t\t\t\t\t\tuniforms.shadowBias = light.shadow.bias;\r\n\t\t\t\t\t\tuniforms.shadowRadius = light.shadow.radius;\r\n\t\t\t\t\t\tuniforms.shadowMapSize = light.shadow.mapSize;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t_lights.directionalShadowMap[ directionalLength ] = light.shadow.map;\r\n\t\t\t\t\t_lights.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;\r\n\t\t\t\t\t_lights.directional[ directionalLength ++ ] = uniforms;\r\n\t\r\n\t\t\t\t} else if ( light instanceof THREE.SpotLight ) {\r\n\t\r\n\t\t\t\t\tvar uniforms = lightCache.get( light );\r\n\t\r\n\t\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\r\n\t\t\t\t\tuniforms.position.applyMatrix4( viewMatrix );\r\n\t\r\n\t\t\t\t\tuniforms.color.copy( color ).multiplyScalar( intensity );\r\n\t\t\t\t\tuniforms.distance = distance;\r\n\t\r\n\t\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\r\n\t\t\t\t\t_vector3.setFromMatrixPosition( light.target.matrixWorld );\r\n\t\t\t\t\tuniforms.direction.sub( _vector3 );\r\n\t\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\r\n\t\r\n\t\t\t\t\tuniforms.coneCos = Math.cos( light.angle );\r\n\t\t\t\t\tuniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );\r\n\t\t\t\t\tuniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;\r\n\t\r\n\t\t\t\t\tuniforms.shadow = light.castShadow;\r\n\t\r\n\t\t\t\t\tif ( light.castShadow ) {\r\n\t\r\n\t\t\t\t\t\tuniforms.shadowBias = light.shadow.bias;\r\n\t\t\t\t\t\tuniforms.shadowRadius = light.shadow.radius;\r\n\t\t\t\t\t\tuniforms.shadowMapSize = light.shadow.mapSize;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t_lights.spotShadowMap[ spotLength ] = light.shadow.map;\r\n\t\t\t\t\t_lights.spotShadowMatrix[ spotLength ] = light.shadow.matrix;\r\n\t\t\t\t\t_lights.spot[ spotLength ++ ] = uniforms;\r\n\t\r\n\t\t\t\t} else if ( light instanceof THREE.PointLight ) {\r\n\t\r\n\t\t\t\t\tvar uniforms = lightCache.get( light );\r\n\t\r\n\t\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\r\n\t\t\t\t\tuniforms.position.applyMatrix4( viewMatrix );\r\n\t\r\n\t\t\t\t\tuniforms.color.copy( light.color ).multiplyScalar( light.intensity );\r\n\t\t\t\t\tuniforms.distance = light.distance;\r\n\t\t\t\t\tuniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;\r\n\t\r\n\t\t\t\t\tuniforms.shadow = light.castShadow;\r\n\t\r\n\t\t\t\t\tif ( light.castShadow ) {\r\n\t\r\n\t\t\t\t\t\tuniforms.shadowBias = light.shadow.bias;\r\n\t\t\t\t\t\tuniforms.shadowRadius = light.shadow.radius;\r\n\t\t\t\t\t\tuniforms.shadowMapSize = light.shadow.mapSize;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t_lights.pointShadowMap[ pointLength ] = light.shadow.map;\r\n\t\r\n\t\t\t\t\tif ( _lights.pointShadowMatrix[ pointLength ] === undefined ) {\r\n\t\r\n\t\t\t\t\t\t_lights.pointShadowMatrix[ pointLength ] = new THREE.Matrix4();\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t// for point lights we set the shadow matrix to be a translation-only matrix\r\n\t\t\t\t\t// equal to inverse of the light's position\r\n\t\t\t\t\t_vector3.setFromMatrixPosition( light.matrixWorld ).negate();\r\n\t\t\t\t\t_lights.pointShadowMatrix[ pointLength ].identity().setPosition( _vector3 );\r\n\t\r\n\t\t\t\t\t_lights.point[ pointLength ++ ] = uniforms;\r\n\t\r\n\t\t\t\t} else if ( light instanceof THREE.HemisphereLight ) {\r\n\t\r\n\t\t\t\t\tvar uniforms = lightCache.get( light );\r\n\t\r\n\t\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\r\n\t\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\r\n\t\t\t\t\tuniforms.direction.normalize();\r\n\t\r\n\t\t\t\t\tuniforms.skyColor.copy( light.color ).multiplyScalar( intensity );\r\n\t\t\t\t\tuniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );\r\n\t\r\n\t\t\t\t\t_lights.hemi[ hemiLength ++ ] = uniforms;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t_lights.ambient[ 0 ] = r;\r\n\t\t\t_lights.ambient[ 1 ] = g;\r\n\t\t\t_lights.ambient[ 2 ] = b;\r\n\t\r\n\t\t\t_lights.directional.length = directionalLength;\r\n\t\t\t_lights.spot.length = spotLength;\r\n\t\t\t_lights.point.length = pointLength;\r\n\t\t\t_lights.hemi.length = hemiLength;\r\n\t\r\n\t\t\t_lights.hash = directionalLength + ',' + pointLength + ',' + spotLength + ',' + hemiLength + ',' + _lights.shadows.length;\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Clipping\r\n\t\r\n\t\tfunction setupGlobalClippingPlanes( planes, camera ) {\r\n\t\r\n\t\t\t_clippingEnabled =\r\n\t\t\t\t\t_this.clippingPlanes.length !== 0 ||\r\n\t\t\t\t\t_this.localClippingEnabled ||\r\n\t\t\t\t\t// enable state of previous frame - the clipping code has to\r\n\t\t\t\t\t// run another frame in order to reset the state:\r\n\t\t\t\t\t_numGlobalClippingPlanes !== 0 ||\r\n\t\t\t\t\t_localClippingEnabled;\r\n\t\r\n\t\t\t_localClippingEnabled = _this.localClippingEnabled;\r\n\t\r\n\t\t\t_globalClippingState = setupClippingPlanes( planes, camera, 0 );\r\n\t\t\t_numGlobalClippingPlanes = planes !== null ? planes.length : 0;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction setupClippingPlanes( planes, camera, dstOffset, skipTransform ) {\r\n\t\r\n\t\t\tvar nPlanes = planes !== null ? planes.length : 0,\r\n\t\t\t\tdstArray = null;\r\n\t\r\n\t\t\tif ( nPlanes !== 0 ) {\r\n\t\r\n\t\t\t\tdstArray = _clippingPlanesUniform.value;\r\n\t\r\n\t\t\t\tif ( skipTransform !== true || dstArray === null ) {\r\n\t\r\n\t\t\t\t\tvar flatSize = dstOffset + nPlanes * 4,\r\n\t\t\t\t\t\tviewMatrix = camera.matrixWorldInverse,\r\n\t\t\t\t\t\tviewNormalMatrix = _matrix3.getNormalMatrix( viewMatrix );\r\n\t\r\n\t\t\t\t\tif ( dstArray === null || dstArray.length < flatSize ) {\r\n\t\r\n\t\t\t\t\t\tdstArray = new Float32Array( flatSize );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tfor ( var i = 0, i4 = dstOffset; i !== nPlanes; ++ i, i4 += 4 ) {\r\n\t\r\n\t\t\t\t\t\tvar plane = _plane.copy( planes[ i ] ).\r\n\t\t\t\t\t\t\t\tapplyMatrix4( viewMatrix, viewNormalMatrix );\r\n\t\r\n\t\t\t\t\t\tplane.normal.toArray( dstArray, i4 );\r\n\t\t\t\t\t\tdstArray[ i4 + 3 ] = plane.constant;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t_clippingPlanesUniform.value = dstArray;\r\n\t\t\t\t_clippingPlanesUniform.needsUpdate = true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t_numClippingPlanes = nPlanes;\r\n\t\t\treturn dstArray;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction resetGlobalClippingState() {\r\n\t\r\n\t\t\tif ( _clippingPlanesUniform.value !== _globalClippingState ) {\r\n\t\r\n\t\t\t\t_clippingPlanesUniform.value = _globalClippingState;\r\n\t\t\t\t_clippingPlanesUniform.needsUpdate = _numGlobalClippingPlanes > 0;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t_numClippingPlanes = _numGlobalClippingPlanes;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction setClippingState( planes, clipShadows, camera, cache, fromCache ) {\r\n\t\r\n\t\t\tif ( ! _localClippingEnabled ||\r\n\t\t\t\t\tplanes === null || planes.length === 0 ||\r\n\t\t\t\t\t_clipRenderingShadows && ! clipShadows ) {\r\n\t\t\t\t// there's no local clipping\r\n\t\r\n\t\t\t\tif ( _clipRenderingShadows ) {\r\n\t\t\t\t\t// there's no global clipping\r\n\t\r\n\t\t\t\t\tsetupClippingPlanes( null );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tresetGlobalClippingState();\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tvar nGlobal = _clipRenderingShadows ? 0 : _numGlobalClippingPlanes,\r\n\t\t\t\t\tlGlobal = nGlobal * 4,\r\n\t\r\n\t\t\t\t\tdstArray = cache.clippingState || null;\r\n\t\r\n\t\t\t\t_clippingPlanesUniform.value = dstArray; // ensure unique state\r\n\t\r\n\t\t\t\tdstArray = setupClippingPlanes(\r\n\t\t\t\t\t\tplanes, camera, lGlobal, fromCache );\r\n\t\r\n\t\t\t\tfor ( var i = 0; i !== lGlobal; ++ i ) {\r\n\t\r\n\t\t\t\t\tdstArray[ i ] = _globalClippingState[ i ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tcache.clippingState = dstArray;\r\n\t\t\t\t_numClippingPlanes += nGlobal;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t\t// GL state setting\r\n\t\r\n\t\tthis.setFaceCulling = function ( cullFace, frontFaceDirection ) {\r\n\t\r\n\t\t\tif ( cullFace === THREE.CullFaceNone ) {\r\n\t\r\n\t\t\t\tstate.disable( _gl.CULL_FACE );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tif ( frontFaceDirection === THREE.FrontFaceDirectionCW ) {\r\n\t\r\n\t\t\t\t\t_gl.frontFace( _gl.CW );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t_gl.frontFace( _gl.CCW );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( cullFace === THREE.CullFaceBack ) {\r\n\t\r\n\t\t\t\t\t_gl.cullFace( _gl.BACK );\r\n\t\r\n\t\t\t\t} else if ( cullFace === THREE.CullFaceFront ) {\r\n\t\r\n\t\t\t\t\t_gl.cullFace( _gl.FRONT );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t_gl.cullFace( _gl.FRONT_AND_BACK );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tstate.enable( _gl.CULL_FACE );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\t// Textures\r\n\t\r\n\t\tfunction allocTextureUnit() {\r\n\t\r\n\t\t\tvar textureUnit = _usedTextureUnits;\r\n\t\r\n\t\t\tif ( textureUnit >= capabilities.maxTextures ) {\r\n\t\r\n\t\t\t\tconsole.warn( 'WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t_usedTextureUnits += 1;\r\n\t\r\n\t\t\treturn textureUnit;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction setTextureParameters ( textureType, texture, isPowerOfTwoImage ) {\r\n\t\r\n\t\t\tvar extension;\r\n\t\r\n\t\t\tif ( isPowerOfTwoImage ) {\r\n\t\r\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );\r\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );\r\n\t\r\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );\r\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );\r\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );\r\n\t\r\n\t\t\t\tif ( texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping ) {\r\n\t\r\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.', texture );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );\r\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );\r\n\t\r\n\t\t\t\tif ( texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter ) {\r\n\t\r\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.', texture );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\textension = extensions.get( 'EXT_texture_filter_anisotropic' );\r\n\t\r\n\t\t\tif ( extension ) {\r\n\t\r\n\t\t\t\tif ( texture.type === THREE.FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) return;\r\n\t\t\t\tif ( texture.type === THREE.HalfFloatType && extensions.get( 'OES_texture_half_float_linear' ) === null ) return;\r\n\t\r\n\t\t\t\tif ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {\r\n\t\r\n\t\t\t\t\t_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, _this.getMaxAnisotropy() ) );\r\n\t\t\t\t\tproperties.get( texture ).__currentAnisotropy = texture.anisotropy;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction uploadTexture( textureProperties, texture, slot ) {\r\n\t\r\n\t\t\tif ( textureProperties.__webglInit === undefined ) {\r\n\t\r\n\t\t\t\ttextureProperties.__webglInit = true;\r\n\t\r\n\t\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\r\n\t\r\n\t\t\t\ttextureProperties.__webglTexture = _gl.createTexture();\r\n\t\r\n\t\t\t\t_infoMemory.textures ++;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\r\n\t\t\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\r\n\t\r\n\t\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\r\n\t\t\t_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );\r\n\t\t\t_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );\r\n\t\r\n\t\t\tvar image = clampToMaxSize( texture.image, capabilities.maxTextureSize );\r\n\t\r\n\t\t\tif ( textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( image ) === false ) {\r\n\t\r\n\t\t\t\timage = makePowerOfTwo( image );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar isPowerOfTwoImage = isPowerOfTwo( image ),\r\n\t\t\tglFormat = paramThreeToGL( texture.format ),\r\n\t\t\tglType = paramThreeToGL( texture.type );\r\n\t\r\n\t\t\tsetTextureParameters( _gl.TEXTURE_2D, texture, isPowerOfTwoImage );\r\n\t\r\n\t\t\tvar mipmap, mipmaps = texture.mipmaps;\r\n\t\r\n\t\t\tif ( texture instanceof THREE.DepthTexture ) {\r\n\t\r\n\t\t\t\t// populate depth texture with dummy data\r\n\t\r\n\t\t\t\tvar internalFormat = _gl.DEPTH_COMPONENT;\r\n\t\r\n\t\t\t\tif ( texture.type === THREE.FloatType ) {\r\n\t\r\n\t\t\t\t\tif ( !_isWebGL2 ) throw new Error('Float Depth Texture only supported in WebGL2.0');\r\n\t\t\t\t\tinternalFormat = _gl.DEPTH_COMPONENT32F;\r\n\t\r\n\t\t\t\t} else if ( _isWebGL2 ) {\r\n\t\r\n\t\t\t\t\t// WebGL 2.0 requires signed internalformat for glTexImage2D\r\n\t\t\t\t\tinternalFormat = _gl.DEPTH_COMPONENT16;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, 0, internalFormat, image.width, image.height, 0, glFormat, glType, null );\r\n\t\r\n\t\t\t} else if ( texture instanceof THREE.DataTexture ) {\r\n\t\r\n\t\t\t\t// use manually created mipmaps if available\r\n\t\t\t\t// if there are no manual mipmaps\r\n\t\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\r\n\t\r\n\t\t\t\tif ( mipmaps.length > 0 && isPowerOfTwoImage ) {\r\n\t\r\n\t\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\t\tmipmap = mipmaps[ i ];\r\n\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\ttexture.generateMipmaps = false;\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else if ( texture instanceof THREE.CompressedTexture ) {\r\n\t\r\n\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\tmipmap = mipmaps[ i ];\r\n\t\r\n\t\t\t\t\tif ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {\r\n\t\r\n\t\t\t\t\t\tif ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {\r\n\t\r\n\t\t\t\t\t\t\tstate.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );\r\n\t\r\n\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()\" );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\t// regular Texture (image, video, canvas)\r\n\t\r\n\t\t\t\t// use manually created mipmaps if available\r\n\t\t\t\t// if there are no manual mipmaps\r\n\t\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\r\n\t\r\n\t\t\t\tif ( mipmaps.length > 0 && isPowerOfTwoImage ) {\r\n\t\r\n\t\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\t\tmipmap = mipmaps[ i ];\r\n\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\ttexture.generateMipmaps = false;\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, image );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( texture.generateMipmaps && isPowerOfTwoImage ) _gl.generateMipmap( _gl.TEXTURE_2D );\r\n\t\r\n\t\t\ttextureProperties.__version = texture.version;\r\n\t\r\n\t\t\tif ( texture.onUpdate ) texture.onUpdate( texture );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction setTexture2D( texture, slot ) {\r\n\t\r\n\t\t\tif ( texture instanceof THREE.WebGLRenderTarget ) texture = texture.texture;\r\n\t\r\n\t\t\tvar textureProperties = properties.get( texture );\r\n\t\r\n\t\t\tif ( texture.version > 0 && textureProperties.__version !== texture.version ) {\r\n\t\r\n\t\t\t\tvar image = texture.image;\r\n\t\r\n\t\t\t\tif ( image === undefined ) {\r\n\t\r\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined', texture );\r\n\t\t\t\t\treturn;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( image.complete === false ) {\r\n\t\r\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete', texture );\r\n\t\t\t\t\treturn;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tuploadTexture( textureProperties, texture, slot );\r\n\t\r\n\t\t\t\treturn;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\r\n\t\t\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction clampToMaxSize ( image, maxSize ) {\r\n\t\r\n\t\t\tif ( image.width > maxSize || image.height > maxSize ) {\r\n\t\r\n\t\t\t\t// Warning: Scaling through the canvas will only work with images that use\r\n\t\t\t\t// premultiplied alpha.\r\n\t\r\n\t\t\t\tvar scale = maxSize / Math.max( image.width, image.height );\r\n\t\r\n\t\t\t\tvar canvas = document.createElement( 'canvas' );\r\n\t\t\t\tcanvas.width = Math.floor( image.width * scale );\r\n\t\t\t\tcanvas.height = Math.floor( image.height * scale );\r\n\t\r\n\t\t\t\tvar context = canvas.getContext( '2d' );\r\n\t\t\t\tcontext.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );\r\n\t\r\n\t\t\t\treturn canvas;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn image;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction isPowerOfTwo( image ) {\r\n\t\r\n\t\t\treturn THREE.Math.isPowerOfTwo( image.width ) && THREE.Math.isPowerOfTwo( image.height );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction textureNeedsPowerOfTwo( texture ) {\r\n\t\r\n\t\t\tif ( texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping ) return true;\r\n\t\t\tif ( texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter ) return true;\r\n\t\r\n\t\t\treturn false;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction makePowerOfTwo( image ) {\r\n\t\r\n\t\t\tif ( image instanceof HTMLImageElement || image instanceof HTMLCanvasElement ) {\r\n\t\r\n\t\t\t\tvar canvas = document.createElement( 'canvas' );\r\n\t\t\t\tcanvas.width = THREE.Math.nearestPowerOfTwo( image.width );\r\n\t\t\t\tcanvas.height = THREE.Math.nearestPowerOfTwo( image.height );\r\n\t\r\n\t\t\t\tvar context = canvas.getContext( '2d' );\r\n\t\t\t\tcontext.drawImage( image, 0, 0, canvas.width, canvas.height );\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: image is not power of two (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );\r\n\t\r\n\t\t\t\treturn canvas;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn image;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction setCubeTexture ( texture, slot ) {\r\n\t\r\n\t\t\tvar textureProperties = properties.get( texture );\r\n\t\r\n\t\t\tif ( texture.image.length === 6 ) {\r\n\t\r\n\t\t\t\tif ( texture.version > 0 && textureProperties.__version !== texture.version ) {\r\n\t\r\n\t\t\t\t\tif ( ! textureProperties.__image__webglTextureCube ) {\r\n\t\r\n\t\t\t\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\r\n\t\r\n\t\t\t\t\t\ttextureProperties.__image__webglTextureCube = _gl.createTexture();\r\n\t\r\n\t\t\t\t\t\t_infoMemory.textures ++;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\r\n\t\t\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );\r\n\t\r\n\t\t\t\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\r\n\t\r\n\t\t\t\t\tvar isCompressed = texture instanceof THREE.CompressedTexture;\r\n\t\t\t\t\tvar isDataTexture = texture.image[ 0 ] instanceof THREE.DataTexture;\r\n\t\r\n\t\t\t\t\tvar cubeImage = [];\r\n\t\r\n\t\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\t\r\n\t\t\t\t\t\tif ( _this.autoScaleCubemaps && ! isCompressed && ! isDataTexture ) {\r\n\t\r\n\t\t\t\t\t\t\tcubeImage[ i ] = clampToMaxSize( texture.image[ i ], capabilities.maxCubemapSize );\r\n\t\r\n\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\tcubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tvar image = cubeImage[ 0 ],\r\n\t\t\t\t\tisPowerOfTwoImage = isPowerOfTwo( image ),\r\n\t\t\t\t\tglFormat = paramThreeToGL( texture.format ),\r\n\t\t\t\t\tglType = paramThreeToGL( texture.type );\r\n\t\r\n\t\t\t\t\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isPowerOfTwoImage );\r\n\t\r\n\t\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\t\r\n\t\t\t\t\t\tif ( ! isCompressed ) {\r\n\t\r\n\t\t\t\t\t\t\tif ( isDataTexture ) {\r\n\t\r\n\t\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );\r\n\t\r\n\t\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\tvar mipmap, mipmaps = cubeImage[ i ].mipmaps;\r\n\t\r\n\t\t\t\t\t\t\tfor ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\tmipmap = mipmaps[ j ];\r\n\t\r\n\t\t\t\t\t\t\t\tif ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {\r\n\t\r\n\t\t\t\t\t\t\t\t\tif ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {\r\n\t\r\n\t\t\t\t\t\t\t\t\t\tstate.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );\r\n\t\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setCubeTexture()\" );\r\n\t\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\r\n\t\r\n\t\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( texture.generateMipmaps && isPowerOfTwoImage ) {\r\n\t\r\n\t\t\t\t\t\t_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\ttextureProperties.__version = texture.version;\r\n\t\r\n\t\t\t\t\tif ( texture.onUpdate ) texture.onUpdate( texture );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\r\n\t\t\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction setCubeTextureDynamic ( texture, slot ) {\r\n\t\r\n\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\r\n\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, properties.get( texture ).__webglTexture );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar setTextureWarned = false;\r\n\t\tthis.setTexture = function( texture, slot ) {\r\n\t\r\n\t\t\tif ( ! setTextureWarned ) {\r\n\t\r\n\t\t\t\tconsole.warn( \"THREE.WebGLRenderer: .setTexture is deprecated, \" +\r\n\t\t\t\t\t\"use setTexture2D instead.\" );\r\n\t\t\t\tsetTextureWarned = true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tsetTexture2D( texture, slot );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.allocTextureUnit = allocTextureUnit;\r\n\t\tthis.setTexture2D = setTexture2D;\r\n\t\tthis.setTextureCube = function( texture, slot ) {\r\n\t\r\n\t\t\tif ( texture instanceof THREE.CubeTexture ||\r\n\t\t\t\t ( Array.isArray( texture.image ) && texture.image.length === 6 ) ) {\r\n\t\r\n\t\t\t\t// CompressedTexture can have Array in image :/\r\n\t\r\n\t\t\t\tsetCubeTexture( texture, slot );\r\n\t\r\n\t\t\t} else {\r\n\t\t\t\t// assumed: texture instanceof THREE.WebGLRenderTargetCube\r\n\t\r\n\t\t\t\tsetCubeTextureDynamic( texture.texture, slot );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\t// Render targets\r\n\t\r\n\t\t// Setup storage for target texture and bind it to correct framebuffer\r\n\t\tfunction setupFrameBufferTexture ( framebuffer, renderTarget, attachment, textureTarget ) {\r\n\t\r\n\t\t\tvar glFormat = paramThreeToGL( renderTarget.texture.format );\r\n\t\t\tvar glType = paramThreeToGL( renderTarget.texture.type );\r\n\t\t\tstate.texImage2D( textureTarget, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );\r\n\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\r\n\t\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, attachment, textureTarget, properties.get( renderTarget.texture ).__webglTexture, 0 );\r\n\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Setup storage for internal depth/stencil buffers and bind to correct framebuffer\r\n\t\tfunction setupRenderBufferStorage ( renderbuffer, renderTarget ) {\r\n\t\r\n\t\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );\r\n\t\r\n\t\t\tif ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {\r\n\t\r\n\t\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );\r\n\t\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\r\n\t\r\n\t\t\t} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {\r\n\t\r\n\t\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );\r\n\t\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\t// FIXME: We don't support !depth !stencil\r\n\t\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Setup resources for a Depth Texture for a FBO (needs an extension)\r\n\t\tfunction setupDepthTexture ( framebuffer, renderTarget ) {\r\n\t\r\n\t\t\tvar isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );\r\n\t\t\tif ( isCube ) throw new Error('Depth Texture with cube render targets is not supported!');\r\n\t\r\n\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\r\n\t\r\n\t\t\tif ( !( renderTarget.depthTexture instanceof THREE.DepthTexture ) ) {\r\n\t\r\n\t\t\t\tthrow new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// upload an empty depth texture with framebuffer size\r\n\t\t\tif ( !properties.get( renderTarget.depthTexture ).__webglTexture ||\r\n\t\t\t\t\trenderTarget.depthTexture.image.width !== renderTarget.width ||\r\n\t\t\t\t\trenderTarget.depthTexture.image.height !== renderTarget.height ) {\r\n\t\t\t\trenderTarget.depthTexture.image.width = renderTarget.width;\r\n\t\t\t\trenderTarget.depthTexture.image.height = renderTarget.height;\r\n\t\t\t\trenderTarget.depthTexture.needsUpdate = true;\r\n\t\t\t}\r\n\t\r\n\t\t\t_this.setTexture( renderTarget.depthTexture, 0 );\r\n\t\r\n\t\t\tvar webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;\r\n\t\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Setup GL resources for a non-texture depth buffer\r\n\t\tfunction setupDepthRenderbuffer( renderTarget ) {\r\n\t\r\n\t\t\tvar renderTargetProperties = properties.get( renderTarget );\r\n\t\r\n\t\t\tvar isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );\r\n\t\r\n\t\t\tif ( renderTarget.depthTexture ) {\r\n\t\r\n\t\t\t\tif ( isCube ) throw new Error('target.depthTexture not supported in Cube render targets');\r\n\t\r\n\t\t\t\tsetupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tif ( isCube ) {\r\n\t\r\n\t\t\t\t\trenderTargetProperties.__webglDepthbuffer = [];\r\n\t\r\n\t\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\t\r\n\t\t\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[ i ] );\r\n\t\t\t\t\t\trenderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();\r\n\t\t\t\t\t\tsetupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );\r\n\t\t\t\t\trenderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();\r\n\t\t\t\t\tsetupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Set up GL resources for the render target\r\n\t\tfunction setupRenderTarget( renderTarget ) {\r\n\t\r\n\t\t\tvar renderTargetProperties = properties.get( renderTarget );\r\n\t\t\tvar textureProperties = properties.get( renderTarget.texture );\r\n\t\r\n\t\t\trenderTarget.addEventListener( 'dispose', onRenderTargetDispose );\r\n\t\r\n\t\t\ttextureProperties.__webglTexture = _gl.createTexture();\r\n\t\r\n\t\t\t_infoMemory.textures ++;\r\n\t\r\n\t\t\tvar isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );\r\n\t\t\tvar isTargetPowerOfTwo = THREE.Math.isPowerOfTwo( renderTarget.width ) && THREE.Math.isPowerOfTwo( renderTarget.height );\r\n\t\r\n\t\t\t// Setup framebuffer\r\n\t\r\n\t\t\tif ( isCube ) {\r\n\t\r\n\t\t\t\trenderTargetProperties.__webglFramebuffer = [];\r\n\t\r\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\t\r\n\t\t\t\t\trenderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\trenderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// Setup color buffer\r\n\t\r\n\t\t\tif ( isCube ) {\r\n\t\r\n\t\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );\r\n\t\t\t\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo );\r\n\t\r\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\t\r\n\t\t\t\t\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\r\n\t\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, null );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\r\n\t\t\t\tsetTextureParameters( _gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo );\r\n\t\t\t\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D );\r\n\t\r\n\t\t\t\tif ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );\r\n\t\t\t\tstate.bindTexture( _gl.TEXTURE_2D, null );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// Setup depth and stencil buffers\r\n\t\r\n\t\t\tif ( renderTarget.depthBuffer ) {\r\n\t\r\n\t\t\t\tsetupDepthRenderbuffer( renderTarget );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.getCurrentRenderTarget = function() {\r\n\t\r\n\t\t\treturn _currentRenderTarget;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setRenderTarget = function ( renderTarget ) {\r\n\t\r\n\t\t\t_currentRenderTarget = renderTarget;\r\n\t\r\n\t\t\tif ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {\r\n\t\r\n\t\t\t\tsetupRenderTarget( renderTarget );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );\r\n\t\t\tvar framebuffer;\r\n\t\r\n\t\t\tif ( renderTarget ) {\r\n\t\r\n\t\t\t\tvar renderTargetProperties = properties.get( renderTarget );\r\n\t\r\n\t\t\t\tif ( isCube ) {\r\n\t\r\n\t\t\t\t\tframebuffer = renderTargetProperties.__webglFramebuffer[ renderTarget.activeCubeFace ];\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tframebuffer = renderTargetProperties.__webglFramebuffer;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t_currentScissor.copy( renderTarget.scissor );\r\n\t\t\t\t_currentScissorTest = renderTarget.scissorTest;\r\n\t\r\n\t\t\t\t_currentViewport.copy( renderTarget.viewport );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tframebuffer = null;\r\n\t\r\n\t\t\t\t_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio );\r\n\t\t\t\t_currentScissorTest = _scissorTest;\r\n\t\r\n\t\t\t\t_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( _currentFramebuffer !== framebuffer ) {\r\n\t\r\n\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\r\n\t\t\t\t_currentFramebuffer = framebuffer;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tstate.scissor( _currentScissor );\r\n\t\t\tstate.setScissorTest( _currentScissorTest );\r\n\t\r\n\t\t\tstate.viewport( _currentViewport );\r\n\t\r\n\t\t\tif ( isCube ) {\r\n\t\r\n\t\t\t\tvar textureProperties = properties.get( renderTarget.texture );\r\n\t\t\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, renderTarget.activeMipMapLevel );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer ) {\r\n\t\r\n\t\t\tif ( renderTarget instanceof THREE.WebGLRenderTarget === false ) {\r\n\t\r\n\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );\r\n\t\t\t\treturn;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar framebuffer = properties.get( renderTarget ).__webglFramebuffer;\r\n\t\r\n\t\t\tif ( framebuffer ) {\r\n\t\r\n\t\t\t\tvar restore = false;\r\n\t\r\n\t\t\t\tif ( framebuffer !== _currentFramebuffer ) {\r\n\t\r\n\t\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\r\n\t\r\n\t\t\t\t\trestore = true;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\ttry {\r\n\t\r\n\t\t\t\t\tvar texture = renderTarget.texture;\r\n\t\r\n\t\t\t\t\tif ( texture.format !== THREE.RGBAFormat && paramThreeToGL( texture.format ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_FORMAT ) ) {\r\n\t\r\n\t\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );\r\n\t\t\t\t\t\treturn;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( texture.type !== THREE.UnsignedByteType &&\r\n\t\t\t\t\t     paramThreeToGL( texture.type ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_TYPE ) &&\r\n\t\t\t\t\t     ! ( texture.type === THREE.FloatType && extensions.get( 'WEBGL_color_buffer_float' ) ) &&\r\n\t\t\t\t\t     ! ( texture.type === THREE.HalfFloatType && extensions.get( 'EXT_color_buffer_half_float' ) ) ) {\r\n\t\r\n\t\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );\r\n\t\t\t\t\t\treturn;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {\r\n\t\r\n\t\t\t\t\t\t// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)\r\n\t\r\n\t\t\t\t\t\tif ( ( x > 0 && x <= ( renderTarget.width - width ) ) && ( y > 0 && y <= ( renderTarget.height - height ) ) ) {\r\n\t\r\n\t\t\t\t\t\t\t_gl.readPixels( x, y, width, height, paramThreeToGL( texture.format ), paramThreeToGL( texture.type ), buffer );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} finally {\r\n\t\r\n\t\t\t\t\tif ( restore ) {\r\n\t\r\n\t\t\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, _currentFramebuffer );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tfunction updateRenderTargetMipmap( renderTarget ) {\r\n\t\r\n\t\t\tvar target = renderTarget instanceof THREE.WebGLRenderTargetCube ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;\r\n\t\t\tvar texture = properties.get( renderTarget.texture ).__webglTexture;\r\n\t\r\n\t\t\tstate.bindTexture( target, texture );\r\n\t\t\t_gl.generateMipmap( target );\r\n\t\t\tstate.bindTexture( target, null );\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Fallback filters for non-power-of-2 textures\r\n\t\r\n\t\tfunction filterFallback ( f ) {\r\n\t\r\n\t\t\tif ( f === THREE.NearestFilter || f === THREE.NearestMipMapNearestFilter || f === THREE.NearestMipMapLinearFilter ) {\r\n\t\r\n\t\t\t\treturn _gl.NEAREST;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn _gl.LINEAR;\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Map three.js constants to WebGL constants\r\n\t\r\n\t\tfunction paramThreeToGL ( p ) {\r\n\t\r\n\t\t\tvar extension;\r\n\t\r\n\t\t\tif ( p === THREE.RepeatWrapping ) return _gl.REPEAT;\r\n\t\t\tif ( p === THREE.ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;\r\n\t\t\tif ( p === THREE.MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;\r\n\t\r\n\t\t\tif ( p === THREE.NearestFilter ) return _gl.NEAREST;\r\n\t\t\tif ( p === THREE.NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;\r\n\t\t\tif ( p === THREE.NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;\r\n\t\r\n\t\t\tif ( p === THREE.LinearFilter ) return _gl.LINEAR;\r\n\t\t\tif ( p === THREE.LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;\r\n\t\t\tif ( p === THREE.LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;\r\n\t\r\n\t\t\tif ( p === THREE.UnsignedByteType ) return _gl.UNSIGNED_BYTE;\r\n\t\t\tif ( p === THREE.UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;\r\n\t\t\tif ( p === THREE.UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;\r\n\t\t\tif ( p === THREE.UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;\r\n\t\r\n\t\t\tif ( p === THREE.ByteType ) return _gl.BYTE;\r\n\t\t\tif ( p === THREE.ShortType ) return _gl.SHORT;\r\n\t\t\tif ( p === THREE.UnsignedShortType ) return _gl.UNSIGNED_SHORT;\r\n\t\t\tif ( p === THREE.IntType ) return _gl.INT;\r\n\t\t\tif ( p === THREE.UnsignedIntType ) return _gl.UNSIGNED_INT;\r\n\t\t\tif ( p === THREE.FloatType ) return _gl.FLOAT;\r\n\t\r\n\t\t\textension = extensions.get( 'OES_texture_half_float' );\r\n\t\r\n\t\t\tif ( extension !== null ) {\r\n\t\r\n\t\t\t\tif ( p === THREE.HalfFloatType ) return extension.HALF_FLOAT_OES;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( p === THREE.AlphaFormat ) return _gl.ALPHA;\r\n\t\t\tif ( p === THREE.RGBFormat ) return _gl.RGB;\r\n\t\t\tif ( p === THREE.RGBAFormat ) return _gl.RGBA;\r\n\t\t\tif ( p === THREE.LuminanceFormat ) return _gl.LUMINANCE;\r\n\t\t\tif ( p === THREE.LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;\r\n\t\t\tif ( p === THREE.DepthFormat ) return _gl.DEPTH_COMPONENT;\r\n\t\r\n\t\t\tif ( p === THREE.AddEquation ) return _gl.FUNC_ADD;\r\n\t\t\tif ( p === THREE.SubtractEquation ) return _gl.FUNC_SUBTRACT;\r\n\t\t\tif ( p === THREE.ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;\r\n\t\r\n\t\t\tif ( p === THREE.ZeroFactor ) return _gl.ZERO;\r\n\t\t\tif ( p === THREE.OneFactor ) return _gl.ONE;\r\n\t\t\tif ( p === THREE.SrcColorFactor ) return _gl.SRC_COLOR;\r\n\t\t\tif ( p === THREE.OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;\r\n\t\t\tif ( p === THREE.SrcAlphaFactor ) return _gl.SRC_ALPHA;\r\n\t\t\tif ( p === THREE.OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;\r\n\t\t\tif ( p === THREE.DstAlphaFactor ) return _gl.DST_ALPHA;\r\n\t\t\tif ( p === THREE.OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;\r\n\t\r\n\t\t\tif ( p === THREE.DstColorFactor ) return _gl.DST_COLOR;\r\n\t\t\tif ( p === THREE.OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;\r\n\t\t\tif ( p === THREE.SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;\r\n\t\r\n\t\t\textension = extensions.get( 'WEBGL_compressed_texture_s3tc' );\r\n\t\r\n\t\t\tif ( extension !== null ) {\r\n\t\r\n\t\t\t\tif ( p === THREE.RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;\r\n\t\t\t\tif ( p === THREE.RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;\r\n\t\t\t\tif ( p === THREE.RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;\r\n\t\t\t\tif ( p === THREE.RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\textension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );\r\n\t\r\n\t\t\tif ( extension !== null ) {\r\n\t\r\n\t\t\t\tif ( p === THREE.RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;\r\n\t\t\t\tif ( p === THREE.RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;\r\n\t\t\t\tif ( p === THREE.RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;\r\n\t\t\t\tif ( p === THREE.RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\textension = extensions.get( 'WEBGL_compressed_texture_etc1' );\r\n\t\r\n\t\t\tif ( extension !== null ) {\r\n\t\r\n\t\t\t\tif ( p === THREE.RGB_ETC1_Format ) return extension.COMPRESSED_RGB_ETC1_WEBGL;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\textension = extensions.get( 'EXT_blend_minmax' );\r\n\t\r\n\t\t\tif ( extension !== null ) {\r\n\t\r\n\t\t\t\tif ( p === THREE.MinEquation ) return extension.MIN_EXT;\r\n\t\t\t\tif ( p === THREE.MaxEquation ) return extension.MAX_EXT;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn 0;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/renderers/WebGLRenderTarget.js\r\n\t\r\n\t/**\r\n\t * @author szimek / https://github.com/szimek/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author Marius Kintel / https://github.com/kintel\r\n\t */\r\n\t\r\n\t/*\r\n\t In options, we can specify:\r\n\t * Texture parameters for an auto-generated target texture\r\n\t * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers\r\n\t*/\r\n\tTHREE.WebGLRenderTarget = function ( width, height, options ) {\r\n\t\r\n\t\tthis.uuid = THREE.Math.generateUUID();\r\n\t\r\n\t\tthis.width = width;\r\n\t\tthis.height = height;\r\n\t\r\n\t\tthis.scissor = new THREE.Vector4( 0, 0, width, height );\r\n\t\tthis.scissorTest = false;\r\n\t\r\n\t\tthis.viewport = new THREE.Vector4( 0, 0, width, height );\r\n\t\r\n\t\toptions = options || {};\r\n\t\r\n\t\tif ( options.minFilter === undefined ) options.minFilter = THREE.LinearFilter;\r\n\t\r\n\t\tthis.texture = new THREE.Texture( undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );\r\n\t\r\n\t\tthis.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;\r\n\t\tthis.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;\r\n\t\tthis.depthTexture = null;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.WebGLRenderTarget.prototype = {\r\n\t\r\n\t\tconstructor: THREE.WebGLRenderTarget,\r\n\t\r\n\t\tsetSize: function ( width, height ) {\r\n\t\r\n\t\t\tif ( this.width !== width || this.height !== height ) {\r\n\t\r\n\t\t\t\tthis.width = width;\r\n\t\t\t\tthis.height = height;\r\n\t\r\n\t\t\t\tthis.dispose();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.viewport.set( 0, 0, width, height );\r\n\t\t\tthis.scissor.set( 0, 0, width, height );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new this.constructor().copy( this );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( source ) {\r\n\t\r\n\t\t\tthis.width = source.width;\r\n\t\t\tthis.height = source.height;\r\n\t\r\n\t\t\tthis.viewport.copy( source.viewport );\r\n\t\r\n\t\t\tthis.texture = source.texture.clone();\r\n\t\r\n\t\t\tthis.depthBuffer = source.depthBuffer;\r\n\t\t\tthis.stencilBuffer = source.stencilBuffer;\r\n\t\t\tthis.depthTexture = source.depthTexture;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdispose: function () {\r\n\t\r\n\t\t\tthis.dispatchEvent( { type: 'dispose' } );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.EventDispatcher.prototype.apply( THREE.WebGLRenderTarget.prototype );\r\n\t\r\n\t// File:src/renderers/WebGLRenderTargetCube.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com\r\n\t */\r\n\t\r\n\tTHREE.WebGLRenderTargetCube = function ( width, height, options ) {\r\n\t\r\n\t\tTHREE.WebGLRenderTarget.call( this, width, height, options );\r\n\t\r\n\t\tthis.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5\r\n\t\tthis.activeMipMapLevel = 0;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.WebGLRenderTargetCube.prototype = Object.create( THREE.WebGLRenderTarget.prototype );\r\n\tTHREE.WebGLRenderTargetCube.prototype.constructor = THREE.WebGLRenderTargetCube;\r\n\t\r\n\t// File:src/renderers/webgl/WebGLBufferRenderer.js\r\n\t\r\n\t/**\r\n\t* @author mrdoob / http://mrdoob.com/\r\n\t*/\r\n\t\r\n\tTHREE.WebGLBufferRenderer = function ( _gl, extensions, _infoRender ) {\r\n\t\r\n\t\tvar mode;\r\n\t\r\n\t\tfunction setMode( value ) {\r\n\t\r\n\t\t\tmode = value;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction render( start, count ) {\r\n\t\r\n\t\t\t_gl.drawArrays( mode, start, count );\r\n\t\r\n\t\t\t_infoRender.calls ++;\r\n\t\t\t_infoRender.vertices += count;\r\n\t\t\tif ( mode === _gl.TRIANGLES ) _infoRender.faces += count / 3;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction renderInstances( geometry ) {\r\n\t\r\n\t\t\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\r\n\t\r\n\t\t\tif ( extension === null ) {\r\n\t\r\n\t\t\t\tconsole.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\r\n\t\t\t\treturn;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar position = geometry.attributes.position;\r\n\t\r\n\t\t\tvar count = 0;\r\n\t\r\n\t\t\tif ( position instanceof THREE.InterleavedBufferAttribute ) {\r\n\t\r\n\t\t\t\tcount = position.data.count;\r\n\t\r\n\t\t\t\textension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tcount = position.count;\r\n\t\r\n\t\t\t\textension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t_infoRender.calls ++;\r\n\t\t\t_infoRender.vertices += count * geometry.maxInstancedCount;\r\n\t\t\tif ( mode === _gl.TRIANGLES ) _infoRender.faces += geometry.maxInstancedCount * count / 3;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.setMode = setMode;\r\n\t\tthis.render = render;\r\n\t\tthis.renderInstances = renderInstances;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/renderers/webgl/WebGLIndexedBufferRenderer.js\r\n\t\r\n\t/**\r\n\t* @author mrdoob / http://mrdoob.com/\r\n\t*/\r\n\t\r\n\tTHREE.WebGLIndexedBufferRenderer = function ( _gl, extensions, _infoRender ) {\r\n\t\r\n\t\tvar mode;\r\n\t\r\n\t\tfunction setMode( value ) {\r\n\t\r\n\t\t\tmode = value;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar type, size;\r\n\t\r\n\t\tfunction setIndex( index ) {\r\n\t\r\n\t\t\tif ( index.array instanceof Uint32Array && extensions.get( 'OES_element_index_uint' ) ) {\r\n\t\r\n\t\t\t\ttype = _gl.UNSIGNED_INT;\r\n\t\t\t\tsize = 4;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\ttype = _gl.UNSIGNED_SHORT;\r\n\t\t\t\tsize = 2;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction render( start, count ) {\r\n\t\r\n\t\t\t_gl.drawElements( mode, count, type, start * size );\r\n\t\r\n\t\t\t_infoRender.calls ++;\r\n\t\t\t_infoRender.vertices += count;\r\n\t\t\tif ( mode === _gl.TRIANGLES ) _infoRender.faces += count / 3;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction renderInstances( geometry, start, count ) {\r\n\t\r\n\t\t\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\r\n\t\r\n\t\t\tif ( extension === null ) {\r\n\t\r\n\t\t\t\tconsole.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\r\n\t\t\t\treturn;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\textension.drawElementsInstancedANGLE( mode, count, type, start * size, geometry.maxInstancedCount );\r\n\t\r\n\t\t\t_infoRender.calls ++;\r\n\t\t\t_infoRender.vertices += count * geometry.maxInstancedCount;\r\n\t\t\tif ( mode === _gl.TRIANGLES ) _infoRender.faces += geometry.maxInstancedCount * count / 3;\r\n\t\t}\r\n\t\r\n\t\tthis.setMode = setMode;\r\n\t\tthis.setIndex = setIndex;\r\n\t\tthis.render = render;\r\n\t\tthis.renderInstances = renderInstances;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/renderers/webgl/WebGLExtensions.js\r\n\t\r\n\t/**\r\n\t* @author mrdoob / http://mrdoob.com/\r\n\t*/\r\n\t\r\n\tTHREE.WebGLExtensions = function ( gl ) {\r\n\t\r\n\t\tvar extensions = {};\r\n\t\r\n\t\tthis.get = function ( name ) {\r\n\t\r\n\t\t\tif ( extensions[ name ] !== undefined ) {\r\n\t\r\n\t\t\t\treturn extensions[ name ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar extension;\r\n\t\r\n\t\t\tswitch ( name ) {\r\n\t\r\n\t\t\t\tcase 'WEBGL_depth_texture':\r\n\t\t\t\t\textension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );\r\n\t\r\n\t\t\t\tcase 'EXT_texture_filter_anisotropic':\r\n\t\t\t\t\textension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\tcase 'WEBGL_compressed_texture_s3tc':\r\n\t\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\tcase 'WEBGL_compressed_texture_pvrtc':\r\n\t\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\tcase 'WEBGL_compressed_texture_etc1':\r\n\t\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_etc1' );\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\tdefault:\r\n\t\t\t\t\textension = gl.getExtension( name );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( extension === null ) {\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\textensions[ name ] = extension;\r\n\t\r\n\t\t\treturn extension;\r\n\t\r\n\t\t};\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/renderers/webgl/WebGLCapabilities.js\r\n\t\r\n\tTHREE.WebGLCapabilities = function ( gl, extensions, parameters ) {\r\n\t\r\n\t\tfunction getMaxPrecision( precision ) {\r\n\t\r\n\t\t\tif ( precision === 'highp' ) {\r\n\t\r\n\t\t\t\tif ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&\r\n\t\t\t\t     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {\r\n\t\r\n\t\t\t\t\treturn 'highp';\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tprecision = 'mediump';\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( precision === 'mediump' ) {\r\n\t\r\n\t\t\t\tif ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&\r\n\t\t\t\t     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {\r\n\t\r\n\t\t\t\t\treturn 'mediump';\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn 'lowp';\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.getMaxPrecision = getMaxPrecision;\r\n\t\r\n\t\tthis.precision = parameters.precision !== undefined ? parameters.precision : 'highp',\r\n\t\tthis.logarithmicDepthBuffer = parameters.logarithmicDepthBuffer !== undefined ? parameters.logarithmicDepthBuffer : false;\r\n\t\r\n\t\tthis.maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );\r\n\t\tthis.maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );\r\n\t\tthis.maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );\r\n\t\tthis.maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );\r\n\t\r\n\t\tthis.maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );\r\n\t\tthis.maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );\r\n\t\tthis.maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );\r\n\t\tthis.maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );\r\n\t\r\n\t\tthis.vertexTextures = this.maxVertexTextures > 0;\r\n\t\tthis.floatFragmentTextures = !! extensions.get( 'OES_texture_float' );\r\n\t\tthis.floatVertexTextures = this.vertexTextures && this.floatFragmentTextures;\r\n\t\r\n\t\tvar _maxPrecision = getMaxPrecision( this.precision );\r\n\t\r\n\t\tif ( _maxPrecision !== this.precision ) {\r\n\t\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderer:', this.precision, 'not supported, using', _maxPrecision, 'instead.' );\r\n\t\t\tthis.precision = _maxPrecision;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tif ( this.logarithmicDepthBuffer ) {\r\n\t\r\n\t\t\tthis.logarithmicDepthBuffer = !! extensions.get( 'EXT_frag_depth' );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/renderers/webgl/WebGLGeometries.js\r\n\t\r\n\t/**\r\n\t* @author mrdoob / http://mrdoob.com/\r\n\t*/\r\n\t\r\n\tTHREE.WebGLGeometries = function ( gl, properties, info ) {\r\n\t\r\n\t\tvar geometries = {};\r\n\t\r\n\t\tfunction get( object ) {\r\n\t\r\n\t\t\tvar geometry = object.geometry;\r\n\t\r\n\t\t\tif ( geometries[ geometry.id ] !== undefined ) {\r\n\t\r\n\t\t\t\treturn geometries[ geometry.id ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tgeometry.addEventListener( 'dispose', onGeometryDispose );\r\n\t\r\n\t\t\tvar buffergeometry;\r\n\t\r\n\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\r\n\t\r\n\t\t\t\tbuffergeometry = geometry;\r\n\t\r\n\t\t\t} else if ( geometry instanceof THREE.Geometry ) {\r\n\t\r\n\t\t\t\tif ( geometry._bufferGeometry === undefined ) {\r\n\t\r\n\t\t\t\t\tgeometry._bufferGeometry = new THREE.BufferGeometry().setFromObject( object );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tbuffergeometry = geometry._bufferGeometry;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tgeometries[ geometry.id ] = buffergeometry;\r\n\t\r\n\t\t\tinfo.memory.geometries ++;\r\n\t\r\n\t\t\treturn buffergeometry;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction onGeometryDispose( event ) {\r\n\t\r\n\t\t\tvar geometry = event.target;\r\n\t\t\tvar buffergeometry = geometries[ geometry.id ];\r\n\t\r\n\t\t\tif ( buffergeometry.index !== null ) {\r\n\t\r\n\t\t\t\tdeleteAttribute( buffergeometry.index );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tdeleteAttributes( buffergeometry.attributes );\r\n\t\r\n\t\t\tgeometry.removeEventListener( 'dispose', onGeometryDispose );\r\n\t\r\n\t\t\tdelete geometries[ geometry.id ];\r\n\t\r\n\t\t\t// TODO\r\n\t\r\n\t\t\tvar property = properties.get( geometry );\r\n\t\r\n\t\t\tif ( property.wireframe ) {\r\n\t\r\n\t\t\t\tdeleteAttribute( property.wireframe );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tproperties.delete( geometry );\r\n\t\r\n\t\t\tvar bufferproperty = properties.get( buffergeometry );\r\n\t\r\n\t\t\tif ( bufferproperty.wireframe ) {\r\n\t\r\n\t\t\t\tdeleteAttribute( bufferproperty.wireframe );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tproperties.delete( buffergeometry );\r\n\t\r\n\t\t\t//\r\n\t\r\n\t\t\tinfo.memory.geometries --;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction getAttributeBuffer( attribute ) {\r\n\t\r\n\t\t\tif ( attribute instanceof THREE.InterleavedBufferAttribute ) {\r\n\t\r\n\t\t\t\treturn properties.get( attribute.data ).__webglBuffer;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn properties.get( attribute ).__webglBuffer;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction deleteAttribute( attribute ) {\r\n\t\r\n\t\t\tvar buffer = getAttributeBuffer( attribute );\r\n\t\r\n\t\t\tif ( buffer !== undefined ) {\r\n\t\r\n\t\t\t\tgl.deleteBuffer( buffer );\r\n\t\t\t\tremoveAttributeBuffer( attribute );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction deleteAttributes( attributes ) {\r\n\t\r\n\t\t\tfor ( var name in attributes ) {\r\n\t\r\n\t\t\t\tdeleteAttribute( attributes[ name ] );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction removeAttributeBuffer( attribute ) {\r\n\t\r\n\t\t\tif ( attribute instanceof THREE.InterleavedBufferAttribute ) {\r\n\t\r\n\t\t\t\tproperties.delete( attribute.data );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tproperties.delete( attribute );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.get = get;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/renderers/webgl/WebGLLights.js\r\n\t\r\n\t/**\r\n\t* @author mrdoob / http://mrdoob.com/\r\n\t*/\r\n\t\r\n\tTHREE.WebGLLights = function () {\r\n\t\r\n\t\tvar lights = {};\r\n\t\r\n\t\tthis.get = function ( light ) {\r\n\t\r\n\t\t\tif ( lights[ light.id ] !== undefined ) {\r\n\t\r\n\t\t\t\treturn lights[ light.id ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar uniforms;\r\n\t\r\n\t\t\tswitch ( light.type ) {\r\n\t\r\n\t\t\t\tcase 'DirectionalLight':\r\n\t\t\t\t\tuniforms = {\r\n\t\t\t\t\t\tdirection: new THREE.Vector3(),\r\n\t\t\t\t\t\tcolor: new THREE.Color(),\r\n\t\r\n\t\t\t\t\t\tshadow: false,\r\n\t\t\t\t\t\tshadowBias: 0,\r\n\t\t\t\t\t\tshadowRadius: 1,\r\n\t\t\t\t\t\tshadowMapSize: new THREE.Vector2()\r\n\t\t\t\t\t};\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\tcase 'SpotLight':\r\n\t\t\t\t\tuniforms = {\r\n\t\t\t\t\t\tposition: new THREE.Vector3(),\r\n\t\t\t\t\t\tdirection: new THREE.Vector3(),\r\n\t\t\t\t\t\tcolor: new THREE.Color(),\r\n\t\t\t\t\t\tdistance: 0,\r\n\t\t\t\t\t\tconeCos: 0,\r\n\t\t\t\t\t\tpenumbraCos: 0,\r\n\t\t\t\t\t\tdecay: 0,\r\n\t\r\n\t\t\t\t\t\tshadow: false,\r\n\t\t\t\t\t\tshadowBias: 0,\r\n\t\t\t\t\t\tshadowRadius: 1,\r\n\t\t\t\t\t\tshadowMapSize: new THREE.Vector2()\r\n\t\t\t\t\t};\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\tcase 'PointLight':\r\n\t\t\t\t\tuniforms = {\r\n\t\t\t\t\t\tposition: new THREE.Vector3(),\r\n\t\t\t\t\t\tcolor: new THREE.Color(),\r\n\t\t\t\t\t\tdistance: 0,\r\n\t\t\t\t\t\tdecay: 0,\r\n\t\r\n\t\t\t\t\t\tshadow: false,\r\n\t\t\t\t\t\tshadowBias: 0,\r\n\t\t\t\t\t\tshadowRadius: 1,\r\n\t\t\t\t\t\tshadowMapSize: new THREE.Vector2()\r\n\t\t\t\t\t};\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\tcase 'HemisphereLight':\r\n\t\t\t\t\tuniforms = {\r\n\t\t\t\t\t\tdirection: new THREE.Vector3(),\r\n\t\t\t\t\t\tskyColor: new THREE.Color(),\r\n\t\t\t\t\t\tgroundColor: new THREE.Color()\r\n\t\t\t\t\t};\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tlights[ light.id ] = uniforms;\r\n\t\r\n\t\t\treturn uniforms;\r\n\t\r\n\t\t};\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/renderers/webgl/WebGLObjects.js\r\n\t\r\n\t/**\r\n\t* @author mrdoob / http://mrdoob.com/\r\n\t*/\r\n\t\r\n\tTHREE.WebGLObjects = function ( gl, properties, info ) {\r\n\t\r\n\t\tvar geometries = new THREE.WebGLGeometries( gl, properties, info );\r\n\t\r\n\t\t//\r\n\t\r\n\t\tfunction update( object ) {\r\n\t\r\n\t\t\t// TODO: Avoid updating twice (when using shadowMap). Maybe add frame counter.\r\n\t\r\n\t\t\tvar geometry = geometries.get( object );\r\n\t\r\n\t\t\tif ( object.geometry instanceof THREE.Geometry ) {\r\n\t\r\n\t\t\t\tgeometry.updateFromObject( object );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar index = geometry.index;\r\n\t\t\tvar attributes = geometry.attributes;\r\n\t\r\n\t\t\tif ( index !== null ) {\r\n\t\r\n\t\t\t\tupdateAttribute( index, gl.ELEMENT_ARRAY_BUFFER );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( var name in attributes ) {\r\n\t\r\n\t\t\t\tupdateAttribute( attributes[ name ], gl.ARRAY_BUFFER );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// morph targets\r\n\t\r\n\t\t\tvar morphAttributes = geometry.morphAttributes;\r\n\t\r\n\t\t\tfor ( var name in morphAttributes ) {\r\n\t\r\n\t\t\t\tvar array = morphAttributes[ name ];\r\n\t\r\n\t\t\t\tfor ( var i = 0, l = array.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\tupdateAttribute( array[ i ], gl.ARRAY_BUFFER );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn geometry;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction updateAttribute( attribute, bufferType ) {\r\n\t\r\n\t\t\tvar data = ( attribute instanceof THREE.InterleavedBufferAttribute ) ? attribute.data : attribute;\r\n\t\r\n\t\t\tvar attributeProperties = properties.get( data );\r\n\t\r\n\t\t\tif ( attributeProperties.__webglBuffer === undefined ) {\r\n\t\r\n\t\t\t\tcreateBuffer( attributeProperties, data, bufferType );\r\n\t\r\n\t\t\t} else if ( attributeProperties.version !== data.version ) {\r\n\t\r\n\t\t\t\tupdateBuffer( attributeProperties, data, bufferType );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction createBuffer( attributeProperties, data, bufferType ) {\r\n\t\r\n\t\t\tattributeProperties.__webglBuffer = gl.createBuffer();\r\n\t\t\tgl.bindBuffer( bufferType, attributeProperties.__webglBuffer );\r\n\t\r\n\t\t\tvar usage = data.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;\r\n\t\r\n\t\t\tgl.bufferData( bufferType, data.array, usage );\r\n\t\r\n\t\t\tattributeProperties.version = data.version;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction updateBuffer( attributeProperties, data, bufferType ) {\r\n\t\r\n\t\t\tgl.bindBuffer( bufferType, attributeProperties.__webglBuffer );\r\n\t\r\n\t\t\tif ( data.dynamic === false || data.updateRange.count === - 1 ) {\r\n\t\r\n\t\t\t\t// Not using update ranges\r\n\t\r\n\t\t\t\tgl.bufferSubData( bufferType, 0, data.array );\r\n\t\r\n\t\t\t} else if ( data.updateRange.count === 0 ) {\r\n\t\r\n\t\t\t\tconsole.error( 'THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.' );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tgl.bufferSubData( bufferType, data.updateRange.offset * data.array.BYTES_PER_ELEMENT,\r\n\t\t\t\t\t\t\t\t  data.array.subarray( data.updateRange.offset, data.updateRange.offset + data.updateRange.count ) );\r\n\t\r\n\t\t\t\tdata.updateRange.count = 0; // reset range\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tattributeProperties.version = data.version;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction getAttributeBuffer( attribute ) {\r\n\t\r\n\t\t\tif ( attribute instanceof THREE.InterleavedBufferAttribute ) {\r\n\t\r\n\t\t\t\treturn properties.get( attribute.data ).__webglBuffer;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn properties.get( attribute ).__webglBuffer;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction getWireframeAttribute( geometry ) {\r\n\t\r\n\t\t\tvar property = properties.get( geometry );\r\n\t\r\n\t\t\tif ( property.wireframe !== undefined ) {\r\n\t\r\n\t\t\t\treturn property.wireframe;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar indices = [];\r\n\t\r\n\t\t\tvar index = geometry.index;\r\n\t\t\tvar attributes = geometry.attributes;\r\n\t\t\tvar position = attributes.position;\r\n\t\r\n\t\t\t// console.time( 'wireframe' );\r\n\t\r\n\t\t\tif ( index !== null ) {\r\n\t\r\n\t\t\t\tvar edges = {};\r\n\t\t\t\tvar array = index.array;\r\n\t\r\n\t\t\t\tfor ( var i = 0, l = array.length; i < l; i += 3 ) {\r\n\t\r\n\t\t\t\t\tvar a = array[ i + 0 ];\r\n\t\t\t\t\tvar b = array[ i + 1 ];\r\n\t\t\t\t\tvar c = array[ i + 2 ];\r\n\t\r\n\t\t\t\t\tif ( checkEdge( edges, a, b ) ) indices.push( a, b );\r\n\t\t\t\t\tif ( checkEdge( edges, b, c ) ) indices.push( b, c );\r\n\t\t\t\t\tif ( checkEdge( edges, c, a ) ) indices.push( c, a );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tvar array = attributes.position.array;\r\n\t\r\n\t\t\t\tfor ( var i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {\r\n\t\r\n\t\t\t\t\tvar a = i + 0;\r\n\t\t\t\t\tvar b = i + 1;\r\n\t\t\t\t\tvar c = i + 2;\r\n\t\r\n\t\t\t\t\tindices.push( a, b, b, c, c, a );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// console.timeEnd( 'wireframe' );\r\n\t\r\n\t\t\tvar TypeArray = position.count > 65535 ? Uint32Array : Uint16Array;\r\n\t\t\tvar attribute = new THREE.BufferAttribute( new TypeArray( indices ), 1 );\r\n\t\r\n\t\t\tupdateAttribute( attribute, gl.ELEMENT_ARRAY_BUFFER );\r\n\t\r\n\t\t\tproperty.wireframe = attribute;\r\n\t\r\n\t\t\treturn attribute;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction checkEdge( edges, a, b ) {\r\n\t\r\n\t\t\tif ( a > b ) {\r\n\t\r\n\t\t\t\tvar tmp = a;\r\n\t\t\t\ta = b;\r\n\t\t\t\tb = tmp;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar list = edges[ a ];\r\n\t\r\n\t\t\tif ( list === undefined ) {\r\n\t\r\n\t\t\t\tedges[ a ] = [ b ];\r\n\t\t\t\treturn true;\r\n\t\r\n\t\t\t} else if ( list.indexOf( b ) === -1 ) {\r\n\t\r\n\t\t\t\tlist.push( b );\r\n\t\t\t\treturn true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn false;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.getAttributeBuffer = getAttributeBuffer;\r\n\t\tthis.getWireframeAttribute = getWireframeAttribute;\r\n\t\r\n\t\tthis.update = update;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/renderers/webgl/WebGLProgram.js\r\n\t\r\n\tTHREE.WebGLProgram = ( function () {\r\n\t\r\n\t\tvar programIdCount = 0;\r\n\t\r\n\t\tfunction getEncodingComponents( encoding ) {\r\n\t\r\n\t\t\tswitch ( encoding ) {\r\n\t\r\n\t\t\t\tcase THREE.LinearEncoding:\r\n\t\t\t\t\treturn [ 'Linear','( value )' ];\r\n\t\t\t\tcase THREE.sRGBEncoding:\r\n\t\t\t\t\treturn [ 'sRGB','( value )' ];\r\n\t\t\t\tcase THREE.RGBEEncoding:\r\n\t\t\t\t\treturn [ 'RGBE','( value )' ];\r\n\t\t\t\tcase THREE.RGBM7Encoding:\r\n\t\t\t\t\treturn [ 'RGBM','( value, 7.0 )' ];\r\n\t\t\t\tcase THREE.RGBM16Encoding:\r\n\t\t\t\t\treturn [ 'RGBM','( value, 16.0 )' ];\r\n\t\t\t\tcase THREE.RGBDEncoding:\r\n\t\t\t\t\treturn [ 'RGBD','( value, 256.0 )' ];\r\n\t\t\t\tcase THREE.GammaEncoding:\r\n\t\t\t\t\treturn [ 'Gamma','( value, float( GAMMA_FACTOR ) )' ];\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tthrow new Error( 'unsupported encoding: ' + encoding );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction getTexelDecodingFunction( functionName, encoding ) {\r\n\t\r\n\t\t\tvar components = getEncodingComponents( encoding );\r\n\t\t\treturn \"vec4 \" + functionName + \"( vec4 value ) { return \" + components[ 0 ] + \"ToLinear\" + components[ 1 ] + \"; }\";\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction getTexelEncodingFunction( functionName, encoding ) {\r\n\t\r\n\t\t\tvar components = getEncodingComponents( encoding );\r\n\t\t\treturn \"vec4 \" + functionName + \"( vec4 value ) { return LinearTo\" + components[ 0 ] + components[ 1 ] + \"; }\";\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction getToneMappingFunction( functionName, toneMapping ) {\r\n\t\r\n\t\t\tvar toneMappingName;\r\n\t\r\n\t\t\tswitch ( toneMapping ) {\r\n\t\r\n\t\t\t\tcase THREE.LinearToneMapping:\r\n\t\t\t\t\ttoneMappingName = \"Linear\";\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\tcase THREE.ReinhardToneMapping:\r\n\t\t\t\t\ttoneMappingName = \"Reinhard\";\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\tcase THREE.Uncharted2ToneMapping:\r\n\t\t\t\t\ttoneMappingName = \"Uncharted2\";\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\tcase THREE.CineonToneMapping:\r\n\t\t\t\t\ttoneMappingName = \"OptimizedCineon\";\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tthrow new Error( 'unsupported toneMapping: ' + toneMapping );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn \"vec3 \" + functionName + \"( vec3 color ) { return \" + toneMappingName + \"ToneMapping( color ); }\";\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction generateExtensions( extensions, parameters, rendererExtensions ) {\r\n\t\r\n\t\t\textensions = extensions || {};\r\n\t\r\n\t\t\tvar chunks = [\r\n\t\t\t\t( extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.normalMap || parameters.flatShading ) ? '#extension GL_OES_standard_derivatives : enable' : '',\r\n\t\t\t\t( extensions.fragDepth || parameters.logarithmicDepthBuffer ) && rendererExtensions.get( 'EXT_frag_depth' ) ? '#extension GL_EXT_frag_depth : enable' : '',\r\n\t\t\t\t( extensions.drawBuffers ) && rendererExtensions.get( 'WEBGL_draw_buffers' ) ? '#extension GL_EXT_draw_buffers : require' : '',\r\n\t\t\t\t( extensions.shaderTextureLOD || parameters.envMap ) && rendererExtensions.get( 'EXT_shader_texture_lod' ) ? '#extension GL_EXT_shader_texture_lod : enable' : '',\r\n\t\t\t];\r\n\t\r\n\t\t\treturn chunks.filter( filterEmptyLine ).join( '\\n' );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction generateDefines( defines ) {\r\n\t\r\n\t\t\tvar chunks = [];\r\n\t\r\n\t\t\tfor ( var name in defines ) {\r\n\t\r\n\t\t\t\tvar value = defines[ name ];\r\n\t\r\n\t\t\t\tif ( value === false ) continue;\r\n\t\r\n\t\t\t\tchunks.push( '#define ' + name + ' ' + value );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn chunks.join( '\\n' );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction fetchAttributeLocations( gl, program, identifiers ) {\r\n\t\r\n\t\t\tvar attributes = {};\r\n\t\r\n\t\t\tvar n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );\r\n\t\r\n\t\t\tfor ( var i = 0; i < n; i ++ ) {\r\n\t\r\n\t\t\t\tvar info = gl.getActiveAttrib( program, i );\r\n\t\t\t\tvar name = info.name;\r\n\t\r\n\t\t\t\t// console.log(\"THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:\", name, i );\r\n\t\r\n\t\t\t\tattributes[ name ] = gl.getAttribLocation( program, name );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn attributes;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction filterEmptyLine( string ) {\r\n\t\r\n\t\t\treturn string !== '';\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction replaceLightNums( string, parameters ) {\r\n\t\r\n\t\t\treturn string\r\n\t\t\t\t.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )\r\n\t\t\t\t.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )\r\n\t\t\t\t.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )\r\n\t\t\t\t.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction parseIncludes( string ) {\r\n\t\r\n\t\t\tvar pattern = /#include +<([\\w\\d.]+)>/g;\r\n\t\r\n\t\t\tfunction replace( match, include ) {\r\n\t\r\n\t\t\t\tvar replace = THREE.ShaderChunk[ include ];\r\n\t\r\n\t\t\t\tif ( replace === undefined ) {\r\n\t\r\n\t\t\t\t\tthrow new Error( 'Can not resolve #include <' + include + '>' );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn parseIncludes( replace );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn string.replace( pattern, replace );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction unrollLoops( string ) {\r\n\t\r\n\t\t\tvar pattern = /for \\( int i \\= (\\d+)\\; i < (\\d+)\\; i \\+\\+ \\) \\{([\\s\\S]+?)(?=\\})\\}/g;\r\n\t\r\n\t\t\tfunction replace( match, start, end, snippet ) {\r\n\t\r\n\t\t\t\tvar unroll = '';\r\n\t\r\n\t\t\t\tfor ( var i = parseInt( start ); i < parseInt( end ); i ++ ) {\r\n\t\r\n\t\t\t\t\tunroll += snippet.replace( /\\[ i \\]/g, '[ ' + i + ' ]' );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn unroll;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn string.replace( pattern, replace );\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn function WebGLProgram( renderer, code, material, parameters ) {\r\n\t\r\n\t\t\tvar gl = renderer.context;\r\n\t\r\n\t\t\tvar extensions = material.extensions;\r\n\t\t\tvar defines = material.defines;\r\n\t\r\n\t\t\tvar vertexShader = material.__webglShader.vertexShader;\r\n\t\t\tvar fragmentShader = material.__webglShader.fragmentShader;\r\n\t\r\n\t\t\tvar shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';\r\n\t\r\n\t\t\tif ( parameters.shadowMapType === THREE.PCFShadowMap ) {\r\n\t\r\n\t\t\t\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';\r\n\t\r\n\t\t\t} else if ( parameters.shadowMapType === THREE.PCFSoftShadowMap ) {\r\n\t\r\n\t\t\t\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar envMapTypeDefine = 'ENVMAP_TYPE_CUBE';\r\n\t\t\tvar envMapModeDefine = 'ENVMAP_MODE_REFLECTION';\r\n\t\t\tvar envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\r\n\t\r\n\t\t\tif ( parameters.envMap ) {\r\n\t\r\n\t\t\t\tswitch ( material.envMap.mapping ) {\r\n\t\r\n\t\t\t\t\tcase THREE.CubeReflectionMapping:\r\n\t\t\t\t\tcase THREE.CubeRefractionMapping:\r\n\t\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_CUBE';\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase THREE.CubeUVReflectionMapping:\r\n\t\t\t\t\tcase THREE.CubeUVRefractionMapping:\r\n\t\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase THREE.EquirectangularReflectionMapping:\r\n\t\t\t\t\tcase THREE.EquirectangularRefractionMapping:\r\n\t\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase THREE.SphericalReflectionMapping:\r\n\t\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_SPHERE';\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tswitch ( material.envMap.mapping ) {\r\n\t\r\n\t\t\t\t\tcase THREE.CubeRefractionMapping:\r\n\t\t\t\t\tcase THREE.EquirectangularRefractionMapping:\r\n\t\t\t\t\t\tenvMapModeDefine = 'ENVMAP_MODE_REFRACTION';\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tswitch ( material.combine ) {\r\n\t\r\n\t\t\t\t\tcase THREE.MultiplyOperation:\r\n\t\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase THREE.MixOperation:\r\n\t\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MIX';\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase THREE.AddOperation:\r\n\t\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_ADD';\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;\r\n\t\r\n\t\t\t// console.log( 'building new program ' );\r\n\t\r\n\t\t\t//\r\n\t\r\n\t\t\tvar customExtensions = generateExtensions( extensions, parameters, renderer.extensions );\r\n\t\r\n\t\t\tvar customDefines = generateDefines( defines );\r\n\t\r\n\t\t\t//\r\n\t\r\n\t\t\tvar program = gl.createProgram();\r\n\t\r\n\t\t\tvar prefixVertex, prefixFragment;\r\n\t\r\n\t\t\tif ( material instanceof THREE.RawShaderMaterial ) {\r\n\t\r\n\t\t\t\tprefixVertex = '';\r\n\t\t\t\tprefixFragment = '';\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tprefixVertex = [\r\n\t\r\n\t\t\t\t\t'precision ' + parameters.precision + ' float;',\r\n\t\t\t\t\t'precision ' + parameters.precision + ' int;',\r\n\t\r\n\t\t\t\t\t'#define SHADER_NAME ' + material.__webglShader.name,\r\n\t\r\n\t\t\t\t\tcustomDefines,\r\n\t\r\n\t\t\t\t\tparameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',\r\n\t\r\n\t\t\t\t\t'#define GAMMA_FACTOR ' + gammaFactorDefine,\r\n\t\r\n\t\t\t\t\t'#define MAX_BONES ' + parameters.maxBones,\r\n\t\r\n\t\t\t\t\tparameters.map ? '#define USE_MAP' : '',\r\n\t\t\t\t\tparameters.envMap ? '#define USE_ENVMAP' : '',\r\n\t\t\t\t\tparameters.envMap ? '#define ' + envMapModeDefine : '',\r\n\t\t\t\t\tparameters.lightMap ? '#define USE_LIGHTMAP' : '',\r\n\t\t\t\t\tparameters.aoMap ? '#define USE_AOMAP' : '',\r\n\t\t\t\t\tparameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',\r\n\t\t\t\t\tparameters.bumpMap ? '#define USE_BUMPMAP' : '',\r\n\t\t\t\t\tparameters.normalMap ? '#define USE_NORMALMAP' : '',\r\n\t\t\t\t\tparameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',\r\n\t\t\t\t\tparameters.specularMap ? '#define USE_SPECULARMAP' : '',\r\n\t\t\t\t\tparameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',\r\n\t\t\t\t\tparameters.metalnessMap ? '#define USE_METALNESSMAP' : '',\r\n\t\t\t\t\tparameters.alphaMap ? '#define USE_ALPHAMAP' : '',\r\n\t\t\t\t\tparameters.vertexColors ? '#define USE_COLOR' : '',\r\n\t\r\n\t\t\t\t\tparameters.flatShading ? '#define FLAT_SHADED' : '',\r\n\t\r\n\t\t\t\t\tparameters.skinning ? '#define USE_SKINNING' : '',\r\n\t\t\t\t\tparameters.useVertexTexture ? '#define BONE_TEXTURE' : '',\r\n\t\r\n\t\t\t\t\tparameters.morphTargets ? '#define USE_MORPHTARGETS' : '',\r\n\t\t\t\t\tparameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',\r\n\t\t\t\t\tparameters.doubleSided ? '#define DOUBLE_SIDED' : '',\r\n\t\t\t\t\tparameters.flipSided ? '#define FLIP_SIDED' : '',\r\n\t\r\n\t\t\t\t\t'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,\r\n\t\r\n\t\t\t\t\tparameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\r\n\t\t\t\t\tparameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\r\n\t\r\n\t\t\t\t\tparameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',\r\n\t\r\n\t\t\t\t\tparameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\r\n\t\t\t\t\tparameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',\r\n\t\r\n\t\t\t\t\t'uniform mat4 modelMatrix;',\r\n\t\t\t\t\t'uniform mat4 modelViewMatrix;',\r\n\t\t\t\t\t'uniform mat4 projectionMatrix;',\r\n\t\t\t\t\t'uniform mat4 viewMatrix;',\r\n\t\t\t\t\t'uniform mat3 normalMatrix;',\r\n\t\t\t\t\t'uniform vec3 cameraPosition;',\r\n\t\r\n\t\t\t\t\t'attribute vec3 position;',\r\n\t\t\t\t\t'attribute vec3 normal;',\r\n\t\t\t\t\t'attribute vec2 uv;',\r\n\t\r\n\t\t\t\t\t'#ifdef USE_COLOR',\r\n\t\r\n\t\t\t\t\t'\tattribute vec3 color;',\r\n\t\r\n\t\t\t\t\t'#endif',\r\n\t\r\n\t\t\t\t\t'#ifdef USE_MORPHTARGETS',\r\n\t\r\n\t\t\t\t\t'\tattribute vec3 morphTarget0;',\r\n\t\t\t\t\t'\tattribute vec3 morphTarget1;',\r\n\t\t\t\t\t'\tattribute vec3 morphTarget2;',\r\n\t\t\t\t\t'\tattribute vec3 morphTarget3;',\r\n\t\r\n\t\t\t\t\t'\t#ifdef USE_MORPHNORMALS',\r\n\t\r\n\t\t\t\t\t'\t\tattribute vec3 morphNormal0;',\r\n\t\t\t\t\t'\t\tattribute vec3 morphNormal1;',\r\n\t\t\t\t\t'\t\tattribute vec3 morphNormal2;',\r\n\t\t\t\t\t'\t\tattribute vec3 morphNormal3;',\r\n\t\r\n\t\t\t\t\t'\t#else',\r\n\t\r\n\t\t\t\t\t'\t\tattribute vec3 morphTarget4;',\r\n\t\t\t\t\t'\t\tattribute vec3 morphTarget5;',\r\n\t\t\t\t\t'\t\tattribute vec3 morphTarget6;',\r\n\t\t\t\t\t'\t\tattribute vec3 morphTarget7;',\r\n\t\r\n\t\t\t\t\t'\t#endif',\r\n\t\r\n\t\t\t\t\t'#endif',\r\n\t\r\n\t\t\t\t\t'#ifdef USE_SKINNING',\r\n\t\r\n\t\t\t\t\t'\tattribute vec4 skinIndex;',\r\n\t\t\t\t\t'\tattribute vec4 skinWeight;',\r\n\t\r\n\t\t\t\t\t'#endif',\r\n\t\r\n\t\t\t\t\t'\\n'\r\n\t\r\n\t\t\t\t].filter( filterEmptyLine ).join( '\\n' );\r\n\t\r\n\t\t\t\tprefixFragment = [\r\n\t\r\n\t\t\t\t\tcustomExtensions,\r\n\t\r\n\t\t\t\t\t'precision ' + parameters.precision + ' float;',\r\n\t\t\t\t\t'precision ' + parameters.precision + ' int;',\r\n\t\r\n\t\t\t\t\t'#define SHADER_NAME ' + material.__webglShader.name,\r\n\t\r\n\t\t\t\t\tcustomDefines,\r\n\t\r\n\t\t\t\t\tparameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',\r\n\t\r\n\t\t\t\t\t'#define GAMMA_FACTOR ' + gammaFactorDefine,\r\n\t\r\n\t\t\t\t\t( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',\r\n\t\t\t\t\t( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',\r\n\t\r\n\t\t\t\t\tparameters.map ? '#define USE_MAP' : '',\r\n\t\t\t\t\tparameters.envMap ? '#define USE_ENVMAP' : '',\r\n\t\t\t\t\tparameters.envMap ? '#define ' + envMapTypeDefine : '',\r\n\t\t\t\t\tparameters.envMap ? '#define ' + envMapModeDefine : '',\r\n\t\t\t\t\tparameters.envMap ? '#define ' + envMapBlendingDefine : '',\r\n\t\t\t\t\tparameters.lightMap ? '#define USE_LIGHTMAP' : '',\r\n\t\t\t\t\tparameters.aoMap ? '#define USE_AOMAP' : '',\r\n\t\t\t\t\tparameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',\r\n\t\t\t\t\tparameters.bumpMap ? '#define USE_BUMPMAP' : '',\r\n\t\t\t\t\tparameters.normalMap ? '#define USE_NORMALMAP' : '',\r\n\t\t\t\t\tparameters.specularMap ? '#define USE_SPECULARMAP' : '',\r\n\t\t\t\t\tparameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',\r\n\t\t\t\t\tparameters.metalnessMap ? '#define USE_METALNESSMAP' : '',\r\n\t\t\t\t\tparameters.alphaMap ? '#define USE_ALPHAMAP' : '',\r\n\t\t\t\t\tparameters.vertexColors ? '#define USE_COLOR' : '',\r\n\t\r\n\t\t\t\t\tparameters.flatShading ? '#define FLAT_SHADED' : '',\r\n\t\r\n\t\t\t\t\tparameters.doubleSided ? '#define DOUBLE_SIDED' : '',\r\n\t\t\t\t\tparameters.flipSided ? '#define FLIP_SIDED' : '',\r\n\t\r\n\t\t\t\t\t'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,\r\n\t\r\n\t\t\t\t\tparameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\r\n\t\t\t\t\tparameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\r\n\t\r\n\t\t\t\t\tparameters.premultipliedAlpha ? \"#define PREMULTIPLIED_ALPHA\" : '',\r\n\t\r\n\t\t\t\t\tparameters.physicallyCorrectLights ? \"#define PHYSICALLY_CORRECT_LIGHTS\" : '',\r\n\t\r\n\t\t\t\t\tparameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\r\n\t\t\t\t\tparameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',\r\n\t\r\n\t\t\t\t\tparameters.envMap && renderer.extensions.get( 'EXT_shader_texture_lod' ) ? '#define TEXTURE_LOD_EXT' : '',\r\n\t\r\n\t\t\t\t\t'uniform mat4 viewMatrix;',\r\n\t\t\t\t\t'uniform vec3 cameraPosition;',\r\n\t\r\n\t\t\t\t\t( parameters.toneMapping !== THREE.NoToneMapping ) ? \"#define TONE_MAPPING\" : '',\r\n\t\t\t\t\t( parameters.toneMapping !== THREE.NoToneMapping ) ? THREE.ShaderChunk[ 'tonemapping_pars_fragment' ] : '',  // this code is required here because it is used by the toneMapping() function defined below\r\n\t\t\t\t\t( parameters.toneMapping !== THREE.NoToneMapping ) ? getToneMappingFunction( \"toneMapping\", parameters.toneMapping ) : '',\r\n\t\r\n\t\t\t\t\t( parameters.outputEncoding || parameters.mapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding ) ? THREE.ShaderChunk[ 'encodings_pars_fragment' ] : '', // this code is required here because it is used by the various encoding/decoding function defined below\r\n\t\t\t\t\tparameters.mapEncoding ? getTexelDecodingFunction( 'mapTexelToLinear', parameters.mapEncoding ) : '',\r\n\t\t\t\t\tparameters.envMapEncoding ? getTexelDecodingFunction( 'envMapTexelToLinear', parameters.envMapEncoding ) : '',\r\n\t\t\t\t\tparameters.emissiveMapEncoding ? getTexelDecodingFunction( 'emissiveMapTexelToLinear', parameters.emissiveMapEncoding ) : '',\r\n\t\t\t\t\tparameters.outputEncoding ? getTexelEncodingFunction( \"linearToOutputTexel\", parameters.outputEncoding ) : '',\r\n\t\r\n\t\t\t\t\tparameters.depthPacking ? \"#define DEPTH_PACKING \" + material.depthPacking : '',\r\n\t\r\n\t\t\t\t\t'\\n'\r\n\t\r\n\t\t\t\t].filter( filterEmptyLine ).join( '\\n' );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvertexShader = parseIncludes( vertexShader, parameters );\r\n\t\t\tvertexShader = replaceLightNums( vertexShader, parameters );\r\n\t\r\n\t\t\tfragmentShader = parseIncludes( fragmentShader, parameters );\r\n\t\t\tfragmentShader = replaceLightNums( fragmentShader, parameters );\r\n\t\r\n\t\t\tif ( material instanceof THREE.ShaderMaterial === false ) {\r\n\t\r\n\t\t\t\tvertexShader = unrollLoops( vertexShader );\r\n\t\t\t\tfragmentShader = unrollLoops( fragmentShader );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar vertexGlsl = prefixVertex + vertexShader;\r\n\t\t\tvar fragmentGlsl = prefixFragment + fragmentShader;\r\n\t\r\n\t\t\t// console.log( '*VERTEX*', vertexGlsl );\r\n\t\t\t// console.log( '*FRAGMENT*', fragmentGlsl );\r\n\t\r\n\t\t\tvar glVertexShader = THREE.WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );\r\n\t\t\tvar glFragmentShader = THREE.WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );\r\n\t\r\n\t\t\tgl.attachShader( program, glVertexShader );\r\n\t\t\tgl.attachShader( program, glFragmentShader );\r\n\t\r\n\t\t\t// Force a particular attribute to index 0.\r\n\t\r\n\t\t\tif ( material.index0AttributeName !== undefined ) {\r\n\t\r\n\t\t\t\tgl.bindAttribLocation( program, 0, material.index0AttributeName );\r\n\t\r\n\t\t\t} else if ( parameters.morphTargets === true ) {\r\n\t\r\n\t\t\t\t// programs with morphTargets displace position out of attribute 0\r\n\t\t\t\tgl.bindAttribLocation( program, 0, 'position' );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tgl.linkProgram( program );\r\n\t\r\n\t\t\tvar programLog = gl.getProgramInfoLog( program );\r\n\t\t\tvar vertexLog = gl.getShaderInfoLog( glVertexShader );\r\n\t\t\tvar fragmentLog = gl.getShaderInfoLog( glFragmentShader );\r\n\t\r\n\t\t\tvar runnable = true;\r\n\t\t\tvar haveDiagnostics = true;\r\n\t\r\n\t\t\t// console.log( '**VERTEX**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );\r\n\t\t\t// console.log( '**FRAGMENT**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );\r\n\t\r\n\t\t\tif ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {\r\n\t\r\n\t\t\t\trunnable = false;\r\n\t\r\n\t\t\t\tconsole.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter( program, gl.VALIDATE_STATUS ), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog );\r\n\t\r\n\t\t\t} else if ( programLog !== '' ) {\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );\r\n\t\r\n\t\t\t} else if ( vertexLog === '' || fragmentLog === '' ) {\r\n\t\r\n\t\t\t\thaveDiagnostics = false;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( haveDiagnostics ) {\r\n\t\r\n\t\t\t\tthis.diagnostics = {\r\n\t\r\n\t\t\t\t\trunnable: runnable,\r\n\t\t\t\t\tmaterial: material,\r\n\t\r\n\t\t\t\t\tprogramLog: programLog,\r\n\t\r\n\t\t\t\t\tvertexShader: {\r\n\t\r\n\t\t\t\t\t\tlog: vertexLog,\r\n\t\t\t\t\t\tprefix: prefixVertex\r\n\t\r\n\t\t\t\t\t},\r\n\t\r\n\t\t\t\t\tfragmentShader: {\r\n\t\r\n\t\t\t\t\t\tlog: fragmentLog,\r\n\t\t\t\t\t\tprefix: prefixFragment\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t};\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// clean up\r\n\t\r\n\t\t\tgl.deleteShader( glVertexShader );\r\n\t\t\tgl.deleteShader( glFragmentShader );\r\n\t\r\n\t\t\t// set up caching for uniform locations\r\n\t\r\n\t\t\tvar cachedUniforms;\r\n\t\r\n\t\t\tthis.getUniforms = function() {\r\n\t\r\n\t\t\t\tif ( cachedUniforms === undefined ) {\r\n\t\r\n\t\t\t\t\tcachedUniforms =\r\n\t\t\t\t\t\t\tnew THREE.WebGLUniforms( gl, program, renderer );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn cachedUniforms;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t\t// set up caching for attribute locations\r\n\t\r\n\t\t\tvar cachedAttributes;\r\n\t\r\n\t\t\tthis.getAttributes = function() {\r\n\t\r\n\t\t\t\tif ( cachedAttributes === undefined ) {\r\n\t\r\n\t\t\t\t\tcachedAttributes = fetchAttributeLocations( gl, program );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn cachedAttributes;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t\t// free resource\r\n\t\r\n\t\t\tthis.destroy = function() {\r\n\t\r\n\t\t\t\tgl.deleteProgram( program );\r\n\t\t\t\tthis.program = undefined;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t\t// DEPRECATED\r\n\t\r\n\t\t\tObject.defineProperties( this, {\r\n\t\r\n\t\t\t\tuniforms: {\r\n\t\t\t\t\tget: function() {\r\n\t\r\n\t\t\t\t\t\tconsole.warn( 'THREE.WebGLProgram: .uniforms is now .getUniforms().' );\r\n\t\t\t\t\t\treturn this.getUniforms();\r\n\t\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\t\r\n\t\t\t\tattributes: {\r\n\t\t\t\t\tget: function() {\r\n\t\r\n\t\t\t\t\t\tconsole.warn( 'THREE.WebGLProgram: .attributes is now .getAttributes().' );\r\n\t\t\t\t\t\treturn this.getAttributes();\r\n\t\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} );\r\n\t\r\n\t\r\n\t\t\t//\r\n\t\r\n\t\t\tthis.id = programIdCount ++;\r\n\t\t\tthis.code = code;\r\n\t\t\tthis.usedTimes = 1;\r\n\t\t\tthis.program = program;\r\n\t\t\tthis.vertexShader = glVertexShader;\r\n\t\t\tthis.fragmentShader = glFragmentShader;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t};\r\n\t\r\n\t} )();\r\n\t\r\n\t// File:src/renderers/webgl/WebGLPrograms.js\r\n\t\r\n\tTHREE.WebGLPrograms = function ( renderer, capabilities ) {\r\n\t\r\n\t\tvar programs = [];\r\n\t\r\n\t\tvar shaderIDs = {\r\n\t\t\tMeshDepthMaterial: 'depth',\r\n\t\t\tMeshNormalMaterial: 'normal',\r\n\t\t\tMeshBasicMaterial: 'basic',\r\n\t\t\tMeshLambertMaterial: 'lambert',\r\n\t\t\tMeshPhongMaterial: 'phong',\r\n\t\t\tMeshStandardMaterial: 'physical',\r\n\t\t\tMeshPhysicalMaterial: 'physical',\r\n\t\t\tLineBasicMaterial: 'basic',\r\n\t\t\tLineDashedMaterial: 'dashed',\r\n\t\t\tPointsMaterial: 'points'\r\n\t\t};\r\n\t\r\n\t\tvar parameterNames = [\r\n\t\t\t\"precision\", \"supportsVertexTextures\", \"map\", \"mapEncoding\", \"envMap\", \"envMapMode\", \"envMapEncoding\",\r\n\t\t\t\"lightMap\", \"aoMap\", \"emissiveMap\", \"emissiveMapEncoding\", \"bumpMap\", \"normalMap\", \"displacementMap\", \"specularMap\",\r\n\t\t\t\"roughnessMap\", \"metalnessMap\",\r\n\t\t\t\"alphaMap\", \"combine\", \"vertexColors\", \"fog\", \"useFog\", \"fogExp\",\r\n\t\t\t\"flatShading\", \"sizeAttenuation\", \"logarithmicDepthBuffer\", \"skinning\",\r\n\t\t\t\"maxBones\", \"useVertexTexture\", \"morphTargets\", \"morphNormals\",\r\n\t\t\t\"maxMorphTargets\", \"maxMorphNormals\", \"premultipliedAlpha\",\r\n\t\t\t\"numDirLights\", \"numPointLights\", \"numSpotLights\", \"numHemiLights\",\r\n\t\t\t\"shadowMapEnabled\", \"shadowMapType\", \"toneMapping\", 'physicallyCorrectLights',\r\n\t\t\t\"alphaTest\", \"doubleSided\", \"flipSided\", \"numClippingPlanes\", \"depthPacking\"\r\n\t\t];\r\n\t\r\n\t\r\n\t\tfunction allocateBones ( object ) {\r\n\t\r\n\t\t\tif ( capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture ) {\r\n\t\r\n\t\t\t\treturn 1024;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\t// default for when object is not specified\r\n\t\t\t\t// ( for example when prebuilding shader to be used with multiple objects )\r\n\t\t\t\t//\r\n\t\t\t\t//  - leave some extra space for other uniforms\r\n\t\t\t\t//  - limit here is ANGLE's 254 max uniform vectors\r\n\t\t\t\t//    (up to 54 should be safe)\r\n\t\r\n\t\t\t\tvar nVertexUniforms = capabilities.maxVertexUniforms;\r\n\t\t\t\tvar nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );\r\n\t\r\n\t\t\t\tvar maxBones = nVertexMatrices;\r\n\t\r\n\t\t\t\tif ( object !== undefined && object instanceof THREE.SkinnedMesh ) {\r\n\t\r\n\t\t\t\t\tmaxBones = Math.min( object.skeleton.bones.length, maxBones );\r\n\t\r\n\t\t\t\t\tif ( maxBones < object.skeleton.bones.length ) {\r\n\t\r\n\t\t\t\t\t\tconsole.warn( 'WebGLRenderer: too many bones - ' + object.skeleton.bones.length + ', this GPU supports just ' + maxBones + ' (try OpenGL instead of ANGLE)' );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn maxBones;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction getTextureEncodingFromMap( map, gammaOverrideLinear ) {\r\n\t\r\n\t\t\tvar encoding;\r\n\t\r\n\t\t\tif ( ! map ) {\r\n\t\r\n\t\t\t\tencoding = THREE.LinearEncoding;\r\n\t\r\n\t\t\t} else if ( map instanceof THREE.Texture ) {\r\n\t\r\n\t\t\t\tencoding = map.encoding;\r\n\t\r\n\t\t\t} else if ( map instanceof THREE.WebGLRenderTarget ) {\r\n\t\r\n\t\t\t\tencoding = map.texture.encoding;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// add backwards compatibility for WebGLRenderer.gammaInput/gammaOutput parameter, should probably be removed at some point.\r\n\t\t\tif ( encoding === THREE.LinearEncoding && gammaOverrideLinear ) {\r\n\t\r\n\t\t\t\tencoding = THREE.GammaEncoding;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn encoding;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.getParameters = function ( material, lights, fog, nClipPlanes, object ) {\r\n\t\r\n\t\t\tvar shaderID = shaderIDs[ material.type ];\r\n\t\r\n\t\t\t// heuristics to create shader parameters according to lights in the scene\r\n\t\t\t// (not to blow over maxLights budget)\r\n\t\r\n\t\t\tvar maxBones = allocateBones( object );\r\n\t\t\tvar precision = renderer.getPrecision();\r\n\t\r\n\t\t\tif ( material.precision !== null ) {\r\n\t\r\n\t\t\t\tprecision = capabilities.getMaxPrecision( material.precision );\r\n\t\r\n\t\t\t\tif ( precision !== material.precision ) {\r\n\t\r\n\t\t\t\t\tconsole.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar parameters = {\r\n\t\r\n\t\t\t\tshaderID: shaderID,\r\n\t\r\n\t\t\t\tprecision: precision,\r\n\t\t\t\tsupportsVertexTextures: capabilities.vertexTextures,\r\n\t\t\t\toutputEncoding: getTextureEncodingFromMap( renderer.getCurrentRenderTarget(), renderer.gammaOutput ),\r\n\t\t\t\tmap: !! material.map,\r\n\t\t\t\tmapEncoding: getTextureEncodingFromMap( material.map, renderer.gammaInput ),\r\n\t\t\t\tenvMap: !! material.envMap,\r\n\t\t\t\tenvMapMode: material.envMap && material.envMap.mapping,\r\n\t\t\t\tenvMapEncoding: getTextureEncodingFromMap( material.envMap, renderer.gammaInput ),\r\n\t\t\t\tenvMapCubeUV: ( !! material.envMap ) && ( ( material.envMap.mapping === THREE.CubeUVReflectionMapping ) || ( material.envMap.mapping === THREE.CubeUVRefractionMapping ) ),\r\n\t\t\t\tlightMap: !! material.lightMap,\r\n\t\t\t\taoMap: !! material.aoMap,\r\n\t\t\t\temissiveMap: !! material.emissiveMap,\r\n\t\t\t\temissiveMapEncoding: getTextureEncodingFromMap( material.emissiveMap, renderer.gammaInput ),\r\n\t\t\t\tbumpMap: !! material.bumpMap,\r\n\t\t\t\tnormalMap: !! material.normalMap,\r\n\t\t\t\tdisplacementMap: !! material.displacementMap,\r\n\t\t\t\troughnessMap: !! material.roughnessMap,\r\n\t\t\t\tmetalnessMap: !! material.metalnessMap,\r\n\t\t\t\tspecularMap: !! material.specularMap,\r\n\t\t\t\talphaMap: !! material.alphaMap,\r\n\t\r\n\t\t\t\tcombine: material.combine,\r\n\t\r\n\t\t\t\tvertexColors: material.vertexColors,\r\n\t\r\n\t\t\t\tfog: fog,\r\n\t\t\t\tuseFog: material.fog,\r\n\t\t\t\tfogExp: fog instanceof THREE.FogExp2,\r\n\t\r\n\t\t\t\tflatShading: material.shading === THREE.FlatShading,\r\n\t\r\n\t\t\t\tsizeAttenuation: material.sizeAttenuation,\r\n\t\t\t\tlogarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,\r\n\t\r\n\t\t\t\tskinning: material.skinning,\r\n\t\t\t\tmaxBones: maxBones,\r\n\t\t\t\tuseVertexTexture: capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture,\r\n\t\r\n\t\t\t\tmorphTargets: material.morphTargets,\r\n\t\t\t\tmorphNormals: material.morphNormals,\r\n\t\t\t\tmaxMorphTargets: renderer.maxMorphTargets,\r\n\t\t\t\tmaxMorphNormals: renderer.maxMorphNormals,\r\n\t\r\n\t\t\t\tnumDirLights: lights.directional.length,\r\n\t\t\t\tnumPointLights: lights.point.length,\r\n\t\t\t\tnumSpotLights: lights.spot.length,\r\n\t\t\t\tnumHemiLights: lights.hemi.length,\r\n\t\r\n\t\t\t\tnumClippingPlanes: nClipPlanes,\r\n\t\r\n\t\t\t\tshadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && lights.shadows.length > 0,\r\n\t\t\t\tshadowMapType: renderer.shadowMap.type,\r\n\t\r\n\t\t\t\ttoneMapping: renderer.toneMapping,\r\n\t\t\t\tphysicallyCorrectLights: renderer.physicallyCorrectLights,\r\n\t\r\n\t\t\t\tpremultipliedAlpha: material.premultipliedAlpha,\r\n\t\r\n\t\t\t\talphaTest: material.alphaTest,\r\n\t\t\t\tdoubleSided: material.side === THREE.DoubleSide,\r\n\t\t\t\tflipSided: material.side === THREE.BackSide,\r\n\t\r\n\t\t\t\tdepthPacking: ( material.depthPacking !== undefined ) ? material.depthPacking : false\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t\treturn parameters;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.getProgramCode = function ( material, parameters ) {\r\n\t\r\n\t\t\tvar array = [];\r\n\t\r\n\t\t\tif ( parameters.shaderID ) {\r\n\t\r\n\t\t\t\tarray.push( parameters.shaderID );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tarray.push( material.fragmentShader );\r\n\t\t\t\tarray.push( material.vertexShader );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( material.defines !== undefined ) {\r\n\t\r\n\t\t\t\tfor ( var name in material.defines ) {\r\n\t\r\n\t\t\t\t\tarray.push( name );\r\n\t\t\t\t\tarray.push( material.defines[ name ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( var i = 0; i < parameterNames.length; i ++ ) {\r\n\t\r\n\t\t\t\tarray.push( parameters[ parameterNames[ i ] ] );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn array.join();\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.acquireProgram = function ( material, parameters, code ) {\r\n\t\r\n\t\t\tvar program;\r\n\t\r\n\t\t\t// Check if code has been already compiled\r\n\t\t\tfor ( var p = 0, pl = programs.length; p < pl; p ++ ) {\r\n\t\r\n\t\t\t\tvar programInfo = programs[ p ];\r\n\t\r\n\t\t\t\tif ( programInfo.code === code ) {\r\n\t\r\n\t\t\t\t\tprogram = programInfo;\r\n\t\t\t\t\t++ program.usedTimes;\r\n\t\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( program === undefined ) {\r\n\t\r\n\t\t\t\tprogram = new THREE.WebGLProgram( renderer, code, material, parameters );\r\n\t\t\t\tprograms.push( program );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn program;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.releaseProgram = function( program ) {\r\n\t\r\n\t\t\tif ( -- program.usedTimes === 0 ) {\r\n\t\r\n\t\t\t\t// Remove from unordered set\r\n\t\t\t\tvar i = programs.indexOf( program );\r\n\t\t\t\tprograms[ i ] = programs[ programs.length - 1 ];\r\n\t\t\t\tprograms.pop();\r\n\t\r\n\t\t\t\t// Free WebGL resources\r\n\t\t\t\tprogram.destroy();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\t// Exposed for resource monitoring & error feedback via renderer.info:\r\n\t\tthis.programs = programs;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/renderers/webgl/WebGLProperties.js\r\n\t\r\n\t/**\r\n\t* @author fordacious / fordacious.github.io\r\n\t*/\r\n\t\r\n\tTHREE.WebGLProperties = function () {\r\n\t\r\n\t\tvar properties = {};\r\n\t\r\n\t\tthis.get = function ( object ) {\r\n\t\r\n\t\t\tvar uuid = object.uuid;\r\n\t\t\tvar map = properties[ uuid ];\r\n\t\r\n\t\t\tif ( map === undefined ) {\r\n\t\r\n\t\t\t\tmap = {};\r\n\t\t\t\tproperties[ uuid ] = map;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn map;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.delete = function ( object ) {\r\n\t\r\n\t\t\tdelete properties[ object.uuid ];\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.clear = function () {\r\n\t\r\n\t\t\tproperties = {};\r\n\t\r\n\t\t};\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/renderers/webgl/WebGLShader.js\r\n\t\r\n\tTHREE.WebGLShader = ( function () {\r\n\t\r\n\t\tfunction addLineNumbers( string ) {\r\n\t\r\n\t\t\tvar lines = string.split( '\\n' );\r\n\t\r\n\t\t\tfor ( var i = 0; i < lines.length; i ++ ) {\r\n\t\r\n\t\t\t\tlines[ i ] = ( i + 1 ) + ': ' + lines[ i ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn lines.join( '\\n' );\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn function WebGLShader( gl, type, string ) {\r\n\t\r\n\t\t\tvar shader = gl.createShader( type );\r\n\t\r\n\t\t\tgl.shaderSource( shader, string );\r\n\t\t\tgl.compileShader( shader );\r\n\t\r\n\t\t\tif ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {\r\n\t\r\n\t\t\t\tconsole.error( 'THREE.WebGLShader: Shader couldn\\'t compile.' );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( gl.getShaderInfoLog( shader ) !== '' ) {\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// --enable-privileged-webgl-extension\r\n\t\t\t// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );\r\n\t\r\n\t\t\treturn shader;\r\n\t\r\n\t\t};\r\n\t\r\n\t} )();\r\n\t\r\n\t// File:src/renderers/webgl/WebGLShadowMap.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.WebGLShadowMap = function ( _renderer, _lights, _objects ) {\r\n\t\r\n\t\tvar _gl = _renderer.context,\r\n\t\t_state = _renderer.state,\r\n\t\t_frustum = new THREE.Frustum(),\r\n\t\t_projScreenMatrix = new THREE.Matrix4(),\r\n\t\r\n\t\t_lightShadows = _lights.shadows,\r\n\t\r\n\t\t_shadowMapSize = new THREE.Vector2(),\r\n\t\r\n\t\t_lookTarget = new THREE.Vector3(),\r\n\t\t_lightPositionWorld = new THREE.Vector3(),\r\n\t\r\n\t\t_renderList = [],\r\n\t\r\n\t\t_MorphingFlag = 1,\r\n\t\t_SkinningFlag = 2,\r\n\t\r\n\t\t_NumberOfMaterialVariants = ( _MorphingFlag | _SkinningFlag ) + 1,\r\n\t\r\n\t\t_depthMaterials = new Array( _NumberOfMaterialVariants ),\r\n\t\t_distanceMaterials = new Array( _NumberOfMaterialVariants ),\r\n\t\r\n\t\t_materialCache = {};\r\n\t\r\n\t\tvar cubeDirections = [\r\n\t\t\tnew THREE.Vector3( 1, 0, 0 ), new THREE.Vector3( - 1, 0, 0 ), new THREE.Vector3( 0, 0, 1 ),\r\n\t\t\tnew THREE.Vector3( 0, 0, - 1 ), new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, - 1, 0 )\r\n\t\t];\r\n\t\r\n\t\tvar cubeUps = [\r\n\t\t\tnew THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, 1, 0 ),\r\n\t\t\tnew THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, 0, 1 ),\tnew THREE.Vector3( 0, 0, - 1 )\r\n\t\t];\r\n\t\r\n\t\tvar cube2DViewPorts = [\r\n\t\t\tnew THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4(),\r\n\t\t\tnew THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4()\r\n\t\t];\r\n\t\r\n\t\t// init\r\n\t\r\n\t\tvar depthMaterialTemplate = new THREE.MeshDepthMaterial();\r\n\t\tdepthMaterialTemplate.depthPacking = THREE.RGBADepthPacking;\r\n\t\tdepthMaterialTemplate.clipping = true;\r\n\t\r\n\t\tvar distanceShader = THREE.ShaderLib[ \"distanceRGBA\" ];\r\n\t\tvar distanceUniforms = THREE.UniformsUtils.clone( distanceShader.uniforms );\r\n\t\r\n\t\tfor ( var i = 0; i !== _NumberOfMaterialVariants; ++ i ) {\r\n\t\r\n\t\t\tvar useMorphing = ( i & _MorphingFlag ) !== 0;\r\n\t\t\tvar useSkinning = ( i & _SkinningFlag ) !== 0;\r\n\t\r\n\t\t\tvar depthMaterial = depthMaterialTemplate.clone();\r\n\t\t\tdepthMaterial.morphTargets = useMorphing;\r\n\t\t\tdepthMaterial.skinning = useSkinning;\r\n\t\r\n\t\t\t_depthMaterials[ i ] = depthMaterial;\r\n\t\r\n\t\t\tvar distanceMaterial = new THREE.ShaderMaterial( {\r\n\t\t\t\tdefines: {\r\n\t\t\t\t\t'USE_SHADOWMAP': ''\r\n\t\t\t\t},\r\n\t\t\t\tuniforms: distanceUniforms,\r\n\t\t\t\tvertexShader: distanceShader.vertexShader,\r\n\t\t\t\tfragmentShader: distanceShader.fragmentShader,\r\n\t\t\t\tmorphTargets: useMorphing,\r\n\t\t\t\tskinning: useSkinning,\r\n\t\t\t\tclipping: true\r\n\t\t\t} );\r\n\t\r\n\t\t\t_distanceMaterials[ i ] = distanceMaterial;\r\n\t\r\n\t\t}\r\n\t\r\n\t\t//\r\n\t\r\n\t\tvar scope = this;\r\n\t\r\n\t\tthis.enabled = false;\r\n\t\r\n\t\tthis.autoUpdate = true;\r\n\t\tthis.needsUpdate = false;\r\n\t\r\n\t\tthis.type = THREE.PCFShadowMap;\r\n\t\tthis.cullFace = THREE.CullFaceFront;\r\n\t\r\n\t\tthis.render = function ( scene, camera ) {\r\n\t\r\n\t\t\tif ( scope.enabled === false ) return;\r\n\t\t\tif ( scope.autoUpdate === false && scope.needsUpdate === false ) return;\r\n\t\r\n\t\t\tif ( _lightShadows.length === 0 ) return;\r\n\t\r\n\t\t\t// Set GL state for depth map.\r\n\t\t\t_state.clearColor( 1, 1, 1, 1 );\r\n\t\t\t_state.disable( _gl.BLEND );\r\n\t\t\t_state.enable( _gl.CULL_FACE );\r\n\t\t\t_gl.frontFace( _gl.CCW );\r\n\t\t\t_gl.cullFace( scope.cullFace === THREE.CullFaceFront ? _gl.FRONT : _gl.BACK );\r\n\t\t\t_state.setDepthTest( true );\r\n\t\t\t_state.setScissorTest( false );\r\n\t\r\n\t\t\t// render depth map\r\n\t\r\n\t\t\tvar faceCount, isPointLight;\r\n\t\r\n\t\t\tfor ( var i = 0, il = _lightShadows.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tvar light = _lightShadows[ i ];\r\n\t\r\n\t\t\t\tvar shadow = light.shadow;\r\n\t\t\t\tvar shadowCamera = shadow.camera;\r\n\t\r\n\t\t\t\t_shadowMapSize.copy( shadow.mapSize );\r\n\t\r\n\t\t\t\tif ( light instanceof THREE.PointLight ) {\r\n\t\r\n\t\t\t\t\tfaceCount = 6;\r\n\t\t\t\t\tisPointLight = true;\r\n\t\r\n\t\t\t\t\tvar vpWidth = _shadowMapSize.x;\r\n\t\t\t\t\tvar vpHeight = _shadowMapSize.y;\r\n\t\r\n\t\t\t\t\t// These viewports map a cube-map onto a 2D texture with the\r\n\t\t\t\t\t// following orientation:\r\n\t\t\t\t\t//\r\n\t\t\t\t\t//  xzXZ\r\n\t\t\t\t\t//   y Y\r\n\t\t\t\t\t//\r\n\t\t\t\t\t// X - Positive x direction\r\n\t\t\t\t\t// x - Negative x direction\r\n\t\t\t\t\t// Y - Positive y direction\r\n\t\t\t\t\t// y - Negative y direction\r\n\t\t\t\t\t// Z - Positive z direction\r\n\t\t\t\t\t// z - Negative z direction\r\n\t\r\n\t\t\t\t\t// positive X\r\n\t\t\t\t\tcube2DViewPorts[ 0 ].set( vpWidth * 2, vpHeight, vpWidth, vpHeight );\r\n\t\t\t\t\t// negative X\r\n\t\t\t\t\tcube2DViewPorts[ 1 ].set( 0, vpHeight, vpWidth, vpHeight );\r\n\t\t\t\t\t// positive Z\r\n\t\t\t\t\tcube2DViewPorts[ 2 ].set( vpWidth * 3, vpHeight, vpWidth, vpHeight );\r\n\t\t\t\t\t// negative Z\r\n\t\t\t\t\tcube2DViewPorts[ 3 ].set( vpWidth, vpHeight, vpWidth, vpHeight );\r\n\t\t\t\t\t// positive Y\r\n\t\t\t\t\tcube2DViewPorts[ 4 ].set( vpWidth * 3, 0, vpWidth, vpHeight );\r\n\t\t\t\t\t// negative Y\r\n\t\t\t\t\tcube2DViewPorts[ 5 ].set( vpWidth, 0, vpWidth, vpHeight );\r\n\t\r\n\t\t\t\t\t_shadowMapSize.x *= 4.0;\r\n\t\t\t\t\t_shadowMapSize.y *= 2.0;\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tfaceCount = 1;\r\n\t\t\t\t\tisPointLight = false;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( shadow.map === null ) {\r\n\t\r\n\t\t\t\t\tvar pars = { minFilter: THREE.NearestFilter, magFilter: THREE.NearestFilter, format: THREE.RGBAFormat };\r\n\t\r\n\t\t\t\t\tshadow.map = new THREE.WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );\r\n\t\r\n\t\t\t\t\tshadowCamera.updateProjectionMatrix();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( shadow instanceof THREE.SpotLightShadow ) {\r\n\t\r\n\t\t\t\t\tshadow.update( light );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar shadowMap = shadow.map;\r\n\t\t\t\tvar shadowMatrix = shadow.matrix;\r\n\t\r\n\t\t\t\t_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );\r\n\t\t\t\tshadowCamera.position.copy( _lightPositionWorld );\r\n\t\r\n\t\t\t\t_renderer.setRenderTarget( shadowMap );\r\n\t\t\t\t_renderer.clear();\r\n\t\r\n\t\t\t\t// render shadow map for each cube face (if omni-directional) or\r\n\t\t\t\t// run a single pass if not\r\n\t\r\n\t\t\t\tfor ( var face = 0; face < faceCount; face ++ ) {\r\n\t\r\n\t\t\t\t\tif ( isPointLight ) {\r\n\t\r\n\t\t\t\t\t\t_lookTarget.copy( shadowCamera.position );\r\n\t\t\t\t\t\t_lookTarget.add( cubeDirections[ face ] );\r\n\t\t\t\t\t\tshadowCamera.up.copy( cubeUps[ face ] );\r\n\t\t\t\t\t\tshadowCamera.lookAt( _lookTarget );\r\n\t\r\n\t\t\t\t\t\tvar vpDimensions = cube2DViewPorts[ face ];\r\n\t\t\t\t\t\t_state.viewport( vpDimensions );\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t_lookTarget.setFromMatrixPosition( light.target.matrixWorld );\r\n\t\t\t\t\t\tshadowCamera.lookAt( _lookTarget );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tshadowCamera.updateMatrixWorld();\r\n\t\t\t\t\tshadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );\r\n\t\r\n\t\t\t\t\t// compute shadow matrix\r\n\t\r\n\t\t\t\t\tshadowMatrix.set(\r\n\t\t\t\t\t\t0.5, 0.0, 0.0, 0.5,\r\n\t\t\t\t\t\t0.0, 0.5, 0.0, 0.5,\r\n\t\t\t\t\t\t0.0, 0.0, 0.5, 0.5,\r\n\t\t\t\t\t\t0.0, 0.0, 0.0, 1.0\r\n\t\t\t\t\t);\r\n\t\r\n\t\t\t\t\tshadowMatrix.multiply( shadowCamera.projectionMatrix );\r\n\t\t\t\t\tshadowMatrix.multiply( shadowCamera.matrixWorldInverse );\r\n\t\r\n\t\t\t\t\t// update camera matrices and frustum\r\n\t\r\n\t\t\t\t\t_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );\r\n\t\t\t\t\t_frustum.setFromMatrix( _projScreenMatrix );\r\n\t\r\n\t\t\t\t\t// set object matrices & frustum culling\r\n\t\r\n\t\t\t\t\t_renderList.length = 0;\r\n\t\r\n\t\t\t\t\tprojectObject( scene, camera, shadowCamera );\r\n\t\r\n\t\t\t\t\t// render shadow map\r\n\t\t\t\t\t// render regular objects\r\n\t\r\n\t\t\t\t\tfor ( var j = 0, jl = _renderList.length; j < jl; j ++ ) {\r\n\t\r\n\t\t\t\t\t\tvar object = _renderList[ j ];\r\n\t\t\t\t\t\tvar geometry = _objects.update( object );\r\n\t\t\t\t\t\tvar material = object.material;\r\n\t\r\n\t\t\t\t\t\tif ( material instanceof THREE.MultiMaterial ) {\r\n\t\r\n\t\t\t\t\t\t\tvar groups = geometry.groups;\r\n\t\t\t\t\t\t\tvar materials = material.materials;\r\n\t\r\n\t\t\t\t\t\t\tfor ( var k = 0, kl = groups.length; k < kl; k ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\tvar group = groups[ k ];\r\n\t\t\t\t\t\t\t\tvar groupMaterial = materials[ group.materialIndex ];\r\n\t\r\n\t\t\t\t\t\t\t\tif ( groupMaterial.visible === true ) {\r\n\t\r\n\t\t\t\t\t\t\t\t\tvar depthMaterial = getDepthMaterial( object, groupMaterial, isPointLight, _lightPositionWorld );\r\n\t\t\t\t\t\t\t\t\t_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );\r\n\t\r\n\t\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\tvar depthMaterial = getDepthMaterial( object, material, isPointLight, _lightPositionWorld );\r\n\t\t\t\t\t\t\t_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// Restore GL state.\r\n\t\t\tvar clearColor = _renderer.getClearColor(),\r\n\t\t\tclearAlpha = _renderer.getClearAlpha();\r\n\t\t\t_renderer.setClearColor( clearColor, clearAlpha );\r\n\t\r\n\t\t\t_state.enable( _gl.BLEND );\r\n\t\r\n\t\t\tif ( scope.cullFace === THREE.CullFaceFront ) {\r\n\t\r\n\t\t\t\t_gl.cullFace( _gl.BACK );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tscope.needsUpdate = false;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tfunction getDepthMaterial( object, material, isPointLight, lightPositionWorld ) {\r\n\t\r\n\t\t\tvar geometry = object.geometry;\r\n\t\r\n\t\t\tvar result = null;\r\n\t\r\n\t\t\tvar materialVariants = _depthMaterials;\r\n\t\t\tvar customMaterial = object.customDepthMaterial;\r\n\t\r\n\t\t\tif ( isPointLight ) {\r\n\t\r\n\t\t\t\tmaterialVariants = _distanceMaterials;\r\n\t\t\t\tcustomMaterial = object.customDistanceMaterial;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( ! customMaterial ) {\r\n\t\r\n\t\t\t\tvar useMorphing = geometry.morphTargets !== undefined &&\r\n\t\t\t\t\t\tgeometry.morphTargets.length > 0 && material.morphTargets;\r\n\t\r\n\t\t\t\tvar useSkinning = object instanceof THREE.SkinnedMesh && material.skinning;\r\n\t\r\n\t\t\t\tvar variantIndex = 0;\r\n\t\r\n\t\t\t\tif ( useMorphing ) variantIndex |= _MorphingFlag;\r\n\t\t\t\tif ( useSkinning ) variantIndex |= _SkinningFlag;\r\n\t\r\n\t\t\t\tresult = materialVariants[ variantIndex ];\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tresult = customMaterial;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( _renderer.localClippingEnabled &&\r\n\t\t\t\t material.clipShadows === true &&\r\n\t\t\t\t\tmaterial.clippingPlanes.length !== 0 ) {\r\n\t\r\n\t\t\t\t// in this case we need a unique material instance reflecting the\r\n\t\t\t\t// appropriate state\r\n\t\r\n\t\t\t\tvar keyA = result.uuid, keyB = material.uuid;\r\n\t\r\n\t\t\t\tvar materialsForVariant = _materialCache[ keyA ];\r\n\t\r\n\t\t\t\tif ( materialsForVariant === undefined ) {\r\n\t\r\n\t\t\t\t\tmaterialsForVariant = {};\r\n\t\t\t\t\t_materialCache[ keyA ] = materialsForVariant;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar cachedMaterial = materialsForVariant[ keyB ];\r\n\t\r\n\t\t\t\tif ( cachedMaterial === undefined ) {\r\n\t\r\n\t\t\t\t\tcachedMaterial = result.clone();\r\n\t\t\t\t\tmaterialsForVariant[ keyB ] = cachedMaterial;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tresult = cachedMaterial;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tresult.visible = material.visible;\r\n\t\t\tresult.wireframe = material.wireframe;\r\n\t\t\tresult.side = material.side;\r\n\t\t\tresult.clipShadows = material.clipShadows;\r\n\t\t\tresult.clippingPlanes = material.clippingPlanes;\r\n\t\t\tresult.wireframeLinewidth = material.wireframeLinewidth;\r\n\t\t\tresult.linewidth = material.linewidth;\r\n\t\r\n\t\t\tif ( isPointLight && result.uniforms.lightPos !== undefined ) {\r\n\t\r\n\t\t\t\tresult.uniforms.lightPos.value.copy( lightPositionWorld );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn result;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction projectObject( object, camera, shadowCamera ) {\r\n\t\r\n\t\t\tif ( object.visible === false ) return;\r\n\t\r\n\t\t\tif ( object.layers.test( camera.layers ) && ( object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Points ) ) {\r\n\t\r\n\t\t\t\tif ( object.castShadow && ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) ) {\r\n\t\r\n\t\t\t\t\tvar material = object.material;\r\n\t\r\n\t\t\t\t\tif ( material.visible === true ) {\r\n\t\r\n\t\t\t\t\t\tobject.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );\r\n\t\t\t\t\t\t_renderList.push( object );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar children = object.children;\r\n\t\r\n\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tprojectObject( children[ i ], camera, shadowCamera );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/renderers/webgl/WebGLState.js\r\n\t\r\n\t/**\r\n\t* @author mrdoob / http://mrdoob.com/\r\n\t*/\r\n\t\r\n\tTHREE.WebGLState = function ( gl, extensions, paramThreeToGL ) {\r\n\t\r\n\t\tvar _this = this;\r\n\t\r\n\t\tvar color = new THREE.Vector4();\r\n\t\r\n\t\tvar maxVertexAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );\r\n\t\tvar newAttributes = new Uint8Array( maxVertexAttributes );\r\n\t\tvar enabledAttributes = new Uint8Array( maxVertexAttributes );\r\n\t\tvar attributeDivisors = new Uint8Array( maxVertexAttributes );\r\n\t\r\n\t\tvar capabilities = {};\r\n\t\r\n\t\tvar compressedTextureFormats = null;\r\n\t\r\n\t\tvar currentBlending = null;\r\n\t\tvar currentBlendEquation = null;\r\n\t\tvar currentBlendSrc = null;\r\n\t\tvar currentBlendDst = null;\r\n\t\tvar currentBlendEquationAlpha = null;\r\n\t\tvar currentBlendSrcAlpha = null;\r\n\t\tvar currentBlendDstAlpha = null;\r\n\t\tvar currentPremultipledAlpha = false;\r\n\t\r\n\t\tvar currentDepthFunc = null;\r\n\t\tvar currentDepthWrite = null;\r\n\t\r\n\t\tvar currentColorWrite = null;\r\n\t\r\n\t\tvar currentStencilWrite = null;\r\n\t\tvar currentStencilFunc = null;\r\n\t\tvar currentStencilRef = null;\r\n\t\tvar currentStencilMask = null;\r\n\t\tvar currentStencilFail  = null;\r\n\t\tvar currentStencilZFail = null;\r\n\t\tvar currentStencilZPass = null;\r\n\t\r\n\t\tvar currentFlipSided = null;\r\n\t\r\n\t\tvar currentLineWidth = null;\r\n\t\r\n\t\tvar currentPolygonOffsetFactor = null;\r\n\t\tvar currentPolygonOffsetUnits = null;\r\n\t\r\n\t\tvar currentScissorTest = null;\r\n\t\r\n\t\tvar maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );\r\n\t\r\n\t\tvar currentTextureSlot = undefined;\r\n\t\tvar currentBoundTextures = {};\r\n\t\r\n\t\tvar currentClearColor = new THREE.Vector4();\r\n\t\tvar currentClearDepth = null;\r\n\t\tvar currentClearStencil = null;\r\n\t\r\n\t\tvar currentScissor = new THREE.Vector4();\r\n\t\tvar currentViewport = new THREE.Vector4();\r\n\t\r\n\t\tthis.init = function () {\r\n\t\r\n\t\t\tthis.clearColor( 0, 0, 0, 1 );\r\n\t\t\tthis.clearDepth( 1 );\r\n\t\t\tthis.clearStencil( 0 );\r\n\t\r\n\t\t\tthis.enable( gl.DEPTH_TEST );\r\n\t\t\tgl.depthFunc( gl.LEQUAL );\r\n\t\r\n\t\t\tgl.frontFace( gl.CCW );\r\n\t\t\tgl.cullFace( gl.BACK );\r\n\t\t\tthis.enable( gl.CULL_FACE );\r\n\t\r\n\t\t\tthis.enable( gl.BLEND );\r\n\t\t\tgl.blendEquation( gl.FUNC_ADD );\r\n\t\t\tgl.blendFunc( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.initAttributes = function () {\r\n\t\r\n\t\t\tfor ( var i = 0, l = newAttributes.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tnewAttributes[ i ] = 0;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.enableAttribute = function ( attribute ) {\r\n\t\r\n\t\t\tnewAttributes[ attribute ] = 1;\r\n\t\r\n\t\t\tif ( enabledAttributes[ attribute ] === 0 ) {\r\n\t\r\n\t\t\t\tgl.enableVertexAttribArray( attribute );\r\n\t\t\t\tenabledAttributes[ attribute ] = 1;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( attributeDivisors[ attribute ] !== 0 ) {\r\n\t\r\n\t\t\t\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\r\n\t\r\n\t\t\t\textension.vertexAttribDivisorANGLE( attribute, 0 );\r\n\t\t\t\tattributeDivisors[ attribute ] = 0;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.enableAttributeAndDivisor = function ( attribute, meshPerAttribute, extension ) {\r\n\t\r\n\t\t\tnewAttributes[ attribute ] = 1;\r\n\t\r\n\t\t\tif ( enabledAttributes[ attribute ] === 0 ) {\r\n\t\r\n\t\t\t\tgl.enableVertexAttribArray( attribute );\r\n\t\t\t\tenabledAttributes[ attribute ] = 1;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( attributeDivisors[ attribute ] !== meshPerAttribute ) {\r\n\t\r\n\t\t\t\textension.vertexAttribDivisorANGLE( attribute, meshPerAttribute );\r\n\t\t\t\tattributeDivisors[ attribute ] = meshPerAttribute;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.disableUnusedAttributes = function () {\r\n\t\r\n\t\t\tfor ( var i = 0, l = enabledAttributes.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tif ( enabledAttributes[ i ] !== newAttributes[ i ] ) {\r\n\t\r\n\t\t\t\t\tgl.disableVertexAttribArray( i );\r\n\t\t\t\t\tenabledAttributes[ i ] = 0;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.enable = function ( id ) {\r\n\t\r\n\t\t\tif ( capabilities[ id ] !== true ) {\r\n\t\r\n\t\t\t\tgl.enable( id );\r\n\t\t\t\tcapabilities[ id ] = true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.disable = function ( id ) {\r\n\t\r\n\t\t\tif ( capabilities[ id ] !== false ) {\r\n\t\r\n\t\t\t\tgl.disable( id );\r\n\t\t\t\tcapabilities[ id ] = false;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.getCompressedTextureFormats = function () {\r\n\t\r\n\t\t\tif ( compressedTextureFormats === null ) {\r\n\t\r\n\t\t\t\tcompressedTextureFormats = [];\r\n\t\r\n\t\t\t\tif ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) ||\r\n\t\t\t\t     extensions.get( 'WEBGL_compressed_texture_s3tc' ) ||\r\n\t\t\t\t     extensions.get( 'WEBGL_compressed_texture_etc1' ) ) {\r\n\t\r\n\t\t\t\t\tvar formats = gl.getParameter( gl.COMPRESSED_TEXTURE_FORMATS );\r\n\t\r\n\t\t\t\t\tfor ( var i = 0; i < formats.length; i ++ ) {\r\n\t\r\n\t\t\t\t\t\tcompressedTextureFormats.push( formats[ i ] );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn compressedTextureFormats;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setBlending = function ( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {\r\n\t\r\n\t\t\tif ( blending === THREE.NoBlending ) {\r\n\t\r\n\t\t\t\tthis.disable( gl.BLEND );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tthis.enable( gl.BLEND );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {\r\n\t\r\n\t\t\t\tif ( blending === THREE.AdditiveBlending ) {\r\n\t\r\n\t\t\t\t\tif ( premultipliedAlpha ) {\r\n\t\r\n\t\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\r\n\t\t\t\t\t\tgl.blendFuncSeparate( gl.ONE, gl.ONE, gl.ONE, gl.ONE );\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\r\n\t\t\t\t\t\tgl.blendFunc( gl.SRC_ALPHA, gl.ONE );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else if ( blending === THREE.SubtractiveBlending ) {\r\n\t\r\n\t\t\t\t\tif ( premultipliedAlpha ) {\r\n\t\r\n\t\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\r\n\t\t\t\t\t\tgl.blendFuncSeparate( gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA );\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\r\n\t\t\t\t\t\tgl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else if ( blending === THREE.MultiplyBlending ) {\r\n\t\r\n\t\t\t\t\tif ( premultipliedAlpha ) {\r\n\t\r\n\t\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\r\n\t\t\t\t\t\tgl.blendFuncSeparate( gl.ZERO, gl.ZERO, gl.SRC_COLOR, gl.SRC_ALPHA );\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\r\n\t\t\t\t\t\tgl.blendFunc( gl.ZERO, gl.SRC_COLOR );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tif ( premultipliedAlpha ) {\r\n\t\r\n\t\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\r\n\t\t\t\t\t\tgl.blendFuncSeparate( gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\r\n\t\t\t\t\t\tgl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tcurrentBlending = blending;\r\n\t\t\t\tcurrentPremultipledAlpha = premultipliedAlpha;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( blending === THREE.CustomBlending ) {\r\n\t\r\n\t\t\t\tblendEquationAlpha = blendEquationAlpha || blendEquation;\r\n\t\t\t\tblendSrcAlpha = blendSrcAlpha || blendSrc;\r\n\t\t\t\tblendDstAlpha = blendDstAlpha || blendDst;\r\n\t\r\n\t\t\t\tif ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {\r\n\t\r\n\t\t\t\t\tgl.blendEquationSeparate( paramThreeToGL( blendEquation ), paramThreeToGL( blendEquationAlpha ) );\r\n\t\r\n\t\t\t\t\tcurrentBlendEquation = blendEquation;\r\n\t\t\t\t\tcurrentBlendEquationAlpha = blendEquationAlpha;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {\r\n\t\r\n\t\t\t\t\tgl.blendFuncSeparate( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ), paramThreeToGL( blendSrcAlpha ), paramThreeToGL( blendDstAlpha ) );\r\n\t\r\n\t\t\t\t\tcurrentBlendSrc = blendSrc;\r\n\t\t\t\t\tcurrentBlendDst = blendDst;\r\n\t\t\t\t\tcurrentBlendSrcAlpha = blendSrcAlpha;\r\n\t\t\t\t\tcurrentBlendDstAlpha = blendDstAlpha;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tcurrentBlendEquation = null;\r\n\t\t\t\tcurrentBlendSrc = null;\r\n\t\t\t\tcurrentBlendDst = null;\r\n\t\t\t\tcurrentBlendEquationAlpha = null;\r\n\t\t\t\tcurrentBlendSrcAlpha = null;\r\n\t\t\t\tcurrentBlendDstAlpha = null;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setDepthFunc = function ( depthFunc ) {\r\n\t\r\n\t\t\tif ( currentDepthFunc !== depthFunc ) {\r\n\t\r\n\t\t\t\tif ( depthFunc ) {\r\n\t\r\n\t\t\t\t\tswitch ( depthFunc ) {\r\n\t\r\n\t\t\t\t\t\tcase THREE.NeverDepth:\r\n\t\r\n\t\t\t\t\t\t\tgl.depthFunc( gl.NEVER );\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tcase THREE.AlwaysDepth:\r\n\t\r\n\t\t\t\t\t\t\tgl.depthFunc( gl.ALWAYS );\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tcase THREE.LessDepth:\r\n\t\r\n\t\t\t\t\t\t\tgl.depthFunc( gl.LESS );\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tcase THREE.LessEqualDepth:\r\n\t\r\n\t\t\t\t\t\t\tgl.depthFunc( gl.LEQUAL );\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tcase THREE.EqualDepth:\r\n\t\r\n\t\t\t\t\t\t\tgl.depthFunc( gl.EQUAL );\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tcase THREE.GreaterEqualDepth:\r\n\t\r\n\t\t\t\t\t\t\tgl.depthFunc( gl.GEQUAL );\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tcase THREE.GreaterDepth:\r\n\t\r\n\t\t\t\t\t\t\tgl.depthFunc( gl.GREATER );\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tcase THREE.NotEqualDepth:\r\n\t\r\n\t\t\t\t\t\t\tgl.depthFunc( gl.NOTEQUAL );\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tdefault:\r\n\t\r\n\t\t\t\t\t\t\tgl.depthFunc( gl.LEQUAL );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tgl.depthFunc( gl.LEQUAL );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tcurrentDepthFunc = depthFunc;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setDepthTest = function ( depthTest ) {\r\n\t\r\n\t\t\tif ( depthTest ) {\r\n\t\r\n\t\t\t\tthis.enable( gl.DEPTH_TEST );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tthis.disable( gl.DEPTH_TEST );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setDepthWrite = function ( depthWrite ) {\r\n\t\r\n\t\t\t// TODO: Rename to setDepthMask\r\n\t\r\n\t\t\tif ( currentDepthWrite !== depthWrite ) {\r\n\t\r\n\t\t\t\tgl.depthMask( depthWrite );\r\n\t\t\t\tcurrentDepthWrite = depthWrite;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setColorWrite = function ( colorWrite ) {\r\n\t\r\n\t\t\t// TODO: Rename to setColorMask\r\n\t\r\n\t\t\tif ( currentColorWrite !== colorWrite ) {\r\n\t\r\n\t\t\t\tgl.colorMask( colorWrite, colorWrite, colorWrite, colorWrite );\r\n\t\t\t\tcurrentColorWrite = colorWrite;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setStencilFunc = function ( stencilFunc, stencilRef, stencilMask ) {\r\n\t\r\n\t\t\tif ( currentStencilFunc !== stencilFunc ||\r\n\t\t\t\t\t currentStencilRef \t!== stencilRef \t||\r\n\t\t\t\t\t currentStencilMask !== stencilMask ) {\r\n\t\r\n\t\t\t\tgl.stencilFunc( stencilFunc,  stencilRef, stencilMask );\r\n\t\r\n\t\t\t\tcurrentStencilFunc = stencilFunc;\r\n\t\t\t\tcurrentStencilRef  = stencilRef;\r\n\t\t\t\tcurrentStencilMask = stencilMask;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setStencilOp = function ( stencilFail, stencilZFail, stencilZPass ) {\r\n\t\r\n\t\t\tif ( currentStencilFail\t !== stencilFail \t||\r\n\t\t\t\t\t currentStencilZFail !== stencilZFail ||\r\n\t\t\t\t\t currentStencilZPass !== stencilZPass ) {\r\n\t\r\n\t\t\t\tgl.stencilOp( stencilFail,  stencilZFail, stencilZPass );\r\n\t\r\n\t\t\t\tcurrentStencilFail  = stencilFail;\r\n\t\t\t\tcurrentStencilZFail = stencilZFail;\r\n\t\t\t\tcurrentStencilZPass = stencilZPass;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setStencilTest = function ( stencilTest ) {\r\n\t\r\n\t\t\tif ( stencilTest ) {\r\n\t\r\n\t\t\t\tthis.enable( gl.STENCIL_TEST );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tthis.disable( gl.STENCIL_TEST );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setStencilWrite = function ( stencilWrite ) {\r\n\t\r\n\t\t\t// TODO: Rename to setStencilMask\r\n\t\r\n\t\t\tif ( currentStencilWrite !== stencilWrite ) {\r\n\t\r\n\t\t\t\tgl.stencilMask( stencilWrite );\r\n\t\t\t\tcurrentStencilWrite = stencilWrite;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setFlipSided = function ( flipSided ) {\r\n\t\r\n\t\t\tif ( currentFlipSided !== flipSided ) {\r\n\t\r\n\t\t\t\tif ( flipSided ) {\r\n\t\r\n\t\t\t\t\tgl.frontFace( gl.CW );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tgl.frontFace( gl.CCW );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tcurrentFlipSided = flipSided;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setLineWidth = function ( width ) {\r\n\t\r\n\t\t\tif ( width !== currentLineWidth ) {\r\n\t\r\n\t\t\t\tgl.lineWidth( width );\r\n\t\r\n\t\t\t\tcurrentLineWidth = width;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setPolygonOffset = function ( polygonOffset, factor, units ) {\r\n\t\r\n\t\t\tif ( polygonOffset ) {\r\n\t\r\n\t\t\t\tthis.enable( gl.POLYGON_OFFSET_FILL );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tthis.disable( gl.POLYGON_OFFSET_FILL );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( polygonOffset && ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) ) {\r\n\t\r\n\t\t\t\tgl.polygonOffset( factor, units );\r\n\t\r\n\t\t\t\tcurrentPolygonOffsetFactor = factor;\r\n\t\t\t\tcurrentPolygonOffsetUnits = units;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.getScissorTest = function () {\r\n\t\r\n\t\t\treturn currentScissorTest;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setScissorTest = function ( scissorTest ) {\r\n\t\r\n\t\t\tcurrentScissorTest = scissorTest;\r\n\t\r\n\t\t\tif ( scissorTest ) {\r\n\t\r\n\t\t\t\tthis.enable( gl.SCISSOR_TEST );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tthis.disable( gl.SCISSOR_TEST );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\t// texture\r\n\t\r\n\t\tthis.activeTexture = function ( webglSlot ) {\r\n\t\r\n\t\t\tif ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;\r\n\t\r\n\t\t\tif ( currentTextureSlot !== webglSlot ) {\r\n\t\r\n\t\t\t\tgl.activeTexture( webglSlot );\r\n\t\t\t\tcurrentTextureSlot = webglSlot;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.bindTexture = function ( webglType, webglTexture ) {\r\n\t\r\n\t\t\tif ( currentTextureSlot === undefined ) {\r\n\t\r\n\t\t\t\t_this.activeTexture();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar boundTexture = currentBoundTextures[ currentTextureSlot ];\r\n\t\r\n\t\t\tif ( boundTexture === undefined ) {\r\n\t\r\n\t\t\t\tboundTexture = { type: undefined, texture: undefined };\r\n\t\t\t\tcurrentBoundTextures[ currentTextureSlot ] = boundTexture;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {\r\n\t\r\n\t\t\t\tgl.bindTexture( webglType, webglTexture );\r\n\t\r\n\t\t\t\tboundTexture.type = webglType;\r\n\t\t\t\tboundTexture.texture = webglTexture;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.compressedTexImage2D = function () {\r\n\t\r\n\t\t\ttry {\r\n\t\r\n\t\t\t\tgl.compressedTexImage2D.apply( gl, arguments );\r\n\t\r\n\t\t\t} catch ( error ) {\r\n\t\r\n\t\t\t\tconsole.error( error );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.texImage2D = function () {\r\n\t\r\n\t\t\ttry {\r\n\t\r\n\t\t\t\tgl.texImage2D.apply( gl, arguments );\r\n\t\r\n\t\t\t} catch ( error ) {\r\n\t\r\n\t\t\t\tconsole.error( error );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\t// clear values\r\n\t\r\n\t\tthis.clearColor = function ( r, g, b, a ) {\r\n\t\r\n\t\t\tcolor.set( r, g, b, a );\r\n\t\r\n\t\t\tif ( currentClearColor.equals( color ) === false ) {\r\n\t\r\n\t\t\t\tgl.clearColor( r, g, b, a );\r\n\t\t\t\tcurrentClearColor.copy( color );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.clearDepth = function ( depth ) {\r\n\t\r\n\t\t\tif ( currentClearDepth !== depth ) {\r\n\t\r\n\t\t\t\tgl.clearDepth( depth );\r\n\t\t\t\tcurrentClearDepth = depth;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.clearStencil = function ( stencil ) {\r\n\t\r\n\t\t\tif ( currentClearStencil !== stencil ) {\r\n\t\r\n\t\t\t\tgl.clearStencil( stencil );\r\n\t\t\t\tcurrentClearStencil = stencil;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\t//\r\n\t\r\n\t\tthis.scissor = function ( scissor ) {\r\n\t\r\n\t\t\tif ( currentScissor.equals( scissor ) === false ) {\r\n\t\r\n\t\t\t\tgl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );\r\n\t\t\t\tcurrentScissor.copy( scissor );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.viewport = function ( viewport ) {\r\n\t\r\n\t\t\tif ( currentViewport.equals( viewport ) === false ) {\r\n\t\r\n\t\t\t\tgl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );\r\n\t\t\t\tcurrentViewport.copy( viewport );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\t//\r\n\t\r\n\t\tthis.reset = function () {\r\n\t\r\n\t\t\tfor ( var i = 0; i < enabledAttributes.length; i ++ ) {\r\n\t\r\n\t\t\t\tif ( enabledAttributes[ i ] === 1 ) {\r\n\t\r\n\t\t\t\t\tgl.disableVertexAttribArray( i );\r\n\t\t\t\t\tenabledAttributes[ i ] = 0;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tcapabilities = {};\r\n\t\r\n\t\t\tcompressedTextureFormats = null;\r\n\t\r\n\t\t\tcurrentTextureSlot = undefined;\r\n\t\t\tcurrentBoundTextures = {};\r\n\t\r\n\t\t\tcurrentBlending = null;\r\n\t\r\n\t\t\tcurrentColorWrite = null;\r\n\t\t\tcurrentDepthWrite = null;\r\n\t\t\tcurrentStencilWrite = null;\r\n\t\r\n\t\t\tcurrentFlipSided = null;\r\n\t\r\n\t\t};\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/renderers/webgl/WebGLUniforms.js\r\n\t\r\n\t/**\r\n\t *\r\n\t * Uniforms of a program.\r\n\t * Those form a tree structure with a special top-level container for the root,\r\n\t * which you get by calling 'new WebGLUniforms( gl, program, renderer )'.\r\n\t *\r\n\t *\r\n\t * Properties of inner nodes including the top-level container:\r\n\t *\r\n\t * .seq - array of nested uniforms\r\n\t * .map - nested uniforms by name\r\n\t *\r\n\t *\r\n\t * Methods of all nodes except the top-level container:\r\n\t *\r\n\t * .setValue( gl, value, [renderer] )\r\n\t *\r\n\t * \t\tuploads a uniform value(s)\r\n\t *  \tthe 'renderer' parameter is needed for sampler uniforms\r\n\t *\r\n\t *\r\n\t * Static methods of the top-level container (renderer factorizations):\r\n\t *\r\n\t * .upload( gl, seq, values, renderer )\r\n\t *\r\n\t * \t\tsets uniforms in 'seq' to 'values[id].value'\r\n\t *\r\n\t * .seqWithValue( seq, values ) : filteredSeq\r\n\t *\r\n\t * \t\tfilters 'seq' entries with corresponding entry in values\r\n\t *\r\n\t * .splitDynamic( seq, values ) : filteredSeq\r\n\t *\r\n\t * \t\tfilters 'seq' entries with dynamic entry and removes them from 'seq'\r\n\t *\r\n\t *\r\n\t * Methods of the top-level container (renderer factorizations):\r\n\t *\r\n\t * .setValue( gl, name, value )\r\n\t *\r\n\t * \t\tsets uniform with  name 'name' to 'value'\r\n\t *\r\n\t * .set( gl, obj, prop )\r\n\t *\r\n\t * \t\tsets uniform from object and property with same name than uniform\r\n\t *\r\n\t * .setOptional( gl, obj, prop )\r\n\t *\r\n\t * \t\tlike .set for an optional property of the object\r\n\t *\r\n\t *\r\n\t * @author tschw\r\n\t *\r\n\t */\r\n\t\r\n\tTHREE.WebGLUniforms = ( function() { // scope\r\n\t\r\n\t\t// --- Base for inner nodes (including the root) ---\r\n\t\r\n\t\tvar UniformContainer = function() {\r\n\t\r\n\t\t\t\tthis.seq = [];\r\n\t\t\t\tthis.map = {};\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t// --- Utilities ---\r\n\t\r\n\t\t// Array Caches (provide typed arrays for temporary by size)\r\n\t\r\n\t\t\tarrayCacheF32 = [],\r\n\t\t\tarrayCacheI32 = [],\r\n\t\r\n\t\t\tuncacheTemporaryArrays = function() {\r\n\t\r\n\t\t\t\tarrayCacheF32.length = 0;\r\n\t\t\t\tarrayCacheI32.length = 0;\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t// Flattening for arrays of vectors and matrices\r\n\t\r\n\t\t\tflatten = function( array, nBlocks, blockSize ) {\r\n\t\r\n\t\t\t\tvar firstElem = array[ 0 ];\r\n\t\r\n\t\t\t\tif ( firstElem <= 0 || firstElem > 0 ) return array;\r\n\t\t\t\t// unoptimized: ! isNaN( firstElem )\r\n\t\t\t\t// see http://jacksondunstan.com/articles/983\r\n\t\r\n\t\t\t\tvar n = nBlocks * blockSize,\r\n\t\t\t\t\tr = arrayCacheF32[ n ];\r\n\t\r\n\t\t\t\tif ( r === undefined ) {\r\n\t\r\n\t\t\t\t\tr = new Float32Array( n );\r\n\t\t\t\t\tarrayCacheF32[ n ] = r;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( nBlocks !== 0 ) {\r\n\t\r\n\t\t\t\t\tfirstElem.toArray( r, 0 );\r\n\t\r\n\t\t\t\t\tfor ( var i = 1, offset = 0; i !== nBlocks; ++ i ) {\r\n\t\r\n\t\t\t\t\t\toffset += blockSize;\r\n\t\t\t\t\t\tarray[ i ].toArray( r, offset );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn r;\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t// Texture unit allocation\r\n\t\r\n\t\t\tallocTexUnits = function( renderer, n ) {\r\n\t\r\n\t\t\t\tvar r = arrayCacheI32[ n ];\r\n\t\r\n\t\t\t\tif ( r === undefined ) {\r\n\t\r\n\t\t\t\t\tr = new Int32Array( n );\r\n\t\t\t\t\tarrayCacheI32[ n ] = r;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tfor ( var i = 0; i !== n; ++ i )\r\n\t\t\t\t\tr[ i ] = renderer.allocTextureUnit();\r\n\t\r\n\t\t\t\treturn r;\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t// --- Setters ---\r\n\t\r\n\t\t// Note: Defining these methods externally, because they come in a bunch\r\n\t\t// and this way their names minify.\r\n\t\r\n\t\t\t// Single scalar\r\n\t\r\n\t\t\tsetValue1f = function( gl, v ) { gl.uniform1f( this.addr, v ); },\r\n\t\t\tsetValue1i = function( gl, v ) { gl.uniform1i( this.addr, v ); },\r\n\t\r\n\t\t\t// Single float vector (from flat array or THREE.VectorN)\r\n\t\r\n\t\t\tsetValue2fv = function( gl, v ) {\r\n\t\r\n\t\t\t\tif ( v.x === undefined ) gl.uniform2fv( this.addr, v );\r\n\t\t\t\telse gl.uniform2f( this.addr, v.x, v.y );\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t\tsetValue3fv = function( gl, v ) {\r\n\t\r\n\t\t\t\tif ( v.x !== undefined )\r\n\t\t\t\t\tgl.uniform3f( this.addr, v.x, v.y, v.z );\r\n\t\t\t\telse if ( v.r !== undefined )\r\n\t\t\t\t\tgl.uniform3f( this.addr, v.r, v.g, v.b );\r\n\t\t\t\telse\r\n\t\t\t\t\tgl.uniform3fv( this.addr, v );\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t\tsetValue4fv = function( gl, v ) {\r\n\t\r\n\t\t\t\tif ( v.x === undefined ) gl.uniform4fv( this.addr, v );\r\n\t\t\t\telse gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t\t// Single matrix (from flat array or MatrixN)\r\n\t\r\n\t\t\tsetValue2fm = function( gl, v ) {\r\n\t\r\n\t\t\t\tgl.uniformMatrix2fv( this.addr, false, v.elements || v );\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t\tsetValue3fm = function( gl, v ) {\r\n\t\r\n\t\t\t\tgl.uniformMatrix3fv( this.addr, false, v.elements || v );\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t\tsetValue4fm = function( gl, v ) {\r\n\t\r\n\t\t\t\tgl.uniformMatrix4fv( this.addr, false, v.elements || v );\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t\t// Single texture (2D / Cube)\r\n\t\r\n\t\t\tsetValueT1 = function( gl, v, renderer ) {\r\n\t\r\n\t\t\t\tvar unit = renderer.allocTextureUnit();\r\n\t\t\t\tgl.uniform1i( this.addr, unit );\r\n\t\t\t\tif ( v ) renderer.setTexture2D( v, unit );\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t\tsetValueT6 = function( gl, v, renderer ) {\r\n\t\r\n\t\t\t\tvar unit = renderer.allocTextureUnit();\r\n\t\t\t\tgl.uniform1i( this.addr, unit );\r\n\t\t\t\tif ( v ) renderer.setTextureCube( v, unit );\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t\t// Integer / Boolean vectors or arrays thereof (always flat arrays)\r\n\t\r\n\t\t\tsetValue2iv = function( gl, v ) { gl.uniform2iv( this.addr, v ); },\r\n\t\t\tsetValue3iv = function( gl, v ) { gl.uniform3iv( this.addr, v ); },\r\n\t\t\tsetValue4iv = function( gl, v ) { gl.uniform4iv( this.addr, v ); },\r\n\t\r\n\t\t\t// Helper to pick the right setter for the singular case\r\n\t\r\n\t\t\tgetSingularSetter = function( type ) {\r\n\t\r\n\t\t\t\tswitch ( type ) {\r\n\t\r\n\t\t\t\t\tcase 0x1406: return setValue1f; // FLOAT\r\n\t\t\t\t\tcase 0x8b50: return setValue2fv; // _VEC2\r\n\t\t\t\t\tcase 0x8b51: return setValue3fv; // _VEC3\r\n\t\t\t\t\tcase 0x8b52: return setValue4fv; // _VEC4\r\n\t\r\n\t\t\t\t\tcase 0x8b5a: return setValue2fm; // _MAT2\r\n\t\t\t\t\tcase 0x8b5b: return setValue3fm; // _MAT3\r\n\t\t\t\t\tcase 0x8b5c: return setValue4fm; // _MAT4\r\n\t\r\n\t\t\t\t\tcase 0x8b5e: return setValueT1; // SAMPLER_2D\r\n\t\t\t\t\tcase 0x8b60: return setValueT6; // SAMPLER_CUBE\r\n\t\r\n\t\t\t\t\tcase 0x1404: case 0x8b56: return setValue1i; // INT, BOOL\r\n\t\t\t\t\tcase 0x8b53: case 0x8b57: return setValue2iv; // _VEC2\r\n\t\t\t\t\tcase 0x8b54: case 0x8b58: return setValue3iv; // _VEC3\r\n\t\t\t\t\tcase 0x8b55: case 0x8b59: return setValue4iv; // _VEC4\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t\t// Array of scalars\r\n\t\r\n\t\t\tsetValue1fv = function( gl, v ) { gl.uniform1fv( this.addr, v ); },\r\n\t\t\tsetValue1iv = function( gl, v ) { gl.uniform1iv( this.addr, v ); },\r\n\t\r\n\t\t\t// Array of vectors (flat or from THREE classes)\r\n\t\r\n\t\t\tsetValueV2a = function( gl, v ) {\r\n\t\r\n\t\t\t\tgl.uniform2fv( this.addr, flatten( v, this.size, 2 ) );\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t\tsetValueV3a = function( gl, v ) {\r\n\t\r\n\t\t\t\tgl.uniform3fv( this.addr, flatten( v, this.size, 3 ) );\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t\tsetValueV4a = function( gl, v ) {\r\n\t\r\n\t\t\t\tgl.uniform4fv( this.addr, flatten( v, this.size, 4 ) );\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t\t// Array of matrices (flat or from THREE clases)\r\n\t\r\n\t\t\tsetValueM2a = function( gl, v ) {\r\n\t\r\n\t\t\t\tgl.uniformMatrix2fv( this.addr, false, flatten( v, this.size, 4 ) );\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t\tsetValueM3a = function( gl, v ) {\r\n\t\r\n\t\t\t\tgl.uniformMatrix3fv( this.addr, false, flatten( v, this.size, 9 ) );\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t\tsetValueM4a = function( gl, v ) {\r\n\t\r\n\t\t\t\tgl.uniformMatrix4fv( this.addr, false, flatten( v, this.size, 16 ) );\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t\t// Array of textures (2D / Cube)\r\n\t\r\n\t\t\tsetValueT1a = function( gl, v, renderer ) {\r\n\t\r\n\t\t\t\tvar n = v.length,\r\n\t\t\t\t\tunits = allocTexUnits( renderer, n );\r\n\t\r\n\t\t\t\tgl.uniform1iv( this.addr, units );\r\n\t\r\n\t\t\t\tfor ( var i = 0; i !== n; ++ i ) {\r\n\t\r\n\t\t\t\t\tvar tex = v[ i ];\r\n\t\t\t\t\tif ( tex ) renderer.setTexture2D( tex, units[ i ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t\tsetValueT6a = function( gl, v, renderer ) {\r\n\t\r\n\t\t\t\tvar n = v.length,\r\n\t\t\t\t\tunits = allocTexUnits( renderer, n );\r\n\t\r\n\t\t\t\tgl.uniform1iv( this.addr, units );\r\n\t\r\n\t\t\t\tfor ( var i = 0; i !== n; ++ i ) {\r\n\t\r\n\t\t\t\t\tvar tex = v[ i ];\r\n\t\t\t\t\tif ( tex ) renderer.setTextureCube( tex, units[ i ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\r\n\t\t\t// Helper to pick the right setter for a pure (bottom-level) array\r\n\t\r\n\t\t\tgetPureArraySetter = function( type ) {\r\n\t\r\n\t\t\t\tswitch ( type ) {\r\n\t\r\n\t\t\t\t\tcase 0x1406: return setValue1fv; // FLOAT\r\n\t\t\t\t\tcase 0x8b50: return setValueV2a; // _VEC2\r\n\t\t\t\t\tcase 0x8b51: return setValueV3a; // _VEC3\r\n\t\t\t\t\tcase 0x8b52: return setValueV4a; // _VEC4\r\n\t\r\n\t\t\t\t\tcase 0x8b5a: return setValueM2a; // _MAT2\r\n\t\t\t\t\tcase 0x8b5b: return setValueM3a; // _MAT3\r\n\t\t\t\t\tcase 0x8b5c: return setValueM4a; // _MAT4\r\n\t\r\n\t\t\t\t\tcase 0x8b5e: return setValueT1a; // SAMPLER_2D\r\n\t\t\t\t\tcase 0x8b60: return setValueT6a; // SAMPLER_CUBE\r\n\t\r\n\t\t\t\t\tcase 0x1404: case 0x8b56: return setValue1iv; // INT, BOOL\r\n\t\t\t\t\tcase 0x8b53: case 0x8b57: return setValue2iv; // _VEC2\r\n\t\t\t\t\tcase 0x8b54: case 0x8b58: return setValue3iv; // _VEC3\r\n\t\t\t\t\tcase 0x8b55: case 0x8b59: return setValue4iv; // _VEC4\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t// --- Uniform Classes ---\r\n\t\r\n\t\t\tSingleUniform = function SingleUniform( id, activeInfo, addr ) {\r\n\t\r\n\t\t\t\tthis.id = id;\r\n\t\t\t\tthis.addr = addr;\r\n\t\t\t\tthis.setValue = getSingularSetter( activeInfo.type );\r\n\t\r\n\t\t\t\t// this.path = activeInfo.name; // DEBUG\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t\tPureArrayUniform = function( id, activeInfo, addr ) {\r\n\t\r\n\t\t\t\tthis.id = id;\r\n\t\t\t\tthis.addr = addr;\r\n\t\t\t\tthis.size = activeInfo.size;\r\n\t\t\t\tthis.setValue = getPureArraySetter( activeInfo.type );\r\n\t\r\n\t\t\t\t// this.path = activeInfo.name; // DEBUG\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t\tStructuredUniform = function( id ) {\r\n\t\r\n\t\t\t\tthis.id = id;\r\n\t\r\n\t\t\t\tUniformContainer.call( this ); // mix-in\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\tStructuredUniform.prototype.setValue = function( gl, value ) {\r\n\t\r\n\t\t\t// Note: Don't need an extra 'renderer' parameter, since samplers\r\n\t\t\t// are not allowed in structured uniforms.\r\n\t\r\n\t\t\tvar seq = this.seq;\r\n\t\r\n\t\t\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\r\n\t\r\n\t\t\t\tvar u = seq[ i ];\r\n\t\t\t\tu.setValue( gl, value[ u.id ] );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\t// --- Top-level ---\r\n\t\r\n\t\t// Parser - builds up the property tree from the path strings\r\n\t\r\n\t\tvar RePathPart = /([\\w\\d_]+)(\\])?(\\[|\\.)?/g,\r\n\t\t\t// extracts\r\n\t\t\t// \t- the identifier (member name or array index)\r\n\t\t\t//  - followed by an optional right bracket (found when array index)\r\n\t\t\t//  - followed by an optional left bracket or dot (type of subscript)\r\n\t\t\t//\r\n\t\t\t// Note: These portions can be read in a non-overlapping fashion and\r\n\t\t\t// allow straightforward parsing of the hierarchy that WebGL encodes\r\n\t\t\t// in the uniform names.\r\n\t\r\n\t\t\taddUniform = function( container, uniformObject ) {\r\n\t\r\n\t\t\t\tcontainer.seq.push( uniformObject );\r\n\t\t\t\tcontainer.map[ uniformObject.id ] = uniformObject;\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t\tparseUniform = function( activeInfo, addr, container ) {\r\n\t\r\n\t\t\t\tvar path = activeInfo.name,\r\n\t\t\t\t\tpathLength = path.length;\r\n\t\r\n\t\t\t\t// reset RegExp object, because of the early exit of a previous run\r\n\t\t\t\tRePathPart.lastIndex = 0;\r\n\t\r\n\t\t\t\tfor (; ;) {\r\n\t\r\n\t\t\t\t\tvar match = RePathPart.exec( path ),\r\n\t\t\t\t\t\tmatchEnd = RePathPart.lastIndex,\r\n\t\r\n\t\t\t\t\t\tid = match[ 1 ],\r\n\t\t\t\t\t\tidIsIndex = match[ 2 ] === ']',\r\n\t\t\t\t\t\tsubscript = match[ 3 ];\r\n\t\r\n\t\t\t\t\tif ( idIsIndex ) id = id | 0; // convert to integer\r\n\t\r\n\t\t\t\t\tif ( subscript === undefined ||\r\n\t\t\t\t\t\t\tsubscript === '[' && matchEnd + 2 === pathLength ) {\r\n\t\t\t\t\t\t// bare name or \"pure\" bottom-level array \"[0]\" suffix\r\n\t\r\n\t\t\t\t\t\taddUniform( container, subscript === undefined ?\r\n\t\t\t\t\t\t\t\tnew SingleUniform( id, activeInfo, addr ) :\r\n\t\t\t\t\t\t\t\tnew PureArrayUniform( id, activeInfo, addr ) );\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// step into inner node / create it in case it doesn't exist\r\n\t\r\n\t\t\t\t\t\tvar map = container.map,\r\n\t\t\t\t\t\t\tnext = map[ id ];\r\n\t\r\n\t\t\t\t\t\tif ( next === undefined ) {\r\n\t\r\n\t\t\t\t\t\t\tnext = new StructuredUniform( id );\r\n\t\t\t\t\t\t\taddUniform( container, next );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tcontainer = next;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t// Root Container\r\n\t\r\n\t\t\tWebGLUniforms = function WebGLUniforms( gl, program, renderer ) {\r\n\t\r\n\t\t\t\tUniformContainer.call( this );\r\n\t\r\n\t\t\t\tthis.renderer = renderer;\r\n\t\r\n\t\t\t\tvar n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );\r\n\t\r\n\t\t\t\tfor ( var i = 0; i !== n; ++ i ) {\r\n\t\r\n\t\t\t\t\tvar info = gl.getActiveUniform( program, i ),\r\n\t\t\t\t\t\tpath = info.name,\r\n\t\t\t\t\t\taddr = gl.getUniformLocation( program, path );\r\n\t\r\n\t\t\t\t\tparseUniform( info, addr, this );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\r\n\t\tWebGLUniforms.prototype.setValue = function( gl, name, value ) {\r\n\t\r\n\t\t\tvar u = this.map[ name ];\r\n\t\r\n\t\t\tif ( u !== undefined ) u.setValue( gl, value, this.renderer );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tWebGLUniforms.prototype.set = function( gl, object, name ) {\r\n\t\r\n\t\t\tvar u = this.map[ name ];\r\n\t\r\n\t\t\tif ( u !== undefined ) u.setValue( gl, object[ name ], this.renderer );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tWebGLUniforms.prototype.setOptional = function( gl, object, name ) {\r\n\t\r\n\t\t\tvar v = object[ name ];\r\n\t\r\n\t\t\tif ( v !== undefined ) this.setValue( gl, name, v );\r\n\t\r\n\t\t};\r\n\t\r\n\t\r\n\t\t// Static interface\r\n\t\r\n\t\tWebGLUniforms.upload = function( gl, seq, values, renderer ) {\r\n\t\r\n\t\t\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\r\n\t\r\n\t\t\t\tvar u = seq[ i ],\r\n\t\t\t\t\tv = values[ u.id ];\r\n\t\r\n\t\t\t\tif ( v.needsUpdate !== false ) {\r\n\t\t\t\t\t// note: always updating when .needsUpdate is undefined\r\n\t\r\n\t\t\t\t\tu.setValue( gl, v.value, renderer );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tWebGLUniforms.seqWithValue = function( seq, values ) {\r\n\t\r\n\t\t\tvar r = [];\r\n\t\r\n\t\t\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\r\n\t\r\n\t\t\t\tvar u = seq[ i ];\r\n\t\t\t\tif ( u.id in values ) r.push( u );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn r;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tWebGLUniforms.splitDynamic = function( seq, values ) {\r\n\t\r\n\t\t\tvar r = null,\r\n\t\t\t\tn = seq.length,\r\n\t\t\t\tw = 0;\r\n\t\r\n\t\t\tfor ( var i = 0; i !== n; ++ i ) {\r\n\t\r\n\t\t\t\tvar u = seq[ i ],\r\n\t\t\t\t\tv = values[ u.id ];\r\n\t\r\n\t\t\t\tif ( v && v.dynamic === true ) {\r\n\t\r\n\t\t\t\t\tif ( r === null ) r = [];\r\n\t\t\t\t\tr.push( u );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t// in-place compact 'seq', removing the matches\r\n\t\t\t\t\tif ( w < i ) seq[ w ] = u;\r\n\t\t\t\t\t++ w;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( w < n ) seq.length = w;\r\n\t\r\n\t\t\treturn r;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tWebGLUniforms.evalDynamic = function( seq, values, object, camera ) {\r\n\t\r\n\t\t\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\r\n\t\r\n\t\t\t\tvar v = values[ seq[ i ].id ],\r\n\t\t\t\t\tf = v.onUpdateCallback;\r\n\t\r\n\t\t\t\tif ( f !== undefined ) f.call( v, object, camera );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\treturn WebGLUniforms;\r\n\t\r\n\t} )();\r\n\t\r\n\t\r\n\t// File:src/renderers/webgl/plugins/LensFlarePlugin.js\r\n\t\r\n\t/**\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.LensFlarePlugin = function ( renderer, flares ) {\r\n\t\r\n\t\tvar gl = renderer.context;\r\n\t\tvar state = renderer.state;\r\n\t\r\n\t\tvar vertexBuffer, elementBuffer;\r\n\t\tvar shader, program, attributes, uniforms;\r\n\t\r\n\t\tvar tempTexture, occlusionTexture;\r\n\t\r\n\t\tfunction init() {\r\n\t\r\n\t\t\tvar vertices = new Float32Array( [\r\n\t\t\t\t- 1, - 1,  0, 0,\r\n\t\t\t\t 1, - 1,  1, 0,\r\n\t\t\t\t 1,  1,  1, 1,\r\n\t\t\t\t- 1,  1,  0, 1\r\n\t\t\t] );\r\n\t\r\n\t\t\tvar faces = new Uint16Array( [\r\n\t\t\t\t0, 1, 2,\r\n\t\t\t\t0, 2, 3\r\n\t\t\t] );\r\n\t\r\n\t\t\t// buffers\r\n\t\r\n\t\t\tvertexBuffer     = gl.createBuffer();\r\n\t\t\telementBuffer    = gl.createBuffer();\r\n\t\r\n\t\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\r\n\t\t\tgl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );\r\n\t\r\n\t\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\r\n\t\t\tgl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );\r\n\t\r\n\t\t\t// textures\r\n\t\r\n\t\t\ttempTexture      = gl.createTexture();\r\n\t\t\tocclusionTexture = gl.createTexture();\r\n\t\r\n\t\t\tstate.bindTexture( gl.TEXTURE_2D, tempTexture );\r\n\t\t\tgl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null );\r\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );\r\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );\r\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\r\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\r\n\t\r\n\t\t\tstate.bindTexture( gl.TEXTURE_2D, occlusionTexture );\r\n\t\t\tgl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null );\r\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );\r\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );\r\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\r\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\r\n\t\r\n\t\t\tshader = {\r\n\t\r\n\t\t\t\tvertexShader: [\r\n\t\r\n\t\t\t\t\t\"uniform lowp int renderType;\",\r\n\t\r\n\t\t\t\t\t\"uniform vec3 screenPosition;\",\r\n\t\t\t\t\t\"uniform vec2 scale;\",\r\n\t\t\t\t\t\"uniform float rotation;\",\r\n\t\r\n\t\t\t\t\t\"uniform sampler2D occlusionMap;\",\r\n\t\r\n\t\t\t\t\t\"attribute vec2 position;\",\r\n\t\t\t\t\t\"attribute vec2 uv;\",\r\n\t\r\n\t\t\t\t\t\"varying vec2 vUV;\",\r\n\t\t\t\t\t\"varying float vVisibility;\",\r\n\t\r\n\t\t\t\t\t\"void main() {\",\r\n\t\r\n\t\t\t\t\t\t\"vUV = uv;\",\r\n\t\r\n\t\t\t\t\t\t\"vec2 pos = position;\",\r\n\t\r\n\t\t\t\t\t\t\"if ( renderType == 2 ) {\",\r\n\t\r\n\t\t\t\t\t\t\t\"vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\",\r\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\",\r\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\",\r\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\",\r\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\",\r\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\",\r\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\",\r\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\",\r\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\",\r\n\t\r\n\t\t\t\t\t\t\t\"vVisibility =        visibility.r / 9.0;\",\r\n\t\t\t\t\t\t\t\"vVisibility *= 1.0 - visibility.g / 9.0;\",\r\n\t\t\t\t\t\t\t\"vVisibility *=       visibility.b / 9.0;\",\r\n\t\t\t\t\t\t\t\"vVisibility *= 1.0 - visibility.a / 9.0;\",\r\n\t\r\n\t\t\t\t\t\t\t\"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\",\r\n\t\t\t\t\t\t\t\"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\",\r\n\t\r\n\t\t\t\t\t\t\"}\",\r\n\t\r\n\t\t\t\t\t\t\"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\",\r\n\t\r\n\t\t\t\t\t\"}\"\r\n\t\r\n\t\t\t\t].join( \"\\n\" ),\r\n\t\r\n\t\t\t\tfragmentShader: [\r\n\t\r\n\t\t\t\t\t\"uniform lowp int renderType;\",\r\n\t\r\n\t\t\t\t\t\"uniform sampler2D map;\",\r\n\t\t\t\t\t\"uniform float opacity;\",\r\n\t\t\t\t\t\"uniform vec3 color;\",\r\n\t\r\n\t\t\t\t\t\"varying vec2 vUV;\",\r\n\t\t\t\t\t\"varying float vVisibility;\",\r\n\t\r\n\t\t\t\t\t\"void main() {\",\r\n\t\r\n\t\t\t\t\t\t// pink square\r\n\t\r\n\t\t\t\t\t\t\"if ( renderType == 0 ) {\",\r\n\t\r\n\t\t\t\t\t\t\t\"gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );\",\r\n\t\r\n\t\t\t\t\t\t// restore\r\n\t\r\n\t\t\t\t\t\t\"} else if ( renderType == 1 ) {\",\r\n\t\r\n\t\t\t\t\t\t\t\"gl_FragColor = texture2D( map, vUV );\",\r\n\t\r\n\t\t\t\t\t\t// flare\r\n\t\r\n\t\t\t\t\t\t\"} else {\",\r\n\t\r\n\t\t\t\t\t\t\t\"vec4 texture = texture2D( map, vUV );\",\r\n\t\t\t\t\t\t\t\"texture.a *= opacity * vVisibility;\",\r\n\t\t\t\t\t\t\t\"gl_FragColor = texture;\",\r\n\t\t\t\t\t\t\t\"gl_FragColor.rgb *= color;\",\r\n\t\r\n\t\t\t\t\t\t\"}\",\r\n\t\r\n\t\t\t\t\t\"}\"\r\n\t\r\n\t\t\t\t].join( \"\\n\" )\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t\tprogram = createProgram( shader );\r\n\t\r\n\t\t\tattributes = {\r\n\t\t\t\tvertex: gl.getAttribLocation ( program, \"position\" ),\r\n\t\t\t\tuv:     gl.getAttribLocation ( program, \"uv\" )\r\n\t\t\t};\r\n\t\r\n\t\t\tuniforms = {\r\n\t\t\t\trenderType:     gl.getUniformLocation( program, \"renderType\" ),\r\n\t\t\t\tmap:            gl.getUniformLocation( program, \"map\" ),\r\n\t\t\t\tocclusionMap:   gl.getUniformLocation( program, \"occlusionMap\" ),\r\n\t\t\t\topacity:        gl.getUniformLocation( program, \"opacity\" ),\r\n\t\t\t\tcolor:          gl.getUniformLocation( program, \"color\" ),\r\n\t\t\t\tscale:          gl.getUniformLocation( program, \"scale\" ),\r\n\t\t\t\trotation:       gl.getUniformLocation( program, \"rotation\" ),\r\n\t\t\t\tscreenPosition: gl.getUniformLocation( program, \"screenPosition\" )\r\n\t\t\t};\r\n\t\r\n\t\t}\r\n\t\r\n\t\t/*\r\n\t\t * Render lens flares\r\n\t\t * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,\r\n\t\t *         reads these back and calculates occlusion.\r\n\t\t */\r\n\t\r\n\t\tthis.render = function ( scene, camera, viewport ) {\r\n\t\r\n\t\t\tif ( flares.length === 0 ) return;\r\n\t\r\n\t\t\tvar tempPosition = new THREE.Vector3();\r\n\t\r\n\t\t\tvar invAspect = viewport.w / viewport.z,\r\n\t\t\t\thalfViewportWidth = viewport.z * 0.5,\r\n\t\t\t\thalfViewportHeight = viewport.w * 0.5;\r\n\t\r\n\t\t\tvar size = 16 / viewport.w,\r\n\t\t\t\tscale = new THREE.Vector2( size * invAspect, size );\r\n\t\r\n\t\t\tvar screenPosition = new THREE.Vector3( 1, 1, 0 ),\r\n\t\t\t\tscreenPositionPixels = new THREE.Vector2( 1, 1 );\r\n\t\r\n\t\t\tvar validArea = new THREE.Box2();\r\n\t\r\n\t\t\tvalidArea.min.set( 0, 0 );\r\n\t\t\tvalidArea.max.set( viewport.z - 16, viewport.w - 16 );\r\n\t\r\n\t\t\tif ( program === undefined ) {\r\n\t\r\n\t\t\t\tinit();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tgl.useProgram( program );\r\n\t\r\n\t\t\tstate.initAttributes();\r\n\t\t\tstate.enableAttribute( attributes.vertex );\r\n\t\t\tstate.enableAttribute( attributes.uv );\r\n\t\t\tstate.disableUnusedAttributes();\r\n\t\r\n\t\t\t// loop through all lens flares to update their occlusion and positions\r\n\t\t\t// setup gl and common used attribs/uniforms\r\n\t\r\n\t\t\tgl.uniform1i( uniforms.occlusionMap, 0 );\r\n\t\t\tgl.uniform1i( uniforms.map, 1 );\r\n\t\r\n\t\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\r\n\t\t\tgl.vertexAttribPointer( attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0 );\r\n\t\t\tgl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );\r\n\t\r\n\t\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\r\n\t\r\n\t\t\tstate.disable( gl.CULL_FACE );\r\n\t\t\tstate.setDepthWrite( false );\r\n\t\r\n\t\t\tfor ( var i = 0, l = flares.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tsize = 16 / viewport.w;\r\n\t\t\t\tscale.set( size * invAspect, size );\r\n\t\r\n\t\t\t\t// calc object screen position\r\n\t\r\n\t\t\t\tvar flare = flares[ i ];\r\n\t\r\n\t\t\t\ttempPosition.set( flare.matrixWorld.elements[ 12 ], flare.matrixWorld.elements[ 13 ], flare.matrixWorld.elements[ 14 ] );\r\n\t\r\n\t\t\t\ttempPosition.applyMatrix4( camera.matrixWorldInverse );\r\n\t\t\t\ttempPosition.applyProjection( camera.projectionMatrix );\r\n\t\r\n\t\t\t\t// setup arrays for gl programs\r\n\t\r\n\t\t\t\tscreenPosition.copy( tempPosition );\r\n\t\r\n\t\t\t\t// horizontal and vertical coordinate of the lower left corner of the pixels to copy\r\n\t\r\n\t\t\t\tscreenPositionPixels.x = viewport.x + ( screenPosition.x * halfViewportWidth ) + halfViewportWidth - 8;\r\n\t\t\t\tscreenPositionPixels.y = viewport.y + ( screenPosition.y * halfViewportHeight ) + halfViewportHeight - 8;\r\n\t\r\n\t\t\t\t// screen cull\r\n\t\r\n\t\t\t\tif ( validArea.containsPoint( screenPositionPixels ) === true ) {\r\n\t\r\n\t\t\t\t\t// save current RGB to temp texture\r\n\t\r\n\t\t\t\t\tstate.activeTexture( gl.TEXTURE0 );\r\n\t\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, null );\r\n\t\t\t\t\tstate.activeTexture( gl.TEXTURE1 );\r\n\t\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, tempTexture );\r\n\t\t\t\t\tgl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );\r\n\t\r\n\t\r\n\t\t\t\t\t// render pink quad\r\n\t\r\n\t\t\t\t\tgl.uniform1i( uniforms.renderType, 0 );\r\n\t\t\t\t\tgl.uniform2f( uniforms.scale, scale.x, scale.y );\r\n\t\t\t\t\tgl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );\r\n\t\r\n\t\t\t\t\tstate.disable( gl.BLEND );\r\n\t\t\t\t\tstate.enable( gl.DEPTH_TEST );\r\n\t\r\n\t\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\r\n\t\r\n\t\r\n\t\t\t\t\t// copy result to occlusionMap\r\n\t\r\n\t\t\t\t\tstate.activeTexture( gl.TEXTURE0 );\r\n\t\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, occlusionTexture );\r\n\t\t\t\t\tgl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );\r\n\t\r\n\t\r\n\t\t\t\t\t// restore graphics\r\n\t\r\n\t\t\t\t\tgl.uniform1i( uniforms.renderType, 1 );\r\n\t\t\t\t\tstate.disable( gl.DEPTH_TEST );\r\n\t\r\n\t\t\t\t\tstate.activeTexture( gl.TEXTURE1 );\r\n\t\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, tempTexture );\r\n\t\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\r\n\t\r\n\t\r\n\t\t\t\t\t// update object positions\r\n\t\r\n\t\t\t\t\tflare.positionScreen.copy( screenPosition );\r\n\t\r\n\t\t\t\t\tif ( flare.customUpdateCallback ) {\r\n\t\r\n\t\t\t\t\t\tflare.customUpdateCallback( flare );\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tflare.updateLensFlares();\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t// render flares\r\n\t\r\n\t\t\t\t\tgl.uniform1i( uniforms.renderType, 2 );\r\n\t\t\t\t\tstate.enable( gl.BLEND );\r\n\t\r\n\t\t\t\t\tfor ( var j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {\r\n\t\r\n\t\t\t\t\t\tvar sprite = flare.lensFlares[ j ];\r\n\t\r\n\t\t\t\t\t\tif ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {\r\n\t\r\n\t\t\t\t\t\t\tscreenPosition.x = sprite.x;\r\n\t\t\t\t\t\t\tscreenPosition.y = sprite.y;\r\n\t\t\t\t\t\t\tscreenPosition.z = sprite.z;\r\n\t\r\n\t\t\t\t\t\t\tsize = sprite.size * sprite.scale / viewport.w;\r\n\t\r\n\t\t\t\t\t\t\tscale.x = size * invAspect;\r\n\t\t\t\t\t\t\tscale.y = size;\r\n\t\r\n\t\t\t\t\t\t\tgl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );\r\n\t\t\t\t\t\t\tgl.uniform2f( uniforms.scale, scale.x, scale.y );\r\n\t\t\t\t\t\t\tgl.uniform1f( uniforms.rotation, sprite.rotation );\r\n\t\r\n\t\t\t\t\t\t\tgl.uniform1f( uniforms.opacity, sprite.opacity );\r\n\t\t\t\t\t\t\tgl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );\r\n\t\r\n\t\t\t\t\t\t\tstate.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );\r\n\t\t\t\t\t\t\trenderer.setTexture2D( sprite.texture, 1 );\r\n\t\r\n\t\t\t\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// restore gl\r\n\t\r\n\t\t\tstate.enable( gl.CULL_FACE );\r\n\t\t\tstate.enable( gl.DEPTH_TEST );\r\n\t\t\tstate.setDepthWrite( true );\r\n\t\r\n\t\t\trenderer.resetGLState();\r\n\t\r\n\t\t};\r\n\t\r\n\t\tfunction createProgram ( shader ) {\r\n\t\r\n\t\t\tvar program = gl.createProgram();\r\n\t\r\n\t\t\tvar fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );\r\n\t\t\tvar vertexShader = gl.createShader( gl.VERTEX_SHADER );\r\n\t\r\n\t\t\tvar prefix = \"precision \" + renderer.getPrecision() + \" float;\\n\";\r\n\t\r\n\t\t\tgl.shaderSource( fragmentShader, prefix + shader.fragmentShader );\r\n\t\t\tgl.shaderSource( vertexShader, prefix + shader.vertexShader );\r\n\t\r\n\t\t\tgl.compileShader( fragmentShader );\r\n\t\t\tgl.compileShader( vertexShader );\r\n\t\r\n\t\t\tgl.attachShader( program, fragmentShader );\r\n\t\t\tgl.attachShader( program, vertexShader );\r\n\t\r\n\t\t\tgl.linkProgram( program );\r\n\t\r\n\t\t\treturn program;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/renderers/webgl/plugins/SpritePlugin.js\r\n\t\r\n\t/**\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.SpritePlugin = function ( renderer, sprites ) {\r\n\t\r\n\t\tvar gl = renderer.context;\r\n\t\tvar state = renderer.state;\r\n\t\r\n\t\tvar vertexBuffer, elementBuffer;\r\n\t\tvar program, attributes, uniforms;\r\n\t\r\n\t\tvar texture;\r\n\t\r\n\t\t// decompose matrixWorld\r\n\t\r\n\t\tvar spritePosition = new THREE.Vector3();\r\n\t\tvar spriteRotation = new THREE.Quaternion();\r\n\t\tvar spriteScale = new THREE.Vector3();\r\n\t\r\n\t\tfunction init() {\r\n\t\r\n\t\t\tvar vertices = new Float32Array( [\r\n\t\t\t\t- 0.5, - 0.5,  0, 0,\r\n\t\t\t\t  0.5, - 0.5,  1, 0,\r\n\t\t\t\t  0.5,   0.5,  1, 1,\r\n\t\t\t\t- 0.5,   0.5,  0, 1\r\n\t\t\t] );\r\n\t\r\n\t\t\tvar faces = new Uint16Array( [\r\n\t\t\t\t0, 1, 2,\r\n\t\t\t\t0, 2, 3\r\n\t\t\t] );\r\n\t\r\n\t\t\tvertexBuffer  = gl.createBuffer();\r\n\t\t\telementBuffer = gl.createBuffer();\r\n\t\r\n\t\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\r\n\t\t\tgl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );\r\n\t\r\n\t\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\r\n\t\t\tgl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );\r\n\t\r\n\t\t\tprogram = createProgram();\r\n\t\r\n\t\t\tattributes = {\r\n\t\t\t\tposition:\t\t\tgl.getAttribLocation ( program, 'position' ),\r\n\t\t\t\tuv:\t\t\t\t\tgl.getAttribLocation ( program, 'uv' )\r\n\t\t\t};\r\n\t\r\n\t\t\tuniforms = {\r\n\t\t\t\tuvOffset:\t\t\tgl.getUniformLocation( program, 'uvOffset' ),\r\n\t\t\t\tuvScale:\t\t\tgl.getUniformLocation( program, 'uvScale' ),\r\n\t\r\n\t\t\t\trotation:\t\t\tgl.getUniformLocation( program, 'rotation' ),\r\n\t\t\t\tscale:\t\t\t\tgl.getUniformLocation( program, 'scale' ),\r\n\t\r\n\t\t\t\tcolor:\t\t\t\tgl.getUniformLocation( program, 'color' ),\r\n\t\t\t\tmap:\t\t\t\tgl.getUniformLocation( program, 'map' ),\r\n\t\t\t\topacity:\t\t\tgl.getUniformLocation( program, 'opacity' ),\r\n\t\r\n\t\t\t\tmodelViewMatrix: \tgl.getUniformLocation( program, 'modelViewMatrix' ),\r\n\t\t\t\tprojectionMatrix:\tgl.getUniformLocation( program, 'projectionMatrix' ),\r\n\t\r\n\t\t\t\tfogType:\t\t\tgl.getUniformLocation( program, 'fogType' ),\r\n\t\t\t\tfogDensity:\t\t\tgl.getUniformLocation( program, 'fogDensity' ),\r\n\t\t\t\tfogNear:\t\t\tgl.getUniformLocation( program, 'fogNear' ),\r\n\t\t\t\tfogFar:\t\t\t\tgl.getUniformLocation( program, 'fogFar' ),\r\n\t\t\t\tfogColor:\t\t\tgl.getUniformLocation( program, 'fogColor' ),\r\n\t\r\n\t\t\t\talphaTest:\t\t\tgl.getUniformLocation( program, 'alphaTest' )\r\n\t\t\t};\r\n\t\r\n\t\t\tvar canvas = document.createElement( 'canvas' );\r\n\t\t\tcanvas.width = 8;\r\n\t\t\tcanvas.height = 8;\r\n\t\r\n\t\t\tvar context = canvas.getContext( '2d' );\r\n\t\t\tcontext.fillStyle = 'white';\r\n\t\t\tcontext.fillRect( 0, 0, 8, 8 );\r\n\t\r\n\t\t\ttexture = new THREE.Texture( canvas );\r\n\t\t\ttexture.needsUpdate = true;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.render = function ( scene, camera ) {\r\n\t\r\n\t\t\tif ( sprites.length === 0 ) return;\r\n\t\r\n\t\t\t// setup gl\r\n\t\r\n\t\t\tif ( program === undefined ) {\r\n\t\r\n\t\t\t\tinit();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tgl.useProgram( program );\r\n\t\r\n\t\t\tstate.initAttributes();\r\n\t\t\tstate.enableAttribute( attributes.position );\r\n\t\t\tstate.enableAttribute( attributes.uv );\r\n\t\t\tstate.disableUnusedAttributes();\r\n\t\r\n\t\t\tstate.disable( gl.CULL_FACE );\r\n\t\t\tstate.enable( gl.BLEND );\r\n\t\r\n\t\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\r\n\t\t\tgl.vertexAttribPointer( attributes.position, 2, gl.FLOAT, false, 2 * 8, 0 );\r\n\t\t\tgl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );\r\n\t\r\n\t\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\r\n\t\r\n\t\t\tgl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );\r\n\t\r\n\t\t\tstate.activeTexture( gl.TEXTURE0 );\r\n\t\t\tgl.uniform1i( uniforms.map, 0 );\r\n\t\r\n\t\t\tvar oldFogType = 0;\r\n\t\t\tvar sceneFogType = 0;\r\n\t\t\tvar fog = scene.fog;\r\n\t\r\n\t\t\tif ( fog ) {\r\n\t\r\n\t\t\t\tgl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );\r\n\t\r\n\t\t\t\tif ( fog instanceof THREE.Fog ) {\r\n\t\r\n\t\t\t\t\tgl.uniform1f( uniforms.fogNear, fog.near );\r\n\t\t\t\t\tgl.uniform1f( uniforms.fogFar, fog.far );\r\n\t\r\n\t\t\t\t\tgl.uniform1i( uniforms.fogType, 1 );\r\n\t\t\t\t\toldFogType = 1;\r\n\t\t\t\t\tsceneFogType = 1;\r\n\t\r\n\t\t\t\t} else if ( fog instanceof THREE.FogExp2 ) {\r\n\t\r\n\t\t\t\t\tgl.uniform1f( uniforms.fogDensity, fog.density );\r\n\t\r\n\t\t\t\t\tgl.uniform1i( uniforms.fogType, 2 );\r\n\t\t\t\t\toldFogType = 2;\r\n\t\t\t\t\tsceneFogType = 2;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tgl.uniform1i( uniforms.fogType, 0 );\r\n\t\t\t\toldFogType = 0;\r\n\t\t\t\tsceneFogType = 0;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\r\n\t\t\t// update positions and sort\r\n\t\r\n\t\t\tfor ( var i = 0, l = sprites.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tvar sprite = sprites[ i ];\r\n\t\r\n\t\t\t\tsprite.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );\r\n\t\t\t\tsprite.z = - sprite.modelViewMatrix.elements[ 14 ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tsprites.sort( painterSortStable );\r\n\t\r\n\t\t\t// render all sprites\r\n\t\r\n\t\t\tvar scale = [];\r\n\t\r\n\t\t\tfor ( var i = 0, l = sprites.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tvar sprite = sprites[ i ];\r\n\t\t\t\tvar material = sprite.material;\r\n\t\r\n\t\t\t\tgl.uniform1f( uniforms.alphaTest, material.alphaTest );\r\n\t\t\t\tgl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements );\r\n\t\r\n\t\t\t\tsprite.matrixWorld.decompose( spritePosition, spriteRotation, spriteScale );\r\n\t\r\n\t\t\t\tscale[ 0 ] = spriteScale.x;\r\n\t\t\t\tscale[ 1 ] = spriteScale.y;\r\n\t\r\n\t\t\t\tvar fogType = 0;\r\n\t\r\n\t\t\t\tif ( scene.fog && material.fog ) {\r\n\t\r\n\t\t\t\t\tfogType = sceneFogType;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( oldFogType !== fogType ) {\r\n\t\r\n\t\t\t\t\tgl.uniform1i( uniforms.fogType, fogType );\r\n\t\t\t\t\toldFogType = fogType;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( material.map !== null ) {\r\n\t\r\n\t\t\t\t\tgl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );\r\n\t\t\t\t\tgl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tgl.uniform2f( uniforms.uvOffset, 0, 0 );\r\n\t\t\t\t\tgl.uniform2f( uniforms.uvScale, 1, 1 );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tgl.uniform1f( uniforms.opacity, material.opacity );\r\n\t\t\t\tgl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );\r\n\t\r\n\t\t\t\tgl.uniform1f( uniforms.rotation, material.rotation );\r\n\t\t\t\tgl.uniform2fv( uniforms.scale, scale );\r\n\t\r\n\t\t\t\tstate.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );\r\n\t\t\t\tstate.setDepthTest( material.depthTest );\r\n\t\t\t\tstate.setDepthWrite( material.depthWrite );\r\n\t\r\n\t\t\t\tif ( material.map ) {\r\n\t\r\n\t\t\t\t\trenderer.setTexture2D( material.map, 0 );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\trenderer.setTexture2D( texture, 0 );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// restore gl\r\n\t\r\n\t\t\tstate.enable( gl.CULL_FACE );\r\n\t\r\n\t\t\trenderer.resetGLState();\r\n\t\r\n\t\t};\r\n\t\r\n\t\tfunction createProgram () {\r\n\t\r\n\t\t\tvar program = gl.createProgram();\r\n\t\r\n\t\t\tvar vertexShader = gl.createShader( gl.VERTEX_SHADER );\r\n\t\t\tvar fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );\r\n\t\r\n\t\t\tgl.shaderSource( vertexShader, [\r\n\t\r\n\t\t\t\t'precision ' + renderer.getPrecision() + ' float;',\r\n\t\r\n\t\t\t\t'uniform mat4 modelViewMatrix;',\r\n\t\t\t\t'uniform mat4 projectionMatrix;',\r\n\t\t\t\t'uniform float rotation;',\r\n\t\t\t\t'uniform vec2 scale;',\r\n\t\t\t\t'uniform vec2 uvOffset;',\r\n\t\t\t\t'uniform vec2 uvScale;',\r\n\t\r\n\t\t\t\t'attribute vec2 position;',\r\n\t\t\t\t'attribute vec2 uv;',\r\n\t\r\n\t\t\t\t'varying vec2 vUV;',\r\n\t\r\n\t\t\t\t'void main() {',\r\n\t\r\n\t\t\t\t\t'vUV = uvOffset + uv * uvScale;',\r\n\t\r\n\t\t\t\t\t'vec2 alignedPosition = position * scale;',\r\n\t\r\n\t\t\t\t\t'vec2 rotatedPosition;',\r\n\t\t\t\t\t'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',\r\n\t\t\t\t\t'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',\r\n\t\r\n\t\t\t\t\t'vec4 finalPosition;',\r\n\t\r\n\t\t\t\t\t'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',\r\n\t\t\t\t\t'finalPosition.xy += rotatedPosition;',\r\n\t\t\t\t\t'finalPosition = projectionMatrix * finalPosition;',\r\n\t\r\n\t\t\t\t\t'gl_Position = finalPosition;',\r\n\t\r\n\t\t\t\t'}'\r\n\t\r\n\t\t\t].join( '\\n' ) );\r\n\t\r\n\t\t\tgl.shaderSource( fragmentShader, [\r\n\t\r\n\t\t\t\t'precision ' + renderer.getPrecision() + ' float;',\r\n\t\r\n\t\t\t\t'uniform vec3 color;',\r\n\t\t\t\t'uniform sampler2D map;',\r\n\t\t\t\t'uniform float opacity;',\r\n\t\r\n\t\t\t\t'uniform int fogType;',\r\n\t\t\t\t'uniform vec3 fogColor;',\r\n\t\t\t\t'uniform float fogDensity;',\r\n\t\t\t\t'uniform float fogNear;',\r\n\t\t\t\t'uniform float fogFar;',\r\n\t\t\t\t'uniform float alphaTest;',\r\n\t\r\n\t\t\t\t'varying vec2 vUV;',\r\n\t\r\n\t\t\t\t'void main() {',\r\n\t\r\n\t\t\t\t\t'vec4 texture = texture2D( map, vUV );',\r\n\t\r\n\t\t\t\t\t'if ( texture.a < alphaTest ) discard;',\r\n\t\r\n\t\t\t\t\t'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',\r\n\t\r\n\t\t\t\t\t'if ( fogType > 0 ) {',\r\n\t\r\n\t\t\t\t\t\t'float depth = gl_FragCoord.z / gl_FragCoord.w;',\r\n\t\t\t\t\t\t'float fogFactor = 0.0;',\r\n\t\r\n\t\t\t\t\t\t'if ( fogType == 1 ) {',\r\n\t\r\n\t\t\t\t\t\t\t'fogFactor = smoothstep( fogNear, fogFar, depth );',\r\n\t\r\n\t\t\t\t\t\t'} else {',\r\n\t\r\n\t\t\t\t\t\t\t'const float LOG2 = 1.442695;',\r\n\t\t\t\t\t\t\t'fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',\r\n\t\t\t\t\t\t\t'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',\r\n\t\r\n\t\t\t\t\t\t'}',\r\n\t\r\n\t\t\t\t\t\t'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',\r\n\t\r\n\t\t\t\t\t'}',\r\n\t\r\n\t\t\t\t'}'\r\n\t\r\n\t\t\t].join( '\\n' ) );\r\n\t\r\n\t\t\tgl.compileShader( vertexShader );\r\n\t\t\tgl.compileShader( fragmentShader );\r\n\t\r\n\t\t\tgl.attachShader( program, vertexShader );\r\n\t\t\tgl.attachShader( program, fragmentShader );\r\n\t\r\n\t\t\tgl.linkProgram( program );\r\n\t\r\n\t\t\treturn program;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction painterSortStable ( a, b ) {\r\n\t\t\t\r\n\t\t\tif ( a.renderOrder !== b.renderOrder ) {\r\n\t\r\n\t\t\t\treturn a.renderOrder - b.renderOrder;\r\n\t\r\n\t\t\t} else if ( a.z !== b.z ) {\r\n\t\r\n\t\t\t\treturn b.z - a.z;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\treturn b.id - a.id;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/Three.Legacy.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tObject.defineProperties( THREE.Box2.prototype, {\r\n\t\tempty: {\r\n\t\t\tvalue: function () {\r\n\t\t\t\tconsole.warn( 'THREE.Box2: .empty() has been renamed to .isEmpty().' );\r\n\t\t\t\treturn this.isEmpty();\r\n\t\t\t}\r\n\t\t},\r\n\t\tisIntersectionBox: {\r\n\t\t\tvalue: function ( box ) {\r\n\t\t\t\tconsole.warn( 'THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().' );\r\n\t\t\t\treturn this.intersectsBox( box );\r\n\t\t\t}\r\n\t\t}\r\n\t} );\r\n\t\r\n\tObject.defineProperties( THREE.Box3.prototype, {\r\n\t\tempty: {\r\n\t\t\tvalue: function () {\r\n\t\t\t\tconsole.warn( 'THREE.Box3: .empty() has been renamed to .isEmpty().' );\r\n\t\t\t\treturn this.isEmpty();\r\n\t\t\t}\r\n\t\t},\r\n\t\tisIntersectionBox: {\r\n\t\t\tvalue: function ( box ) {\r\n\t\t\t\tconsole.warn( 'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().' );\r\n\t\t\t\treturn this.intersectsBox( box );\r\n\t\t\t}\r\n\t\t},\r\n\t\tisIntersectionSphere: {\r\n\t\t\tvalue: function ( sphere ) {\r\n\t\t\t\tconsole.warn( 'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().' );\r\n\t\t\t\treturn this.intersectsSphere( sphere );\r\n\t\t\t}\r\n\t\t}\r\n\t} );\r\n\t\r\n\tObject.defineProperties( THREE.Matrix3.prototype, {\r\n\t\tmultiplyVector3: {\r\n\t\t\tvalue: function ( vector ) {\r\n\t\t\t\tconsole.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );\r\n\t\t\t\treturn vector.applyMatrix3( this );\r\n\t\t\t}\r\n\t\t},\r\n\t\tmultiplyVector3Array: {\r\n\t\t\tvalue: function ( a ) {\r\n\t\t\t\tconsole.warn( 'THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );\r\n\t\t\t\treturn this.applyToVector3Array( a );\r\n\t\t\t}\r\n\t\t}\r\n\t} );\r\n\t\r\n\tObject.defineProperties( THREE.Matrix4.prototype, {\r\n\t\textractPosition: {\r\n\t\t\tvalue: function ( m ) {\r\n\t\t\t\tconsole.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );\r\n\t\t\t\treturn this.copyPosition( m );\r\n\t\t\t}\r\n\t\t},\r\n\t\tsetRotationFromQuaternion: {\r\n\t\t\tvalue: function ( q ) {\r\n\t\t\t\tconsole.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );\r\n\t\t\t\treturn this.makeRotationFromQuaternion( q );\r\n\t\t\t}\r\n\t\t},\r\n\t\tmultiplyVector3: {\r\n\t\t\tvalue: function ( vector ) {\r\n\t\t\t\tconsole.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.' );\r\n\t\t\t\treturn vector.applyProjection( this );\r\n\t\t\t}\r\n\t\t},\r\n\t\tmultiplyVector4: {\r\n\t\t\tvalue: function ( vector ) {\r\n\t\t\t\tconsole.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\r\n\t\t\t\treturn vector.applyMatrix4( this );\r\n\t\t\t}\r\n\t\t},\r\n\t\tmultiplyVector3Array: {\r\n\t\t\tvalue: function ( a ) {\r\n\t\t\t\tconsole.warn( 'THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );\r\n\t\t\t\treturn this.applyToVector3Array( a );\r\n\t\t\t}\r\n\t\t},\r\n\t\trotateAxis: {\r\n\t\t\tvalue: function ( v ) {\r\n\t\t\t\tconsole.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );\r\n\t\t\t\tv.transformDirection( this );\r\n\t\t\t}\r\n\t\t},\r\n\t\tcrossVector: {\r\n\t\t\tvalue: function ( vector ) {\r\n\t\t\t\tconsole.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\r\n\t\t\t\treturn vector.applyMatrix4( this );\r\n\t\t\t}\r\n\t\t},\r\n\t\ttranslate: {\r\n\t\t\tvalue: function ( v ) {\r\n\t\t\t\tconsole.error( 'THREE.Matrix4: .translate() has been removed.' );\r\n\t\t\t}\r\n\t\t},\r\n\t\trotateX: {\r\n\t\t\tvalue: function ( angle ) {\r\n\t\t\t\tconsole.error( 'THREE.Matrix4: .rotateX() has been removed.' );\r\n\t\t\t}\r\n\t\t},\r\n\t\trotateY: {\r\n\t\t\tvalue: function ( angle ) {\r\n\t\t\t\tconsole.error( 'THREE.Matrix4: .rotateY() has been removed.' );\r\n\t\t\t}\r\n\t\t},\r\n\t\trotateZ: {\r\n\t\t\tvalue: function ( angle ) {\r\n\t\t\t\tconsole.error( 'THREE.Matrix4: .rotateZ() has been removed.' );\r\n\t\t\t}\r\n\t\t},\r\n\t\trotateByAxis: {\r\n\t\t\tvalue: function ( axis, angle ) {\r\n\t\t\t\tconsole.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );\r\n\t\t\t}\r\n\t\t}\r\n\t} );\r\n\t\r\n\tObject.defineProperties( THREE.Plane.prototype, {\r\n\t\tisIntersectionLine: {\r\n\t\t\tvalue: function ( line ) {\r\n\t\t\t\tconsole.warn( 'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().' );\r\n\t\t\t\treturn this.intersectsLine( line );\r\n\t\t\t}\r\n\t\t}\r\n\t} );\r\n\t\r\n\tObject.defineProperties( THREE.Quaternion.prototype, {\r\n\t\tmultiplyVector3: {\r\n\t\t\tvalue: function ( vector ) {\r\n\t\t\t\tconsole.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );\r\n\t\t\t\treturn vector.applyQuaternion( this );\r\n\t\t\t}\r\n\t\t}\r\n\t} );\r\n\t\r\n\tObject.defineProperties( THREE.Ray.prototype, {\r\n\t\tisIntersectionBox: {\r\n\t\t\tvalue: function ( box ) {\r\n\t\t\t\tconsole.warn( 'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().' );\r\n\t\t\t\treturn this.intersectsBox( box );\r\n\t\t\t}\r\n\t\t},\r\n\t\tisIntersectionPlane: {\r\n\t\t\tvalue: function ( plane ) {\r\n\t\t\t\tconsole.warn( 'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().' );\r\n\t\t\t\treturn this.intersectsPlane( plane );\r\n\t\t\t}\r\n\t\t},\r\n\t\tisIntersectionSphere: {\r\n\t\t\tvalue: function ( sphere ) {\r\n\t\t\t\tconsole.warn( 'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().' );\r\n\t\t\t\treturn this.intersectsSphere( sphere );\r\n\t\t\t}\r\n\t\t}\r\n\t} );\r\n\t\r\n\tObject.defineProperties( THREE.Vector3.prototype, {\r\n\t\tsetEulerFromRotationMatrix: {\r\n\t\t\tvalue: function () {\r\n\t\t\t\tconsole.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );\r\n\t\t\t}\r\n\t\t},\r\n\t\tsetEulerFromQuaternion: {\r\n\t\t\tvalue: function () {\r\n\t\t\t\tconsole.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );\r\n\t\t\t}\r\n\t\t},\r\n\t\tgetPositionFromMatrix: {\r\n\t\t\tvalue: function ( m ) {\r\n\t\t\t\tconsole.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );\r\n\t\t\t\treturn this.setFromMatrixPosition( m );\r\n\t\t\t}\r\n\t\t},\r\n\t\tgetScaleFromMatrix: {\r\n\t\t\tvalue: function ( m ) {\r\n\t\t\t\tconsole.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );\r\n\t\t\t\treturn this.setFromMatrixScale( m );\r\n\t\t\t}\r\n\t\t},\r\n\t\tgetColumnFromMatrix: {\r\n\t\t\tvalue: function ( index, matrix ) {\r\n\t\t\t\tconsole.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );\r\n\t\t\t\treturn this.setFromMatrixColumn( index, matrix );\r\n\t\t\t}\r\n\t\t}\r\n\t} );\r\n\t\r\n\t//\r\n\t\r\n\tTHREE.Face4 = function ( a, b, c, d, normal, color, materialIndex ) {\r\n\t\r\n\t\tconsole.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' );\r\n\t\treturn new THREE.Face3( a, b, c, normal, color, materialIndex );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Vertex = function ( x, y, z ) {\r\n\t\r\n\t\tconsole.warn( 'THREE.Vertex has been removed. Use THREE.Vector3 instead.' );\r\n\t\treturn new THREE.Vector3( x, y, z );\r\n\t\r\n\t};\r\n\t\r\n\t//\r\n\t\r\n\tObject.defineProperties( THREE.Object3D.prototype, {\r\n\t\teulerOrder: {\r\n\t\t\tget: function () {\r\n\t\t\t\tconsole.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );\r\n\t\t\t\treturn this.rotation.order;\r\n\t\t\t},\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );\r\n\t\t\t\tthis.rotation.order = value;\r\n\t\t\t}\r\n\t\t},\r\n\t\tgetChildByName: {\r\n\t\t\tvalue: function ( name ) {\r\n\t\t\t\tconsole.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );\r\n\t\t\t\treturn this.getObjectByName( name );\r\n\t\t\t}\r\n\t\t},\r\n\t\trenderDepth: {\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );\r\n\t\t\t}\r\n\t\t},\r\n\t\ttranslate: {\r\n\t\t\tvalue: function ( distance, axis ) {\r\n\t\t\t\tconsole.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );\r\n\t\t\t\treturn this.translateOnAxis( axis, distance );\r\n\t\t\t}\r\n\t\t},\r\n\t\tuseQuaternion: {\r\n\t\t\tget: function () {\r\n\t\t\t\tconsole.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );\r\n\t\t\t},\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );\r\n\t\t\t}\r\n\t\t}\r\n\t} );\r\n\t\r\n\t//\r\n\t\r\n\tObject.defineProperties( THREE, {\r\n\t\tPointCloud: {\r\n\t\t\tvalue: function ( geometry, material ) {\r\n\t\t\t\tconsole.warn( 'THREE.PointCloud has been renamed to THREE.Points.' );\r\n\t\t\t\treturn new THREE.Points( geometry, material );\r\n\t\t\t}\r\n\t\t},\r\n\t\tParticleSystem: {\r\n\t\t\tvalue: function ( geometry, material ) {\r\n\t\t\t\tconsole.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' );\r\n\t\t\t\treturn new THREE.Points( geometry, material );\r\n\t\t\t}\r\n\t\t}\r\n\t} );\r\n\t\r\n\t//\r\n\t\r\n\tObject.defineProperties( THREE.Light.prototype, {\r\n\t\tonlyShadow: {\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.Light: .onlyShadow has been removed.' );\r\n\t\t\t}\r\n\t\t},\r\n\t\tshadowCameraFov: {\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.' );\r\n\t\t\t\tthis.shadow.camera.fov = value;\r\n\t\t\t}\r\n\t\t},\r\n\t\tshadowCameraLeft: {\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.' );\r\n\t\t\t\tthis.shadow.camera.left = value;\r\n\t\t\t}\r\n\t\t},\r\n\t\tshadowCameraRight: {\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraRight is now .shadow.camera.right.' );\r\n\t\t\t\tthis.shadow.camera.right = value;\r\n\t\t\t}\r\n\t\t},\r\n\t\tshadowCameraTop: {\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraTop is now .shadow.camera.top.' );\r\n\t\t\t\tthis.shadow.camera.top = value;\r\n\t\t\t}\r\n\t\t},\r\n\t\tshadowCameraBottom: {\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.' );\r\n\t\t\t\tthis.shadow.camera.bottom = value;\r\n\t\t\t}\r\n\t\t},\r\n\t\tshadowCameraNear: {\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraNear is now .shadow.camera.near.' );\r\n\t\t\t\tthis.shadow.camera.near = value;\r\n\t\t\t}\r\n\t\t},\r\n\t\tshadowCameraFar: {\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraFar is now .shadow.camera.far.' );\r\n\t\t\t\tthis.shadow.camera.far = value;\r\n\t\t\t}\r\n\t\t},\r\n\t\tshadowCameraVisible: {\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.' );\r\n\t\t\t}\r\n\t\t},\r\n\t\tshadowBias: {\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowBias is now .shadow.bias.' );\r\n\t\t\t\tthis.shadow.bias = value;\r\n\t\t\t}\r\n\t\t},\r\n\t\tshadowDarkness: {\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowDarkness has been removed.' );\r\n\t\t\t}\r\n\t\t},\r\n\t\tshadowMapWidth: {\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.' );\r\n\t\t\t\tthis.shadow.mapSize.width = value;\r\n\t\t\t}\r\n\t\t},\r\n\t\tshadowMapHeight: {\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.' );\r\n\t\t\t\tthis.shadow.mapSize.height = value;\r\n\t\t\t}\r\n\t\t}\r\n\t} );\r\n\t\r\n\t//\r\n\t\r\n\tObject.defineProperties( THREE.BufferAttribute.prototype, {\r\n\t\tlength: {\r\n\t\t\tget: function () {\r\n\t\t\t\tconsole.warn( 'THREE.BufferAttribute: .length has been deprecated. Please use .count.' );\r\n\t\t\t\treturn this.array.length;\r\n\t\t\t}\r\n\t\t}\r\n\t} );\r\n\t\r\n\tObject.defineProperties( THREE.BufferGeometry.prototype, {\r\n\t\tdrawcalls: {\r\n\t\t\tget: function () {\r\n\t\t\t\tconsole.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );\r\n\t\t\t\treturn this.groups;\r\n\t\t\t}\r\n\t\t},\r\n\t\toffsets: {\r\n\t\t\tget: function () {\r\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );\r\n\t\t\t\treturn this.groups;\r\n\t\t\t}\r\n\t\t},\r\n\t\taddIndex: {\r\n\t\t\tvalue: function ( index ) {\r\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );\r\n\t\t\t\tthis.setIndex( index );\r\n\t\t\t}\r\n\t\t},\r\n\t\taddDrawCall: {\r\n\t\t\tvalue: function ( start, count, indexOffset ) {\r\n\t\t\t\tif ( indexOffset !== undefined ) {\r\n\t\t\t\t\tconsole.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );\r\n\t\t\t\t}\r\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );\r\n\t\t\t\tthis.addGroup( start, count );\r\n\t\t\t}\r\n\t\t},\r\n\t\tclearDrawCalls: {\r\n\t\t\tvalue: function () {\r\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );\r\n\t\t\t\tthis.clearGroups();\r\n\t\t\t}\r\n\t\t},\r\n\t\tcomputeTangents: {\r\n\t\t\tvalue: function () {\r\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry: .computeTangents() has been removed.' );\r\n\t\t\t}\r\n\t\t},\r\n\t\tcomputeOffsets: {\r\n\t\t\tvalue: function () {\r\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.' );\r\n\t\t\t}\r\n\t\t}\r\n\t} );\r\n\t\r\n\t//\r\n\t\r\n\tObject.defineProperties( THREE.Material.prototype, {\r\n\t\twrapAround: {\r\n\t\t\tget: function () {\r\n\t\t\t\tconsole.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );\r\n\t\t\t},\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );\r\n\t\t\t}\r\n\t\t},\r\n\t\twrapRGB: {\r\n\t\t\tget: function () {\r\n\t\t\t\tconsole.warn( 'THREE.' + this.type + ': .wrapRGB has been removed.' );\r\n\t\t\t\treturn new THREE.Color();\r\n\t\t\t}\r\n\t\t}\r\n\t} );\r\n\t\r\n\tObject.defineProperties( THREE, {\r\n\t\tPointCloudMaterial: {\r\n\t\t\tvalue: function ( parameters ) {\r\n\t\t\t\tconsole.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' );\r\n\t\t\t\treturn new THREE.PointsMaterial( parameters );\r\n\t\t\t}\r\n\t\t},\r\n\t\tParticleBasicMaterial: {\r\n\t\t\tvalue: function ( parameters ) {\r\n\t\t\t\tconsole.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' );\r\n\t\t\t\treturn new THREE.PointsMaterial( parameters );\r\n\t\t\t}\r\n\t\t},\r\n\t\tParticleSystemMaterial:{\r\n\t\t\tvalue: function ( parameters ) {\r\n\t\t\t\tconsole.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' );\r\n\t\t\t\treturn new THREE.PointsMaterial( parameters );\r\n\t\t\t}\r\n\t\t}\r\n\t} );\r\n\t\r\n\tObject.defineProperties( THREE.MeshPhongMaterial.prototype, {\r\n\t\tmetal: {\r\n\t\t\tget: function () {\r\n\t\t\t\tconsole.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.' );\r\n\t\t\t\treturn false;\r\n\t\t\t},\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead' );\r\n\t\t\t}\r\n\t\t}\r\n\t} );\r\n\t\r\n\tObject.defineProperties( THREE.ShaderMaterial.prototype, {\r\n\t\tderivatives: {\r\n\t\t\tget: function () {\r\n\t\t\t\tconsole.warn( 'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );\r\n\t\t\t\treturn this.extensions.derivatives;\r\n\t\t\t},\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );\r\n\t\t\t\tthis.extensions.derivatives = value;\r\n\t\t\t}\r\n\t\t}\r\n\t} );\r\n\t\r\n\t//\r\n\t\r\n\tObject.defineProperties( THREE.WebGLRenderer.prototype, {\r\n\t\tsupportsFloatTextures: {\r\n\t\t\tvalue: function () {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \\'OES_texture_float\\' ).' );\r\n\t\t\t\treturn this.extensions.get( 'OES_texture_float' );\r\n\t\t\t}\r\n\t\t},\r\n\t\tsupportsHalfFloatTextures: {\r\n\t\t\tvalue: function () {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \\'OES_texture_half_float\\' ).' );\r\n\t\t\t\treturn this.extensions.get( 'OES_texture_half_float' );\r\n\t\t\t}\r\n\t\t},\r\n\t\tsupportsStandardDerivatives: {\r\n\t\t\tvalue: function () {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \\'OES_standard_derivatives\\' ).' );\r\n\t\t\t\treturn this.extensions.get( 'OES_standard_derivatives' );\r\n\t\t\t}\r\n\t\t},\r\n\t\tsupportsCompressedTextureS3TC: {\r\n\t\t\tvalue: function () {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \\'WEBGL_compressed_texture_s3tc\\' ).' );\r\n\t\t\t\treturn this.extensions.get( 'WEBGL_compressed_texture_s3tc' );\r\n\t\t\t}\r\n\t\t},\r\n\t\tsupportsCompressedTexturePVRTC: {\r\n\t\t\tvalue: function () {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \\'WEBGL_compressed_texture_pvrtc\\' ).' );\r\n\t\t\t\treturn this.extensions.get( 'WEBGL_compressed_texture_pvrtc' );\r\n\t\t\t}\r\n\t\t},\r\n\t\tsupportsBlendMinMax: {\r\n\t\t\tvalue: function () {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \\'EXT_blend_minmax\\' ).' );\r\n\t\t\t\treturn this.extensions.get( 'EXT_blend_minmax' );\r\n\t\t\t}\r\n\t\t},\r\n\t\tsupportsVertexTextures: {\r\n\t\t\tvalue: function () {\r\n\t\t\t\treturn this.capabilities.vertexTextures;\r\n\t\t\t}\r\n\t\t},\r\n\t\tsupportsInstancedArrays: {\r\n\t\t\tvalue: function () {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \\'ANGLE_instanced_arrays\\' ).' );\r\n\t\t\t\treturn this.extensions.get( 'ANGLE_instanced_arrays' );\r\n\t\t\t}\r\n\t\t},\r\n\t\tenableScissorTest: {\r\n\t\t\tvalue: function ( boolean ) {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().' );\r\n\t\t\t\tthis.setScissorTest( boolean );\r\n\t\t\t}\r\n\t\t},\r\n\t\tinitMaterial: {\r\n\t\t\tvalue: function () {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );\r\n\t\t\t}\r\n\t\t},\r\n\t\taddPrePlugin: {\r\n\t\t\tvalue: function () {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );\r\n\t\t\t}\r\n\t\t},\r\n\t\taddPostPlugin: {\r\n\t\t\tvalue: function () {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );\r\n\t\t\t}\r\n\t\t},\r\n\t\tupdateShadowMap: {\r\n\t\t\tvalue: function () {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );\r\n\t\t\t}\r\n\t\t},\r\n\t\tshadowMapEnabled: {\r\n\t\t\tget: function () {\r\n\t\t\t\treturn this.shadowMap.enabled;\r\n\t\t\t},\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );\r\n\t\t\t\tthis.shadowMap.enabled = value;\r\n\t\t\t}\r\n\t\t},\r\n\t\tshadowMapType: {\r\n\t\t\tget: function () {\r\n\t\t\t\treturn this.shadowMap.type;\r\n\t\t\t},\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );\r\n\t\t\t\tthis.shadowMap.type = value;\r\n\t\t\t}\r\n\t\t},\r\n\t\tshadowMapCullFace: {\r\n\t\t\tget: function () {\r\n\t\t\t\treturn this.shadowMap.cullFace;\r\n\t\t\t},\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.' );\r\n\t\t\t\tthis.shadowMap.cullFace = value;\r\n\t\t\t}\r\n\t\t}\r\n\t} );\r\n\t\r\n\t//\r\n\t\r\n\tObject.defineProperties( THREE.WebGLRenderTarget.prototype, {\r\n\t\twrapS: {\r\n\t\t\tget: function () {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );\r\n\t\t\t\treturn this.texture.wrapS;\r\n\t\t\t},\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );\r\n\t\t\t\tthis.texture.wrapS = value;\r\n\t\t\t}\r\n\t\t},\r\n\t\twrapT: {\r\n\t\t\tget: function () {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );\r\n\t\t\t\treturn this.texture.wrapT;\r\n\t\t\t},\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );\r\n\t\t\t\tthis.texture.wrapT = value;\r\n\t\t\t}\r\n\t\t},\r\n\t\tmagFilter: {\r\n\t\t\tget: function () {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );\r\n\t\t\t\treturn this.texture.magFilter;\r\n\t\t\t},\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );\r\n\t\t\t\tthis.texture.magFilter = value;\r\n\t\t\t}\r\n\t\t},\r\n\t\tminFilter: {\r\n\t\t\tget: function () {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );\r\n\t\t\t\treturn this.texture.minFilter;\r\n\t\t\t},\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );\r\n\t\t\t\tthis.texture.minFilter = value;\r\n\t\t\t}\r\n\t\t},\r\n\t\tanisotropy: {\r\n\t\t\tget: function () {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );\r\n\t\t\t\treturn this.texture.anisotropy;\r\n\t\t\t},\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );\r\n\t\t\t\tthis.texture.anisotropy = value;\r\n\t\t\t}\r\n\t\t},\r\n\t\toffset: {\r\n\t\t\tget: function () {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );\r\n\t\t\t\treturn this.texture.offset;\r\n\t\t\t},\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );\r\n\t\t\t\tthis.texture.offset = value;\r\n\t\t\t}\r\n\t\t},\r\n\t\trepeat: {\r\n\t\t\tget: function () {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );\r\n\t\t\t\treturn this.texture.repeat;\r\n\t\t\t},\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );\r\n\t\t\t\tthis.texture.repeat = value;\r\n\t\t\t}\r\n\t\t},\r\n\t\tformat: {\r\n\t\t\tget: function () {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );\r\n\t\t\t\treturn this.texture.format;\r\n\t\t\t},\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );\r\n\t\t\t\tthis.texture.format = value;\r\n\t\t\t}\r\n\t\t},\r\n\t\ttype: {\r\n\t\t\tget: function () {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );\r\n\t\t\t\treturn this.texture.type;\r\n\t\t\t},\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );\r\n\t\t\t\tthis.texture.type = value;\r\n\t\t\t}\r\n\t\t},\r\n\t\tgenerateMipmaps: {\r\n\t\t\tget: function () {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );\r\n\t\t\t\treturn this.texture.generateMipmaps;\r\n\t\t\t},\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );\r\n\t\t\t\tthis.texture.generateMipmaps = value;\r\n\t\t\t}\r\n\t\t}\r\n\t} );\r\n\t\r\n\t//\r\n\t\r\n\tObject.defineProperties( THREE.Audio.prototype, {\r\n\t\tload: {\r\n\t\t\tvalue: function ( file ) {\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.Audio: .load has been deprecated. Please use THREE.AudioLoader.' );\r\n\t\r\n\t\t\t\tvar scope = this;\r\n\t\r\n\t\t\t\tvar audioLoader = new THREE.AudioLoader();\r\n\t\r\n\t\t\t\taudioLoader.load( file, function ( buffer ) {\r\n\t\r\n\t\t\t\t\tscope.setBuffer( buffer );\r\n\t\r\n\t\t\t\t} );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t}\r\n\t\t}\r\n\t} );\r\n\t\r\n\t//\r\n\t\r\n\tTHREE.GeometryUtils = {\r\n\t\r\n\t\tmerge: function ( geometry1, geometry2, materialIndexOffset ) {\r\n\t\r\n\t\t\tconsole.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );\r\n\t\r\n\t\t\tvar matrix;\r\n\t\r\n\t\t\tif ( geometry2 instanceof THREE.Mesh ) {\r\n\t\r\n\t\t\t\tgeometry2.matrixAutoUpdate && geometry2.updateMatrix();\r\n\t\r\n\t\t\t\tmatrix = geometry2.matrix;\r\n\t\t\t\tgeometry2 = geometry2.geometry;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tgeometry1.merge( geometry2, matrix, materialIndexOffset );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcenter: function ( geometry ) {\r\n\t\r\n\t\t\tconsole.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );\r\n\t\t\treturn geometry.center();\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.ImageUtils = {\r\n\t\r\n\t\tcrossOrigin: undefined,\r\n\t\r\n\t\tloadTexture: function ( url, mapping, onLoad, onError ) {\r\n\t\r\n\t\t\tconsole.warn( 'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.' );\r\n\t\r\n\t\t\tvar loader = new THREE.TextureLoader();\r\n\t\t\tloader.setCrossOrigin( this.crossOrigin );\r\n\t\r\n\t\t\tvar texture = loader.load( url, onLoad, undefined, onError );\r\n\t\r\n\t\t\tif ( mapping ) texture.mapping = mapping;\r\n\t\r\n\t\t\treturn texture;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tloadTextureCube: function ( urls, mapping, onLoad, onError ) {\r\n\t\r\n\t\t\tconsole.warn( 'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.' );\r\n\t\r\n\t\t\tvar loader = new THREE.CubeTextureLoader();\r\n\t\t\tloader.setCrossOrigin( this.crossOrigin );\r\n\t\r\n\t\t\tvar texture = loader.load( urls, onLoad, undefined, onError );\r\n\t\r\n\t\t\tif ( mapping ) texture.mapping = mapping;\r\n\t\r\n\t\t\treturn texture;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tloadCompressedTexture: function () {\r\n\t\r\n\t\t\tconsole.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tloadCompressedTextureCube: function () {\r\n\t\r\n\t\t\tconsole.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t//\r\n\t\r\n\tTHREE.Projector = function () {\r\n\t\r\n\t\tconsole.error( 'THREE.Projector has been moved to /examples/js/renderers/Projector.js.' );\r\n\t\r\n\t\tthis.projectVector = function ( vector, camera ) {\r\n\t\r\n\t\t\tconsole.warn( 'THREE.Projector: .projectVector() is now vector.project().' );\r\n\t\t\tvector.project( camera );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.unprojectVector = function ( vector, camera ) {\r\n\t\r\n\t\t\tconsole.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );\r\n\t\t\tvector.unproject( camera );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.pickingRay = function ( vector, camera ) {\r\n\t\r\n\t\t\tconsole.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );\r\n\t\r\n\t\t};\r\n\t\r\n\t};\r\n\t\r\n\t//\r\n\t\r\n\tTHREE.CanvasRenderer = function () {\r\n\t\r\n\t\tconsole.error( 'THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js' );\r\n\t\r\n\t\tthis.domElement = document.createElement( 'canvas' );\r\n\t\tthis.clear = function () {};\r\n\t\tthis.render = function () {};\r\n\t\tthis.setClearColor = function () {};\r\n\t\tthis.setSize = function () {};\r\n\t\r\n\t};\r\n\t\r\n\t//\r\n\t\r\n\tTHREE.MeshFaceMaterial = THREE.MultiMaterial;\r\n\t\r\n\t//\r\n\t\r\n\tObject.defineProperties( THREE.LOD.prototype, {\r\n\t\tobjects: {\r\n\t\t\tget: function () {\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.LOD: .objects has been renamed to .levels.' );\r\n\t\t\t\treturn this.levels;\r\n\t\r\n\t\t\t}\r\n\t\t}\r\n\t} );\r\n\t\r\n\t// File:src/extras/CurveUtils.js\r\n\t\r\n\t/**\r\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\r\n\t */\r\n\t\r\n\tTHREE.CurveUtils = {\r\n\t\r\n\t\ttangentQuadraticBezier: function ( t, p0, p1, p2 ) {\r\n\t\r\n\t\t\treturn 2 * ( 1 - t ) * ( p1 - p0 ) + 2 * t * ( p2 - p1 );\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Puay Bing, thanks for helping with this derivative!\r\n\t\r\n\t\ttangentCubicBezier: function ( t, p0, p1, p2, p3 ) {\r\n\t\r\n\t\t\treturn - 3 * p0 * ( 1 - t ) * ( 1 - t )  +\r\n\t\t\t\t3 * p1 * ( 1 - t ) * ( 1 - t ) - 6 * t * p1 * ( 1 - t ) +\r\n\t\t\t\t6 * t *  p2 * ( 1 - t ) - 3 * t * t * p2 +\r\n\t\t\t\t3 * t * t * p3;\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttangentSpline: function ( t, p0, p1, p2, p3 ) {\r\n\t\r\n\t\t\t// To check if my formulas are correct\r\n\t\r\n\t\t\tvar h00 = 6 * t * t - 6 * t; \t// derived from 2t^3  3t^2 + 1\r\n\t\t\tvar h10 = 3 * t * t - 4 * t + 1; // t^3  2t^2 + t\r\n\t\t\tvar h01 = - 6 * t * t + 6 * t; \t//  2t3 + 3t2\r\n\t\t\tvar h11 = 3 * t * t - 2 * t;\t// t3  t2\r\n\t\r\n\t\t\treturn h00 + h10 + h01 + h11;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Catmull-Rom\r\n\t\r\n\t\tinterpolate: function( p0, p1, p2, p3, t ) {\r\n\t\r\n\t\t\tvar v0 = ( p2 - p0 ) * 0.5;\r\n\t\t\tvar v1 = ( p3 - p1 ) * 0.5;\r\n\t\t\tvar t2 = t * t;\r\n\t\t\tvar t3 = t * t2;\r\n\t\t\treturn ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/SceneUtils.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.SceneUtils = {\r\n\t\r\n\t\tcreateMultiMaterialObject: function ( geometry, materials ) {\r\n\t\r\n\t\t\tvar group = new THREE.Group();\r\n\t\r\n\t\t\tfor ( var i = 0, l = materials.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tgroup.add( new THREE.Mesh( geometry, materials[ i ] ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn group;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdetach: function ( child, parent, scene ) {\r\n\t\r\n\t\t\tchild.applyMatrix( parent.matrixWorld );\r\n\t\t\tparent.remove( child );\r\n\t\t\tscene.add( child );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tattach: function ( child, scene, parent ) {\r\n\t\r\n\t\t\tvar matrixWorldInverse = new THREE.Matrix4();\r\n\t\t\tmatrixWorldInverse.getInverse( parent.matrixWorld );\r\n\t\t\tchild.applyMatrix( matrixWorldInverse );\r\n\t\r\n\t\t\tscene.remove( child );\r\n\t\t\tparent.add( child );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/ShapeUtils.js\r\n\t\r\n\t/**\r\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\r\n\t */\r\n\t\r\n\tTHREE.ShapeUtils = {\r\n\t\r\n\t\t// calculate area of the contour polygon\r\n\t\r\n\t\tarea: function ( contour ) {\r\n\t\r\n\t\t\tvar n = contour.length;\r\n\t\t\tvar a = 0.0;\r\n\t\r\n\t\t\tfor ( var p = n - 1, q = 0; q < n; p = q ++ ) {\r\n\t\r\n\t\t\t\ta += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn a * 0.5;\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttriangulate: ( function () {\r\n\t\r\n\t\t\t/**\r\n\t\t\t * This code is a quick port of code written in C++ which was submitted to\r\n\t\t\t * flipcode.com by John W. Ratcliff  // July 22, 2000\r\n\t\t\t * See original code and more information here:\r\n\t\t\t * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml\r\n\t\t\t *\r\n\t\t\t * ported to actionscript by Zevan Rosser\r\n\t\t\t * www.actionsnippet.com\r\n\t\t\t *\r\n\t\t\t * ported to javascript by Joshua Koo\r\n\t\t\t * http://www.lab4games.net/zz85/blog\r\n\t\t\t *\r\n\t\t\t */\r\n\t\r\n\t\t\tfunction snip( contour, u, v, w, n, verts ) {\r\n\t\r\n\t\t\t\tvar p;\r\n\t\t\t\tvar ax, ay, bx, by;\r\n\t\t\t\tvar cx, cy, px, py;\r\n\t\r\n\t\t\t\tax = contour[ verts[ u ] ].x;\r\n\t\t\t\tay = contour[ verts[ u ] ].y;\r\n\t\r\n\t\t\t\tbx = contour[ verts[ v ] ].x;\r\n\t\t\t\tby = contour[ verts[ v ] ].y;\r\n\t\r\n\t\t\t\tcx = contour[ verts[ w ] ].x;\r\n\t\t\t\tcy = contour[ verts[ w ] ].y;\r\n\t\r\n\t\t\t\tif ( Number.EPSILON > ( ( ( bx - ax ) * ( cy - ay ) ) - ( ( by - ay ) * ( cx - ax ) ) ) ) return false;\r\n\t\r\n\t\t\t\tvar aX, aY, bX, bY, cX, cY;\r\n\t\t\t\tvar apx, apy, bpx, bpy, cpx, cpy;\r\n\t\t\t\tvar cCROSSap, bCROSScp, aCROSSbp;\r\n\t\r\n\t\t\t\taX = cx - bx;  aY = cy - by;\r\n\t\t\t\tbX = ax - cx;  bY = ay - cy;\r\n\t\t\t\tcX = bx - ax;  cY = by - ay;\r\n\t\r\n\t\t\t\tfor ( p = 0; p < n; p ++ ) {\r\n\t\r\n\t\t\t\t\tpx = contour[ verts[ p ] ].x;\r\n\t\t\t\t\tpy = contour[ verts[ p ] ].y;\r\n\t\r\n\t\t\t\t\tif ( ( ( px === ax ) && ( py === ay ) ) ||\r\n\t\t\t\t\t\t ( ( px === bx ) && ( py === by ) ) ||\r\n\t\t\t\t\t\t ( ( px === cx ) && ( py === cy ) ) )\tcontinue;\r\n\t\r\n\t\t\t\t\tapx = px - ax;  apy = py - ay;\r\n\t\t\t\t\tbpx = px - bx;  bpy = py - by;\r\n\t\t\t\t\tcpx = px - cx;  cpy = py - cy;\r\n\t\r\n\t\t\t\t\t// see if p is inside triangle abc\r\n\t\r\n\t\t\t\t\taCROSSbp = aX * bpy - aY * bpx;\r\n\t\t\t\t\tcCROSSap = cX * apy - cY * apx;\r\n\t\t\t\t\tbCROSScp = bX * cpy - bY * cpx;\r\n\t\r\n\t\t\t\t\tif ( ( aCROSSbp >= - Number.EPSILON ) && ( bCROSScp >= - Number.EPSILON ) && ( cCROSSap >= - Number.EPSILON ) ) return false;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// takes in an contour array and returns\r\n\t\r\n\t\t\treturn function ( contour, indices ) {\r\n\t\r\n\t\t\t\tvar n = contour.length;\r\n\t\r\n\t\t\t\tif ( n < 3 ) return null;\r\n\t\r\n\t\t\t\tvar result = [],\r\n\t\t\t\t\tverts = [],\r\n\t\t\t\t\tvertIndices = [];\r\n\t\r\n\t\t\t\t/* we want a counter-clockwise polygon in verts */\r\n\t\r\n\t\t\t\tvar u, v, w;\r\n\t\r\n\t\t\t\tif ( THREE.ShapeUtils.area( contour ) > 0.0 ) {\r\n\t\r\n\t\t\t\t\tfor ( v = 0; v < n; v ++ ) verts[ v ] = v;\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tfor ( v = 0; v < n; v ++ ) verts[ v ] = ( n - 1 ) - v;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar nv = n;\r\n\t\r\n\t\t\t\t/*  remove nv - 2 vertices, creating 1 triangle every time */\r\n\t\r\n\t\t\t\tvar count = 2 * nv;   /* error detection */\r\n\t\r\n\t\t\t\tfor ( v = nv - 1; nv > 2; ) {\r\n\t\r\n\t\t\t\t\t/* if we loop, it is probably a non-simple polygon */\r\n\t\r\n\t\t\t\t\tif ( ( count -- ) <= 0 ) {\r\n\t\r\n\t\t\t\t\t\t//** Triangulate: ERROR - probable bad polygon!\r\n\t\r\n\t\t\t\t\t\t//throw ( \"Warning, unable to triangulate polygon!\" );\r\n\t\t\t\t\t\t//return null;\r\n\t\t\t\t\t\t// Sometimes warning is fine, especially polygons are triangulated in reverse.\r\n\t\t\t\t\t\tconsole.warn( 'THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()' );\r\n\t\r\n\t\t\t\t\t\tif ( indices ) return vertIndices;\r\n\t\t\t\t\t\treturn result;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t/* three consecutive vertices in current polygon, <u,v,w> */\r\n\t\r\n\t\t\t\t\tu = v; \t \tif ( nv <= u ) u = 0;     /* previous */\r\n\t\t\t\t\tv = u + 1;  if ( nv <= v ) v = 0;     /* new v    */\r\n\t\t\t\t\tw = v + 1;  if ( nv <= w ) w = 0;     /* next     */\r\n\t\r\n\t\t\t\t\tif ( snip( contour, u, v, w, nv, verts ) ) {\r\n\t\r\n\t\t\t\t\t\tvar a, b, c, s, t;\r\n\t\r\n\t\t\t\t\t\t/* true names of the vertices */\r\n\t\r\n\t\t\t\t\t\ta = verts[ u ];\r\n\t\t\t\t\t\tb = verts[ v ];\r\n\t\t\t\t\t\tc = verts[ w ];\r\n\t\r\n\t\t\t\t\t\t/* output Triangle */\r\n\t\r\n\t\t\t\t\t\tresult.push( [ contour[ a ],\r\n\t\t\t\t\t\t\tcontour[ b ],\r\n\t\t\t\t\t\t\tcontour[ c ] ] );\r\n\t\r\n\t\r\n\t\t\t\t\t\tvertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );\r\n\t\r\n\t\t\t\t\t\t/* remove v from the remaining polygon */\r\n\t\r\n\t\t\t\t\t\tfor ( s = v, t = v + 1; t < nv; s ++, t ++ ) {\r\n\t\r\n\t\t\t\t\t\t\tverts[ s ] = verts[ t ];\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tnv --;\r\n\t\r\n\t\t\t\t\t\t/* reset error detection counter */\r\n\t\r\n\t\t\t\t\t\tcount = 2 * nv;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( indices ) return vertIndices;\r\n\t\t\t\treturn result;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t} )(),\r\n\t\r\n\t\ttriangulateShape: function ( contour, holes ) {\r\n\t\r\n\t\t\tfunction point_in_segment_2D_colin( inSegPt1, inSegPt2, inOtherPt ) {\r\n\t\r\n\t\t\t\t// inOtherPt needs to be collinear to the inSegment\r\n\t\t\t\tif ( inSegPt1.x !== inSegPt2.x ) {\r\n\t\r\n\t\t\t\t\tif ( inSegPt1.x < inSegPt2.x ) {\r\n\t\r\n\t\t\t\t\t\treturn\t( ( inSegPt1.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt2.x ) );\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\treturn\t( ( inSegPt2.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt1.x ) );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tif ( inSegPt1.y < inSegPt2.y ) {\r\n\t\r\n\t\t\t\t\t\treturn\t( ( inSegPt1.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt2.y ) );\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\treturn\t( ( inSegPt2.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt1.y ) );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfunction intersect_segments_2D( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs ) {\r\n\t\r\n\t\t\t\tvar seg1dx = inSeg1Pt2.x - inSeg1Pt1.x,   seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;\r\n\t\t\t\tvar seg2dx = inSeg2Pt2.x - inSeg2Pt1.x,   seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;\r\n\t\r\n\t\t\t\tvar seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;\r\n\t\t\t\tvar seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;\r\n\t\r\n\t\t\t\tvar limit\t\t= seg1dy * seg2dx - seg1dx * seg2dy;\r\n\t\t\t\tvar perpSeg1\t= seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;\r\n\t\r\n\t\t\t\tif ( Math.abs( limit ) > Number.EPSILON ) {\r\n\t\r\n\t\t\t\t\t// not parallel\r\n\t\r\n\t\t\t\t\tvar perpSeg2;\r\n\t\t\t\t\tif ( limit > 0 ) {\r\n\t\r\n\t\t\t\t\t\tif ( ( perpSeg1 < 0 ) || ( perpSeg1 > limit ) ) \t\treturn [];\r\n\t\t\t\t\t\tperpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;\r\n\t\t\t\t\t\tif ( ( perpSeg2 < 0 ) || ( perpSeg2 > limit ) ) \t\treturn [];\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tif ( ( perpSeg1 > 0 ) || ( perpSeg1 < limit ) ) \t\treturn [];\r\n\t\t\t\t\t\tperpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;\r\n\t\t\t\t\t\tif ( ( perpSeg2 > 0 ) || ( perpSeg2 < limit ) ) \t\treturn [];\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t// i.e. to reduce rounding errors\r\n\t\t\t\t\t// intersection at endpoint of segment#1?\r\n\t\t\t\t\tif ( perpSeg2 === 0 ) {\r\n\t\r\n\t\t\t\t\t\tif ( ( inExcludeAdjacentSegs ) &&\r\n\t\t\t\t\t\t\t ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )\t\treturn [];\r\n\t\t\t\t\t\treturn [ inSeg1Pt1 ];\r\n\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ( perpSeg2 === limit ) {\r\n\t\r\n\t\t\t\t\t\tif ( ( inExcludeAdjacentSegs ) &&\r\n\t\t\t\t\t\t\t ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )\t\treturn [];\r\n\t\t\t\t\t\treturn [ inSeg1Pt2 ];\r\n\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// intersection at endpoint of segment#2?\r\n\t\t\t\t\tif ( perpSeg1 === 0 )\t\treturn [ inSeg2Pt1 ];\r\n\t\t\t\t\tif ( perpSeg1 === limit )\treturn [ inSeg2Pt2 ];\r\n\t\r\n\t\t\t\t\t// return real intersection point\r\n\t\t\t\t\tvar factorSeg1 = perpSeg2 / limit;\r\n\t\t\t\t\treturn\t[ { x: inSeg1Pt1.x + factorSeg1 * seg1dx,\r\n\t\t\t\t\t\t\t\ty: inSeg1Pt1.y + factorSeg1 * seg1dy } ];\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t// parallel or collinear\r\n\t\t\t\t\tif ( ( perpSeg1 !== 0 ) ||\r\n\t\t\t\t\t\t ( seg2dy * seg1seg2dx !== seg2dx * seg1seg2dy ) ) \t\t\treturn [];\r\n\t\r\n\t\t\t\t\t// they are collinear or degenerate\r\n\t\t\t\t\tvar seg1Pt = ( ( seg1dx === 0 ) && ( seg1dy === 0 ) );\t// segment1 is just a point?\r\n\t\t\t\t\tvar seg2Pt = ( ( seg2dx === 0 ) && ( seg2dy === 0 ) );\t// segment2 is just a point?\r\n\t\t\t\t\t// both segments are points\r\n\t\t\t\t\tif ( seg1Pt && seg2Pt ) {\r\n\t\r\n\t\t\t\t\t\tif ( ( inSeg1Pt1.x !== inSeg2Pt1.x ) ||\r\n\t\t\t\t\t\t\t ( inSeg1Pt1.y !== inSeg2Pt1.y ) )\t\treturn [];\t// they are distinct  points\r\n\t\t\t\t\t\treturn [ inSeg1Pt1 ];                 \t\t\t\t\t\t// they are the same point\r\n\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// segment#1  is a single point\r\n\t\t\t\t\tif ( seg1Pt ) {\r\n\t\r\n\t\t\t\t\t\tif ( ! point_in_segment_2D_colin( inSeg2Pt1, inSeg2Pt2, inSeg1Pt1 ) )\t\treturn [];\t\t// but not in segment#2\r\n\t\t\t\t\t\treturn [ inSeg1Pt1 ];\r\n\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// segment#2  is a single point\r\n\t\t\t\t\tif ( seg2Pt ) {\r\n\t\r\n\t\t\t\t\t\tif ( ! point_in_segment_2D_colin( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1 ) )\t\treturn [];\t\t// but not in segment#1\r\n\t\t\t\t\t\treturn [ inSeg2Pt1 ];\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t// they are collinear segments, which might overlap\r\n\t\t\t\t\tvar seg1min, seg1max, seg1minVal, seg1maxVal;\r\n\t\t\t\t\tvar seg2min, seg2max, seg2minVal, seg2maxVal;\r\n\t\t\t\t\tif ( seg1dx !== 0 ) {\r\n\t\r\n\t\t\t\t\t\t// the segments are NOT on a vertical line\r\n\t\t\t\t\t\tif ( inSeg1Pt1.x < inSeg1Pt2.x ) {\r\n\t\r\n\t\t\t\t\t\t\tseg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.x;\r\n\t\t\t\t\t\t\tseg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.x;\r\n\t\r\n\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\tseg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.x;\r\n\t\t\t\t\t\t\tseg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.x;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif ( inSeg2Pt1.x < inSeg2Pt2.x ) {\r\n\t\r\n\t\t\t\t\t\t\tseg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.x;\r\n\t\t\t\t\t\t\tseg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.x;\r\n\t\r\n\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\tseg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.x;\r\n\t\t\t\t\t\t\tseg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.x;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t// the segments are on a vertical line\r\n\t\t\t\t\t\tif ( inSeg1Pt1.y < inSeg1Pt2.y ) {\r\n\t\r\n\t\t\t\t\t\t\tseg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.y;\r\n\t\t\t\t\t\t\tseg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.y;\r\n\t\r\n\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\tseg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.y;\r\n\t\t\t\t\t\t\tseg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.y;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif ( inSeg2Pt1.y < inSeg2Pt2.y ) {\r\n\t\r\n\t\t\t\t\t\t\tseg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.y;\r\n\t\t\t\t\t\t\tseg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.y;\r\n\t\r\n\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\tseg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.y;\r\n\t\t\t\t\t\t\tseg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.y;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ( seg1minVal <= seg2minVal ) {\r\n\t\r\n\t\t\t\t\t\tif ( seg1maxVal <  seg2minVal )\treturn [];\r\n\t\t\t\t\t\tif ( seg1maxVal === seg2minVal )\t{\r\n\t\r\n\t\t\t\t\t\t\tif ( inExcludeAdjacentSegs )\t\treturn [];\r\n\t\t\t\t\t\t\treturn [ seg2min ];\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif ( seg1maxVal <= seg2maxVal )\treturn [ seg2min, seg1max ];\r\n\t\t\t\t\t\treturn\t[ seg2min, seg2max ];\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tif ( seg1minVal >  seg2maxVal )\treturn [];\r\n\t\t\t\t\t\tif ( seg1minVal === seg2maxVal )\t{\r\n\t\r\n\t\t\t\t\t\t\tif ( inExcludeAdjacentSegs )\t\treturn [];\r\n\t\t\t\t\t\t\treturn [ seg1min ];\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif ( seg1maxVal <= seg2maxVal )\treturn [ seg1min, seg1max ];\r\n\t\t\t\t\t\treturn\t[ seg1min, seg2max ];\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfunction isPointInsideAngle( inVertex, inLegFromPt, inLegToPt, inOtherPt ) {\r\n\t\r\n\t\t\t\t// The order of legs is important\r\n\t\r\n\t\t\t\t// translation of all points, so that Vertex is at (0,0)\r\n\t\t\t\tvar legFromPtX\t= inLegFromPt.x - inVertex.x,  legFromPtY\t= inLegFromPt.y - inVertex.y;\r\n\t\t\t\tvar legToPtX\t= inLegToPt.x\t- inVertex.x,  legToPtY\t\t= inLegToPt.y\t- inVertex.y;\r\n\t\t\t\tvar otherPtX\t= inOtherPt.x\t- inVertex.x,  otherPtY\t\t= inOtherPt.y\t- inVertex.y;\r\n\t\r\n\t\t\t\t// main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.\r\n\t\t\t\tvar from2toAngle\t= legFromPtX * legToPtY - legFromPtY * legToPtX;\r\n\t\t\t\tvar from2otherAngle\t= legFromPtX * otherPtY - legFromPtY * otherPtX;\r\n\t\r\n\t\t\t\tif ( Math.abs( from2toAngle ) > Number.EPSILON ) {\r\n\t\r\n\t\t\t\t\t// angle != 180 deg.\r\n\t\r\n\t\t\t\t\tvar other2toAngle\t\t= otherPtX * legToPtY - otherPtY * legToPtX;\r\n\t\t\t\t\t// console.log( \"from2to: \" + from2toAngle + \", from2other: \" + from2otherAngle + \", other2to: \" + other2toAngle );\r\n\t\r\n\t\t\t\t\tif ( from2toAngle > 0 ) {\r\n\t\r\n\t\t\t\t\t\t// main angle < 180 deg.\r\n\t\t\t\t\t\treturn\t( ( from2otherAngle >= 0 ) && ( other2toAngle >= 0 ) );\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t// main angle > 180 deg.\r\n\t\t\t\t\t\treturn\t( ( from2otherAngle >= 0 ) || ( other2toAngle >= 0 ) );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t// angle == 180 deg.\r\n\t\t\t\t\t// console.log( \"from2to: 180 deg., from2other: \" + from2otherAngle  );\r\n\t\t\t\t\treturn\t( from2otherAngle > 0 );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\r\n\t\t\tfunction removeHoles( contour, holes ) {\r\n\t\r\n\t\t\t\tvar shape = contour.concat(); // work on this shape\r\n\t\t\t\tvar hole;\r\n\t\r\n\t\t\t\tfunction isCutLineInsideAngles( inShapeIdx, inHoleIdx ) {\r\n\t\r\n\t\t\t\t\t// Check if hole point lies within angle around shape point\r\n\t\t\t\t\tvar lastShapeIdx = shape.length - 1;\r\n\t\r\n\t\t\t\t\tvar prevShapeIdx = inShapeIdx - 1;\r\n\t\t\t\t\tif ( prevShapeIdx < 0 )\t\t\tprevShapeIdx = lastShapeIdx;\r\n\t\r\n\t\t\t\t\tvar nextShapeIdx = inShapeIdx + 1;\r\n\t\t\t\t\tif ( nextShapeIdx > lastShapeIdx )\tnextShapeIdx = 0;\r\n\t\r\n\t\t\t\t\tvar insideAngle = isPointInsideAngle( shape[ inShapeIdx ], shape[ prevShapeIdx ], shape[ nextShapeIdx ], hole[ inHoleIdx ] );\r\n\t\t\t\t\tif ( ! insideAngle ) {\r\n\t\r\n\t\t\t\t\t\t// console.log( \"Vertex (Shape): \" + inShapeIdx + \", Point: \" + hole[inHoleIdx].x + \"/\" + hole[inHoleIdx].y );\r\n\t\t\t\t\t\treturn\tfalse;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t// Check if shape point lies within angle around hole point\r\n\t\t\t\t\tvar lastHoleIdx = hole.length - 1;\r\n\t\r\n\t\t\t\t\tvar prevHoleIdx = inHoleIdx - 1;\r\n\t\t\t\t\tif ( prevHoleIdx < 0 )\t\t\tprevHoleIdx = lastHoleIdx;\r\n\t\r\n\t\t\t\t\tvar nextHoleIdx = inHoleIdx + 1;\r\n\t\t\t\t\tif ( nextHoleIdx > lastHoleIdx )\tnextHoleIdx = 0;\r\n\t\r\n\t\t\t\t\tinsideAngle = isPointInsideAngle( hole[ inHoleIdx ], hole[ prevHoleIdx ], hole[ nextHoleIdx ], shape[ inShapeIdx ] );\r\n\t\t\t\t\tif ( ! insideAngle ) {\r\n\t\r\n\t\t\t\t\t\t// console.log( \"Vertex (Hole): \" + inHoleIdx + \", Point: \" + shape[inShapeIdx].x + \"/\" + shape[inShapeIdx].y );\r\n\t\t\t\t\t\treturn\tfalse;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\treturn\ttrue;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tfunction intersectsShapeEdge( inShapePt, inHolePt ) {\r\n\t\r\n\t\t\t\t\t// checks for intersections with shape edges\r\n\t\t\t\t\tvar sIdx, nextIdx, intersection;\r\n\t\t\t\t\tfor ( sIdx = 0; sIdx < shape.length; sIdx ++ ) {\r\n\t\r\n\t\t\t\t\t\tnextIdx = sIdx + 1; nextIdx %= shape.length;\r\n\t\t\t\t\t\tintersection = intersect_segments_2D( inShapePt, inHolePt, shape[ sIdx ], shape[ nextIdx ], true );\r\n\t\t\t\t\t\tif ( intersection.length > 0 )\t\treturn\ttrue;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\treturn\tfalse;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar indepHoles = [];\r\n\t\r\n\t\t\t\tfunction intersectsHoleEdge( inShapePt, inHolePt ) {\r\n\t\r\n\t\t\t\t\t// checks for intersections with hole edges\r\n\t\t\t\t\tvar ihIdx, chkHole,\r\n\t\t\t\t\t\thIdx, nextIdx, intersection;\r\n\t\t\t\t\tfor ( ihIdx = 0; ihIdx < indepHoles.length; ihIdx ++ ) {\r\n\t\r\n\t\t\t\t\t\tchkHole = holes[ indepHoles[ ihIdx ]];\r\n\t\t\t\t\t\tfor ( hIdx = 0; hIdx < chkHole.length; hIdx ++ ) {\r\n\t\r\n\t\t\t\t\t\t\tnextIdx = hIdx + 1; nextIdx %= chkHole.length;\r\n\t\t\t\t\t\t\tintersection = intersect_segments_2D( inShapePt, inHolePt, chkHole[ hIdx ], chkHole[ nextIdx ], true );\r\n\t\t\t\t\t\t\tif ( intersection.length > 0 )\t\treturn\ttrue;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn\tfalse;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar holeIndex, shapeIndex,\r\n\t\t\t\t\tshapePt, holePt,\r\n\t\t\t\t\tholeIdx, cutKey, failedCuts = [],\r\n\t\t\t\t\ttmpShape1, tmpShape2,\r\n\t\t\t\t\ttmpHole1, tmpHole2;\r\n\t\r\n\t\t\t\tfor ( var h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\t\r\n\t\t\t\t\tindepHoles.push( h );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar minShapeIndex = 0;\r\n\t\t\t\tvar counter = indepHoles.length * 2;\r\n\t\t\t\twhile ( indepHoles.length > 0 ) {\r\n\t\r\n\t\t\t\t\tcounter --;\r\n\t\t\t\t\tif ( counter < 0 ) {\r\n\t\r\n\t\t\t\t\t\tconsole.log( \"Infinite Loop! Holes left:\" + indepHoles.length + \", Probably Hole outside Shape!\" );\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t// search for shape-vertex and hole-vertex,\r\n\t\t\t\t\t// which can be connected without intersections\r\n\t\t\t\t\tfor ( shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex ++ ) {\r\n\t\r\n\t\t\t\t\t\tshapePt = shape[ shapeIndex ];\r\n\t\t\t\t\t\tholeIndex\t= - 1;\r\n\t\r\n\t\t\t\t\t\t// search for hole which can be reached without intersections\r\n\t\t\t\t\t\tfor ( var h = 0; h < indepHoles.length; h ++ ) {\r\n\t\r\n\t\t\t\t\t\t\tholeIdx = indepHoles[ h ];\r\n\t\r\n\t\t\t\t\t\t\t// prevent multiple checks\r\n\t\t\t\t\t\t\tcutKey = shapePt.x + \":\" + shapePt.y + \":\" + holeIdx;\r\n\t\t\t\t\t\t\tif ( failedCuts[ cutKey ] !== undefined )\t\t\tcontinue;\r\n\t\r\n\t\t\t\t\t\t\thole = holes[ holeIdx ];\r\n\t\t\t\t\t\t\tfor ( var h2 = 0; h2 < hole.length; h2 ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\tholePt = hole[ h2 ];\r\n\t\t\t\t\t\t\t\tif ( ! isCutLineInsideAngles( shapeIndex, h2 ) )\t\tcontinue;\r\n\t\t\t\t\t\t\t\tif ( intersectsShapeEdge( shapePt, holePt ) )\t\tcontinue;\r\n\t\t\t\t\t\t\t\tif ( intersectsHoleEdge( shapePt, holePt ) )\t\tcontinue;\r\n\t\r\n\t\t\t\t\t\t\t\tholeIndex = h2;\r\n\t\t\t\t\t\t\t\tindepHoles.splice( h, 1 );\r\n\t\r\n\t\t\t\t\t\t\t\ttmpShape1 = shape.slice( 0, shapeIndex + 1 );\r\n\t\t\t\t\t\t\t\ttmpShape2 = shape.slice( shapeIndex );\r\n\t\t\t\t\t\t\t\ttmpHole1 = hole.slice( holeIndex );\r\n\t\t\t\t\t\t\t\ttmpHole2 = hole.slice( 0, holeIndex + 1 );\r\n\t\r\n\t\t\t\t\t\t\t\tshape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );\r\n\t\r\n\t\t\t\t\t\t\t\tminShapeIndex = shapeIndex;\r\n\t\r\n\t\t\t\t\t\t\t\t// Debug only, to show the selected cuts\r\n\t\t\t\t\t\t\t\t// glob_CutLines.push( [ shapePt, holePt ] );\r\n\t\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif ( holeIndex >= 0 )\tbreak;\t\t// hole-vertex found\r\n\t\r\n\t\t\t\t\t\t\tfailedCuts[ cutKey ] = true;\t\t\t// remember failure\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif ( holeIndex >= 0 )\tbreak;\t\t// hole-vertex found\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn shape; \t\t\t/* shape with no holes */\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\r\n\t\t\tvar i, il, f, face,\r\n\t\t\t\tkey, index,\r\n\t\t\t\tallPointsMap = {};\r\n\t\r\n\t\t\t// To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.\r\n\t\r\n\t\t\tvar allpoints = contour.concat();\r\n\t\r\n\t\t\tfor ( var h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\t\r\n\t\t\t\tArray.prototype.push.apply( allpoints, holes[ h ] );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t//console.log( \"allpoints\",allpoints, allpoints.length );\r\n\t\r\n\t\t\t// prepare all points map\r\n\t\r\n\t\t\tfor ( i = 0, il = allpoints.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tkey = allpoints[ i ].x + \":\" + allpoints[ i ].y;\r\n\t\r\n\t\t\t\tif ( allPointsMap[ key ] !== undefined ) {\r\n\t\r\n\t\t\t\t\tconsole.warn( \"THREE.Shape: Duplicate point\", key );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tallPointsMap[ key ] = i;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// remove holes by cutting paths to holes and adding them to the shape\r\n\t\t\tvar shapeWithoutHoles = removeHoles( contour, holes );\r\n\t\r\n\t\t\tvar triangles = THREE.ShapeUtils.triangulate( shapeWithoutHoles, false ); // True returns indices for points of spooled shape\r\n\t\t\t//console.log( \"triangles\",triangles, triangles.length );\r\n\t\r\n\t\t\t// check all face vertices against all points map\r\n\t\r\n\t\t\tfor ( i = 0, il = triangles.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tface = triangles[ i ];\r\n\t\r\n\t\t\t\tfor ( f = 0; f < 3; f ++ ) {\r\n\t\r\n\t\t\t\t\tkey = face[ f ].x + \":\" + face[ f ].y;\r\n\t\r\n\t\t\t\t\tindex = allPointsMap[ key ];\r\n\t\r\n\t\t\t\t\tif ( index !== undefined ) {\r\n\t\r\n\t\t\t\t\t\tface[ f ] = index;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn triangles.concat();\r\n\t\r\n\t\t},\r\n\t\r\n\t\tisClockWise: function ( pts ) {\r\n\t\r\n\t\t\treturn THREE.ShapeUtils.area( pts ) < 0;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Bezier Curves formulas obtained from\r\n\t\t// http://en.wikipedia.org/wiki/B%C3%A9zier_curve\r\n\t\r\n\t\t// Quad Bezier Functions\r\n\t\r\n\t\tb2: ( function () {\r\n\t\r\n\t\t\tfunction b2p0( t, p ) {\r\n\t\r\n\t\t\t\tvar k = 1 - t;\r\n\t\t\t\treturn k * k * p;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfunction b2p1( t, p ) {\r\n\t\r\n\t\t\t\treturn 2 * ( 1 - t ) * t * p;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfunction b2p2( t, p ) {\r\n\t\r\n\t\t\t\treturn t * t * p;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn function ( t, p0, p1, p2 ) {\r\n\t\r\n\t\t\t\treturn b2p0( t, p0 ) + b2p1( t, p1 ) + b2p2( t, p2 );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t} )(),\r\n\t\r\n\t\t// Cubic Bezier Functions\r\n\t\r\n\t\tb3: ( function () {\r\n\t\r\n\t\t\tfunction b3p0( t, p ) {\r\n\t\r\n\t\t\t\tvar k = 1 - t;\r\n\t\t\t\treturn k * k * k * p;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfunction b3p1( t, p ) {\r\n\t\r\n\t\t\t\tvar k = 1 - t;\r\n\t\t\t\treturn 3 * k * k * t * p;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfunction b3p2( t, p ) {\r\n\t\r\n\t\t\t\tvar k = 1 - t;\r\n\t\t\t\treturn 3 * k * t * t * p;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfunction b3p3( t, p ) {\r\n\t\r\n\t\t\t\treturn t * t * t * p;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn function ( t, p0, p1, p2, p3 ) {\r\n\t\r\n\t\t\t\treturn b3p0( t, p0 ) + b3p1( t, p1 ) + b3p2( t, p2 ) + b3p3( t, p3 );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t} )()\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/core/Curve.js\r\n\t\r\n\t/**\r\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\r\n\t * Extensible curve object\r\n\t *\r\n\t * Some common of Curve methods\r\n\t * .getPoint(t), getTangent(t)\r\n\t * .getPointAt(u), getTagentAt(u)\r\n\t * .getPoints(), .getSpacedPoints()\r\n\t * .getLength()\r\n\t * .updateArcLengths()\r\n\t *\r\n\t * This following classes subclasses THREE.Curve:\r\n\t *\r\n\t * -- 2d classes --\r\n\t * THREE.LineCurve\r\n\t * THREE.QuadraticBezierCurve\r\n\t * THREE.CubicBezierCurve\r\n\t * THREE.SplineCurve\r\n\t * THREE.ArcCurve\r\n\t * THREE.EllipseCurve\r\n\t *\r\n\t * -- 3d classes --\r\n\t * THREE.LineCurve3\r\n\t * THREE.QuadraticBezierCurve3\r\n\t * THREE.CubicBezierCurve3\r\n\t * THREE.SplineCurve3\r\n\t *\r\n\t * A series of curves can be represented as a THREE.CurvePath\r\n\t *\r\n\t **/\r\n\t\r\n\t/**************************************************************\r\n\t *\tAbstract Curve base class\r\n\t **************************************************************/\r\n\t\r\n\tTHREE.Curve = function () {\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Curve.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Curve,\r\n\t\r\n\t\t// Virtual base class method to overwrite and implement in subclasses\r\n\t\t//\t- t [0 .. 1]\r\n\t\r\n\t\tgetPoint: function ( t ) {\r\n\t\r\n\t\t\tconsole.warn( \"THREE.Curve: Warning, getPoint() not implemented!\" );\r\n\t\t\treturn null;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Get point at relative position in curve according to arc length\r\n\t\t// - u [0 .. 1]\r\n\t\r\n\t\tgetPointAt: function ( u ) {\r\n\t\r\n\t\t\tvar t = this.getUtoTmapping( u );\r\n\t\t\treturn this.getPoint( t );\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Get sequence of points using getPoint( t )\r\n\t\r\n\t\tgetPoints: function ( divisions ) {\r\n\t\r\n\t\t\tif ( ! divisions ) divisions = 5;\r\n\t\r\n\t\t\tvar d, pts = [];\r\n\t\r\n\t\t\tfor ( d = 0; d <= divisions; d ++ ) {\r\n\t\r\n\t\t\t\tpts.push( this.getPoint( d / divisions ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn pts;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Get sequence of points using getPointAt( u )\r\n\t\r\n\t\tgetSpacedPoints: function ( divisions ) {\r\n\t\r\n\t\t\tif ( ! divisions ) divisions = 5;\r\n\t\r\n\t\t\tvar d, pts = [];\r\n\t\r\n\t\t\tfor ( d = 0; d <= divisions; d ++ ) {\r\n\t\r\n\t\t\t\tpts.push( this.getPointAt( d / divisions ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn pts;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Get total curve arc length\r\n\t\r\n\t\tgetLength: function () {\r\n\t\r\n\t\t\tvar lengths = this.getLengths();\r\n\t\t\treturn lengths[ lengths.length - 1 ];\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Get list of cumulative segment lengths\r\n\t\r\n\t\tgetLengths: function ( divisions ) {\r\n\t\r\n\t\t\tif ( ! divisions ) divisions = ( this.__arcLengthDivisions ) ? ( this.__arcLengthDivisions ) : 200;\r\n\t\r\n\t\t\tif ( this.cacheArcLengths\r\n\t\t\t\t&& ( this.cacheArcLengths.length === divisions + 1 )\r\n\t\t\t\t&& ! this.needsUpdate ) {\r\n\t\r\n\t\t\t\t//console.log( \"cached\", this.cacheArcLengths );\r\n\t\t\t\treturn this.cacheArcLengths;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.needsUpdate = false;\r\n\t\r\n\t\t\tvar cache = [];\r\n\t\t\tvar current, last = this.getPoint( 0 );\r\n\t\t\tvar p, sum = 0;\r\n\t\r\n\t\t\tcache.push( 0 );\r\n\t\r\n\t\t\tfor ( p = 1; p <= divisions; p ++ ) {\r\n\t\r\n\t\t\t\tcurrent = this.getPoint ( p / divisions );\r\n\t\t\t\tsum += current.distanceTo( last );\r\n\t\t\t\tcache.push( sum );\r\n\t\t\t\tlast = current;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.cacheArcLengths = cache;\r\n\t\r\n\t\t\treturn cache; // { sums: cache, sum:sum }; Sum is in the last element.\r\n\t\r\n\t\t},\r\n\t\r\n\t\tupdateArcLengths: function() {\r\n\t\r\n\t\t\tthis.needsUpdate = true;\r\n\t\t\tthis.getLengths();\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant\r\n\t\r\n\t\tgetUtoTmapping: function ( u, distance ) {\r\n\t\r\n\t\t\tvar arcLengths = this.getLengths();\r\n\t\r\n\t\t\tvar i = 0, il = arcLengths.length;\r\n\t\r\n\t\t\tvar targetArcLength; // The targeted u distance value to get\r\n\t\r\n\t\t\tif ( distance ) {\r\n\t\r\n\t\t\t\ttargetArcLength = distance;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\ttargetArcLength = u * arcLengths[ il - 1 ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t//var time = Date.now();\r\n\t\r\n\t\t\t// binary search for the index with largest value smaller than target u distance\r\n\t\r\n\t\t\tvar low = 0, high = il - 1, comparison;\r\n\t\r\n\t\t\twhile ( low <= high ) {\r\n\t\r\n\t\t\t\ti = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats\r\n\t\r\n\t\t\t\tcomparison = arcLengths[ i ] - targetArcLength;\r\n\t\r\n\t\t\t\tif ( comparison < 0 ) {\r\n\t\r\n\t\t\t\t\tlow = i + 1;\r\n\t\r\n\t\t\t\t} else if ( comparison > 0 ) {\r\n\t\r\n\t\t\t\t\thigh = i - 1;\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\thigh = i;\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t// DONE\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\ti = high;\r\n\t\r\n\t\t\t//console.log('b' , i, low, high, Date.now()- time);\r\n\t\r\n\t\t\tif ( arcLengths[ i ] === targetArcLength ) {\r\n\t\r\n\t\t\t\tvar t = i / ( il - 1 );\r\n\t\t\t\treturn t;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// we could get finer grain at lengths, or use simple interpolation between two points\r\n\t\r\n\t\t\tvar lengthBefore = arcLengths[ i ];\r\n\t\t\tvar lengthAfter = arcLengths[ i + 1 ];\r\n\t\r\n\t\t\tvar segmentLength = lengthAfter - lengthBefore;\r\n\t\r\n\t\t\t// determine where we are between the 'before' and 'after' points\r\n\t\r\n\t\t\tvar segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;\r\n\t\r\n\t\t\t// add that fractional amount to t\r\n\t\r\n\t\t\tvar t = ( i + segmentFraction ) / ( il - 1 );\r\n\t\r\n\t\t\treturn t;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Returns a unit vector tangent at t\r\n\t\t// In case any sub curve does not implement its tangent derivation,\r\n\t\t// 2 points a small delta apart will be used to find its gradient\r\n\t\t// which seems to give a reasonable approximation\r\n\t\r\n\t\tgetTangent: function( t ) {\r\n\t\r\n\t\t\tvar delta = 0.0001;\r\n\t\t\tvar t1 = t - delta;\r\n\t\t\tvar t2 = t + delta;\r\n\t\r\n\t\t\t// Capping in case of danger\r\n\t\r\n\t\t\tif ( t1 < 0 ) t1 = 0;\r\n\t\t\tif ( t2 > 1 ) t2 = 1;\r\n\t\r\n\t\t\tvar pt1 = this.getPoint( t1 );\r\n\t\t\tvar pt2 = this.getPoint( t2 );\r\n\t\r\n\t\t\tvar vec = pt2.clone().sub( pt1 );\r\n\t\t\treturn vec.normalize();\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetTangentAt: function ( u ) {\r\n\t\r\n\t\t\tvar t = this.getUtoTmapping( u );\r\n\t\t\treturn this.getTangent( t );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// TODO: Transformation for Curves?\r\n\t\r\n\t/**************************************************************\r\n\t *\t3D Curves\r\n\t **************************************************************/\r\n\t\r\n\t// A Factory method for creating new curve subclasses\r\n\t\r\n\tTHREE.Curve.create = function ( constructor, getPointFunc ) {\r\n\t\r\n\t\tconstructor.prototype = Object.create( THREE.Curve.prototype );\r\n\t\tconstructor.prototype.constructor = constructor;\r\n\t\tconstructor.prototype.getPoint = getPointFunc;\r\n\t\r\n\t\treturn constructor;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/core/CurvePath.js\r\n\t\r\n\t/**\r\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\r\n\t *\r\n\t **/\r\n\t\r\n\t/**************************************************************\r\n\t *\tCurved Path - a curve path is simply a array of connected\r\n\t *  curves, but retains the api of a curve\r\n\t **************************************************************/\r\n\t\r\n\tTHREE.CurvePath = function () {\r\n\t\r\n\t\tthis.curves = [];\r\n\t\r\n\t\tthis.autoClose = false; // Automatically closes the path\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.CurvePath.prototype = Object.create( THREE.Curve.prototype );\r\n\tTHREE.CurvePath.prototype.constructor = THREE.CurvePath;\r\n\t\r\n\tTHREE.CurvePath.prototype.add = function ( curve ) {\r\n\t\r\n\t\tthis.curves.push( curve );\r\n\t\r\n\t};\r\n\t\r\n\t/*\r\n\tTHREE.CurvePath.prototype.checkConnection = function() {\r\n\t\t// TODO\r\n\t\t// If the ending of curve is not connected to the starting\r\n\t\t// or the next curve, then, this is not a real path\r\n\t};\r\n\t*/\r\n\t\r\n\tTHREE.CurvePath.prototype.closePath = function() {\r\n\t\r\n\t\t// TODO Test\r\n\t\t// and verify for vector3 (needs to implement equals)\r\n\t\t// Add a line curve if start and end of lines are not connected\r\n\t\tvar startPoint = this.curves[ 0 ].getPoint( 0 );\r\n\t\tvar endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );\r\n\t\r\n\t\tif ( ! startPoint.equals( endPoint ) ) {\r\n\t\r\n\t\t\tthis.curves.push( new THREE.LineCurve( endPoint, startPoint ) );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// To get accurate point with reference to\r\n\t// entire path distance at time t,\r\n\t// following has to be done:\r\n\t\r\n\t// 1. Length of each sub path have to be known\r\n\t// 2. Locate and identify type of curve\r\n\t// 3. Get t for the curve\r\n\t// 4. Return curve.getPointAt(t')\r\n\t\r\n\tTHREE.CurvePath.prototype.getPoint = function( t ) {\r\n\t\r\n\t\tvar d = t * this.getLength();\r\n\t\tvar curveLengths = this.getCurveLengths();\r\n\t\tvar i = 0;\r\n\t\r\n\t\t// To think about boundaries points.\r\n\t\r\n\t\twhile ( i < curveLengths.length ) {\r\n\t\r\n\t\t\tif ( curveLengths[ i ] >= d ) {\r\n\t\r\n\t\t\t\tvar diff = curveLengths[ i ] - d;\r\n\t\t\t\tvar curve = this.curves[ i ];\r\n\t\r\n\t\t\t\tvar u = 1 - diff / curve.getLength();\r\n\t\r\n\t\t\t\treturn curve.getPointAt( u );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\ti ++;\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn null;\r\n\t\r\n\t\t// loop where sum != 0, sum > d , sum+1 <d\r\n\t\r\n\t};\r\n\t\r\n\t/*\r\n\tTHREE.CurvePath.prototype.getTangent = function( t ) {\r\n\t};\r\n\t*/\r\n\t\r\n\t// We cannot use the default THREE.Curve getPoint() with getLength() because in\r\n\t// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath\r\n\t// getPoint() depends on getLength\r\n\t\r\n\tTHREE.CurvePath.prototype.getLength = function() {\r\n\t\r\n\t\tvar lens = this.getCurveLengths();\r\n\t\treturn lens[ lens.length - 1 ];\r\n\t\r\n\t};\r\n\t\r\n\t// Compute lengths and cache them\r\n\t// We cannot overwrite getLengths() because UtoT mapping uses it.\r\n\t\r\n\tTHREE.CurvePath.prototype.getCurveLengths = function() {\r\n\t\r\n\t\t// We use cache values if curves and cache array are same length\r\n\t\r\n\t\tif ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {\r\n\t\r\n\t\t\treturn this.cacheLengths;\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Get length of sub-curve\r\n\t\t// Push sums into cached array\r\n\t\r\n\t\tvar lengths = [], sums = 0;\r\n\t\r\n\t\tfor ( var i = 0, l = this.curves.length; i < l; i ++ ) {\r\n\t\r\n\t\t\tsums += this.curves[ i ].getLength();\r\n\t\t\tlengths.push( sums );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.cacheLengths = lengths;\r\n\t\r\n\t\treturn lengths;\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\t\r\n\t/**************************************************************\r\n\t *\tCreate Geometries Helpers\r\n\t **************************************************************/\r\n\t\r\n\t/// Generate geometry from path points (for Line or Points objects)\r\n\t\r\n\tTHREE.CurvePath.prototype.createPointsGeometry = function( divisions ) {\r\n\t\r\n\t\tvar pts = this.getPoints( divisions );\r\n\t\treturn this.createGeometry( pts );\r\n\t\r\n\t};\r\n\t\r\n\t// Generate geometry from equidistant sampling along the path\r\n\t\r\n\tTHREE.CurvePath.prototype.createSpacedPointsGeometry = function( divisions ) {\r\n\t\r\n\t\tvar pts = this.getSpacedPoints( divisions );\r\n\t\treturn this.createGeometry( pts );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.CurvePath.prototype.createGeometry = function( points ) {\r\n\t\r\n\t\tvar geometry = new THREE.Geometry();\r\n\t\r\n\t\tfor ( var i = 0, l = points.length; i < l; i ++ ) {\r\n\t\r\n\t\t\tvar point = points[ i ];\r\n\t\t\tgeometry.vertices.push( new THREE.Vector3( point.x, point.y, point.z || 0 ) );\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn geometry;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/core/Font.js\r\n\t\r\n\t/**\r\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.Font = function ( data ) {\r\n\t\r\n\t\tthis.data = data;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Font.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Font,\r\n\t\r\n\t\tgenerateShapes: function ( text, size, divisions ) {\r\n\t\r\n\t\t\tfunction createPaths( text ) {\r\n\t\r\n\t\t\t\tvar chars = String( text ).split( '' );\r\n\t\t\t\tvar scale = size / data.resolution;\r\n\t\t\t\tvar offset = 0;\r\n\t\r\n\t\t\t\tvar paths = [];\r\n\t\r\n\t\t\t\tfor ( var i = 0; i < chars.length; i ++ ) {\r\n\t\r\n\t\t\t\t\tvar ret = createPath( chars[ i ], scale, offset );\r\n\t\t\t\t\toffset += ret.offset;\r\n\t\r\n\t\t\t\t\tpaths.push( ret.path );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn paths;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfunction createPath( c, scale, offset ) {\r\n\t\r\n\t\t\t\tvar glyph = data.glyphs[ c ] || data.glyphs[ '?' ];\r\n\t\r\n\t\t\t\tif ( ! glyph ) return;\r\n\t\r\n\t\t\t\tvar path = new THREE.Path();\r\n\t\r\n\t\t\t\tvar pts = [], b2 = THREE.ShapeUtils.b2, b3 = THREE.ShapeUtils.b3;\r\n\t\t\t\tvar x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2, laste;\r\n\t\r\n\t\t\t\tif ( glyph.o ) {\r\n\t\r\n\t\t\t\t\tvar outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );\r\n\t\r\n\t\t\t\t\tfor ( var i = 0, l = outline.length; i < l; ) {\r\n\t\r\n\t\t\t\t\t\tvar action = outline[ i ++ ];\r\n\t\r\n\t\t\t\t\t\tswitch ( action ) {\r\n\t\r\n\t\t\t\t\t\t\tcase 'm': // moveTo\r\n\t\r\n\t\t\t\t\t\t\t\tx = outline[ i ++ ] * scale + offset;\r\n\t\t\t\t\t\t\t\ty = outline[ i ++ ] * scale;\r\n\t\r\n\t\t\t\t\t\t\t\tpath.moveTo( x, y );\r\n\t\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\t\tcase 'l': // lineTo\r\n\t\r\n\t\t\t\t\t\t\t\tx = outline[ i ++ ] * scale + offset;\r\n\t\t\t\t\t\t\t\ty = outline[ i ++ ] * scale;\r\n\t\r\n\t\t\t\t\t\t\t\tpath.lineTo( x, y );\r\n\t\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\t\tcase 'q': // quadraticCurveTo\r\n\t\r\n\t\t\t\t\t\t\t\tcpx  = outline[ i ++ ] * scale + offset;\r\n\t\t\t\t\t\t\t\tcpy  = outline[ i ++ ] * scale;\r\n\t\t\t\t\t\t\t\tcpx1 = outline[ i ++ ] * scale + offset;\r\n\t\t\t\t\t\t\t\tcpy1 = outline[ i ++ ] * scale;\r\n\t\r\n\t\t\t\t\t\t\t\tpath.quadraticCurveTo( cpx1, cpy1, cpx, cpy );\r\n\t\r\n\t\t\t\t\t\t\t\tlaste = pts[ pts.length - 1 ];\r\n\t\r\n\t\t\t\t\t\t\t\tif ( laste ) {\r\n\t\r\n\t\t\t\t\t\t\t\t\tcpx0 = laste.x;\r\n\t\t\t\t\t\t\t\t\tcpy0 = laste.y;\r\n\t\r\n\t\t\t\t\t\t\t\t\tfor ( var i2 = 1; i2 <= divisions; i2 ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\t\t\tvar t = i2 / divisions;\r\n\t\t\t\t\t\t\t\t\t\tb2( t, cpx0, cpx1, cpx );\r\n\t\t\t\t\t\t\t\t\t\tb2( t, cpy0, cpy1, cpy );\r\n\t\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\t\tcase 'b': // bezierCurveTo\r\n\t\r\n\t\t\t\t\t\t\t\tcpx  = outline[ i ++ ] * scale + offset;\r\n\t\t\t\t\t\t\t\tcpy  = outline[ i ++ ] * scale;\r\n\t\t\t\t\t\t\t\tcpx1 = outline[ i ++ ] * scale + offset;\r\n\t\t\t\t\t\t\t\tcpy1 = outline[ i ++ ] * scale;\r\n\t\t\t\t\t\t\t\tcpx2 = outline[ i ++ ] * scale + offset;\r\n\t\t\t\t\t\t\t\tcpy2 = outline[ i ++ ] * scale;\r\n\t\r\n\t\t\t\t\t\t\t\tpath.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );\r\n\t\r\n\t\t\t\t\t\t\t\tlaste = pts[ pts.length - 1 ];\r\n\t\r\n\t\t\t\t\t\t\t\tif ( laste ) {\r\n\t\r\n\t\t\t\t\t\t\t\t\tcpx0 = laste.x;\r\n\t\t\t\t\t\t\t\t\tcpy0 = laste.y;\r\n\t\r\n\t\t\t\t\t\t\t\t\tfor ( var i2 = 1; i2 <= divisions; i2 ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\t\t\tvar t = i2 / divisions;\r\n\t\t\t\t\t\t\t\t\t\tb3( t, cpx0, cpx1, cpx2, cpx );\r\n\t\t\t\t\t\t\t\t\t\tb3( t, cpy0, cpy1, cpy2, cpy );\r\n\t\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn { offset: glyph.ha * scale, path: path };\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t//\r\n\t\r\n\t\t\tif ( size === undefined ) size = 100;\r\n\t\t\tif ( divisions === undefined ) divisions = 4;\r\n\t\r\n\t\t\tvar data = this.data;\r\n\t\r\n\t\t\tvar paths = createPaths( text );\r\n\t\t\tvar shapes = [];\r\n\t\r\n\t\t\tfor ( var p = 0, pl = paths.length; p < pl; p ++ ) {\r\n\t\r\n\t\t\t\tArray.prototype.push.apply( shapes, paths[ p ].toShapes() );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn shapes;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/core/Path.js\r\n\t\r\n\t/**\r\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\r\n\t * Creates free form 2d path using series of points, lines or curves.\r\n\t *\r\n\t **/\r\n\t\r\n\tTHREE.Path = function ( points ) {\r\n\t\r\n\t\tTHREE.CurvePath.call( this );\r\n\t\r\n\t\tthis.actions = [];\r\n\t\r\n\t\tif ( points ) {\r\n\t\r\n\t\t\tthis.fromPoints( points );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Path.prototype = Object.create( THREE.CurvePath.prototype );\r\n\tTHREE.Path.prototype.constructor = THREE.Path;\r\n\t\r\n\t// TODO Clean up PATH API\r\n\t\r\n\t// Create path using straight lines to connect all points\r\n\t// - vectors: array of Vector2\r\n\t\r\n\tTHREE.Path.prototype.fromPoints = function ( vectors ) {\r\n\t\r\n\t\tthis.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );\r\n\t\r\n\t\tfor ( var i = 1, l = vectors.length; i < l; i ++ ) {\r\n\t\r\n\t\t\tthis.lineTo( vectors[ i ].x, vectors[ i ].y );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// startPath() endPath()?\r\n\t\r\n\tTHREE.Path.prototype.moveTo = function ( x, y ) {\r\n\t\r\n\t\tthis.actions.push( { action: 'moveTo', args: [ x, y ] } );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Path.prototype.lineTo = function ( x, y ) {\r\n\t\r\n\t\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\r\n\t\r\n\t\tvar x0 = lastargs[ lastargs.length - 2 ];\r\n\t\tvar y0 = lastargs[ lastargs.length - 1 ];\r\n\t\r\n\t\tvar curve = new THREE.LineCurve( new THREE.Vector2( x0, y0 ), new THREE.Vector2( x, y ) );\r\n\t\tthis.curves.push( curve );\r\n\t\r\n\t\tthis.actions.push( { action: 'lineTo', args: [ x, y ] } );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Path.prototype.quadraticCurveTo = function( aCPx, aCPy, aX, aY ) {\r\n\t\r\n\t\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\r\n\t\r\n\t\tvar x0 = lastargs[ lastargs.length - 2 ];\r\n\t\tvar y0 = lastargs[ lastargs.length - 1 ];\r\n\t\r\n\t\tvar curve = new THREE.QuadraticBezierCurve(\r\n\t\t\tnew THREE.Vector2( x0, y0 ),\r\n\t\t\tnew THREE.Vector2( aCPx, aCPy ),\r\n\t\t\tnew THREE.Vector2( aX, aY )\r\n\t\t);\r\n\t\r\n\t\tthis.curves.push( curve );\r\n\t\r\n\t\tthis.actions.push( { action: 'quadraticCurveTo', args: [ aCPx, aCPy, aX, aY ] } );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Path.prototype.bezierCurveTo = function( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {\r\n\t\r\n\t\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\r\n\t\r\n\t\tvar x0 = lastargs[ lastargs.length - 2 ];\r\n\t\tvar y0 = lastargs[ lastargs.length - 1 ];\r\n\t\r\n\t\tvar curve = new THREE.CubicBezierCurve(\r\n\t\t\tnew THREE.Vector2( x0, y0 ),\r\n\t\t\tnew THREE.Vector2( aCP1x, aCP1y ),\r\n\t\t\tnew THREE.Vector2( aCP2x, aCP2y ),\r\n\t\t\tnew THREE.Vector2( aX, aY )\r\n\t\t);\r\n\t\r\n\t\tthis.curves.push( curve );\r\n\t\r\n\t\tthis.actions.push( { action: 'bezierCurveTo', args: [ aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ] } );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Path.prototype.splineThru = function( pts /*Array of Vector*/ ) {\r\n\t\r\n\t\tvar args = Array.prototype.slice.call( arguments );\r\n\t\r\n\t\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\r\n\t\r\n\t\tvar x0 = lastargs[ lastargs.length - 2 ];\r\n\t\tvar y0 = lastargs[ lastargs.length - 1 ];\r\n\t\r\n\t\tvar npts = [ new THREE.Vector2( x0, y0 ) ];\r\n\t\tArray.prototype.push.apply( npts, pts );\r\n\t\r\n\t\tvar curve = new THREE.SplineCurve( npts );\r\n\t\tthis.curves.push( curve );\r\n\t\r\n\t\tthis.actions.push( { action: 'splineThru', args: args } );\r\n\t\r\n\t};\r\n\t\r\n\t// FUTURE: Change the API or follow canvas API?\r\n\t\r\n\tTHREE.Path.prototype.arc = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\r\n\t\r\n\t\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\r\n\t\tvar x0 = lastargs[ lastargs.length - 2 ];\r\n\t\tvar y0 = lastargs[ lastargs.length - 1 ];\r\n\t\r\n\t\tthis.absarc( aX + x0, aY + y0, aRadius,\r\n\t\t\taStartAngle, aEndAngle, aClockwise );\r\n\t\r\n\t };\r\n\t\r\n\t THREE.Path.prototype.absarc = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\r\n\t\r\n\t\tthis.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\r\n\t\r\n\t };\r\n\t\r\n\tTHREE.Path.prototype.ellipse = function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\r\n\t\r\n\t\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\r\n\t\tvar x0 = lastargs[ lastargs.length - 2 ];\r\n\t\tvar y0 = lastargs[ lastargs.length - 1 ];\r\n\t\r\n\t\tthis.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\r\n\t\r\n\t };\r\n\t\r\n\t\r\n\tTHREE.Path.prototype.absellipse = function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\r\n\t\r\n\t\tvar args = [\r\n\t\t\taX, aY,\r\n\t\t\txRadius, yRadius,\r\n\t\t\taStartAngle, aEndAngle,\r\n\t\t\taClockwise,\r\n\t\t\taRotation || 0 // aRotation is optional.\r\n\t\t];\r\n\t\r\n\t\tvar curve = new THREE.EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\r\n\t\tthis.curves.push( curve );\r\n\t\r\n\t\tvar lastPoint = curve.getPoint( 1 );\r\n\t\targs.push( lastPoint.x );\r\n\t\targs.push( lastPoint.y );\r\n\t\r\n\t\tthis.actions.push( { action: 'ellipse', args: args } );\r\n\t\r\n\t };\r\n\t\r\n\tTHREE.Path.prototype.getSpacedPoints = function ( divisions ) {\r\n\t\r\n\t\tif ( ! divisions ) divisions = 40;\r\n\t\r\n\t\tvar points = [];\r\n\t\r\n\t\tfor ( var i = 0; i < divisions; i ++ ) {\r\n\t\r\n\t\t\tpoints.push( this.getPoint( i / divisions ) );\r\n\t\r\n\t\t\t//if ( !this.getPoint( i / divisions ) ) throw \"DIE\";\r\n\t\r\n\t\t}\r\n\t\r\n\t\tif ( this.autoClose ) {\r\n\t\r\n\t\t\tpoints.push( points[ 0 ] );\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn points;\r\n\t\r\n\t};\r\n\t\r\n\t/* Return an array of vectors based on contour of the path */\r\n\t\r\n\tTHREE.Path.prototype.getPoints = function( divisions ) {\r\n\t\r\n\t\tdivisions = divisions || 12;\r\n\t\r\n\t\tvar b2 = THREE.ShapeUtils.b2;\r\n\t\tvar b3 = THREE.ShapeUtils.b3;\r\n\t\r\n\t\tvar points = [];\r\n\t\r\n\t\tvar cpx, cpy, cpx2, cpy2, cpx1, cpy1, cpx0, cpy0,\r\n\t\t\tlaste, tx, ty;\r\n\t\r\n\t\tfor ( var i = 0, l = this.actions.length; i < l; i ++ ) {\r\n\t\r\n\t\t\tvar item = this.actions[ i ];\r\n\t\r\n\t\t\tvar action = item.action;\r\n\t\t\tvar args = item.args;\r\n\t\r\n\t\t\tswitch ( action ) {\r\n\t\r\n\t\t\tcase 'moveTo':\r\n\t\r\n\t\t\t\tpoints.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );\r\n\t\r\n\t\t\t\tbreak;\r\n\t\r\n\t\t\tcase 'lineTo':\r\n\t\r\n\t\t\t\tpoints.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );\r\n\t\r\n\t\t\t\tbreak;\r\n\t\r\n\t\t\tcase 'quadraticCurveTo':\r\n\t\r\n\t\t\t\tcpx  = args[ 2 ];\r\n\t\t\t\tcpy  = args[ 3 ];\r\n\t\r\n\t\t\t\tcpx1 = args[ 0 ];\r\n\t\t\t\tcpy1 = args[ 1 ];\r\n\t\r\n\t\t\t\tif ( points.length > 0 ) {\r\n\t\r\n\t\t\t\t\tlaste = points[ points.length - 1 ];\r\n\t\r\n\t\t\t\t\tcpx0 = laste.x;\r\n\t\t\t\t\tcpy0 = laste.y;\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tlaste = this.actions[ i - 1 ].args;\r\n\t\r\n\t\t\t\t\tcpx0 = laste[ laste.length - 2 ];\r\n\t\t\t\t\tcpy0 = laste[ laste.length - 1 ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tfor ( var j = 1; j <= divisions; j ++ ) {\r\n\t\r\n\t\t\t\t\tvar t = j / divisions;\r\n\t\r\n\t\t\t\t\ttx = b2( t, cpx0, cpx1, cpx );\r\n\t\t\t\t\tty = b2( t, cpy0, cpy1, cpy );\r\n\t\r\n\t\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tbreak;\r\n\t\r\n\t\t\tcase 'bezierCurveTo':\r\n\t\r\n\t\t\t\tcpx  = args[ 4 ];\r\n\t\t\t\tcpy  = args[ 5 ];\r\n\t\r\n\t\t\t\tcpx1 = args[ 0 ];\r\n\t\t\t\tcpy1 = args[ 1 ];\r\n\t\r\n\t\t\t\tcpx2 = args[ 2 ];\r\n\t\t\t\tcpy2 = args[ 3 ];\r\n\t\r\n\t\t\t\tif ( points.length > 0 ) {\r\n\t\r\n\t\t\t\t\tlaste = points[ points.length - 1 ];\r\n\t\r\n\t\t\t\t\tcpx0 = laste.x;\r\n\t\t\t\t\tcpy0 = laste.y;\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tlaste = this.actions[ i - 1 ].args;\r\n\t\r\n\t\t\t\t\tcpx0 = laste[ laste.length - 2 ];\r\n\t\t\t\t\tcpy0 = laste[ laste.length - 1 ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\r\n\t\t\t\tfor ( var j = 1; j <= divisions; j ++ ) {\r\n\t\r\n\t\t\t\t\tvar t = j / divisions;\r\n\t\r\n\t\t\t\t\ttx = b3( t, cpx0, cpx1, cpx2, cpx );\r\n\t\t\t\t\tty = b3( t, cpy0, cpy1, cpy2, cpy );\r\n\t\r\n\t\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tbreak;\r\n\t\r\n\t\t\tcase 'splineThru':\r\n\t\r\n\t\t\t\tlaste = this.actions[ i - 1 ].args;\r\n\t\r\n\t\t\t\tvar last = new THREE.Vector2( laste[ laste.length - 2 ], laste[ laste.length - 1 ] );\r\n\t\t\t\tvar spts = [ last ];\r\n\t\r\n\t\t\t\tvar n = divisions * args[ 0 ].length;\r\n\t\r\n\t\t\t\tspts = spts.concat( args[ 0 ] );\r\n\t\r\n\t\t\t\tvar spline = new THREE.SplineCurve( spts );\r\n\t\r\n\t\t\t\tfor ( var j = 1; j <= n; j ++ ) {\r\n\t\r\n\t\t\t\t\tpoints.push( spline.getPointAt( j / n ) );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tbreak;\r\n\t\r\n\t\t\tcase 'arc':\r\n\t\r\n\t\t\t\tvar aX = args[ 0 ], aY = args[ 1 ],\r\n\t\t\t\t\taRadius = args[ 2 ],\r\n\t\t\t\t\taStartAngle = args[ 3 ], aEndAngle = args[ 4 ],\r\n\t\t\t\t\taClockwise = !! args[ 5 ];\r\n\t\r\n\t\t\t\tvar deltaAngle = aEndAngle - aStartAngle;\r\n\t\t\t\tvar angle;\r\n\t\t\t\tvar tdivisions = divisions * 2;\r\n\t\r\n\t\t\t\tfor ( var j = 1; j <= tdivisions; j ++ ) {\r\n\t\r\n\t\t\t\t\tvar t = j / tdivisions;\r\n\t\r\n\t\t\t\t\tif ( ! aClockwise ) {\r\n\t\r\n\t\t\t\t\t\tt = 1 - t;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tangle = aStartAngle + t * deltaAngle;\r\n\t\r\n\t\t\t\t\ttx = aX + aRadius * Math.cos( angle );\r\n\t\t\t\t\tty = aY + aRadius * Math.sin( angle );\r\n\t\r\n\t\t\t\t\t//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);\r\n\t\r\n\t\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t//console.log(points);\r\n\t\r\n\t\t\t\tbreak;\r\n\t\r\n\t\t\tcase 'ellipse':\r\n\t\r\n\t\t\t\tvar aX = args[ 0 ], aY = args[ 1 ],\r\n\t\t\t\t\txRadius = args[ 2 ],\r\n\t\t\t\t\tyRadius = args[ 3 ],\r\n\t\t\t\t\taStartAngle = args[ 4 ], aEndAngle = args[ 5 ],\r\n\t\t\t\t\taClockwise = !! args[ 6 ],\r\n\t\t\t\t\taRotation = args[ 7 ];\r\n\t\r\n\t\r\n\t\t\t\tvar deltaAngle = aEndAngle - aStartAngle;\r\n\t\t\t\tvar angle;\r\n\t\t\t\tvar tdivisions = divisions * 2;\r\n\t\r\n\t\t\t\tvar cos, sin;\r\n\t\t\t\tif ( aRotation !== 0 ) {\r\n\t\r\n\t\t\t\t\tcos = Math.cos( aRotation );\r\n\t\t\t\t\tsin = Math.sin( aRotation );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tfor ( var j = 1; j <= tdivisions; j ++ ) {\r\n\t\r\n\t\t\t\t\tvar t = j / tdivisions;\r\n\t\r\n\t\t\t\t\tif ( ! aClockwise ) {\r\n\t\r\n\t\t\t\t\t\tt = 1 - t;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tangle = aStartAngle + t * deltaAngle;\r\n\t\r\n\t\t\t\t\ttx = aX + xRadius * Math.cos( angle );\r\n\t\t\t\t\tty = aY + yRadius * Math.sin( angle );\r\n\t\r\n\t\t\t\t\tif ( aRotation !== 0 ) {\r\n\t\r\n\t\t\t\t\t\tvar x = tx, y = ty;\r\n\t\r\n\t\t\t\t\t\t// Rotate the point about the center of the ellipse.\r\n\t\t\t\t\t\ttx = ( x - aX ) * cos - ( y - aY ) * sin + aX;\r\n\t\t\t\t\t\tty = ( x - aX ) * sin + ( y - aY ) * cos + aY;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);\r\n\t\r\n\t\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t//console.log(points);\r\n\t\r\n\t\t\t\tbreak;\r\n\t\r\n\t\t\t} // end switch\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t\r\n\t\t// Normalize to remove the closing point by default.\r\n\t\tvar lastPoint = points[ points.length - 1 ];\r\n\t\tif ( Math.abs( lastPoint.x - points[ 0 ].x ) < Number.EPSILON &&\r\n\t\t\t\t Math.abs( lastPoint.y - points[ 0 ].y ) < Number.EPSILON )\r\n\t\t\tpoints.splice( points.length - 1, 1 );\r\n\t\r\n\t\tif ( this.autoClose ) {\r\n\t\r\n\t\t\tpoints.push( points[ 0 ] );\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn points;\r\n\t\r\n\t};\r\n\t\r\n\t//\r\n\t// Breaks path into shapes\r\n\t//\r\n\t//\tAssumptions (if parameter isCCW==true the opposite holds):\r\n\t//\t- solid shapes are defined clockwise (CW)\r\n\t//\t- holes are defined counterclockwise (CCW)\r\n\t//\r\n\t//\tIf parameter noHoles==true:\r\n\t//  - all subPaths are regarded as solid shapes\r\n\t//  - definition order CW/CCW has no relevance\r\n\t//\r\n\t\r\n\tTHREE.Path.prototype.toShapes = function( isCCW, noHoles ) {\r\n\t\r\n\t\tfunction extractSubpaths( inActions ) {\r\n\t\r\n\t\t\tvar subPaths = [], lastPath = new THREE.Path();\r\n\t\r\n\t\t\tfor ( var i = 0, l = inActions.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tvar item = inActions[ i ];\r\n\t\r\n\t\t\t\tvar args = item.args;\r\n\t\t\t\tvar action = item.action;\r\n\t\r\n\t\t\t\tif ( action === 'moveTo' ) {\r\n\t\r\n\t\t\t\t\tif ( lastPath.actions.length !== 0 ) {\r\n\t\r\n\t\t\t\t\t\tsubPaths.push( lastPath );\r\n\t\t\t\t\t\tlastPath = new THREE.Path();\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tlastPath[ action ].apply( lastPath, args );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( lastPath.actions.length !== 0 ) {\r\n\t\r\n\t\t\t\tsubPaths.push( lastPath );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// console.log(subPaths);\r\n\t\r\n\t\t\treturn\tsubPaths;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction toShapesNoHoles( inSubpaths ) {\r\n\t\r\n\t\t\tvar shapes = [];\r\n\t\r\n\t\t\tfor ( var i = 0, l = inSubpaths.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tvar tmpPath = inSubpaths[ i ];\r\n\t\r\n\t\t\t\tvar tmpShape = new THREE.Shape();\r\n\t\t\t\ttmpShape.actions = tmpPath.actions;\r\n\t\t\t\ttmpShape.curves = tmpPath.curves;\r\n\t\r\n\t\t\t\tshapes.push( tmpShape );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t//console.log(\"shape\", shapes);\r\n\t\r\n\t\t\treturn shapes;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction isPointInsidePolygon( inPt, inPolygon ) {\r\n\t\r\n\t\t\tvar polyLen = inPolygon.length;\r\n\t\r\n\t\t\t// inPt on polygon contour => immediate success    or\r\n\t\t\t// toggling of inside/outside at every single! intersection point of an edge\r\n\t\t\t//  with the horizontal line through inPt, left of inPt\r\n\t\t\t//  not counting lowerY endpoints of edges and whole edges on that line\r\n\t\t\tvar inside = false;\r\n\t\t\tfor ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {\r\n\t\r\n\t\t\t\tvar edgeLowPt  = inPolygon[ p ];\r\n\t\t\t\tvar edgeHighPt = inPolygon[ q ];\r\n\t\r\n\t\t\t\tvar edgeDx = edgeHighPt.x - edgeLowPt.x;\r\n\t\t\t\tvar edgeDy = edgeHighPt.y - edgeLowPt.y;\r\n\t\r\n\t\t\t\tif ( Math.abs( edgeDy ) > Number.EPSILON ) {\r\n\t\r\n\t\t\t\t\t// not parallel\r\n\t\t\t\t\tif ( edgeDy < 0 ) {\r\n\t\r\n\t\t\t\t\t\tedgeLowPt  = inPolygon[ q ]; edgeDx = - edgeDx;\r\n\t\t\t\t\t\tedgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;\r\n\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) \t\tcontinue;\r\n\t\r\n\t\t\t\t\tif ( inPt.y === edgeLowPt.y ) {\r\n\t\r\n\t\t\t\t\t\tif ( inPt.x === edgeLowPt.x )\t\treturn\ttrue;\t\t// inPt is on contour ?\r\n\t\t\t\t\t\t// continue;\t\t\t\t// no intersection or edgeLowPt => doesn't count !!!\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tvar perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );\r\n\t\t\t\t\t\tif ( perpEdge === 0 )\t\t\t\treturn\ttrue;\t\t// inPt is on contour ?\r\n\t\t\t\t\t\tif ( perpEdge < 0 ) \t\t\t\tcontinue;\r\n\t\t\t\t\t\tinside = ! inside;\t\t// true intersection left of inPt\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t// parallel or collinear\r\n\t\t\t\t\tif ( inPt.y !== edgeLowPt.y ) \t\tcontinue;\t\t\t// parallel\r\n\t\t\t\t\t// edge lies on the same horizontal line as inPt\r\n\t\t\t\t\tif ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||\r\n\t\t\t\t\t\t ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )\t\treturn\ttrue;\t// inPt: Point on contour !\r\n\t\t\t\t\t// continue;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn\tinside;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar isClockWise = THREE.ShapeUtils.isClockWise;\r\n\t\r\n\t\tvar subPaths = extractSubpaths( this.actions );\r\n\t\tif ( subPaths.length === 0 ) return [];\r\n\t\r\n\t\tif ( noHoles === true )\treturn\ttoShapesNoHoles( subPaths );\r\n\t\r\n\t\r\n\t\tvar solid, tmpPath, tmpShape, shapes = [];\r\n\t\r\n\t\tif ( subPaths.length === 1 ) {\r\n\t\r\n\t\t\ttmpPath = subPaths[ 0 ];\r\n\t\t\ttmpShape = new THREE.Shape();\r\n\t\t\ttmpShape.actions = tmpPath.actions;\r\n\t\t\ttmpShape.curves = tmpPath.curves;\r\n\t\t\tshapes.push( tmpShape );\r\n\t\t\treturn shapes;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );\r\n\t\tholesFirst = isCCW ? ! holesFirst : holesFirst;\r\n\t\r\n\t\t// console.log(\"Holes first\", holesFirst);\r\n\t\r\n\t\tvar betterShapeHoles = [];\r\n\t\tvar newShapes = [];\r\n\t\tvar newShapeHoles = [];\r\n\t\tvar mainIdx = 0;\r\n\t\tvar tmpPoints;\r\n\t\r\n\t\tnewShapes[ mainIdx ] = undefined;\r\n\t\tnewShapeHoles[ mainIdx ] = [];\r\n\t\r\n\t\tfor ( var i = 0, l = subPaths.length; i < l; i ++ ) {\r\n\t\r\n\t\t\ttmpPath = subPaths[ i ];\r\n\t\t\ttmpPoints = tmpPath.getPoints();\r\n\t\t\tsolid = isClockWise( tmpPoints );\r\n\t\t\tsolid = isCCW ? ! solid : solid;\r\n\t\r\n\t\t\tif ( solid ) {\r\n\t\r\n\t\t\t\tif ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )\tmainIdx ++;\r\n\t\r\n\t\t\t\tnewShapes[ mainIdx ] = { s: new THREE.Shape(), p: tmpPoints };\r\n\t\t\t\tnewShapes[ mainIdx ].s.actions = tmpPath.actions;\r\n\t\t\t\tnewShapes[ mainIdx ].s.curves = tmpPath.curves;\r\n\t\r\n\t\t\t\tif ( holesFirst )\tmainIdx ++;\r\n\t\t\t\tnewShapeHoles[ mainIdx ] = [];\r\n\t\r\n\t\t\t\t//console.log('cw', i);\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tnewShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );\r\n\t\r\n\t\t\t\t//console.log('ccw', i);\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// only Holes? -> probably all Shapes with wrong orientation\r\n\t\tif ( ! newShapes[ 0 ] )\treturn\ttoShapesNoHoles( subPaths );\r\n\t\r\n\t\r\n\t\tif ( newShapes.length > 1 ) {\r\n\t\r\n\t\t\tvar ambiguous = false;\r\n\t\t\tvar toChange = [];\r\n\t\r\n\t\t\tfor ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\r\n\t\r\n\t\t\t\tbetterShapeHoles[ sIdx ] = [];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\r\n\t\r\n\t\t\t\tvar sho = newShapeHoles[ sIdx ];\r\n\t\r\n\t\t\t\tfor ( var hIdx = 0; hIdx < sho.length; hIdx ++ ) {\r\n\t\r\n\t\t\t\t\tvar ho = sho[ hIdx ];\r\n\t\t\t\t\tvar hole_unassigned = true;\r\n\t\r\n\t\t\t\t\tfor ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {\r\n\t\r\n\t\t\t\t\t\tif ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {\r\n\t\r\n\t\t\t\t\t\t\tif ( sIdx !== s2Idx )\ttoChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );\r\n\t\t\t\t\t\t\tif ( hole_unassigned ) {\r\n\t\r\n\t\t\t\t\t\t\t\thole_unassigned = false;\r\n\t\t\t\t\t\t\t\tbetterShapeHoles[ s2Idx ].push( ho );\r\n\t\r\n\t\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\t\tambiguous = true;\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ( hole_unassigned ) {\r\n\t\r\n\t\t\t\t\t\tbetterShapeHoles[ sIdx ].push( ho );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\t\t// console.log(\"ambiguous: \", ambiguous);\r\n\t\t\tif ( toChange.length > 0 ) {\r\n\t\r\n\t\t\t\t// console.log(\"to change: \", toChange);\r\n\t\t\t\tif ( ! ambiguous )\tnewShapeHoles = betterShapeHoles;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar tmpHoles;\r\n\t\r\n\t\tfor ( var i = 0, il = newShapes.length; i < il; i ++ ) {\r\n\t\r\n\t\t\ttmpShape = newShapes[ i ].s;\r\n\t\t\tshapes.push( tmpShape );\r\n\t\t\ttmpHoles = newShapeHoles[ i ];\r\n\t\r\n\t\t\tfor ( var j = 0, jl = tmpHoles.length; j < jl; j ++ ) {\r\n\t\r\n\t\t\t\ttmpShape.holes.push( tmpHoles[ j ].h );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\t//console.log(\"shape\", shapes);\r\n\t\r\n\t\treturn shapes;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/core/Shape.js\r\n\t\r\n\t/**\r\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\r\n\t * Defines a 2d shape plane using paths.\r\n\t **/\r\n\t\r\n\t// STEP 1 Create a path.\r\n\t// STEP 2 Turn path into shape.\r\n\t// STEP 3 ExtrudeGeometry takes in Shape/Shapes\r\n\t// STEP 3a - Extract points from each shape, turn to vertices\r\n\t// STEP 3b - Triangulate each shape, add faces.\r\n\t\r\n\tTHREE.Shape = function () {\r\n\t\r\n\t\tTHREE.Path.apply( this, arguments );\r\n\t\r\n\t\tthis.holes = [];\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Shape.prototype = Object.create( THREE.Path.prototype );\r\n\tTHREE.Shape.prototype.constructor = THREE.Shape;\r\n\t\r\n\t// Convenience method to return ExtrudeGeometry\r\n\t\r\n\tTHREE.Shape.prototype.extrude = function ( options ) {\r\n\t\r\n\t\treturn new THREE.ExtrudeGeometry( this, options );\r\n\t\r\n\t};\r\n\t\r\n\t// Convenience method to return ShapeGeometry\r\n\t\r\n\tTHREE.Shape.prototype.makeGeometry = function ( options ) {\r\n\t\r\n\t\treturn new THREE.ShapeGeometry( this, options );\r\n\t\r\n\t};\r\n\t\r\n\t// Get points of holes\r\n\t\r\n\tTHREE.Shape.prototype.getPointsHoles = function ( divisions ) {\r\n\t\r\n\t\tvar holesPts = [];\r\n\t\r\n\t\tfor ( var i = 0, l = this.holes.length; i < l; i ++ ) {\r\n\t\r\n\t\t\tholesPts[ i ] = this.holes[ i ].getPoints( divisions );\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn holesPts;\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\t// Get points of shape and holes (keypoints based on segments parameter)\r\n\t\r\n\tTHREE.Shape.prototype.extractAllPoints = function ( divisions ) {\r\n\t\r\n\t\treturn {\r\n\t\r\n\t\t\tshape: this.getPoints( divisions ),\r\n\t\t\tholes: this.getPointsHoles( divisions )\r\n\t\r\n\t\t};\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Shape.prototype.extractPoints = function ( divisions ) {\r\n\t\r\n\t\treturn this.extractAllPoints( divisions );\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/curves/LineCurve.js\r\n\t\r\n\t/**************************************************************\r\n\t *\tLine\r\n\t **************************************************************/\r\n\t\r\n\tTHREE.LineCurve = function ( v1, v2 ) {\r\n\t\r\n\t\tthis.v1 = v1;\r\n\t\tthis.v2 = v2;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.LineCurve.prototype = Object.create( THREE.Curve.prototype );\r\n\tTHREE.LineCurve.prototype.constructor = THREE.LineCurve;\r\n\t\r\n\tTHREE.LineCurve.prototype.getPoint = function ( t ) {\r\n\t\r\n\t\tvar point = this.v2.clone().sub( this.v1 );\r\n\t\tpoint.multiplyScalar( t ).add( this.v1 );\r\n\t\r\n\t\treturn point;\r\n\t\r\n\t};\r\n\t\r\n\t// Line curve is linear, so we can overwrite default getPointAt\r\n\t\r\n\tTHREE.LineCurve.prototype.getPointAt = function ( u ) {\r\n\t\r\n\t\treturn this.getPoint( u );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.LineCurve.prototype.getTangent = function( t ) {\r\n\t\r\n\t\tvar tangent = this.v2.clone().sub( this.v1 );\r\n\t\r\n\t\treturn tangent.normalize();\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/curves/QuadraticBezierCurve.js\r\n\t\r\n\t/**************************************************************\r\n\t *\tQuadratic Bezier curve\r\n\t **************************************************************/\r\n\t\r\n\t\r\n\tTHREE.QuadraticBezierCurve = function ( v0, v1, v2 ) {\r\n\t\r\n\t\tthis.v0 = v0;\r\n\t\tthis.v1 = v1;\r\n\t\tthis.v2 = v2;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.QuadraticBezierCurve.prototype = Object.create( THREE.Curve.prototype );\r\n\tTHREE.QuadraticBezierCurve.prototype.constructor = THREE.QuadraticBezierCurve;\r\n\t\r\n\t\r\n\tTHREE.QuadraticBezierCurve.prototype.getPoint = function ( t ) {\r\n\t\r\n\t\tvar b2 = THREE.ShapeUtils.b2;\r\n\t\r\n\t\treturn new THREE.Vector2(\r\n\t\t\tb2( t, this.v0.x, this.v1.x, this.v2.x ),\r\n\t\t\tb2( t, this.v0.y, this.v1.y, this.v2.y )\r\n\t\t);\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\tTHREE.QuadraticBezierCurve.prototype.getTangent = function( t ) {\r\n\t\r\n\t\tvar tangentQuadraticBezier = THREE.CurveUtils.tangentQuadraticBezier;\r\n\t\r\n\t\treturn new THREE.Vector2(\r\n\t\t\ttangentQuadraticBezier( t, this.v0.x, this.v1.x, this.v2.x ),\r\n\t\t\ttangentQuadraticBezier( t, this.v0.y, this.v1.y, this.v2.y )\r\n\t\t).normalize();\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/curves/CubicBezierCurve.js\r\n\t\r\n\t/**************************************************************\r\n\t *\tCubic Bezier curve\r\n\t **************************************************************/\r\n\t\r\n\tTHREE.CubicBezierCurve = function ( v0, v1, v2, v3 ) {\r\n\t\r\n\t\tthis.v0 = v0;\r\n\t\tthis.v1 = v1;\r\n\t\tthis.v2 = v2;\r\n\t\tthis.v3 = v3;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.CubicBezierCurve.prototype = Object.create( THREE.Curve.prototype );\r\n\tTHREE.CubicBezierCurve.prototype.constructor = THREE.CubicBezierCurve;\r\n\t\r\n\tTHREE.CubicBezierCurve.prototype.getPoint = function ( t ) {\r\n\t\r\n\t\tvar b3 = THREE.ShapeUtils.b3;\r\n\t\r\n\t\treturn new THREE.Vector2( \r\n\t\t\tb3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),\r\n\t\t\tb3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y )\r\n\t\t);\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.CubicBezierCurve.prototype.getTangent = function( t ) {\r\n\t\r\n\t\tvar tangentCubicBezier = THREE.CurveUtils.tangentCubicBezier;\r\n\t\r\n\t\treturn new THREE.Vector2( \r\n\t\t\ttangentCubicBezier( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),\r\n\t\t\ttangentCubicBezier( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y )\r\n\t\t).normalize();\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/curves/SplineCurve.js\r\n\t\r\n\t/**************************************************************\r\n\t *\tSpline curve\r\n\t **************************************************************/\r\n\t\r\n\tTHREE.SplineCurve = function ( points /* array of Vector2 */ ) {\r\n\t\r\n\t\tthis.points = ( points == undefined ) ? [] : points;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.SplineCurve.prototype = Object.create( THREE.Curve.prototype );\r\n\tTHREE.SplineCurve.prototype.constructor = THREE.SplineCurve;\r\n\t\r\n\tTHREE.SplineCurve.prototype.getPoint = function ( t ) {\r\n\t\r\n\t\tvar points = this.points;\r\n\t\tvar point = ( points.length - 1 ) * t;\r\n\t\r\n\t\tvar intPoint = Math.floor( point );\r\n\t\tvar weight = point - intPoint;\r\n\t\r\n\t\tvar point0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];\r\n\t\tvar point1 = points[ intPoint ];\r\n\t\tvar point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];\r\n\t\tvar point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];\r\n\t\r\n\t\tvar interpolate = THREE.CurveUtils.interpolate;\r\n\t\r\n\t\treturn new THREE.Vector2(\r\n\t\t\tinterpolate( point0.x, point1.x, point2.x, point3.x, weight ),\r\n\t\t\tinterpolate( point0.y, point1.y, point2.y, point3.y, weight )\r\n\t\t);\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/curves/EllipseCurve.js\r\n\t\r\n\t/**************************************************************\r\n\t *\tEllipse curve\r\n\t **************************************************************/\r\n\t\r\n\tTHREE.EllipseCurve = function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\r\n\t\r\n\t\tthis.aX = aX;\r\n\t\tthis.aY = aY;\r\n\t\r\n\t\tthis.xRadius = xRadius;\r\n\t\tthis.yRadius = yRadius;\r\n\t\r\n\t\tthis.aStartAngle = aStartAngle;\r\n\t\tthis.aEndAngle = aEndAngle;\r\n\t\r\n\t\tthis.aClockwise = aClockwise;\r\n\t\t\r\n\t\tthis.aRotation = aRotation || 0;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.EllipseCurve.prototype = Object.create( THREE.Curve.prototype );\r\n\tTHREE.EllipseCurve.prototype.constructor = THREE.EllipseCurve;\r\n\t\r\n\tTHREE.EllipseCurve.prototype.getPoint = function ( t ) {\r\n\t\r\n\t\tvar deltaAngle = this.aEndAngle - this.aStartAngle;\r\n\t\r\n\t\tif ( deltaAngle < 0 ) deltaAngle += Math.PI * 2;\r\n\t\tif ( deltaAngle > Math.PI * 2 ) deltaAngle -= Math.PI * 2;\r\n\t\r\n\t\tvar angle;\r\n\t\r\n\t\tif ( this.aClockwise === true ) {\r\n\t\r\n\t\t\tangle = this.aEndAngle + ( 1 - t ) * ( Math.PI * 2 - deltaAngle );\r\n\t\r\n\t\t} else {\r\n\t\r\n\t\t\tangle = this.aStartAngle + t * deltaAngle;\r\n\t\r\n\t\t}\r\n\t\t\r\n\t\tvar x = this.aX + this.xRadius * Math.cos( angle );\r\n\t\tvar y = this.aY + this.yRadius * Math.sin( angle );\r\n\t\r\n\t\tif ( this.aRotation !== 0 ) {\r\n\t\r\n\t\t\tvar cos = Math.cos( this.aRotation );\r\n\t\t\tvar sin = Math.sin( this.aRotation );\r\n\t\r\n\t\t\tvar tx = x, ty = y;\r\n\t\r\n\t\t\t// Rotate the point about the center of the ellipse.\r\n\t\t\tx = ( tx - this.aX ) * cos - ( ty - this.aY ) * sin + this.aX;\r\n\t\t\ty = ( tx - this.aX ) * sin + ( ty - this.aY ) * cos + this.aY;\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn new THREE.Vector2( x, y );\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/curves/ArcCurve.js\r\n\t\r\n\t/**************************************************************\r\n\t *\tArc curve\r\n\t **************************************************************/\r\n\t\r\n\tTHREE.ArcCurve = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\r\n\t\r\n\t\tTHREE.EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.ArcCurve.prototype = Object.create( THREE.EllipseCurve.prototype );\r\n\tTHREE.ArcCurve.prototype.constructor = THREE.ArcCurve;\r\n\t\r\n\t// File:src/extras/curves/LineCurve3.js\r\n\t\r\n\t/**************************************************************\r\n\t *\tLine3D\r\n\t **************************************************************/\r\n\t\r\n\tTHREE.LineCurve3 = THREE.Curve.create(\r\n\t\r\n\t\tfunction ( v1, v2 ) {\r\n\t\r\n\t\t\tthis.v1 = v1;\r\n\t\t\tthis.v2 = v2;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfunction ( t ) {\r\n\t\r\n\t\t\tvar vector = new THREE.Vector3();\r\n\t\r\n\t\t\tvector.subVectors( this.v2, this.v1 ); // diff\r\n\t\t\tvector.multiplyScalar( t );\r\n\t\t\tvector.add( this.v1 );\r\n\t\r\n\t\t\treturn vector;\r\n\t\r\n\t\t}\r\n\t\r\n\t);\r\n\t\r\n\t// File:src/extras/curves/QuadraticBezierCurve3.js\r\n\t\r\n\t/**************************************************************\r\n\t *\tQuadratic Bezier 3D curve\r\n\t **************************************************************/\r\n\t\r\n\tTHREE.QuadraticBezierCurve3 = THREE.Curve.create(\r\n\t\r\n\t\tfunction ( v0, v1, v2 ) {\r\n\t\r\n\t\t\tthis.v0 = v0;\r\n\t\t\tthis.v1 = v1;\r\n\t\t\tthis.v2 = v2;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfunction ( t ) {\r\n\t\r\n\t\t\tvar b2 = THREE.ShapeUtils.b2;\t\t\r\n\t\r\n\t\t\treturn new THREE.Vector3(\r\n\t\t\t\tb2( t, this.v0.x, this.v1.x, this.v2.x ),\r\n\t\t\t\tb2( t, this.v0.y, this.v1.y, this.v2.y ),\r\n\t\t\t\tb2( t, this.v0.z, this.v1.z, this.v2.z )\r\n\t\t\t);\r\n\t\r\n\t\t}\r\n\t\r\n\t);\r\n\t\r\n\t// File:src/extras/curves/CubicBezierCurve3.js\r\n\t\r\n\t/**************************************************************\r\n\t *\tCubic Bezier 3D curve\r\n\t **************************************************************/\r\n\t\r\n\tTHREE.CubicBezierCurve3 = THREE.Curve.create(\r\n\t\r\n\t\tfunction ( v0, v1, v2, v3 ) {\r\n\t\r\n\t\t\tthis.v0 = v0;\r\n\t\t\tthis.v1 = v1;\r\n\t\t\tthis.v2 = v2;\r\n\t\t\tthis.v3 = v3;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfunction ( t ) {\r\n\t\r\n\t\t\tvar b3 = THREE.ShapeUtils.b3;\r\n\t\r\n\t\t\treturn new THREE.Vector3(\r\n\t\t\t\tb3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),\r\n\t\t\t\tb3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y ),\r\n\t\t\t\tb3( t, this.v0.z, this.v1.z, this.v2.z, this.v3.z )\r\n\t\t\t);\r\n\t\r\n\t\t}\r\n\t\r\n\t);\r\n\t\r\n\t// File:src/extras/curves/SplineCurve3.js\r\n\t\r\n\t/**************************************************************\r\n\t *\tSpline 3D curve\r\n\t **************************************************************/\r\n\t\r\n\t\r\n\tTHREE.SplineCurve3 = THREE.Curve.create(\r\n\t\r\n\t\tfunction ( points /* array of Vector3 */ ) {\r\n\t\r\n\t\t\tconsole.warn( 'THREE.SplineCurve3 will be deprecated. Please use THREE.CatmullRomCurve3' );\r\n\t\t\tthis.points = ( points == undefined ) ? [] : points;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfunction ( t ) {\r\n\t\r\n\t\t\tvar points = this.points;\r\n\t\t\tvar point = ( points.length - 1 ) * t;\r\n\t\r\n\t\t\tvar intPoint = Math.floor( point );\r\n\t\t\tvar weight = point - intPoint;\r\n\t\r\n\t\t\tvar point0 = points[ intPoint == 0 ? intPoint : intPoint - 1 ];\r\n\t\t\tvar point1 = points[ intPoint ];\r\n\t\t\tvar point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];\r\n\t\t\tvar point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];\r\n\t\r\n\t\t\tvar interpolate = THREE.CurveUtils.interpolate;\r\n\t\r\n\t\t\treturn new THREE.Vector3(\r\n\t\t\t\tinterpolate( point0.x, point1.x, point2.x, point3.x, weight ),\r\n\t\t\t\tinterpolate( point0.y, point1.y, point2.y, point3.y, weight ),\r\n\t\t\t\tinterpolate( point0.z, point1.z, point2.z, point3.z, weight )\r\n\t\t\t);\r\n\t\r\n\t\t}\r\n\t\r\n\t);\r\n\t\r\n\t// File:src/extras/curves/CatmullRomCurve3.js\r\n\t\r\n\t/**\r\n\t * @author zz85 https://github.com/zz85\r\n\t *\r\n\t * Centripetal CatmullRom Curve - which is useful for avoiding\r\n\t * cusps and self-intersections in non-uniform catmull rom curves.\r\n\t * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf\r\n\t *\r\n\t * curve.type accepts centripetal(default), chordal and catmullrom\r\n\t * curve.tension is used for catmullrom which defaults to 0.5\r\n\t */\r\n\t\r\n\tTHREE.CatmullRomCurve3 = ( function() {\r\n\t\r\n\t\tvar\r\n\t\t\ttmp = new THREE.Vector3(),\r\n\t\t\tpx = new CubicPoly(),\r\n\t\t\tpy = new CubicPoly(),\r\n\t\t\tpz = new CubicPoly();\r\n\t\r\n\t\t/*\r\n\t\tBased on an optimized c++ solution in\r\n\t\t - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/\r\n\t\t - http://ideone.com/NoEbVM\r\n\t\r\n\t\tThis CubicPoly class could be used for reusing some variables and calculations,\r\n\t\tbut for three.js curve use, it could be possible inlined and flatten into a single function call\r\n\t\twhich can be placed in CurveUtils.\r\n\t\t*/\r\n\t\r\n\t\tfunction CubicPoly() {\r\n\t\r\n\t\t}\r\n\t\r\n\t\t/*\r\n\t\t * Compute coefficients for a cubic polynomial\r\n\t\t *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3\r\n\t\t * such that\r\n\t\t *   p(0) = x0, p(1) = x1\r\n\t\t *  and\r\n\t\t *   p'(0) = t0, p'(1) = t1.\r\n\t\t */\r\n\t\tCubicPoly.prototype.init = function( x0, x1, t0, t1 ) {\r\n\t\r\n\t\t\tthis.c0 = x0;\r\n\t\t\tthis.c1 = t0;\r\n\t\t\tthis.c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;\r\n\t\t\tthis.c3 = 2 * x0 - 2 * x1 + t0 + t1;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tCubicPoly.prototype.initNonuniformCatmullRom = function( x0, x1, x2, x3, dt0, dt1, dt2 ) {\r\n\t\r\n\t\t\t// compute tangents when parameterized in [t1,t2]\r\n\t\t\tvar t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;\r\n\t\t\tvar t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;\r\n\t\r\n\t\t\t// rescale tangents for parametrization in [0,1]\r\n\t\t\tt1 *= dt1;\r\n\t\t\tt2 *= dt1;\r\n\t\r\n\t\t\t// initCubicPoly\r\n\t\t\tthis.init( x1, x2, t1, t2 );\r\n\t\r\n\t\t};\r\n\t\r\n\t\t// standard Catmull-Rom spline: interpolate between x1 and x2 with previous/following points x1/x4\r\n\t\tCubicPoly.prototype.initCatmullRom = function( x0, x1, x2, x3, tension ) {\r\n\t\r\n\t\t\tthis.init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tCubicPoly.prototype.calc = function( t ) {\r\n\t\r\n\t\t\tvar t2 = t * t;\r\n\t\t\tvar t3 = t2 * t;\r\n\t\t\treturn this.c0 + this.c1 * t + this.c2 * t2 + this.c3 * t3;\r\n\t\r\n\t\t};\r\n\t\r\n\t\t// Subclass Three.js curve\r\n\t\treturn THREE.Curve.create(\r\n\t\r\n\t\t\tfunction ( p /* array of Vector3 */ ) {\r\n\t\r\n\t\t\t\tthis.points = p || [];\r\n\t\t\t\tthis.closed = false;\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t\tfunction ( t ) {\r\n\t\r\n\t\t\t\tvar points = this.points,\r\n\t\t\t\t\tpoint, intPoint, weight, l;\r\n\t\r\n\t\t\t\tl = points.length;\r\n\t\r\n\t\t\t\tif ( l < 2 ) console.log( 'duh, you need at least 2 points' );\r\n\t\r\n\t\t\t\tpoint = ( l - ( this.closed ? 0 : 1 ) ) * t;\r\n\t\t\t\tintPoint = Math.floor( point );\r\n\t\t\t\tweight = point - intPoint;\r\n\t\r\n\t\t\t\tif ( this.closed ) {\r\n\t\r\n\t\t\t\t\tintPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;\r\n\t\r\n\t\t\t\t} else if ( weight === 0 && intPoint === l - 1 ) {\r\n\t\r\n\t\t\t\t\tintPoint = l - 2;\r\n\t\t\t\t\tweight = 1;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar p0, p1, p2, p3; // 4 points\r\n\t\r\n\t\t\t\tif ( this.closed || intPoint > 0 ) {\r\n\t\r\n\t\t\t\t\tp0 = points[ ( intPoint - 1 ) % l ];\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t// extrapolate first point\r\n\t\t\t\t\ttmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );\r\n\t\t\t\t\tp0 = tmp;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tp1 = points[ intPoint % l ];\r\n\t\t\t\tp2 = points[ ( intPoint + 1 ) % l ];\r\n\t\r\n\t\t\t\tif ( this.closed || intPoint + 2 < l ) {\r\n\t\r\n\t\t\t\t\tp3 = points[ ( intPoint + 2 ) % l ];\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t// extrapolate last point\r\n\t\t\t\t\ttmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );\r\n\t\t\t\t\tp3 = tmp;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( this.type === undefined || this.type === 'centripetal' || this.type === 'chordal' ) {\r\n\t\r\n\t\t\t\t\t// init Centripetal / Chordal Catmull-Rom\r\n\t\t\t\t\tvar pow = this.type === 'chordal' ? 0.5 : 0.25;\r\n\t\t\t\t\tvar dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );\r\n\t\t\t\t\tvar dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );\r\n\t\t\t\t\tvar dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );\r\n\t\r\n\t\t\t\t\t// safety check for repeated points\r\n\t\t\t\t\tif ( dt1 < 1e-4 ) dt1 = 1.0;\r\n\t\t\t\t\tif ( dt0 < 1e-4 ) dt0 = dt1;\r\n\t\t\t\t\tif ( dt2 < 1e-4 ) dt2 = dt1;\r\n\t\r\n\t\t\t\t\tpx.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );\r\n\t\t\t\t\tpy.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );\r\n\t\t\t\t\tpz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );\r\n\t\r\n\t\t\t\t} else if ( this.type === 'catmullrom' ) {\r\n\t\r\n\t\t\t\t\tvar tension = this.tension !== undefined ? this.tension : 0.5;\r\n\t\t\t\t\tpx.initCatmullRom( p0.x, p1.x, p2.x, p3.x, tension );\r\n\t\t\t\t\tpy.initCatmullRom( p0.y, p1.y, p2.y, p3.y, tension );\r\n\t\t\t\t\tpz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, tension );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar v = new THREE.Vector3(\r\n\t\t\t\t\tpx.calc( weight ),\r\n\t\t\t\t\tpy.calc( weight ),\r\n\t\t\t\t\tpz.calc( weight )\r\n\t\t\t\t);\r\n\t\r\n\t\t\t\treturn v;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t);\r\n\t\r\n\t} )();\r\n\t\r\n\t// File:src/extras/curves/ClosedSplineCurve3.js\r\n\t\r\n\t/**************************************************************\r\n\t *\tClosed Spline 3D curve\r\n\t **************************************************************/\r\n\t\r\n\t\r\n\tTHREE.ClosedSplineCurve3 = function ( points ) {\r\n\t\r\n\t\tconsole.warn( 'THREE.ClosedSplineCurve3 has been deprecated. Please use THREE.CatmullRomCurve3.' );\r\n\t\r\n\t\tTHREE.CatmullRomCurve3.call( this, points );\r\n\t\tthis.type = 'catmullrom';\r\n\t\tthis.closed = true;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.ClosedSplineCurve3.prototype = Object.create( THREE.CatmullRomCurve3.prototype );\r\n\t\r\n\t// File:src/extras/geometries/BoxGeometry.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as\r\n\t */\r\n\t\r\n\tTHREE.BoxGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {\r\n\t\r\n\t\tTHREE.Geometry.call( this );\r\n\t\r\n\t\tthis.type = 'BoxGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\twidth: width,\r\n\t\t\theight: height,\r\n\t\t\tdepth: depth,\r\n\t\t\twidthSegments: widthSegments,\r\n\t\t\theightSegments: heightSegments,\r\n\t\t\tdepthSegments: depthSegments\r\n\t\t};\r\n\t\r\n\t\tthis.fromBufferGeometry( new THREE.BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) );\r\n\t\tthis.mergeVertices();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.BoxGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\tTHREE.BoxGeometry.prototype.constructor = THREE.BoxGeometry;\r\n\t\r\n\tTHREE.CubeGeometry = THREE.BoxGeometry;\r\n\t\r\n\t// File:src/extras/geometries/BoxBufferGeometry.js\r\n\t\r\n\t/**\r\n\t * @author Mugen87 / https://github.com/Mugen87\r\n\t */\r\n\t\r\n\tTHREE.BoxBufferGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {\r\n\t\r\n\t\tTHREE.BufferGeometry.call( this );\r\n\t\r\n\t\tthis.type = 'BoxBufferGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\twidth: width,\r\n\t\t\theight: height,\r\n\t\t\tdepth: depth,\r\n\t\t\twidthSegments: widthSegments,\r\n\t\t\theightSegments: heightSegments,\r\n\t\t\tdepthSegments: depthSegments\r\n\t\t};\r\n\t\r\n\t\tvar scope = this;\r\n\t\r\n\t\t// segments\r\n\t\twidthSegments = Math.floor( widthSegments ) || 1;\r\n\t\theightSegments = Math.floor( heightSegments ) || 1;\r\n\t\tdepthSegments = Math.floor( depthSegments ) || 1;\r\n\t\r\n\t\t// these are used to calculate buffer length\r\n\t\tvar vertexCount = calculateVertexCount( widthSegments, heightSegments, depthSegments );\r\n\t\tvar indexCount = ( vertexCount / 4 ) * 6;\r\n\t\r\n\t\t// buffers\r\n\t\tvar indices = new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount );\r\n\t\tvar vertices = new Float32Array( vertexCount * 3 );\r\n\t\tvar normals = new Float32Array( vertexCount * 3 );\r\n\t\tvar uvs = new Float32Array( vertexCount * 2 );\r\n\t\r\n\t\t// offset variables\r\n\t\tvar vertexBufferOffset = 0;\r\n\t\tvar uvBufferOffset = 0;\r\n\t\tvar indexBufferOffset = 0;\r\n\t\tvar numberOfVertices = 0;\r\n\t\r\n\t\t// group variables\r\n\t\tvar groupStart = 0;\r\n\t\r\n\t\t// build each side of the box geometry\r\n\t\tbuildPlane( 'z', 'y', 'x', - 1, - 1, depth, height,   width,  depthSegments, heightSegments, 0 ); // px\r\n\t\tbuildPlane( 'z', 'y', 'x',   1, - 1, depth, height, - width,  depthSegments, heightSegments, 1 ); // nx\r\n\t\tbuildPlane( 'x', 'z', 'y',   1,   1, width, depth,    height, widthSegments, depthSegments,  2 ); // py\r\n\t\tbuildPlane( 'x', 'z', 'y',   1, - 1, width, depth,  - height, widthSegments, depthSegments,  3 ); // ny\r\n\t\tbuildPlane( 'x', 'y', 'z',   1, - 1, width, height,   depth,  widthSegments, heightSegments, 4 ); // pz\r\n\t\tbuildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth,  widthSegments, heightSegments, 5 ); // nz\r\n\t\r\n\t\t// build geometry\r\n\t\tthis.setIndex( new THREE.BufferAttribute( indices, 1 ) );\r\n\t\tthis.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\r\n\t\tthis.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );\r\n\t\tthis.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );\r\n\t\r\n\t\t// helper functions\r\n\t\r\n\t\tfunction calculateVertexCount ( w, h, d ) {\r\n\t\r\n\t\t\tvar segments = 0;\r\n\t\r\n\t\t\t// calculate the amount of segments for each side\r\n\t\t\tsegments += w * h * 2; // xy\r\n\t\t\tsegments += w * d * 2; // xz\r\n\t\t\tsegments += d * h * 2; // zy\r\n\t\r\n\t\t\treturn segments * 4; // four vertices per segments\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction buildPlane ( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {\r\n\t\r\n\t\t\tvar segmentWidth\t= width / gridX;\r\n\t\t\tvar segmentHeight = height / gridY;\r\n\t\r\n\t\t\tvar widthHalf = width / 2;\r\n\t\t\tvar heightHalf = height / 2;\r\n\t\t\tvar depthHalf = depth / 2;\r\n\t\r\n\t\t\tvar gridX1 = gridX + 1;\r\n\t\t\tvar gridY1 = gridY + 1;\r\n\t\r\n\t\t\tvar vertexCounter = 0;\r\n\t\t\tvar groupCount = 0;\r\n\t\r\n\t\t\tvar vector = new THREE.Vector3();\r\n\t\r\n\t\t\t// generate vertices, normals and uvs\r\n\t\r\n\t\t\tfor ( var iy = 0; iy < gridY1; iy ++ ) {\r\n\t\r\n\t\t\t\tvar y = iy * segmentHeight - heightHalf;\r\n\t\r\n\t\t\t\tfor ( var ix = 0; ix < gridX1; ix ++ ) {\r\n\t\r\n\t\t\t\t\tvar x = ix * segmentWidth - widthHalf;\r\n\t\r\n\t\t\t\t\t// set values to correct vector component\r\n\t\t\t\t\tvector[ u ] = x * udir;\r\n\t\t\t\t\tvector[ v ] = y * vdir;\r\n\t\t\t\t\tvector[ w ] = depthHalf;\r\n\t\r\n\t\t\t\t\t// now apply vector to vertex buffer\r\n\t\t\t\t\tvertices[ vertexBufferOffset ] = vector.x;\r\n\t\t\t\t\tvertices[ vertexBufferOffset + 1 ] = vector.y;\r\n\t\t\t\t\tvertices[ vertexBufferOffset + 2 ] = vector.z;\r\n\t\r\n\t\t\t\t\t// set values to correct vector component\r\n\t\t\t\t\tvector[ u ] = 0;\r\n\t\t\t\t\tvector[ v ] = 0;\r\n\t\t\t\t\tvector[ w ] = depth > 0 ? 1 : - 1;\r\n\t\r\n\t\t\t\t\t// now apply vector to normal buffer\r\n\t\t\t\t\tnormals[ vertexBufferOffset ] = vector.x;\r\n\t\t\t\t\tnormals[ vertexBufferOffset + 1 ] = vector.y;\r\n\t\t\t\t\tnormals[ vertexBufferOffset + 2 ] = vector.z;\r\n\t\r\n\t\t\t\t\t// uvs\r\n\t\t\t\t\tuvs[ uvBufferOffset ] = ix / gridX;\r\n\t\t\t\t\tuvs[ uvBufferOffset + 1 ] = 1 - ( iy / gridY );\r\n\t\r\n\t\t\t\t\t// update offsets and counters\r\n\t\t\t\t\tvertexBufferOffset += 3;\r\n\t\t\t\t\tuvBufferOffset += 2;\r\n\t\t\t\t\tvertexCounter += 1;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// 1. you need three indices to draw a single face\r\n\t\t\t// 2. a single segment consists of two faces\r\n\t\t\t// 3. so we need to generate six (2*3) indices per segment\r\n\t\r\n\t\t\tfor ( iy = 0; iy < gridY; iy ++ ) {\r\n\t\r\n\t\t\t\tfor ( ix = 0; ix < gridX; ix ++ ) {\r\n\t\r\n\t\t\t\t\t// indices\r\n\t\t\t\t\tvar a = numberOfVertices + ix + gridX1 * iy;\r\n\t\t\t\t\tvar b = numberOfVertices + ix + gridX1 * ( iy + 1 );\r\n\t\t\t\t\tvar c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );\r\n\t\t\t\t\tvar d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;\r\n\t\r\n\t\t\t\t\t// face one\r\n\t\t\t\t\tindices[ indexBufferOffset ] = a;\r\n\t\t\t\t\tindices[ indexBufferOffset + 1 ] = b;\r\n\t\t\t\t\tindices[ indexBufferOffset + 2 ] = d;\r\n\t\r\n\t\t\t\t\t// face two\r\n\t\t\t\t\tindices[ indexBufferOffset + 3 ] = b;\r\n\t\t\t\t\tindices[ indexBufferOffset + 4 ] = c;\r\n\t\t\t\t\tindices[ indexBufferOffset + 5 ] = d;\r\n\t\r\n\t\t\t\t\t// update offsets and counters\r\n\t\t\t\t\tindexBufferOffset += 6;\r\n\t\t\t\t\tgroupCount += 6;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// add a group to the geometry. this will ensure multi material support\r\n\t\t\tscope.addGroup( groupStart, groupCount, materialIndex );\r\n\t\r\n\t\t\t// calculate new start value for groups\r\n\t\t\tgroupStart += groupCount;\r\n\t\r\n\t\t\t// update total number of vertices\r\n\t\t\tnumberOfVertices += vertexCounter;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.BoxBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\n\tTHREE.BoxBufferGeometry.prototype.constructor = THREE.BoxBufferGeometry;\r\n\t\r\n\t// File:src/extras/geometries/CircleGeometry.js\r\n\t\r\n\t/**\r\n\t * @author hughes\r\n\t */\r\n\t\r\n\tTHREE.CircleGeometry = function ( radius, segments, thetaStart, thetaLength ) {\r\n\t\r\n\t\tTHREE.Geometry.call( this );\r\n\t\r\n\t\tthis.type = 'CircleGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tradius: radius,\r\n\t\t\tsegments: segments,\r\n\t\t\tthetaStart: thetaStart,\r\n\t\t\tthetaLength: thetaLength\r\n\t\t};\r\n\t\r\n\t\tthis.fromBufferGeometry( new THREE.CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.CircleGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\tTHREE.CircleGeometry.prototype.constructor = THREE.CircleGeometry;\r\n\t\r\n\t// File:src/extras/geometries/CircleBufferGeometry.js\r\n\t\r\n\t/**\r\n\t * @author benaadams / https://twitter.com/ben_a_adams\r\n\t */\r\n\t\r\n\tTHREE.CircleBufferGeometry = function ( radius, segments, thetaStart, thetaLength ) {\r\n\t\r\n\t\tTHREE.BufferGeometry.call( this );\r\n\t\r\n\t\tthis.type = 'CircleBufferGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tradius: radius,\r\n\t\t\tsegments: segments,\r\n\t\t\tthetaStart: thetaStart,\r\n\t\t\tthetaLength: thetaLength\r\n\t\t};\r\n\t\r\n\t\tradius = radius || 50;\r\n\t\tsegments = segments !== undefined ? Math.max( 3, segments ) : 8;\r\n\t\r\n\t\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\r\n\t\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\r\n\t\r\n\t\tvar vertices = segments + 2;\r\n\t\r\n\t\tvar positions = new Float32Array( vertices * 3 );\r\n\t\tvar normals = new Float32Array( vertices * 3 );\r\n\t\tvar uvs = new Float32Array( vertices * 2 );\r\n\t\r\n\t\t// center data is already zero, but need to set a few extras\r\n\t\tnormals[ 2 ] = 1.0;\r\n\t\tuvs[ 0 ] = 0.5;\r\n\t\tuvs[ 1 ] = 0.5;\r\n\t\r\n\t\tfor ( var s = 0, i = 3, ii = 2 ; s <= segments; s ++, i += 3, ii += 2 ) {\r\n\t\r\n\t\t\tvar segment = thetaStart + s / segments * thetaLength;\r\n\t\r\n\t\t\tpositions[ i ] = radius * Math.cos( segment );\r\n\t\t\tpositions[ i + 1 ] = radius * Math.sin( segment );\r\n\t\r\n\t\t\tnormals[ i + 2 ] = 1; // normal z\r\n\t\r\n\t\t\tuvs[ ii ] = ( positions[ i ] / radius + 1 ) / 2;\r\n\t\t\tuvs[ ii + 1 ] = ( positions[ i + 1 ] / radius + 1 ) / 2;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar indices = [];\r\n\t\r\n\t\tfor ( var i = 1; i <= segments; i ++ ) {\r\n\t\r\n\t\t\tindices.push( i, i + 1, 0 );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.setIndex( new THREE.BufferAttribute( new Uint16Array( indices ), 1 ) );\r\n\t\tthis.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );\r\n\t\tthis.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );\r\n\t\tthis.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );\r\n\t\r\n\t\tthis.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.CircleBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\n\tTHREE.CircleBufferGeometry.prototype.constructor = THREE.CircleBufferGeometry;\r\n\t\r\n\t// File:src/extras/geometries/CylinderBufferGeometry.js\r\n\t\r\n\t/**\r\n\t * @author Mugen87 / https://github.com/Mugen87\r\n\t */\r\n\t\r\n\tTHREE.CylinderBufferGeometry = function( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\r\n\t\r\n\t\tTHREE.BufferGeometry.call( this );\r\n\t\r\n\t\tthis.type = 'CylinderBufferGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tradiusTop: radiusTop,\r\n\t\t\tradiusBottom: radiusBottom,\r\n\t\t\theight: height,\r\n\t\t\tradialSegments: radialSegments,\r\n\t\t\theightSegments: heightSegments,\r\n\t\t\topenEnded: openEnded,\r\n\t\t\tthetaStart: thetaStart,\r\n\t\t\tthetaLength: thetaLength\r\n\t\t};\r\n\t\r\n\t\tvar scope = this;\r\n\t\r\n\t\tradiusTop = radiusTop !== undefined ? radiusTop : 20;\r\n\t\tradiusBottom = radiusBottom !== undefined ? radiusBottom : 20;\r\n\t\theight = height !== undefined ? height : 100;\r\n\t\r\n\t\tradialSegments = Math.floor( radialSegments ) || 8;\r\n\t\theightSegments = Math.floor( heightSegments ) || 1;\r\n\t\r\n\t\topenEnded = openEnded !== undefined ? openEnded : false;\r\n\t\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\r\n\t\tthetaLength = thetaLength !== undefined ? thetaLength : 2 * Math.PI;\r\n\t\r\n\t\t// used to calculate buffer length\r\n\t\r\n\t\tvar vertexCount = calculateVertexCount();\r\n\t\tvar indexCount = calculateIndexCount();\r\n\t\r\n\t\t// buffers\r\n\t\r\n\t\tvar indices = new THREE.BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ), 1 );\r\n\t\tvar vertices = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\r\n\t\tvar normals = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\r\n\t\tvar uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\r\n\t\r\n\t\t// helper variables\r\n\t\r\n\t\tvar index = 0, indexOffset = 0, indexArray = [], halfHeight = height / 2;\r\n\t\r\n\t\t// group variables\r\n\t\tvar groupStart = 0;\r\n\t\r\n\t\t// generate geometry\r\n\t\r\n\t\tgenerateTorso();\r\n\t\r\n\t\tif ( openEnded === false ) {\r\n\t\r\n\t\t\tif ( radiusTop > 0 ) generateCap( true );\r\n\t\t\tif ( radiusBottom > 0 ) generateCap( false );\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// build geometry\r\n\t\r\n\t\tthis.setIndex( indices );\r\n\t\tthis.addAttribute( 'position', vertices );\r\n\t\tthis.addAttribute( 'normal', normals );\r\n\t\tthis.addAttribute( 'uv', uvs );\r\n\t\r\n\t\t// helper functions\r\n\t\r\n\t\tfunction calculateVertexCount() {\r\n\t\r\n\t\t\tvar count = ( radialSegments + 1 ) * ( heightSegments + 1 );\r\n\t\r\n\t\t\tif ( openEnded === false ) {\r\n\t\r\n\t\t\t\tcount += ( ( radialSegments + 1 ) * 2 ) + ( radialSegments * 2 );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn count;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction calculateIndexCount() {\r\n\t\r\n\t\t\tvar count = radialSegments * heightSegments * 2 * 3;\r\n\t\r\n\t\t\tif ( openEnded === false ) {\r\n\t\r\n\t\t\t\tcount += radialSegments * 2 * 3;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn count;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction generateTorso() {\r\n\t\r\n\t\t\tvar x, y;\r\n\t\t\tvar normal = new THREE.Vector3();\r\n\t\t\tvar vertex = new THREE.Vector3();\r\n\t\r\n\t\t\tvar groupCount = 0;\r\n\t\r\n\t\t\t// this will be used to calculate the normal\r\n\t\t\tvar tanTheta = ( radiusBottom - radiusTop ) / height;\r\n\t\r\n\t\t\t// generate vertices, normals and uvs\r\n\t\r\n\t\t\tfor ( y = 0; y <= heightSegments; y ++ ) {\r\n\t\r\n\t\t\t\tvar indexRow = [];\r\n\t\r\n\t\t\t\tvar v = y / heightSegments;\r\n\t\r\n\t\t\t\t// calculate the radius of the current row\r\n\t\t\t\tvar radius = v * ( radiusBottom - radiusTop ) + radiusTop;\r\n\t\r\n\t\t\t\tfor ( x = 0; x <= radialSegments; x ++ ) {\r\n\t\r\n\t\t\t\t\tvar u = x / radialSegments;\r\n\t\r\n\t\t\t\t\t// vertex\r\n\t\t\t\t\tvertex.x = radius * Math.sin( u * thetaLength + thetaStart );\r\n\t\t\t\t\tvertex.y = - v * height + halfHeight;\r\n\t\t\t\t\tvertex.z = radius * Math.cos( u * thetaLength + thetaStart );\r\n\t\t\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\r\n\t\r\n\t\t\t\t\t// normal\r\n\t\t\t\t\tnormal.copy( vertex );\r\n\t\r\n\t\t\t\t\t// handle special case if radiusTop/radiusBottom is zero\r\n\t\t\t\t\tif ( ( radiusTop === 0 && y === 0 ) || ( radiusBottom === 0 && y === heightSegments ) ) {\r\n\t\r\n\t\t\t\t\t\tnormal.x = Math.sin( u * thetaLength + thetaStart );\r\n\t\t\t\t\t\tnormal.z = Math.cos( u * thetaLength + thetaStart );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tnormal.setY( Math.sqrt( normal.x * normal.x + normal.z * normal.z ) * tanTheta ).normalize();\r\n\t\t\t\t\tnormals.setXYZ( index, normal.x, normal.y, normal.z );\r\n\t\r\n\t\t\t\t\t// uv\r\n\t\t\t\t\tuvs.setXY( index, u, 1 - v );\r\n\t\r\n\t\t\t\t\t// save index of vertex in respective row\r\n\t\t\t\t\tindexRow.push( index );\r\n\t\r\n\t\t\t\t\t// increase index\r\n\t\t\t\t\tindex ++;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// now save vertices of the row in our index array\r\n\t\t\t\tindexArray.push( indexRow );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// generate indices\r\n\t\r\n\t\t\tfor ( x = 0; x < radialSegments; x ++ ) {\r\n\t\r\n\t\t\t\tfor ( y = 0; y < heightSegments; y ++ ) {\r\n\t\r\n\t\t\t\t\t// we use the index array to access the correct indices\r\n\t\t\t\t\tvar i1 = indexArray[ y ][ x ];\r\n\t\t\t\t\tvar i2 = indexArray[ y + 1 ][ x ];\r\n\t\t\t\t\tvar i3 = indexArray[ y + 1 ][ x + 1 ];\r\n\t\t\t\t\tvar i4 = indexArray[ y ][ x + 1 ];\r\n\t\r\n\t\t\t\t\t// face one\r\n\t\t\t\t\tindices.setX( indexOffset, i1 ); indexOffset ++;\r\n\t\t\t\t\tindices.setX( indexOffset, i2 ); indexOffset ++;\r\n\t\t\t\t\tindices.setX( indexOffset, i4 ); indexOffset ++;\r\n\t\r\n\t\t\t\t\t// face two\r\n\t\t\t\t\tindices.setX( indexOffset, i2 ); indexOffset ++;\r\n\t\t\t\t\tindices.setX( indexOffset, i3 ); indexOffset ++;\r\n\t\t\t\t\tindices.setX( indexOffset, i4 ); indexOffset ++;\r\n\t\r\n\t\t\t\t\t// update counters\r\n\t\t\t\t\tgroupCount += 6;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// add a group to the geometry. this will ensure multi material support\r\n\t\t\tscope.addGroup( groupStart, groupCount, 0 );\r\n\t\r\n\t\t\t// calculate new start value for groups\r\n\t\t\tgroupStart += groupCount;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction generateCap( top ) {\r\n\t\r\n\t\t\tvar x, centerIndexStart, centerIndexEnd;\r\n\t\t\tvar uv = new THREE.Vector2();\r\n\t\t\tvar vertex = new THREE.Vector3();\r\n\t\r\n\t\t\tvar groupCount = 0;\r\n\t\r\n\t\t\tvar radius = ( top === true ) ? radiusTop : radiusBottom;\r\n\t\t\tvar sign = ( top === true ) ? 1 : - 1;\r\n\t\r\n\t\t\t// save the index of the first center vertex\r\n\t\t\tcenterIndexStart = index;\r\n\t\r\n\t\t\t// first we generate the center vertex data of the cap.\r\n\t\t\t// because the geometry needs one set of uvs per face,\r\n\t\t\t// we must generate a center vertex per face/segment\r\n\t\r\n\t\t\tfor ( x = 1; x <= radialSegments; x ++ ) {\r\n\t\r\n\t\t\t\t// vertex\r\n\t\t\t\tvertices.setXYZ( index, 0, halfHeight * sign, 0 );\r\n\t\r\n\t\t\t\t// normal\r\n\t\t\t\tnormals.setXYZ( index, 0, sign, 0 );\r\n\t\r\n\t\t\t\t// uv\r\n\t\t\t\tif ( top === true ) {\r\n\t\r\n\t\t\t\t\tuv.x = x / radialSegments;\r\n\t\t\t\t\tuv.y = 0;\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tuv.x = ( x - 1 ) / radialSegments;\r\n\t\t\t\t\tuv.y = 1;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tuvs.setXY( index, uv.x, uv.y );\r\n\t\r\n\t\t\t\t// increase index\r\n\t\t\t\tindex ++;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// save the index of the last center vertex\r\n\t\t\tcenterIndexEnd = index;\r\n\t\r\n\t\t\t// now we generate the surrounding vertices, normals and uvs\r\n\t\r\n\t\t\tfor ( x = 0; x <= radialSegments; x ++ ) {\r\n\t\r\n\t\t\t\tvar u = x / radialSegments;\r\n\t\r\n\t\t\t\t// vertex\r\n\t\t\t\tvertex.x = radius * Math.sin( u * thetaLength + thetaStart );\r\n\t\t\t\tvertex.y = halfHeight * sign;\r\n\t\t\t\tvertex.z = radius * Math.cos( u * thetaLength + thetaStart );\r\n\t\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\r\n\t\r\n\t\t\t\t// normal\r\n\t\t\t\tnormals.setXYZ( index, 0, sign, 0 );\r\n\t\r\n\t\t\t\t// uv\r\n\t\t\t\tuvs.setXY( index, u, ( top === true ) ? 1 : 0 );\r\n\t\r\n\t\t\t\t// increase index\r\n\t\t\t\tindex ++;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// generate indices\r\n\t\r\n\t\t\tfor ( x = 0; x < radialSegments; x ++ ) {\r\n\t\r\n\t\t\t\tvar c = centerIndexStart + x;\r\n\t\t\t\tvar i = centerIndexEnd + x;\r\n\t\r\n\t\t\t\tif ( top === true ) {\r\n\t\r\n\t\t\t\t\t// face top\r\n\t\t\t\t\tindices.setX( indexOffset, i ); indexOffset ++;\r\n\t\t\t\t\tindices.setX( indexOffset, i + 1 ); indexOffset ++;\r\n\t\t\t\t\tindices.setX( indexOffset, c ); indexOffset ++;\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t// face bottom\r\n\t\t\t\t\tindices.setX( indexOffset, i + 1 ); indexOffset ++;\r\n\t\t\t\t\tindices.setX( indexOffset, i ); indexOffset ++;\r\n\t\t\t\t\tindices.setX( indexOffset, c ); indexOffset ++;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// update counters\r\n\t\t\t\tgroupCount += 3;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// add a group to the geometry. this will ensure multi material support\r\n\t\t\tscope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );\r\n\t\r\n\t\t\t// calculate new start value for groups\r\n\t\t\tgroupStart += groupCount;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.CylinderBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\n\tTHREE.CylinderBufferGeometry.prototype.constructor = THREE.CylinderBufferGeometry;\r\n\t\r\n\t// File:src/extras/geometries/CylinderGeometry.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.CylinderGeometry = function ( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\r\n\t\r\n\t\tTHREE.Geometry.call( this );\r\n\t\r\n\t\tthis.type = 'CylinderGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tradiusTop: radiusTop,\r\n\t\t\tradiusBottom: radiusBottom,\r\n\t\t\theight: height,\r\n\t\t\tradialSegments: radialSegments,\r\n\t\t\theightSegments: heightSegments,\r\n\t\t\topenEnded: openEnded,\r\n\t\t\tthetaStart: thetaStart,\r\n\t\t\tthetaLength: thetaLength\r\n\t\t};\r\n\t\r\n\t\tthis.fromBufferGeometry( new THREE.CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) );\r\n\t\tthis.mergeVertices();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.CylinderGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\tTHREE.CylinderGeometry.prototype.constructor = THREE.CylinderGeometry;\r\n\t\r\n\t// File:src/extras/geometries/EdgesGeometry.js\r\n\t\r\n\t/**\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t */\r\n\t\r\n\tTHREE.EdgesGeometry = function ( geometry, thresholdAngle ) {\r\n\t\r\n\t\tTHREE.BufferGeometry.call( this );\r\n\t\r\n\t\tthresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;\r\n\t\r\n\t\tvar thresholdDot = Math.cos( THREE.Math.DEG2RAD * thresholdAngle );\r\n\t\r\n\t\tvar edge = [ 0, 0 ], hash = {};\r\n\t\r\n\t\tfunction sortFunction( a, b ) {\r\n\t\r\n\t\t\treturn a - b;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar keys = [ 'a', 'b', 'c' ];\r\n\t\r\n\t\tvar geometry2;\r\n\t\r\n\t\tif ( geometry instanceof THREE.BufferGeometry ) {\r\n\t\r\n\t\t\tgeometry2 = new THREE.Geometry();\r\n\t\t\tgeometry2.fromBufferGeometry( geometry );\r\n\t\r\n\t\t} else {\r\n\t\r\n\t\t\tgeometry2 = geometry.clone();\r\n\t\r\n\t\t}\r\n\t\r\n\t\tgeometry2.mergeVertices();\r\n\t\tgeometry2.computeFaceNormals();\r\n\t\r\n\t\tvar vertices = geometry2.vertices;\r\n\t\tvar faces = geometry2.faces;\r\n\t\r\n\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\t\r\n\t\t\tvar face = faces[ i ];\r\n\t\r\n\t\t\tfor ( var j = 0; j < 3; j ++ ) {\r\n\t\r\n\t\t\t\tedge[ 0 ] = face[ keys[ j ] ];\r\n\t\t\t\tedge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];\r\n\t\t\t\tedge.sort( sortFunction );\r\n\t\r\n\t\t\t\tvar key = edge.toString();\r\n\t\r\n\t\t\t\tif ( hash[ key ] === undefined ) {\r\n\t\r\n\t\t\t\t\thash[ key ] = { vert1: edge[ 0 ], vert2: edge[ 1 ], face1: i, face2: undefined };\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\thash[ key ].face2 = i;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar coords = [];\r\n\t\r\n\t\tfor ( var key in hash ) {\r\n\t\r\n\t\t\tvar h = hash[ key ];\r\n\t\r\n\t\t\tif ( h.face2 === undefined || faces[ h.face1 ].normal.dot( faces[ h.face2 ].normal ) <= thresholdDot ) {\r\n\t\r\n\t\t\t\tvar vertex = vertices[ h.vert1 ];\r\n\t\t\t\tcoords.push( vertex.x );\r\n\t\t\t\tcoords.push( vertex.y );\r\n\t\t\t\tcoords.push( vertex.z );\r\n\t\r\n\t\t\t\tvertex = vertices[ h.vert2 ];\r\n\t\t\t\tcoords.push( vertex.x );\r\n\t\t\t\tcoords.push( vertex.y );\r\n\t\t\t\tcoords.push( vertex.z );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array( coords ), 3 ) );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.EdgesGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\n\tTHREE.EdgesGeometry.prototype.constructor = THREE.EdgesGeometry;\r\n\t\r\n\t// File:src/extras/geometries/ExtrudeGeometry.js\r\n\t\r\n\t/**\r\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\r\n\t *\r\n\t * Creates extruded geometry from a path shape.\r\n\t *\r\n\t * parameters = {\r\n\t *\r\n\t *  curveSegments: <int>, // number of points on the curves\r\n\t *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too\r\n\t *  amount: <int>, // Depth to extrude the shape\r\n\t *\r\n\t *  bevelEnabled: <bool>, // turn on bevel\r\n\t *  bevelThickness: <float>, // how deep into the original shape bevel goes\r\n\t *  bevelSize: <float>, // how far from shape outline is bevel\r\n\t *  bevelSegments: <int>, // number of bevel layers\r\n\t *\r\n\t *  extrudePath: <THREE.CurvePath> // 3d spline path to extrude shape along. (creates Frames if .frames aren't defined)\r\n\t *  frames: <THREE.TubeGeometry.FrenetFrames> // containing arrays of tangents, normals, binormals\r\n\t *\r\n\t *  uvGenerator: <Object> // object that provides UV generator functions\r\n\t *\r\n\t * }\r\n\t **/\r\n\t\r\n\tTHREE.ExtrudeGeometry = function ( shapes, options ) {\r\n\t\r\n\t\tif ( typeof( shapes ) === \"undefined\" ) {\r\n\t\r\n\t\t\tshapes = [];\r\n\t\t\treturn;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tTHREE.Geometry.call( this );\r\n\t\r\n\t\tthis.type = 'ExtrudeGeometry';\r\n\t\r\n\t\tshapes = Array.isArray( shapes ) ? shapes : [ shapes ];\r\n\t\r\n\t\tthis.addShapeList( shapes, options );\r\n\t\r\n\t\tthis.computeFaceNormals();\r\n\t\r\n\t\t// can't really use automatic vertex normals\r\n\t\t// as then front and back sides get smoothed too\r\n\t\t// should do separate smoothing just for sides\r\n\t\r\n\t\t//this.computeVertexNormals();\r\n\t\r\n\t\t//console.log( \"took\", ( Date.now() - startTime ) );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.ExtrudeGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\tTHREE.ExtrudeGeometry.prototype.constructor = THREE.ExtrudeGeometry;\r\n\t\r\n\tTHREE.ExtrudeGeometry.prototype.addShapeList = function ( shapes, options ) {\r\n\t\r\n\t\tvar sl = shapes.length;\r\n\t\r\n\t\tfor ( var s = 0; s < sl; s ++ ) {\r\n\t\r\n\t\t\tvar shape = shapes[ s ];\r\n\t\t\tthis.addShape( shape, options );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.ExtrudeGeometry.prototype.addShape = function ( shape, options ) {\r\n\t\r\n\t\tvar amount = options.amount !== undefined ? options.amount : 100;\r\n\t\r\n\t\tvar bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10\r\n\t\tvar bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8\r\n\t\tvar bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;\r\n\t\r\n\t\tvar bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false\r\n\t\r\n\t\tvar curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\r\n\t\r\n\t\tvar steps = options.steps !== undefined ? options.steps : 1;\r\n\t\r\n\t\tvar extrudePath = options.extrudePath;\r\n\t\tvar extrudePts, extrudeByPath = false;\r\n\t\r\n\t\t// Use default WorldUVGenerator if no UV generators are specified.\r\n\t\tvar uvgen = options.UVGenerator !== undefined ? options.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator;\r\n\t\r\n\t\tvar splineTube, binormal, normal, position2;\r\n\t\tif ( extrudePath ) {\r\n\t\r\n\t\t\textrudePts = extrudePath.getSpacedPoints( steps );\r\n\t\r\n\t\t\textrudeByPath = true;\r\n\t\t\tbevelEnabled = false; // bevels not supported for path extrusion\r\n\t\r\n\t\t\t// SETUP TNB variables\r\n\t\r\n\t\t\t// Reuse TNB from TubeGeomtry for now.\r\n\t\t\t// TODO1 - have a .isClosed in spline?\r\n\t\r\n\t\t\tsplineTube = options.frames !== undefined ? options.frames : new THREE.TubeGeometry.FrenetFrames( extrudePath, steps, false );\r\n\t\r\n\t\t\t// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);\r\n\t\r\n\t\t\tbinormal = new THREE.Vector3();\r\n\t\t\tnormal = new THREE.Vector3();\r\n\t\t\tposition2 = new THREE.Vector3();\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Safeguards if bevels are not enabled\r\n\t\r\n\t\tif ( ! bevelEnabled ) {\r\n\t\r\n\t\t\tbevelSegments = 0;\r\n\t\t\tbevelThickness = 0;\r\n\t\t\tbevelSize = 0;\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Variables initialization\r\n\t\r\n\t\tvar ahole, h, hl; // looping of holes\r\n\t\tvar scope = this;\r\n\t\r\n\t\tvar shapesOffset = this.vertices.length;\r\n\t\r\n\t\tvar shapePoints = shape.extractPoints( curveSegments );\r\n\t\r\n\t\tvar vertices = shapePoints.shape;\r\n\t\tvar holes = shapePoints.holes;\r\n\t\r\n\t\tvar reverse = ! THREE.ShapeUtils.isClockWise( vertices );\r\n\t\r\n\t\tif ( reverse ) {\r\n\t\r\n\t\t\tvertices = vertices.reverse();\r\n\t\r\n\t\t\t// Maybe we should also check if holes are in the opposite direction, just to be safe ...\r\n\t\r\n\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\t\r\n\t\t\t\tahole = holes[ h ];\r\n\t\r\n\t\t\t\tif ( THREE.ShapeUtils.isClockWise( ahole ) ) {\r\n\t\r\n\t\t\t\t\tholes[ h ] = ahole.reverse();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t\tvar faces = THREE.ShapeUtils.triangulateShape( vertices, holes );\r\n\t\r\n\t\t/* Vertices */\r\n\t\r\n\t\tvar contour = vertices; // vertices has all points but contour has only points of circumference\r\n\t\r\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\t\r\n\t\t\tahole = holes[ h ];\r\n\t\r\n\t\t\tvertices = vertices.concat( ahole );\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t\tfunction scalePt2 ( pt, vec, size ) {\r\n\t\r\n\t\t\tif ( ! vec ) console.error( \"THREE.ExtrudeGeometry: vec does not exist\" );\r\n\t\r\n\t\t\treturn vec.clone().multiplyScalar( size ).add( pt );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar b, bs, t, z,\r\n\t\t\tvert, vlen = vertices.length,\r\n\t\t\tface, flen = faces.length;\r\n\t\r\n\t\r\n\t\t// Find directions for point movement\r\n\t\r\n\t\r\n\t\tfunction getBevelVec( inPt, inPrev, inNext ) {\r\n\t\r\n\t\t\t// computes for inPt the corresponding point inPt' on a new contour\r\n\t\t\t//   shifted by 1 unit (length of normalized vector) to the left\r\n\t\t\t// if we walk along contour clockwise, this new contour is outside the old one\r\n\t\t\t//\r\n\t\t\t// inPt' is the intersection of the two lines parallel to the two\r\n\t\t\t//  adjacent edges of inPt at a distance of 1 unit on the left side.\r\n\t\r\n\t\t\tvar v_trans_x, v_trans_y, shrink_by = 1;\t\t// resulting translation vector for inPt\r\n\t\r\n\t\t\t// good reading for geometry algorithms (here: line-line intersection)\r\n\t\t\t// http://geomalgorithms.com/a05-_intersect-1.html\r\n\t\r\n\t\t\tvar v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;\r\n\t\t\tvar v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;\r\n\t\r\n\t\t\tvar v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );\r\n\t\r\n\t\t\t// check for collinear edges\r\n\t\t\tvar collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );\r\n\t\r\n\t\t\tif ( Math.abs( collinear0 ) > Number.EPSILON ) {\r\n\t\r\n\t\t\t\t// not collinear\r\n\t\r\n\t\t\t\t// length of vectors for normalizing\r\n\t\r\n\t\t\t\tvar v_prev_len = Math.sqrt( v_prev_lensq );\r\n\t\t\t\tvar v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );\r\n\t\r\n\t\t\t\t// shift adjacent points by unit vectors to the left\r\n\t\r\n\t\t\t\tvar ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );\r\n\t\t\t\tvar ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );\r\n\t\r\n\t\t\t\tvar ptNextShift_x = ( inNext.x - v_next_y / v_next_len );\r\n\t\t\t\tvar ptNextShift_y = ( inNext.y + v_next_x / v_next_len );\r\n\t\r\n\t\t\t\t// scaling factor for v_prev to intersection point\r\n\t\r\n\t\t\t\tvar sf = (  ( ptNextShift_x - ptPrevShift_x ) * v_next_y -\r\n\t\t\t\t\t\t\t( ptNextShift_y - ptPrevShift_y ) * v_next_x    ) /\r\n\t\t\t\t\t\t  ( v_prev_x * v_next_y - v_prev_y * v_next_x );\r\n\t\r\n\t\t\t\t// vector from inPt to intersection point\r\n\t\r\n\t\t\t\tv_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );\r\n\t\t\t\tv_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );\r\n\t\r\n\t\t\t\t// Don't normalize!, otherwise sharp corners become ugly\r\n\t\t\t\t//  but prevent crazy spikes\r\n\t\t\t\tvar v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );\r\n\t\t\t\tif ( v_trans_lensq <= 2 ) {\r\n\t\r\n\t\t\t\t\treturn\tnew THREE.Vector2( v_trans_x, v_trans_y );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tshrink_by = Math.sqrt( v_trans_lensq / 2 );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\t// handle special case of collinear edges\r\n\t\r\n\t\t\t\tvar direction_eq = false;\t\t// assumes: opposite\r\n\t\t\t\tif ( v_prev_x > Number.EPSILON ) {\r\n\t\r\n\t\t\t\t\tif ( v_next_x > Number.EPSILON ) {\r\n\t\r\n\t\t\t\t\t\tdirection_eq = true;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tif ( v_prev_x < - Number.EPSILON ) {\r\n\t\r\n\t\t\t\t\t\tif ( v_next_x < - Number.EPSILON ) {\r\n\t\r\n\t\t\t\t\t\t\tdirection_eq = true;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tif ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {\r\n\t\r\n\t\t\t\t\t\t\tdirection_eq = true;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( direction_eq ) {\r\n\t\r\n\t\t\t\t\t// console.log(\"Warning: lines are a straight sequence\");\r\n\t\t\t\t\tv_trans_x = - v_prev_y;\r\n\t\t\t\t\tv_trans_y =  v_prev_x;\r\n\t\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t// console.log(\"Warning: lines are a straight spike\");\r\n\t\t\t\t\tv_trans_x = v_prev_x;\r\n\t\t\t\t\tv_trans_y = v_prev_y;\r\n\t\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq / 2 );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn\tnew THREE.Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t\tvar contourMovements = [];\r\n\t\r\n\t\tfor ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\r\n\t\r\n\t\t\tif ( j === il ) j = 0;\r\n\t\t\tif ( k === il ) k = 0;\r\n\t\r\n\t\t\t//  (j)---(i)---(k)\r\n\t\t\t// console.log('i,j,k', i, j , k)\r\n\t\r\n\t\t\tcontourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();\r\n\t\r\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\t\r\n\t\t\tahole = holes[ h ];\r\n\t\r\n\t\t\toneHoleMovements = [];\r\n\t\r\n\t\t\tfor ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\r\n\t\r\n\t\t\t\tif ( j === il ) j = 0;\r\n\t\t\t\tif ( k === il ) k = 0;\r\n\t\r\n\t\t\t\t//  (j)---(i)---(k)\r\n\t\t\t\toneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tholesMovements.push( oneHoleMovements );\r\n\t\t\tverticesMovements = verticesMovements.concat( oneHoleMovements );\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t\t// Loop bevelSegments, 1 for the front, 1 for the back\r\n\t\r\n\t\tfor ( b = 0; b < bevelSegments; b ++ ) {\r\n\t\r\n\t\t\t//for ( b = bevelSegments; b > 0; b -- ) {\r\n\t\r\n\t\t\tt = b / bevelSegments;\r\n\t\t\tz = bevelThickness * ( 1 - t );\r\n\t\r\n\t\t\t//z = bevelThickness * t;\r\n\t\t\tbs = bevelSize * ( Math.sin ( t * Math.PI / 2 ) ); // curved\r\n\t\t\t//bs = bevelSize * t; // linear\r\n\t\r\n\t\t\t// contract shape\r\n\t\r\n\t\t\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\r\n\t\r\n\t\t\t\tv( vert.x, vert.y,  - z );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// expand holes\r\n\t\r\n\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\t\r\n\t\t\t\tahole = holes[ h ];\r\n\t\t\t\toneHoleMovements = holesMovements[ h ];\r\n\t\r\n\t\t\t\tfor ( i = 0, il = ahole.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\r\n\t\r\n\t\t\t\t\tv( vert.x, vert.y,  - z );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tbs = bevelSize;\r\n\t\r\n\t\t// Back facing vertices\r\n\t\r\n\t\tfor ( i = 0; i < vlen; i ++ ) {\r\n\t\r\n\t\t\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\r\n\t\r\n\t\t\tif ( ! extrudeByPath ) {\r\n\t\r\n\t\t\t\tv( vert.x, vert.y, 0 );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\t// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );\r\n\t\r\n\t\t\t\tnormal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );\r\n\t\t\t\tbinormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );\r\n\t\r\n\t\t\t\tposition2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );\r\n\t\r\n\t\t\t\tv( position2.x, position2.y, position2.z );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Add stepped vertices...\r\n\t\t// Including front facing vertices\r\n\t\r\n\t\tvar s;\r\n\t\r\n\t\tfor ( s = 1; s <= steps; s ++ ) {\r\n\t\r\n\t\t\tfor ( i = 0; i < vlen; i ++ ) {\r\n\t\r\n\t\t\t\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\r\n\t\r\n\t\t\t\tif ( ! extrudeByPath ) {\r\n\t\r\n\t\t\t\t\tv( vert.x, vert.y, amount / steps * s );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );\r\n\t\r\n\t\t\t\t\tnormal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );\r\n\t\t\t\t\tbinormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );\r\n\t\r\n\t\t\t\t\tposition2.copy( extrudePts[ s ] ).add( normal ).add( binormal );\r\n\t\r\n\t\t\t\t\tv( position2.x, position2.y, position2.z );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t\t// Add bevel segments planes\r\n\t\r\n\t\t//for ( b = 1; b <= bevelSegments; b ++ ) {\r\n\t\tfor ( b = bevelSegments - 1; b >= 0; b -- ) {\r\n\t\r\n\t\t\tt = b / bevelSegments;\r\n\t\t\tz = bevelThickness * ( 1 - t );\r\n\t\t\t//bs = bevelSize * ( 1-Math.sin ( ( 1 - t ) * Math.PI/2 ) );\r\n\t\t\tbs = bevelSize * Math.sin ( t * Math.PI / 2 );\r\n\t\r\n\t\t\t// contract shape\r\n\t\r\n\t\t\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\r\n\t\t\t\tv( vert.x, vert.y,  amount + z );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// expand holes\r\n\t\r\n\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\t\r\n\t\t\t\tahole = holes[ h ];\r\n\t\t\t\toneHoleMovements = holesMovements[ h ];\r\n\t\r\n\t\t\t\tfor ( i = 0, il = ahole.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\r\n\t\r\n\t\t\t\t\tif ( ! extrudeByPath ) {\r\n\t\r\n\t\t\t\t\t\tv( vert.x, vert.y,  amount + z );\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tv( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\t/* Faces */\r\n\t\r\n\t\t// Top and bottom faces\r\n\t\r\n\t\tbuildLidFaces();\r\n\t\r\n\t\t// Sides faces\r\n\t\r\n\t\tbuildSideFaces();\r\n\t\r\n\t\r\n\t\t/////  Internal functions\r\n\t\r\n\t\tfunction buildLidFaces() {\r\n\t\r\n\t\t\tif ( bevelEnabled ) {\r\n\t\r\n\t\t\t\tvar layer = 0; // steps + 1\r\n\t\t\t\tvar offset = vlen * layer;\r\n\t\r\n\t\t\t\t// Bottom faces\r\n\t\r\n\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\r\n\t\r\n\t\t\t\t\tface = faces[ i ];\r\n\t\t\t\t\tf3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tlayer = steps + bevelSegments * 2;\r\n\t\t\t\toffset = vlen * layer;\r\n\t\r\n\t\t\t\t// Top faces\r\n\t\r\n\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\r\n\t\r\n\t\t\t\t\tface = faces[ i ];\r\n\t\t\t\t\tf3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\t// Bottom faces\r\n\t\r\n\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\r\n\t\r\n\t\t\t\t\tface = faces[ i ];\r\n\t\t\t\t\tf3( face[ 2 ], face[ 1 ], face[ 0 ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// Top faces\r\n\t\r\n\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\r\n\t\r\n\t\t\t\t\tface = faces[ i ];\r\n\t\t\t\t\tf3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Create faces for the z-sides of the shape\r\n\t\r\n\t\tfunction buildSideFaces() {\r\n\t\r\n\t\t\tvar layeroffset = 0;\r\n\t\t\tsidewalls( contour, layeroffset );\r\n\t\t\tlayeroffset += contour.length;\r\n\t\r\n\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\t\r\n\t\t\t\tahole = holes[ h ];\r\n\t\t\t\tsidewalls( ahole, layeroffset );\r\n\t\r\n\t\t\t\t//, true\r\n\t\t\t\tlayeroffset += ahole.length;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction sidewalls( contour, layeroffset ) {\r\n\t\r\n\t\t\tvar j, k;\r\n\t\t\ti = contour.length;\r\n\t\r\n\t\t\twhile ( -- i >= 0 ) {\r\n\t\r\n\t\t\t\tj = i;\r\n\t\t\t\tk = i - 1;\r\n\t\t\t\tif ( k < 0 ) k = contour.length - 1;\r\n\t\r\n\t\t\t\t//console.log('b', i,j, i-1, k,vertices.length);\r\n\t\r\n\t\t\t\tvar s = 0, sl = steps  + bevelSegments * 2;\r\n\t\r\n\t\t\t\tfor ( s = 0; s < sl; s ++ ) {\r\n\t\r\n\t\t\t\t\tvar slen1 = vlen * s;\r\n\t\t\t\t\tvar slen2 = vlen * ( s + 1 );\r\n\t\r\n\t\t\t\t\tvar a = layeroffset + j + slen1,\r\n\t\t\t\t\t\tb = layeroffset + k + slen1,\r\n\t\t\t\t\t\tc = layeroffset + k + slen2,\r\n\t\t\t\t\t\td = layeroffset + j + slen2;\r\n\t\r\n\t\t\t\t\tf4( a, b, c, d, contour, s, sl, j, k );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t\tfunction v( x, y, z ) {\r\n\t\r\n\t\t\tscope.vertices.push( new THREE.Vector3( x, y, z ) );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction f3( a, b, c ) {\r\n\t\r\n\t\t\ta += shapesOffset;\r\n\t\t\tb += shapesOffset;\r\n\t\t\tc += shapesOffset;\r\n\t\r\n\t\t\tscope.faces.push( new THREE.Face3( a, b, c, null, null, 0 ) );\r\n\t\r\n\t\t\tvar uvs = uvgen.generateTopUV( scope, a, b, c );\r\n\t\r\n\t\t\tscope.faceVertexUvs[ 0 ].push( uvs );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {\r\n\t\r\n\t\t\ta += shapesOffset;\r\n\t\t\tb += shapesOffset;\r\n\t\t\tc += shapesOffset;\r\n\t\t\td += shapesOffset;\r\n\t\r\n\t\t\tscope.faces.push( new THREE.Face3( a, b, d, null, null, 1 ) );\r\n\t\t\tscope.faces.push( new THREE.Face3( b, c, d, null, null, 1 ) );\r\n\t\r\n\t\t\tvar uvs = uvgen.generateSideWallUV( scope, a, b, c, d );\r\n\t\r\n\t\t\tscope.faceVertexUvs[ 0 ].push( [ uvs[ 0 ], uvs[ 1 ], uvs[ 3 ] ] );\r\n\t\t\tscope.faceVertexUvs[ 0 ].push( [ uvs[ 1 ], uvs[ 2 ], uvs[ 3 ] ] );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.ExtrudeGeometry.WorldUVGenerator = {\r\n\t\r\n\t\tgenerateTopUV: function ( geometry, indexA, indexB, indexC ) {\r\n\t\r\n\t\t\tvar vertices = geometry.vertices;\r\n\t\r\n\t\t\tvar a = vertices[ indexA ];\r\n\t\t\tvar b = vertices[ indexB ];\r\n\t\t\tvar c = vertices[ indexC ];\r\n\t\r\n\t\t\treturn [\r\n\t\t\t\tnew THREE.Vector2( a.x, a.y ),\r\n\t\t\t\tnew THREE.Vector2( b.x, b.y ),\r\n\t\t\t\tnew THREE.Vector2( c.x, c.y )\r\n\t\t\t];\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgenerateSideWallUV: function ( geometry, indexA, indexB, indexC, indexD ) {\r\n\t\r\n\t\t\tvar vertices = geometry.vertices;\r\n\t\r\n\t\t\tvar a = vertices[ indexA ];\r\n\t\t\tvar b = vertices[ indexB ];\r\n\t\t\tvar c = vertices[ indexC ];\r\n\t\t\tvar d = vertices[ indexD ];\r\n\t\r\n\t\t\tif ( Math.abs( a.y - b.y ) < 0.01 ) {\r\n\t\r\n\t\t\t\treturn [\r\n\t\t\t\t\tnew THREE.Vector2( a.x, 1 - a.z ),\r\n\t\t\t\t\tnew THREE.Vector2( b.x, 1 - b.z ),\r\n\t\t\t\t\tnew THREE.Vector2( c.x, 1 - c.z ),\r\n\t\t\t\t\tnew THREE.Vector2( d.x, 1 - d.z )\r\n\t\t\t\t];\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\treturn [\r\n\t\t\t\t\tnew THREE.Vector2( a.y, 1 - a.z ),\r\n\t\t\t\t\tnew THREE.Vector2( b.y, 1 - b.z ),\r\n\t\t\t\t\tnew THREE.Vector2( c.y, 1 - c.z ),\r\n\t\t\t\t\tnew THREE.Vector2( d.y, 1 - d.z )\r\n\t\t\t\t];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t};\r\n\t\r\n\t// File:src/extras/geometries/ShapeGeometry.js\r\n\t\r\n\t/**\r\n\t * @author jonobr1 / http://jonobr1.com\r\n\t *\r\n\t * Creates a one-sided polygonal geometry from a path shape. Similar to\r\n\t * ExtrudeGeometry.\r\n\t *\r\n\t * parameters = {\r\n\t *\r\n\t *\tcurveSegments: <int>, // number of points on the curves. NOT USED AT THE MOMENT.\r\n\t *\r\n\t *\tmaterial: <int> // material index for front and back faces\r\n\t *\tuvGenerator: <Object> // object that provides UV generator functions\r\n\t *\r\n\t * }\r\n\t **/\r\n\t\r\n\tTHREE.ShapeGeometry = function ( shapes, options ) {\r\n\t\r\n\t\tTHREE.Geometry.call( this );\r\n\t\r\n\t\tthis.type = 'ShapeGeometry';\r\n\t\r\n\t\tif ( Array.isArray( shapes ) === false ) shapes = [ shapes ];\r\n\t\r\n\t\tthis.addShapeList( shapes, options );\r\n\t\r\n\t\tthis.computeFaceNormals();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.ShapeGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\tTHREE.ShapeGeometry.prototype.constructor = THREE.ShapeGeometry;\r\n\t\r\n\t/**\r\n\t * Add an array of shapes to THREE.ShapeGeometry.\r\n\t */\r\n\tTHREE.ShapeGeometry.prototype.addShapeList = function ( shapes, options ) {\r\n\t\r\n\t\tfor ( var i = 0, l = shapes.length; i < l; i ++ ) {\r\n\t\r\n\t\t\tthis.addShape( shapes[ i ], options );\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn this;\r\n\t\r\n\t};\r\n\t\r\n\t/**\r\n\t * Adds a shape to THREE.ShapeGeometry, based on THREE.ExtrudeGeometry.\r\n\t */\r\n\tTHREE.ShapeGeometry.prototype.addShape = function ( shape, options ) {\r\n\t\r\n\t\tif ( options === undefined ) options = {};\r\n\t\tvar curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\r\n\t\r\n\t\tvar material = options.material;\r\n\t\tvar uvgen = options.UVGenerator === undefined ? THREE.ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;\r\n\t\r\n\t\t//\r\n\t\r\n\t\tvar i, l, hole;\r\n\t\r\n\t\tvar shapesOffset = this.vertices.length;\r\n\t\tvar shapePoints = shape.extractPoints( curveSegments );\r\n\t\r\n\t\tvar vertices = shapePoints.shape;\r\n\t\tvar holes = shapePoints.holes;\r\n\t\r\n\t\tvar reverse = ! THREE.ShapeUtils.isClockWise( vertices );\r\n\t\r\n\t\tif ( reverse ) {\r\n\t\r\n\t\t\tvertices = vertices.reverse();\r\n\t\r\n\t\t\t// Maybe we should also check if holes are in the opposite direction, just to be safe...\r\n\t\r\n\t\t\tfor ( i = 0, l = holes.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\thole = holes[ i ];\r\n\t\r\n\t\t\t\tif ( THREE.ShapeUtils.isClockWise( hole ) ) {\r\n\t\r\n\t\t\t\t\tholes[ i ] = hole.reverse();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treverse = false;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar faces = THREE.ShapeUtils.triangulateShape( vertices, holes );\r\n\t\r\n\t\t// Vertices\r\n\t\r\n\t\tfor ( i = 0, l = holes.length; i < l; i ++ ) {\r\n\t\r\n\t\t\thole = holes[ i ];\r\n\t\t\tvertices = vertices.concat( hole );\r\n\t\r\n\t\t}\r\n\t\r\n\t\t//\r\n\t\r\n\t\tvar vert, vlen = vertices.length;\r\n\t\tvar face, flen = faces.length;\r\n\t\r\n\t\tfor ( i = 0; i < vlen; i ++ ) {\r\n\t\r\n\t\t\tvert = vertices[ i ];\r\n\t\r\n\t\t\tthis.vertices.push( new THREE.Vector3( vert.x, vert.y, 0 ) );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfor ( i = 0; i < flen; i ++ ) {\r\n\t\r\n\t\t\tface = faces[ i ];\r\n\t\r\n\t\t\tvar a = face[ 0 ] + shapesOffset;\r\n\t\t\tvar b = face[ 1 ] + shapesOffset;\r\n\t\t\tvar c = face[ 2 ] + shapesOffset;\r\n\t\r\n\t\t\tthis.faces.push( new THREE.Face3( a, b, c, null, null, material ) );\r\n\t\t\tthis.faceVertexUvs[ 0 ].push( uvgen.generateTopUV( this, a, b, c ) );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/geometries/LatheBufferGeometry.js\r\n\t\r\n\t/**\r\n\t * @author Mugen87 / https://github.com/Mugen87\r\n\t */\r\n\t\r\n\t // points - to create a closed torus, one must use a set of points\r\n\t //    like so: [ a, b, c, d, a ], see first is the same as last.\r\n\t // segments - the number of circumference segments to create\r\n\t // phiStart - the starting radian\r\n\t // phiLength - the radian (0 to 2PI) range of the lathed section\r\n\t //    2PI is a closed lathe, less than 2PI is a portion.\r\n\t\r\n\tTHREE.LatheBufferGeometry = function ( points, segments, phiStart, phiLength ) {\r\n\t\r\n\t\tTHREE.BufferGeometry.call( this );\r\n\t\r\n\t\tthis.type = 'LatheBufferGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tpoints: points,\r\n\t\t\tsegments: segments,\r\n\t\t\tphiStart: phiStart,\r\n\t\t\tphiLength: phiLength\r\n\t\t};\r\n\t\r\n\t\tsegments = Math.floor( segments ) || 12;\r\n\t\tphiStart = phiStart || 0;\r\n\t\tphiLength = phiLength || Math.PI * 2;\r\n\t\r\n\t\t// clamp phiLength so it's in range of [ 0, 2PI ]\r\n\t\tphiLength = THREE.Math.clamp( phiLength, 0, Math.PI * 2 );\r\n\t\r\n\t\t// these are used to calculate buffer length\r\n\t\tvar vertexCount = ( segments + 1 ) * points.length;\r\n\t\tvar indexCount = segments * points.length * 2 * 3;\r\n\t\r\n\t\t// buffers\r\n\t\tvar indices = new THREE.BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );\r\n\t\tvar vertices = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\r\n\t\tvar uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\r\n\t\r\n\t\t// helper variables\r\n\t\tvar index = 0, indexOffset = 0, base;\r\n\t\tvar inversePointLength = 1.0 / ( points.length - 1 );\r\n\t\tvar inverseSegments = 1.0 / segments;\r\n\t\tvar vertex = new THREE.Vector3();\r\n\t\tvar uv = new THREE.Vector2();\r\n\t\tvar i, j;\r\n\t\r\n\t\t// generate vertices and uvs\r\n\t\r\n\t\tfor ( i = 0; i <= segments; i ++ ) {\r\n\t\r\n\t\t\tvar phi = phiStart + i * inverseSegments * phiLength;\r\n\t\r\n\t\t\tvar sin = Math.sin( phi );\r\n\t\t\tvar cos = Math.cos( phi );\r\n\t\r\n\t\t\tfor ( j = 0; j <= ( points.length - 1 ); j ++ ) {\r\n\t\r\n\t\t\t\t// vertex\r\n\t\t\t\tvertex.x = points[ j ].x * sin;\r\n\t\t\t\tvertex.y = points[ j ].y;\r\n\t\t\t\tvertex.z = points[ j ].x * cos;\r\n\t\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\r\n\t\r\n\t\t\t\t// uv\r\n\t\t\t\tuv.x = i / segments;\r\n\t\t\t\tuv.y = j / ( points.length - 1 );\r\n\t\t\t\tuvs.setXY( index, uv.x, uv.y );\r\n\t\r\n\t\t\t\t// increase index\r\n\t\t\t\tindex ++;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// generate indices\r\n\t\r\n\t\tfor ( i = 0; i < segments; i ++ ) {\r\n\t\r\n\t\t\tfor ( j = 0; j < ( points.length - 1 ); j ++ ) {\r\n\t\r\n\t\t\t\tbase = j + i * points.length;\r\n\t\r\n\t\t\t\t// indices\r\n\t\t\t\tvar a = base;\r\n\t\t\t\tvar b = base + points.length;\r\n\t\t\t\tvar c = base + points.length + 1;\r\n\t\t\t\tvar d = base + 1;\r\n\t\r\n\t\t\t\t// face one\r\n\t\t\t\tindices.setX( indexOffset, a ); indexOffset++;\r\n\t\t\t\tindices.setX( indexOffset, b ); indexOffset++;\r\n\t\t\t\tindices.setX( indexOffset, d ); indexOffset++;\r\n\t\r\n\t\t\t\t// face two\r\n\t\t\t\tindices.setX( indexOffset, b ); indexOffset++;\r\n\t\t\t\tindices.setX( indexOffset, c ); indexOffset++;\r\n\t\t\t\tindices.setX( indexOffset, d ); indexOffset++;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// build geometry\r\n\t\r\n\t\tthis.setIndex( indices );\r\n\t\tthis.addAttribute( 'position', vertices );\r\n\t\tthis.addAttribute( 'uv', uvs );\r\n\t\r\n\t\t// generate normals\r\n\t\r\n\t\tthis.computeVertexNormals();\r\n\t\r\n\t\t// if the geometry is closed, we need to average the normals along the seam.\r\n\t\t// because the corresponding vertices are identical (but still have different UVs).\r\n\t\r\n\t\tif( phiLength === Math.PI * 2 ) {\r\n\t\r\n\t\t\tvar normals = this.attributes.normal.array;\r\n\t\t\tvar n1 = new THREE.Vector3();\r\n\t\t\tvar n2 = new THREE.Vector3();\r\n\t\t\tvar n = new THREE.Vector3();\r\n\t\r\n\t\t\t// this is the buffer offset for the last line of vertices\r\n\t\t\tbase = segments * points.length * 3;\r\n\t\r\n\t\t\tfor( i = 0, j = 0; i < points.length; i ++, j += 3 ) {\r\n\t\r\n\t\t\t\t// select the normal of the vertex in the first line\r\n\t\t\t\tn1.x = normals[ j + 0 ];\r\n\t\t\t\tn1.y = normals[ j + 1 ];\r\n\t\t\t\tn1.z = normals[ j + 2 ];\r\n\t\r\n\t\t\t\t// select the normal of the vertex in the last line\r\n\t\t\t\tn2.x = normals[ base + j + 0 ];\r\n\t\t\t\tn2.y = normals[ base + j + 1 ];\r\n\t\t\t\tn2.z = normals[ base + j + 2 ];\r\n\t\r\n\t\t\t\t// average normals\r\n\t\t\t\tn.addVectors( n1, n2 ).normalize();\r\n\t\r\n\t\t\t\t// assign the new values to both normals\r\n\t\t\t\tnormals[ j + 0 ] = normals[ base + j + 0 ] = n.x;\r\n\t\t\t\tnormals[ j + 1 ] = normals[ base + j + 1 ] = n.y;\r\n\t\t\t\tnormals[ j + 2 ] = normals[ base + j + 2 ] = n.z;\r\n\t\r\n\t\t\t} // next row\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.LatheBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\n\tTHREE.LatheBufferGeometry.prototype.constructor = THREE.LatheBufferGeometry;\r\n\t\r\n\t// File:src/extras/geometries/LatheGeometry.js\r\n\t\r\n\t/**\r\n\t * @author astrodud / http://astrodud.isgreat.org/\r\n\t * @author zz85 / https://github.com/zz85\r\n\t * @author bhouston / http://clara.io\r\n\t */\r\n\t\r\n\t// points - to create a closed torus, one must use a set of points\r\n\t//    like so: [ a, b, c, d, a ], see first is the same as last.\r\n\t// segments - the number of circumference segments to create\r\n\t// phiStart - the starting radian\r\n\t// phiLength - the radian (0 to 2PI) range of the lathed section\r\n\t//    2PI is a closed lathe, less than 2PI is a portion.\r\n\t\r\n\tTHREE.LatheGeometry = function ( points, segments, phiStart, phiLength ) {\r\n\t\r\n\t\tTHREE.Geometry.call( this );\r\n\t\r\n\t\tthis.type = 'LatheGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tpoints: points,\r\n\t\t\tsegments: segments,\r\n\t\t\tphiStart: phiStart,\r\n\t\t\tphiLength: phiLength\r\n\t\t};\r\n\t\r\n\t\tthis.fromBufferGeometry( new THREE.LatheBufferGeometry( points, segments, phiStart, phiLength ) );\r\n\t\tthis.mergeVertices();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.LatheGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\tTHREE.LatheGeometry.prototype.constructor = THREE.LatheGeometry;\r\n\t\r\n\t// File:src/extras/geometries/PlaneGeometry.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as\r\n\t */\r\n\t\r\n\tTHREE.PlaneGeometry = function ( width, height, widthSegments, heightSegments ) {\r\n\t\r\n\t\tTHREE.Geometry.call( this );\r\n\t\r\n\t\tthis.type = 'PlaneGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\twidth: width,\r\n\t\t\theight: height,\r\n\t\t\twidthSegments: widthSegments,\r\n\t\t\theightSegments: heightSegments\r\n\t\t};\r\n\t\r\n\t\tthis.fromBufferGeometry( new THREE.PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.PlaneGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\tTHREE.PlaneGeometry.prototype.constructor = THREE.PlaneGeometry;\r\n\t\r\n\t// File:src/extras/geometries/PlaneBufferGeometry.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as\r\n\t */\r\n\t\r\n\tTHREE.PlaneBufferGeometry = function ( width, height, widthSegments, heightSegments ) {\r\n\t\r\n\t\tTHREE.BufferGeometry.call( this );\r\n\t\r\n\t\tthis.type = 'PlaneBufferGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\twidth: width,\r\n\t\t\theight: height,\r\n\t\t\twidthSegments: widthSegments,\r\n\t\t\theightSegments: heightSegments\r\n\t\t};\r\n\t\r\n\t\tvar width_half = width / 2;\r\n\t\tvar height_half = height / 2;\r\n\t\r\n\t\tvar gridX = Math.floor( widthSegments ) || 1;\r\n\t\tvar gridY = Math.floor( heightSegments ) || 1;\r\n\t\r\n\t\tvar gridX1 = gridX + 1;\r\n\t\tvar gridY1 = gridY + 1;\r\n\t\r\n\t\tvar segment_width = width / gridX;\r\n\t\tvar segment_height = height / gridY;\r\n\t\r\n\t\tvar vertices = new Float32Array( gridX1 * gridY1 * 3 );\r\n\t\tvar normals = new Float32Array( gridX1 * gridY1 * 3 );\r\n\t\tvar uvs = new Float32Array( gridX1 * gridY1 * 2 );\r\n\t\r\n\t\tvar offset = 0;\r\n\t\tvar offset2 = 0;\r\n\t\r\n\t\tfor ( var iy = 0; iy < gridY1; iy ++ ) {\r\n\t\r\n\t\t\tvar y = iy * segment_height - height_half;\r\n\t\r\n\t\t\tfor ( var ix = 0; ix < gridX1; ix ++ ) {\r\n\t\r\n\t\t\t\tvar x = ix * segment_width - width_half;\r\n\t\r\n\t\t\t\tvertices[ offset ] = x;\r\n\t\t\t\tvertices[ offset + 1 ] = - y;\r\n\t\r\n\t\t\t\tnormals[ offset + 2 ] = 1;\r\n\t\r\n\t\t\t\tuvs[ offset2 ] = ix / gridX;\r\n\t\t\t\tuvs[ offset2 + 1 ] = 1 - ( iy / gridY );\r\n\t\r\n\t\t\t\toffset += 3;\r\n\t\t\t\toffset2 += 2;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\toffset = 0;\r\n\t\r\n\t\tvar indices = new ( ( vertices.length / 3 ) > 65535 ? Uint32Array : Uint16Array )( gridX * gridY * 6 );\r\n\t\r\n\t\tfor ( var iy = 0; iy < gridY; iy ++ ) {\r\n\t\r\n\t\t\tfor ( var ix = 0; ix < gridX; ix ++ ) {\r\n\t\r\n\t\t\t\tvar a = ix + gridX1 * iy;\r\n\t\t\t\tvar b = ix + gridX1 * ( iy + 1 );\r\n\t\t\t\tvar c = ( ix + 1 ) + gridX1 * ( iy + 1 );\r\n\t\t\t\tvar d = ( ix + 1 ) + gridX1 * iy;\r\n\t\r\n\t\t\t\tindices[ offset ] = a;\r\n\t\t\t\tindices[ offset + 1 ] = b;\r\n\t\t\t\tindices[ offset + 2 ] = d;\r\n\t\r\n\t\t\t\tindices[ offset + 3 ] = b;\r\n\t\t\t\tindices[ offset + 4 ] = c;\r\n\t\t\t\tindices[ offset + 5 ] = d;\r\n\t\r\n\t\t\t\toffset += 6;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.setIndex( new THREE.BufferAttribute( indices, 1 ) );\r\n\t\tthis.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\r\n\t\tthis.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );\r\n\t\tthis.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.PlaneBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\n\tTHREE.PlaneBufferGeometry.prototype.constructor = THREE.PlaneBufferGeometry;\r\n\t\r\n\t// File:src/extras/geometries/RingBufferGeometry.js\r\n\t\r\n\t/**\r\n\t * @author Mugen87 / https://github.com/Mugen87\r\n\t */\r\n\t\r\n\tTHREE.RingBufferGeometry = function ( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {\r\n\t\r\n\t\tTHREE.BufferGeometry.call( this );\r\n\t\r\n\t\tthis.type = 'RingBufferGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tinnerRadius: innerRadius,\r\n\t\t\touterRadius: outerRadius,\r\n\t\t\tthetaSegments: thetaSegments,\r\n\t\t\tphiSegments: phiSegments,\r\n\t\t\tthetaStart: thetaStart,\r\n\t\t\tthetaLength: thetaLength\r\n\t\t};\r\n\t\r\n\t\tinnerRadius = innerRadius || 20;\r\n\t\touterRadius = outerRadius || 50;\r\n\t\r\n\t\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\r\n\t\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\r\n\t\r\n\t\tthetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;\r\n\t\tphiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 1;\r\n\t\r\n\t\t// these are used to calculate buffer length\r\n\t\tvar vertexCount = ( thetaSegments + 1 ) * ( phiSegments + 1 );\r\n\t\tvar indexCount = thetaSegments * phiSegments * 2 * 3;\r\n\t\r\n\t\t// buffers\r\n\t\tvar indices = new THREE.BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );\r\n\t\tvar vertices = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\r\n\t\tvar normals = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\r\n\t\tvar uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\r\n\t\r\n\t\t// some helper variables\r\n\t\tvar index = 0, indexOffset = 0, segment;\r\n\t\tvar radius = innerRadius;\r\n\t\tvar radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );\r\n\t\tvar vertex = new THREE.Vector3();\r\n\t\tvar uv = new THREE.Vector2();\r\n\t\tvar j, i;\r\n\t\r\n\t\t// generate vertices, normals and uvs\r\n\t\r\n\t\t// values are generate from the inside of the ring to the outside\r\n\t\r\n\t\tfor ( j = 0; j <= phiSegments; j ++ ) {\r\n\t\r\n\t\t\tfor ( i = 0; i <= thetaSegments; i ++ ) {\r\n\t\r\n\t\t\t\tsegment = thetaStart + i / thetaSegments * thetaLength;\r\n\t\r\n\t\t\t\t// vertex\r\n\t\t\t\tvertex.x = radius * Math.cos( segment );\r\n\t\t\t\tvertex.y = radius * Math.sin( segment );\r\n\t\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\r\n\t\r\n\t\t\t\t// normal\r\n\t\t\t\tnormals.setXYZ( index, 0, 0, 1 );\r\n\t\r\n\t\t\t\t// uv\r\n\t\t\t\tuv.x = ( vertex.x / outerRadius + 1 ) / 2;\r\n\t\t\t\tuv.y = ( vertex.y / outerRadius + 1 ) / 2;\r\n\t\t\t\tuvs.setXY( index, uv.x, uv.y );\r\n\t\r\n\t\t\t\t// increase index\r\n\t\t\t\tindex++;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// increase the radius for next row of vertices\r\n\t\t\tradius += radiusStep;\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// generate indices\r\n\t\r\n\t\tfor ( j = 0; j < phiSegments; j ++ ) {\r\n\t\r\n\t\t\tvar thetaSegmentLevel = j * ( thetaSegments + 1 );\r\n\t\r\n\t\t\tfor ( i = 0; i < thetaSegments; i ++ ) {\r\n\t\r\n\t\t\t\tsegment = i + thetaSegmentLevel;\r\n\t\r\n\t\t\t\t// indices\r\n\t\t\t\tvar a = segment;\r\n\t\t\t\tvar b = segment + thetaSegments + 1;\r\n\t\t\t\tvar c = segment + thetaSegments + 2;\r\n\t\t\t\tvar d = segment + 1;\r\n\t\r\n\t\t\t\t// face one\r\n\t\t\t\tindices.setX( indexOffset, a ); indexOffset++;\r\n\t\t\t\tindices.setX( indexOffset, b ); indexOffset++;\r\n\t\t\t\tindices.setX( indexOffset, c ); indexOffset++;\r\n\t\r\n\t\t\t\t// face two\r\n\t\t\t\tindices.setX( indexOffset, a ); indexOffset++;\r\n\t\t\t\tindices.setX( indexOffset, c ); indexOffset++;\r\n\t\t\t\tindices.setX( indexOffset, d ); indexOffset++;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// build geometry\r\n\t\r\n\t\tthis.setIndex( indices );\r\n\t\tthis.addAttribute( 'position', vertices );\r\n\t\tthis.addAttribute( 'normal', normals );\r\n\t\tthis.addAttribute( 'uv', uvs );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.RingBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\n\tTHREE.RingBufferGeometry.prototype.constructor = THREE.RingBufferGeometry;\r\n\t\r\n\t// File:src/extras/geometries/RingGeometry.js\r\n\t\r\n\t/**\r\n\t * @author Kaleb Murphy\r\n\t */\r\n\t\r\n\tTHREE.RingGeometry = function ( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {\r\n\t\r\n\t\tTHREE.Geometry.call( this );\r\n\t\r\n\t\tthis.type = 'RingGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tinnerRadius: innerRadius,\r\n\t\t\touterRadius: outerRadius,\r\n\t\t\tthetaSegments: thetaSegments,\r\n\t\t\tphiSegments: phiSegments,\r\n\t\t\tthetaStart: thetaStart,\r\n\t\t\tthetaLength: thetaLength\r\n\t\t};\r\n\t\r\n\t\tthis.fromBufferGeometry( new THREE.RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.RingGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\tTHREE.RingGeometry.prototype.constructor = THREE.RingGeometry;\r\n\t\r\n\t// File:src/extras/geometries/SphereGeometry.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.SphereGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {\r\n\t\r\n\t\tTHREE.Geometry.call( this );\r\n\t\r\n\t\tthis.type = 'SphereGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tradius: radius,\r\n\t\t\twidthSegments: widthSegments,\r\n\t\t\theightSegments: heightSegments,\r\n\t\t\tphiStart: phiStart,\r\n\t\t\tphiLength: phiLength,\r\n\t\t\tthetaStart: thetaStart,\r\n\t\t\tthetaLength: thetaLength\r\n\t\t};\r\n\t\r\n\t\tthis.fromBufferGeometry( new THREE.SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.SphereGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\tTHREE.SphereGeometry.prototype.constructor = THREE.SphereGeometry;\r\n\t\r\n\t// File:src/extras/geometries/SphereBufferGeometry.js\r\n\t\r\n\t/**\r\n\t * @author benaadams / https://twitter.com/ben_a_adams\r\n\t * based on THREE.SphereGeometry\r\n\t */\r\n\t\r\n\tTHREE.SphereBufferGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {\r\n\t\r\n\t\tTHREE.BufferGeometry.call( this );\r\n\t\r\n\t\tthis.type = 'SphereBufferGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tradius: radius,\r\n\t\t\twidthSegments: widthSegments,\r\n\t\t\theightSegments: heightSegments,\r\n\t\t\tphiStart: phiStart,\r\n\t\t\tphiLength: phiLength,\r\n\t\t\tthetaStart: thetaStart,\r\n\t\t\tthetaLength: thetaLength\r\n\t\t};\r\n\t\r\n\t\tradius = radius || 50;\r\n\t\r\n\t\twidthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );\r\n\t\theightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );\r\n\t\r\n\t\tphiStart = phiStart !== undefined ? phiStart : 0;\r\n\t\tphiLength = phiLength !== undefined ? phiLength : Math.PI * 2;\r\n\t\r\n\t\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\r\n\t\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI;\r\n\t\r\n\t\tvar thetaEnd = thetaStart + thetaLength;\r\n\t\r\n\t\tvar vertexCount = ( ( widthSegments + 1 ) * ( heightSegments + 1 ) );\r\n\t\r\n\t\tvar positions = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\r\n\t\tvar normals = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\r\n\t\tvar uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\r\n\t\r\n\t\tvar index = 0, vertices = [], normal = new THREE.Vector3();\r\n\t\r\n\t\tfor ( var y = 0; y <= heightSegments; y ++ ) {\r\n\t\r\n\t\t\tvar verticesRow = [];\r\n\t\r\n\t\t\tvar v = y / heightSegments;\r\n\t\r\n\t\t\tfor ( var x = 0; x <= widthSegments; x ++ ) {\r\n\t\r\n\t\t\t\tvar u = x / widthSegments;\r\n\t\r\n\t\t\t\tvar px = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\r\n\t\t\t\tvar py = radius * Math.cos( thetaStart + v * thetaLength );\r\n\t\t\t\tvar pz = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\r\n\t\r\n\t\t\t\tnormal.set( px, py, pz ).normalize();\r\n\t\r\n\t\t\t\tpositions.setXYZ( index, px, py, pz );\r\n\t\t\t\tnormals.setXYZ( index, normal.x, normal.y, normal.z );\r\n\t\t\t\tuvs.setXY( index, u, 1 - v );\r\n\t\r\n\t\t\t\tverticesRow.push( index );\r\n\t\r\n\t\t\t\tindex ++;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvertices.push( verticesRow );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar indices = [];\r\n\t\r\n\t\tfor ( var y = 0; y < heightSegments; y ++ ) {\r\n\t\r\n\t\t\tfor ( var x = 0; x < widthSegments; x ++ ) {\r\n\t\r\n\t\t\t\tvar v1 = vertices[ y ][ x + 1 ];\r\n\t\t\t\tvar v2 = vertices[ y ][ x ];\r\n\t\t\t\tvar v3 = vertices[ y + 1 ][ x ];\r\n\t\t\t\tvar v4 = vertices[ y + 1 ][ x + 1 ];\r\n\t\r\n\t\t\t\tif ( y !== 0 || thetaStart > 0 ) indices.push( v1, v2, v4 );\r\n\t\t\t\tif ( y !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( v2, v3, v4 );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.setIndex( new ( positions.count > 65535 ? THREE.Uint32Attribute : THREE.Uint16Attribute )( indices, 1 ) );\r\n\t\tthis.addAttribute( 'position', positions );\r\n\t\tthis.addAttribute( 'normal', normals );\r\n\t\tthis.addAttribute( 'uv', uvs );\r\n\t\r\n\t\tthis.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.SphereBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\n\tTHREE.SphereBufferGeometry.prototype.constructor = THREE.SphereBufferGeometry;\r\n\t\r\n\t// File:src/extras/geometries/TextGeometry.js\r\n\t\r\n\t/**\r\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t *\r\n\t * Text = 3D Text\r\n\t *\r\n\t * parameters = {\r\n\t *  font: <THREE.Font>, // font\r\n\t *\r\n\t *  size: <float>, // size of the text\r\n\t *  height: <float>, // thickness to extrude text\r\n\t *  curveSegments: <int>, // number of points on the curves\r\n\t *\r\n\t *  bevelEnabled: <bool>, // turn on bevel\r\n\t *  bevelThickness: <float>, // how deep into text bevel goes\r\n\t *  bevelSize: <float> // how far from text outline is bevel\r\n\t * }\r\n\t */\r\n\t\r\n\tTHREE.TextGeometry = function ( text, parameters ) {\r\n\t\r\n\t\tparameters = parameters || {};\r\n\t\r\n\t\tvar font = parameters.font;\r\n\t\r\n\t\tif ( font instanceof THREE.Font === false ) {\r\n\t\r\n\t\t\tconsole.error( 'THREE.TextGeometry: font parameter is not an instance of THREE.Font.' );\r\n\t\t\treturn new THREE.Geometry();\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar shapes = font.generateShapes( text, parameters.size, parameters.curveSegments );\r\n\t\r\n\t\t// translate parameters to ExtrudeGeometry API\r\n\t\r\n\t\tparameters.amount = parameters.height !== undefined ? parameters.height : 50;\r\n\t\r\n\t\t// defaults\r\n\t\r\n\t\tif ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;\r\n\t\tif ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;\r\n\t\tif ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;\r\n\t\r\n\t\tTHREE.ExtrudeGeometry.call( this, shapes, parameters );\r\n\t\r\n\t\tthis.type = 'TextGeometry';\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.TextGeometry.prototype = Object.create( THREE.ExtrudeGeometry.prototype );\r\n\tTHREE.TextGeometry.prototype.constructor = THREE.TextGeometry;\r\n\t\r\n\t// File:src/extras/geometries/TorusBufferGeometry.js\r\n\t\r\n\t/**\r\n\t * @author Mugen87 / https://github.com/Mugen87\r\n\t */\r\n\t\r\n\tTHREE.TorusBufferGeometry = function ( radius, tube, radialSegments, tubularSegments, arc ) {\r\n\t\r\n\t\tTHREE.BufferGeometry.call( this );\r\n\t\r\n\t\tthis.type = 'TorusBufferGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tradius: radius,\r\n\t\t\ttube: tube,\r\n\t\t\tradialSegments: radialSegments,\r\n\t\t\ttubularSegments: tubularSegments,\r\n\t\t\tarc: arc\r\n\t\t};\r\n\t\r\n\t\tradius = radius || 100;\r\n\t\ttube = tube || 40;\r\n\t\tradialSegments = Math.floor( radialSegments ) || 8;\r\n\t\ttubularSegments = Math.floor( tubularSegments ) || 6;\r\n\t\tarc = arc || Math.PI * 2;\r\n\t\r\n\t\t// used to calculate buffer length\r\n\t\tvar vertexCount = ( ( radialSegments + 1 ) * ( tubularSegments + 1 ) );\r\n\t\tvar indexCount = radialSegments * tubularSegments * 2 * 3;\r\n\t\r\n\t\t// buffers\r\n\t\tvar indices = new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount );\r\n\t\tvar vertices = new Float32Array( vertexCount * 3 );\r\n\t\tvar normals = new Float32Array( vertexCount * 3 );\r\n\t\tvar uvs = new Float32Array( vertexCount * 2 );\r\n\t\r\n\t\t// offset variables\r\n\t\tvar vertexBufferOffset = 0;\r\n\t\tvar uvBufferOffset = 0;\r\n\t\tvar indexBufferOffset = 0;\r\n\t\r\n\t\t// helper variables\r\n\t\tvar center = new THREE.Vector3();\r\n\t\tvar vertex = new THREE.Vector3();\r\n\t\tvar normal = new THREE.Vector3();\r\n\t\r\n\t\tvar j, i;\r\n\t\r\n\t\t// generate vertices, normals and uvs\r\n\t\r\n\t\tfor ( j = 0; j <= radialSegments; j ++ ) {\r\n\t\r\n\t\t\tfor ( i = 0; i <= tubularSegments; i ++ ) {\r\n\t\r\n\t\t\t\tvar u = i / tubularSegments * arc;\r\n\t\t\t\tvar v = j / radialSegments * Math.PI * 2;\r\n\t\r\n\t\t\t\t// vertex\r\n\t\t\t\tvertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );\r\n\t\t\t\tvertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );\r\n\t\t\t\tvertex.z = tube * Math.sin( v );\r\n\t\r\n\t\t\t\tvertices[ vertexBufferOffset ] = vertex.x;\r\n\t\t\t\tvertices[ vertexBufferOffset + 1 ] = vertex.y;\r\n\t\t\t\tvertices[ vertexBufferOffset + 2 ] = vertex.z;\r\n\t\r\n\t\t\t\t// this vector is used to calculate the normal\r\n\t\t\t\tcenter.x = radius * Math.cos( u );\r\n\t\t\t\tcenter.y = radius * Math.sin( u );\r\n\t\r\n\t\t\t\t// normal\r\n\t\t\t\tnormal.subVectors( vertex, center ).normalize();\r\n\t\r\n\t\t\t\tnormals[ vertexBufferOffset ] = normal.x;\r\n\t\t\t\tnormals[ vertexBufferOffset + 1 ] = normal.y;\r\n\t\t\t\tnormals[ vertexBufferOffset + 2 ] = normal.z;\r\n\t\r\n\t\t\t\t// uv\r\n\t\t\t\tuvs[ uvBufferOffset ] = i / tubularSegments;\r\n\t\t\t\tuvs[ uvBufferOffset + 1 ] = j / radialSegments;\r\n\t\r\n\t\t\t\t// update offsets\r\n\t\t\t\tvertexBufferOffset += 3;\r\n\t\t\t\tuvBufferOffset += 2;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// generate indices\r\n\t\r\n\t\tfor ( j = 1; j <= radialSegments; j ++ ) {\r\n\t\r\n\t\t\tfor ( i = 1; i <= tubularSegments; i ++ ) {\r\n\t\r\n\t\t\t\t// indices\r\n\t\t\t\tvar a = ( tubularSegments + 1 ) * j + i - 1;\r\n\t\t\t\tvar b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;\r\n\t\t\t\tvar c = ( tubularSegments + 1 ) * ( j - 1 ) + i;\r\n\t\t\t\tvar d = ( tubularSegments + 1 ) * j + i;\r\n\t\r\n\t\t\t\t// face one\r\n\t\t\t\tindices[ indexBufferOffset ] = a;\r\n\t\t\t\tindices[ indexBufferOffset + 1 ] = b;\r\n\t\t\t\tindices[ indexBufferOffset + 2 ] = d;\r\n\t\r\n\t\t\t\t// face two\r\n\t\t\t\tindices[ indexBufferOffset + 3 ] = b;\r\n\t\t\t\tindices[ indexBufferOffset + 4 ] = c;\r\n\t\t\t\tindices[ indexBufferOffset + 5 ] = d;\r\n\t\r\n\t\t\t\t// update offset\r\n\t\t\t\tindexBufferOffset += 6;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// build geometry\r\n\t\tthis.setIndex( new THREE.BufferAttribute( indices, 1 ) );\r\n\t\tthis.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\r\n\t\tthis.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );\r\n\t\tthis.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.TorusBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\n\tTHREE.TorusBufferGeometry.prototype.constructor = THREE.TorusBufferGeometry;\r\n\t\r\n\t// File:src/extras/geometries/TorusGeometry.js\r\n\t\r\n\t/**\r\n\t * @author oosmoxiecode\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888\r\n\t */\r\n\t\r\n\tTHREE.TorusGeometry = function ( radius, tube, radialSegments, tubularSegments, arc ) {\r\n\t\r\n\t\tTHREE.Geometry.call( this );\r\n\t\r\n\t\tthis.type = 'TorusGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tradius: radius,\r\n\t\t\ttube: tube,\r\n\t\t\tradialSegments: radialSegments,\r\n\t\t\ttubularSegments: tubularSegments,\r\n\t\t\tarc: arc\r\n\t\t};\r\n\t\r\n\t\tthis.fromBufferGeometry( new THREE.TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.TorusGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\tTHREE.TorusGeometry.prototype.constructor = THREE.TorusGeometry;\r\n\t\r\n\t// File:src/extras/geometries/TorusKnotBufferGeometry.js\r\n\t\r\n\t/**\r\n\t * @author Mugen87 / https://github.com/Mugen87\r\n\t *\r\n\t * see: http://www.blackpawn.com/texts/pqtorus/\r\n\t */\r\n\tTHREE.TorusKnotBufferGeometry = function ( radius, tube, tubularSegments, radialSegments, p, q ) {\r\n\t\r\n\t\tTHREE.BufferGeometry.call( this );\r\n\t\r\n\t\tthis.type = 'TorusKnotBufferGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tradius: radius,\r\n\t\t\ttube: tube,\r\n\t\t\ttubularSegments: tubularSegments,\r\n\t\t\tradialSegments: radialSegments,\r\n\t\t\tp: p,\r\n\t\t\tq: q\r\n\t\t};\r\n\t\r\n\t\tradius = radius || 100;\r\n\t\ttube = tube || 40;\r\n\t\ttubularSegments = Math.floor( tubularSegments ) || 64;\r\n\t\tradialSegments = Math.floor( radialSegments ) || 8;\r\n\t\tp = p || 2;\r\n\t\tq = q || 3;\r\n\t\r\n\t\t// used to calculate buffer length\r\n\t\tvar vertexCount = ( ( radialSegments + 1 ) * ( tubularSegments + 1 ) );\r\n\t\tvar indexCount = radialSegments * tubularSegments * 2 * 3;\r\n\t\r\n\t\t// buffers\r\n\t\tvar indices = new THREE.BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );\r\n\t\tvar vertices = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\r\n\t\tvar normals = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\r\n\t\tvar uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\r\n\t\r\n\t\t// helper variables\r\n\t\tvar i, j, index = 0, indexOffset = 0;\r\n\t\r\n\t\tvar vertex = new THREE.Vector3();\r\n\t\tvar normal = new THREE.Vector3();\r\n\t\tvar uv = new THREE.Vector2();\r\n\t\r\n\t\tvar P1 = new THREE.Vector3();\r\n\t\tvar P2 = new THREE.Vector3();\r\n\t\r\n\t\tvar B = new THREE.Vector3();\r\n\t\tvar T = new THREE.Vector3();\r\n\t\tvar N = new THREE.Vector3();\r\n\t\r\n\t\t// generate vertices, normals and uvs\r\n\t\r\n\t\tfor ( i = 0; i <= tubularSegments; ++ i ) {\r\n\t\r\n\t\t\t// the radian \"u\" is used to calculate the position on the torus curve of the current tubular segement\r\n\t\r\n\t\t\tvar u = i / tubularSegments * p * Math.PI * 2;\r\n\t\r\n\t\t\t// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.\r\n\t\t\t// these points are used to create a special \"coordinate space\", which is necessary to calculate the correct vertex positions\r\n\t\r\n\t\t\tcalculatePositionOnCurve( u, p, q, radius, P1 );\r\n\t\t\tcalculatePositionOnCurve( u + 0.01, p, q, radius, P2 );\r\n\t\r\n\t\t\t// calculate orthonormal basis\r\n\t\r\n\t\t\tT.subVectors( P2, P1 );\r\n\t\t\tN.addVectors( P2, P1 );\r\n\t\t\tB.crossVectors( T, N );\r\n\t\t\tN.crossVectors( B, T );\r\n\t\r\n\t\t\t// normalize B, N. T can be ignored, we don't use it\r\n\t\r\n\t\t\tB.normalize();\r\n\t\t\tN.normalize();\r\n\t\r\n\t\t\tfor ( j = 0; j <= radialSegments; ++ j ) {\r\n\t\r\n\t\t\t\t// now calculate the vertices. they are nothing more than an extrusion of the torus curve.\r\n\t\t\t\t// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.\r\n\t\r\n\t\t\t\tvar v = j / radialSegments * Math.PI * 2;\r\n\t\t\t\tvar cx = - tube * Math.cos( v );\r\n\t\t\t\tvar cy = tube * Math.sin( v );\r\n\t\r\n\t\t\t\t// now calculate the final vertex position.\r\n\t\t\t\t// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve\r\n\t\r\n\t\t\t\tvertex.x = P1.x + ( cx * N.x + cy * B.x );\r\n\t\t\t\tvertex.y = P1.y + ( cx * N.y + cy * B.y );\r\n\t\t\t\tvertex.z = P1.z + ( cx * N.z + cy * B.z );\r\n\t\r\n\t\t\t\t// vertex\r\n\t\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\r\n\t\r\n\t\t\t\t// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)\r\n\t\t\t\tnormal.subVectors( vertex, P1 ).normalize();\r\n\t\t\t\tnormals.setXYZ( index, normal.x, normal.y, normal.z );\r\n\t\r\n\t\t\t\t// uv\r\n\t\t\t\tuv.x = i / tubularSegments;\r\n\t\t\t\tuv.y = j / radialSegments;\r\n\t\t\t\tuvs.setXY( index, uv.x, uv.y );\r\n\t\r\n\t\t\t\t// increase index\r\n\t\t\t\tindex ++;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// generate indices\r\n\t\r\n\t\tfor ( j = 1; j <= tubularSegments; j ++ ) {\r\n\t\r\n\t\t\tfor ( i = 1; i <= radialSegments; i ++ ) {\r\n\t\r\n\t\t\t\t// indices\r\n\t\t\t\tvar a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );\r\n\t\t\t\tvar b = ( radialSegments + 1 ) * j + ( i - 1 );\r\n\t\t\t\tvar c = ( radialSegments + 1 ) * j + i;\r\n\t\t\t\tvar d = ( radialSegments + 1 ) * ( j - 1 ) + i;\r\n\t\r\n\t\t\t\t// face one\r\n\t\t\t\tindices.setX( indexOffset, a ); indexOffset++;\r\n\t\t\t\tindices.setX( indexOffset, b ); indexOffset++;\r\n\t\t\t\tindices.setX( indexOffset, d ); indexOffset++;\r\n\t\r\n\t\t\t\t// face two\r\n\t\t\t\tindices.setX( indexOffset, b ); indexOffset++;\r\n\t\t\t\tindices.setX( indexOffset, c ); indexOffset++;\r\n\t\t\t\tindices.setX( indexOffset, d ); indexOffset++;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// build geometry\r\n\t\r\n\t\tthis.setIndex( indices );\r\n\t\tthis.addAttribute( 'position', vertices );\r\n\t\tthis.addAttribute( 'normal', normals );\r\n\t\tthis.addAttribute( 'uv', uvs );\r\n\t\r\n\t\t// this function calculates the current position on the torus curve\r\n\t\r\n\t\tfunction calculatePositionOnCurve( u, p, q, radius, position ) {\r\n\t\r\n\t\t\tvar cu = Math.cos( u );\r\n\t\t\tvar su = Math.sin( u );\r\n\t\t\tvar quOverP = q / p * u;\r\n\t\t\tvar cs = Math.cos( quOverP );\r\n\t\r\n\t\t\tposition.x = radius * ( 2 + cs ) * 0.5 * cu;\r\n\t\t\tposition.y = radius * ( 2 + cs ) * su * 0.5;\r\n\t\t\tposition.z = radius * Math.sin( quOverP ) * 0.5;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.TorusKnotBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\n\tTHREE.TorusKnotBufferGeometry.prototype.constructor = THREE.TorusKnotBufferGeometry;\r\n\t\r\n\t// File:src/extras/geometries/TorusKnotGeometry.js\r\n\t\r\n\t/**\r\n\t * @author oosmoxiecode\r\n\t */\r\n\t\r\n\tTHREE.TorusKnotGeometry = function ( radius, tube, tubularSegments, radialSegments, p, q, heightScale ) {\r\n\t\r\n\t\tTHREE.Geometry.call( this );\r\n\t\r\n\t\tthis.type = 'TorusKnotGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tradius: radius,\r\n\t\t\ttube: tube,\r\n\t\t\ttubularSegments: tubularSegments,\r\n\t\t\tradialSegments: radialSegments,\r\n\t\t\tp: p,\r\n\t\t\tq: q\r\n\t\t};\r\n\t\r\n\t\tif( heightScale !== undefined ) console.warn( 'THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.' );\r\n\t\r\n\t\tthis.fromBufferGeometry( new THREE.TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) );\r\n\t\tthis.mergeVertices();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.TorusKnotGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\tTHREE.TorusKnotGeometry.prototype.constructor = THREE.TorusKnotGeometry;\r\n\t\r\n\t// File:src/extras/geometries/TubeGeometry.js\r\n\t\r\n\t/**\r\n\t * @author WestLangley / https://github.com/WestLangley\r\n\t * @author zz85 / https://github.com/zz85\r\n\t * @author miningold / https://github.com/miningold\r\n\t * @author jonobr1 / https://github.com/jonobr1\r\n\t *\r\n\t * Modified from the TorusKnotGeometry by @oosmoxiecode\r\n\t *\r\n\t * Creates a tube which extrudes along a 3d spline\r\n\t *\r\n\t * Uses parallel transport frames as described in\r\n\t * http://www.cs.indiana.edu/pub/techreports/TR425.pdf\r\n\t */\r\n\t\r\n\tTHREE.TubeGeometry = function ( path, segments, radius, radialSegments, closed, taper ) {\r\n\t\r\n\t\tTHREE.Geometry.call( this );\r\n\t\r\n\t\tthis.type = 'TubeGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tpath: path,\r\n\t\t\tsegments: segments,\r\n\t\t\tradius: radius,\r\n\t\t\tradialSegments: radialSegments,\r\n\t\t\tclosed: closed,\r\n\t\t\ttaper: taper\r\n\t\t};\r\n\t\r\n\t\tsegments = segments || 64;\r\n\t\tradius = radius || 1;\r\n\t\tradialSegments = radialSegments || 8;\r\n\t\tclosed = closed || false;\r\n\t\ttaper = taper || THREE.TubeGeometry.NoTaper;\r\n\t\r\n\t\tvar grid = [];\r\n\t\r\n\t\tvar scope = this,\r\n\t\r\n\t\t\ttangent,\r\n\t\t\tnormal,\r\n\t\t\tbinormal,\r\n\t\r\n\t\t\tnumpoints = segments + 1,\r\n\t\r\n\t\t\tu, v, r,\r\n\t\r\n\t\t\tcx, cy,\r\n\t\t\tpos, pos2 = new THREE.Vector3(),\r\n\t\t\ti, j,\r\n\t\t\tip, jp,\r\n\t\t\ta, b, c, d,\r\n\t\t\tuva, uvb, uvc, uvd;\r\n\t\r\n\t\tvar frames = new THREE.TubeGeometry.FrenetFrames( path, segments, closed ),\r\n\t\t\ttangents = frames.tangents,\r\n\t\t\tnormals = frames.normals,\r\n\t\t\tbinormals = frames.binormals;\r\n\t\r\n\t\t// proxy internals\r\n\t\tthis.tangents = tangents;\r\n\t\tthis.normals = normals;\r\n\t\tthis.binormals = binormals;\r\n\t\r\n\t\tfunction vert( x, y, z ) {\r\n\t\r\n\t\t\treturn scope.vertices.push( new THREE.Vector3( x, y, z ) ) - 1;\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// construct the grid\r\n\t\r\n\t\tfor ( i = 0; i < numpoints; i ++ ) {\r\n\t\r\n\t\t\tgrid[ i ] = [];\r\n\t\r\n\t\t\tu = i / ( numpoints - 1 );\r\n\t\r\n\t\t\tpos = path.getPointAt( u );\r\n\t\r\n\t\t\ttangent = tangents[ i ];\r\n\t\t\tnormal = normals[ i ];\r\n\t\t\tbinormal = binormals[ i ];\r\n\t\r\n\t\t\tr = radius * taper( u );\r\n\t\r\n\t\t\tfor ( j = 0; j < radialSegments; j ++ ) {\r\n\t\r\n\t\t\t\tv = j / radialSegments * 2 * Math.PI;\r\n\t\r\n\t\t\t\tcx = - r * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.\r\n\t\t\t\tcy = r * Math.sin( v );\r\n\t\r\n\t\t\t\tpos2.copy( pos );\r\n\t\t\t\tpos2.x += cx * normal.x + cy * binormal.x;\r\n\t\t\t\tpos2.y += cx * normal.y + cy * binormal.y;\r\n\t\t\t\tpos2.z += cx * normal.z + cy * binormal.z;\r\n\t\r\n\t\t\t\tgrid[ i ][ j ] = vert( pos2.x, pos2.y, pos2.z );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t\t// construct the mesh\r\n\t\r\n\t\tfor ( i = 0; i < segments; i ++ ) {\r\n\t\r\n\t\t\tfor ( j = 0; j < radialSegments; j ++ ) {\r\n\t\r\n\t\t\t\tip = ( closed ) ? ( i + 1 ) % segments : i + 1;\r\n\t\t\t\tjp = ( j + 1 ) % radialSegments;\r\n\t\r\n\t\t\t\ta = grid[ i ][ j ];\t\t// *** NOT NECESSARILY PLANAR ! ***\r\n\t\t\t\tb = grid[ ip ][ j ];\r\n\t\t\t\tc = grid[ ip ][ jp ];\r\n\t\t\t\td = grid[ i ][ jp ];\r\n\t\r\n\t\t\t\tuva = new THREE.Vector2( i / segments, j / radialSegments );\r\n\t\t\t\tuvb = new THREE.Vector2( ( i + 1 ) / segments, j / radialSegments );\r\n\t\t\t\tuvc = new THREE.Vector2( ( i + 1 ) / segments, ( j + 1 ) / radialSegments );\r\n\t\t\t\tuvd = new THREE.Vector2( i / segments, ( j + 1 ) / radialSegments );\r\n\t\r\n\t\t\t\tthis.faces.push( new THREE.Face3( a, b, d ) );\r\n\t\t\t\tthis.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );\r\n\t\r\n\t\t\t\tthis.faces.push( new THREE.Face3( b, c, d ) );\r\n\t\t\t\tthis.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.computeFaceNormals();\r\n\t\tthis.computeVertexNormals();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.TubeGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\tTHREE.TubeGeometry.prototype.constructor = THREE.TubeGeometry;\r\n\t\r\n\tTHREE.TubeGeometry.NoTaper = function ( u ) {\r\n\t\r\n\t\treturn 1;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.TubeGeometry.SinusoidalTaper = function ( u ) {\r\n\t\r\n\t\treturn Math.sin( Math.PI * u );\r\n\t\r\n\t};\r\n\t\r\n\t// For computing of Frenet frames, exposing the tangents, normals and binormals the spline\r\n\tTHREE.TubeGeometry.FrenetFrames = function ( path, segments, closed ) {\r\n\t\r\n\t\tvar\tnormal = new THREE.Vector3(),\r\n\t\r\n\t\t\ttangents = [],\r\n\t\t\tnormals = [],\r\n\t\t\tbinormals = [],\r\n\t\r\n\t\t\tvec = new THREE.Vector3(),\r\n\t\t\tmat = new THREE.Matrix4(),\r\n\t\r\n\t\t\tnumpoints = segments + 1,\r\n\t\t\ttheta,\r\n\t\t\tsmallest,\r\n\t\r\n\t\t\ttx, ty, tz,\r\n\t\t\ti, u;\r\n\t\r\n\t\r\n\t\t// expose internals\r\n\t\tthis.tangents = tangents;\r\n\t\tthis.normals = normals;\r\n\t\tthis.binormals = binormals;\r\n\t\r\n\t\t// compute the tangent vectors for each segment on the path\r\n\t\r\n\t\tfor ( i = 0; i < numpoints; i ++ ) {\r\n\t\r\n\t\t\tu = i / ( numpoints - 1 );\r\n\t\r\n\t\t\ttangents[ i ] = path.getTangentAt( u );\r\n\t\t\ttangents[ i ].normalize();\r\n\t\r\n\t\t}\r\n\t\r\n\t\tinitialNormal3();\r\n\t\r\n\t\t/*\r\n\t\tfunction initialNormal1(lastBinormal) {\r\n\t\t\t// fixed start binormal. Has dangers of 0 vectors\r\n\t\t\tnormals[ 0 ] = new THREE.Vector3();\r\n\t\t\tbinormals[ 0 ] = new THREE.Vector3();\r\n\t\t\tif (lastBinormal===undefined) lastBinormal = new THREE.Vector3( 0, 0, 1 );\r\n\t\t\tnormals[ 0 ].crossVectors( lastBinormal, tangents[ 0 ] ).normalize();\r\n\t\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();\r\n\t\t}\r\n\t\r\n\t\tfunction initialNormal2() {\r\n\t\r\n\t\t\t// This uses the Frenet-Serret formula for deriving binormal\r\n\t\t\tvar t2 = path.getTangentAt( epsilon );\r\n\t\r\n\t\t\tnormals[ 0 ] = new THREE.Vector3().subVectors( t2, tangents[ 0 ] ).normalize();\r\n\t\t\tbinormals[ 0 ] = new THREE.Vector3().crossVectors( tangents[ 0 ], normals[ 0 ] );\r\n\t\r\n\t\t\tnormals[ 0 ].crossVectors( binormals[ 0 ], tangents[ 0 ] ).normalize(); // last binormal x tangent\r\n\t\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();\r\n\t\r\n\t\t}\r\n\t\t*/\r\n\t\r\n\t\tfunction initialNormal3() {\r\n\t\r\n\t\t\t// select an initial normal vector perpendicular to the first tangent vector,\r\n\t\t\t// and in the direction of the smallest tangent xyz component\r\n\t\r\n\t\t\tnormals[ 0 ] = new THREE.Vector3();\r\n\t\t\tbinormals[ 0 ] = new THREE.Vector3();\r\n\t\t\tsmallest = Number.MAX_VALUE;\r\n\t\t\ttx = Math.abs( tangents[ 0 ].x );\r\n\t\t\tty = Math.abs( tangents[ 0 ].y );\r\n\t\t\ttz = Math.abs( tangents[ 0 ].z );\r\n\t\r\n\t\t\tif ( tx <= smallest ) {\r\n\t\r\n\t\t\t\tsmallest = tx;\r\n\t\t\t\tnormal.set( 1, 0, 0 );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( ty <= smallest ) {\r\n\t\r\n\t\t\t\tsmallest = ty;\r\n\t\t\t\tnormal.set( 0, 1, 0 );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( tz <= smallest ) {\r\n\t\r\n\t\t\t\tnormal.set( 0, 0, 1 );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvec.crossVectors( tangents[ 0 ], normal ).normalize();\r\n\t\r\n\t\t\tnormals[ 0 ].crossVectors( tangents[ 0 ], vec );\r\n\t\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t\t// compute the slowly-varying normal and binormal vectors for each segment on the path\r\n\t\r\n\t\tfor ( i = 1; i < numpoints; i ++ ) {\r\n\t\r\n\t\t\tnormals[ i ] = normals[ i - 1 ].clone();\r\n\t\r\n\t\t\tbinormals[ i ] = binormals[ i - 1 ].clone();\r\n\t\r\n\t\t\tvec.crossVectors( tangents[ i - 1 ], tangents[ i ] );\r\n\t\r\n\t\t\tif ( vec.length() > Number.EPSILON ) {\r\n\t\r\n\t\t\t\tvec.normalize();\r\n\t\r\n\t\t\t\ttheta = Math.acos( THREE.Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors\r\n\t\r\n\t\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t\t// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\r\n\t\r\n\t\tif ( closed ) {\r\n\t\r\n\t\t\ttheta = Math.acos( THREE.Math.clamp( normals[ 0 ].dot( normals[ numpoints - 1 ] ), - 1, 1 ) );\r\n\t\t\ttheta /= ( numpoints - 1 );\r\n\t\r\n\t\t\tif ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ numpoints - 1 ] ) ) > 0 ) {\r\n\t\r\n\t\t\t\ttheta = - theta;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( i = 1; i < numpoints; i ++ ) {\r\n\t\r\n\t\t\t\t// twist a little...\r\n\t\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );\r\n\t\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/geometries/PolyhedronGeometry.js\r\n\t\r\n\t/**\r\n\t * @author clockworkgeek / https://github.com/clockworkgeek\r\n\t * @author timothypratley / https://github.com/timothypratley\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t*/\r\n\t\r\n\tTHREE.PolyhedronGeometry = function ( vertices, indices, radius, detail ) {\r\n\t\r\n\t\tTHREE.Geometry.call( this );\r\n\t\r\n\t\tthis.type = 'PolyhedronGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tvertices: vertices,\r\n\t\t\tindices: indices,\r\n\t\t\tradius: radius,\r\n\t\t\tdetail: detail\r\n\t\t};\r\n\t\r\n\t\tradius = radius || 1;\r\n\t\tdetail = detail || 0;\r\n\t\r\n\t\tvar that = this;\r\n\t\r\n\t\tfor ( var i = 0, l = vertices.length; i < l; i += 3 ) {\r\n\t\r\n\t\t\tprepare( new THREE.Vector3( vertices[ i ], vertices[ i + 1 ], vertices[ i + 2 ] ) );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar p = this.vertices;\r\n\t\r\n\t\tvar faces = [];\r\n\t\r\n\t\tfor ( var i = 0, j = 0, l = indices.length; i < l; i += 3, j ++ ) {\r\n\t\r\n\t\t\tvar v1 = p[ indices[ i ] ];\r\n\t\t\tvar v2 = p[ indices[ i + 1 ] ];\r\n\t\t\tvar v3 = p[ indices[ i + 2 ] ];\r\n\t\r\n\t\t\tfaces[ j ] = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ], undefined, j );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar centroid = new THREE.Vector3();\r\n\t\r\n\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\t\r\n\t\t\tsubdivide( faces[ i ], detail );\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t\t// Handle case when face straddles the seam\r\n\t\r\n\t\tfor ( var i = 0, l = this.faceVertexUvs[ 0 ].length; i < l; i ++ ) {\r\n\t\r\n\t\t\tvar uvs = this.faceVertexUvs[ 0 ][ i ];\r\n\t\r\n\t\t\tvar x0 = uvs[ 0 ].x;\r\n\t\t\tvar x1 = uvs[ 1 ].x;\r\n\t\t\tvar x2 = uvs[ 2 ].x;\r\n\t\r\n\t\t\tvar max = Math.max( x0, x1, x2 );\r\n\t\t\tvar min = Math.min( x0, x1, x2 );\r\n\t\r\n\t\t\tif ( max > 0.9 && min < 0.1 ) {\r\n\t\r\n\t\t\t\t// 0.9 is somewhat arbitrary\r\n\t\r\n\t\t\t\tif ( x0 < 0.2 ) uvs[ 0 ].x += 1;\r\n\t\t\t\tif ( x1 < 0.2 ) uvs[ 1 ].x += 1;\r\n\t\t\t\tif ( x2 < 0.2 ) uvs[ 2 ].x += 1;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t\t// Apply radius\r\n\t\r\n\t\tfor ( var i = 0, l = this.vertices.length; i < l; i ++ ) {\r\n\t\r\n\t\t\tthis.vertices[ i ].multiplyScalar( radius );\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t\t// Merge vertices\r\n\t\r\n\t\tthis.mergeVertices();\r\n\t\r\n\t\tthis.computeFaceNormals();\r\n\t\r\n\t\tthis.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\r\n\t\r\n\t\r\n\t\t// Project vector onto sphere's surface\r\n\t\r\n\t\tfunction prepare( vector ) {\r\n\t\r\n\t\t\tvar vertex = vector.normalize().clone();\r\n\t\t\tvertex.index = that.vertices.push( vertex ) - 1;\r\n\t\r\n\t\t\t// Texture coords are equivalent to map coords, calculate angle and convert to fraction of a circle.\r\n\t\r\n\t\t\tvar u = azimuth( vector ) / 2 / Math.PI + 0.5;\r\n\t\t\tvar v = inclination( vector ) / Math.PI + 0.5;\r\n\t\t\tvertex.uv = new THREE.Vector2( u, 1 - v );\r\n\t\r\n\t\t\treturn vertex;\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t\t// Approximate a curved face with recursively sub-divided triangles.\r\n\t\r\n\t\tfunction make( v1, v2, v3, materialIndex ) {\r\n\t\r\n\t\t\tvar face = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ], undefined, materialIndex );\r\n\t\t\tthat.faces.push( face );\r\n\t\r\n\t\t\tcentroid.copy( v1 ).add( v2 ).add( v3 ).divideScalar( 3 );\r\n\t\r\n\t\t\tvar azi = azimuth( centroid );\r\n\t\r\n\t\t\tthat.faceVertexUvs[ 0 ].push( [\r\n\t\t\t\tcorrectUV( v1.uv, v1, azi ),\r\n\t\t\t\tcorrectUV( v2.uv, v2, azi ),\r\n\t\t\t\tcorrectUV( v3.uv, v3, azi )\r\n\t\t\t] );\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t\t// Analytically subdivide a face to the required detail level.\r\n\t\r\n\t\tfunction subdivide( face, detail ) {\r\n\t\r\n\t\t\tvar cols = Math.pow( 2, detail );\r\n\t\t\tvar a = prepare( that.vertices[ face.a ] );\r\n\t\t\tvar b = prepare( that.vertices[ face.b ] );\r\n\t\t\tvar c = prepare( that.vertices[ face.c ] );\r\n\t\t\tvar v = [];\r\n\t\r\n\t\t\tvar materialIndex = face.materialIndex;\r\n\t\r\n\t\t\t// Construct all of the vertices for this subdivision.\r\n\t\r\n\t\t\tfor ( var i = 0 ; i <= cols; i ++ ) {\r\n\t\r\n\t\t\t\tv[ i ] = [];\r\n\t\r\n\t\t\t\tvar aj = prepare( a.clone().lerp( c, i / cols ) );\r\n\t\t\t\tvar bj = prepare( b.clone().lerp( c, i / cols ) );\r\n\t\t\t\tvar rows = cols - i;\r\n\t\r\n\t\t\t\tfor ( var j = 0; j <= rows; j ++ ) {\r\n\t\r\n\t\t\t\t\tif ( j === 0 && i === cols ) {\r\n\t\r\n\t\t\t\t\t\tv[ i ][ j ] = aj;\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tv[ i ][ j ] = prepare( aj.clone().lerp( bj, j / rows ) );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// Construct all of the faces.\r\n\t\r\n\t\t\tfor ( var i = 0; i < cols ; i ++ ) {\r\n\t\r\n\t\t\t\tfor ( var j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {\r\n\t\r\n\t\t\t\t\tvar k = Math.floor( j / 2 );\r\n\t\r\n\t\t\t\t\tif ( j % 2 === 0 ) {\r\n\t\r\n\t\t\t\t\t\tmake(\r\n\t\t\t\t\t\t\tv[ i ][ k + 1 ],\r\n\t\t\t\t\t\t\tv[ i + 1 ][ k ],\r\n\t\t\t\t\t\t\tv[ i ][ k ],\r\n\t\t\t\t\t\t\tmaterialIndex\r\n\t\t\t\t\t\t);\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tmake(\r\n\t\t\t\t\t\t\tv[ i ][ k + 1 ],\r\n\t\t\t\t\t\t\tv[ i + 1 ][ k + 1 ],\r\n\t\t\t\t\t\t\tv[ i + 1 ][ k ],\r\n\t\t\t\t\t\t\tmaterialIndex\r\n\t\t\t\t\t\t);\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t\t// Angle around the Y axis, counter-clockwise when looking from above.\r\n\t\r\n\t\tfunction azimuth( vector ) {\r\n\t\r\n\t\t\treturn Math.atan2( vector.z, - vector.x );\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t\t// Angle above the XZ plane.\r\n\t\r\n\t\tfunction inclination( vector ) {\r\n\t\r\n\t\t\treturn Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t\t// Texture fixing helper. Spheres have some odd behaviours.\r\n\t\r\n\t\tfunction correctUV( uv, vector, azimuth ) {\r\n\t\r\n\t\t\tif ( ( azimuth < 0 ) && ( uv.x === 1 ) ) uv = new THREE.Vector2( uv.x - 1, uv.y );\r\n\t\t\tif ( ( vector.x === 0 ) && ( vector.z === 0 ) ) uv = new THREE.Vector2( azimuth / 2 / Math.PI + 0.5, uv.y );\r\n\t\t\treturn uv.clone();\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.PolyhedronGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\tTHREE.PolyhedronGeometry.prototype.constructor = THREE.PolyhedronGeometry;\r\n\t\r\n\t// File:src/extras/geometries/DodecahedronGeometry.js\r\n\t\r\n\t/**\r\n\t * @author Abe Pazos / https://hamoid.com\r\n\t */\r\n\t\r\n\tTHREE.DodecahedronGeometry = function ( radius, detail ) {\r\n\t\r\n\t\tvar t = ( 1 + Math.sqrt( 5 ) ) / 2;\r\n\t\tvar r = 1 / t;\r\n\t\r\n\t\tvar vertices = [\r\n\t\r\n\t\t\t// (1, 1, 1)\r\n\t\t\t- 1, - 1, - 1,    - 1, - 1,  1,\r\n\t\t\t- 1,  1, - 1,    - 1,  1,  1,\r\n\t\t\t 1, - 1, - 1,     1, - 1,  1,\r\n\t\t\t 1,  1, - 1,     1,  1,  1,\r\n\t\r\n\t\t\t// (0, 1/, )\r\n\t\t\t 0, - r, - t,     0, - r,  t,\r\n\t\t\t 0,  r, - t,     0,  r,  t,\r\n\t\r\n\t\t\t// (1/, , 0)\r\n\t\t\t- r, - t,  0,    - r,  t,  0,\r\n\t\t\t r, - t,  0,     r,  t,  0,\r\n\t\r\n\t\t\t// (, 0, 1/)\r\n\t\t\t- t,  0, - r,     t,  0, - r,\r\n\t\t\t- t,  0,  r,     t,  0,  r\r\n\t\t];\r\n\t\r\n\t\tvar indices = [\r\n\t\t\t 3, 11,  7,      3,  7, 15,      3, 15, 13,\r\n\t\t\t 7, 19, 17,      7, 17,  6,      7,  6, 15,\r\n\t\t\t17,  4,  8,     17,  8, 10,     17, 10,  6,\r\n\t\t\t 8,  0, 16,      8, 16,  2,      8,  2, 10,\r\n\t\t\t 0, 12,  1,      0,  1, 18,      0, 18, 16,\r\n\t\t\t 6, 10,  2,      6,  2, 13,      6, 13, 15,\r\n\t\t\t 2, 16, 18,      2, 18,  3,      2,  3, 13,\r\n\t\t\t18,  1,  9,     18,  9, 11,     18, 11,  3,\r\n\t\t\t 4, 14, 12,      4, 12,  0,      4,  0,  8,\r\n\t\t\t11,  9,  5,     11,  5, 19,     11, 19,  7,\r\n\t\t\t19,  5, 14,     19, 14,  4,     19,  4, 17,\r\n\t\t\t 1, 12, 14,      1, 14,  5,      1,  5,  9\r\n\t\t];\r\n\t\r\n\t\tTHREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );\r\n\t\r\n\t\tthis.type = 'DodecahedronGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tradius: radius,\r\n\t\t\tdetail: detail\r\n\t\t};\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.DodecahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );\r\n\tTHREE.DodecahedronGeometry.prototype.constructor = THREE.DodecahedronGeometry;\r\n\t\r\n\t// File:src/extras/geometries/IcosahedronGeometry.js\r\n\t\r\n\t/**\r\n\t * @author timothypratley / https://github.com/timothypratley\r\n\t */\r\n\t\r\n\tTHREE.IcosahedronGeometry = function ( radius, detail ) {\r\n\t\r\n\t\tvar t = ( 1 + Math.sqrt( 5 ) ) / 2;\r\n\t\r\n\t\tvar vertices = [\r\n\t\t\t- 1,  t,  0,    1,  t,  0,   - 1, - t,  0,    1, - t,  0,\r\n\t\t\t 0, - 1,  t,    0,  1,  t,    0, - 1, - t,    0,  1, - t,\r\n\t\t\t t,  0, - 1,    t,  0,  1,   - t,  0, - 1,   - t,  0,  1\r\n\t\t];\r\n\t\r\n\t\tvar indices = [\r\n\t\t\t 0, 11,  5,    0,  5,  1,    0,  1,  7,    0,  7, 10,    0, 10, 11,\r\n\t\t\t 1,  5,  9,    5, 11,  4,   11, 10,  2,   10,  7,  6,    7,  1,  8,\r\n\t\t\t 3,  9,  4,    3,  4,  2,    3,  2,  6,    3,  6,  8,    3,  8,  9,\r\n\t\t\t 4,  9,  5,    2,  4, 11,    6,  2, 10,    8,  6,  7,    9,  8,  1\r\n\t\t];\r\n\t\r\n\t\tTHREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );\r\n\t\r\n\t\tthis.type = 'IcosahedronGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tradius: radius,\r\n\t\t\tdetail: detail\r\n\t\t};\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.IcosahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );\r\n\tTHREE.IcosahedronGeometry.prototype.constructor = THREE.IcosahedronGeometry;\r\n\t\r\n\t// File:src/extras/geometries/OctahedronGeometry.js\r\n\t\r\n\t/**\r\n\t * @author timothypratley / https://github.com/timothypratley\r\n\t */\r\n\t\r\n\tTHREE.OctahedronGeometry = function ( radius, detail ) {\r\n\t\r\n\t\tvar vertices = [\r\n\t\t\t1, 0, 0,   - 1, 0, 0,    0, 1, 0,    0, - 1, 0,    0, 0, 1,    0, 0, - 1\r\n\t\t];\r\n\t\r\n\t\tvar indices = [\r\n\t\t\t0, 2, 4,    0, 4, 3,    0, 3, 5,    0, 5, 2,    1, 2, 5,    1, 5, 3,    1, 3, 4,    1, 4, 2\r\n\t\t];\r\n\t\r\n\t\tTHREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );\r\n\t\r\n\t\tthis.type = 'OctahedronGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tradius: radius,\r\n\t\t\tdetail: detail\r\n\t\t};\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.OctahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );\r\n\tTHREE.OctahedronGeometry.prototype.constructor = THREE.OctahedronGeometry;\r\n\t\r\n\t// File:src/extras/geometries/TetrahedronGeometry.js\r\n\t\r\n\t/**\r\n\t * @author timothypratley / https://github.com/timothypratley\r\n\t */\r\n\t\r\n\tTHREE.TetrahedronGeometry = function ( radius, detail ) {\r\n\t\r\n\t\tvar vertices = [\r\n\t\t\t 1,  1,  1,   - 1, - 1,  1,   - 1,  1, - 1,    1, - 1, - 1\r\n\t\t];\r\n\t\r\n\t\tvar indices = [\r\n\t\t\t 2,  1,  0,    0,  3,  2,    1,  3,  0,    2,  3,  1\r\n\t\t];\r\n\t\r\n\t\tTHREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );\r\n\t\r\n\t\tthis.type = 'TetrahedronGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tradius: radius,\r\n\t\t\tdetail: detail\r\n\t\t};\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.TetrahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );\r\n\tTHREE.TetrahedronGeometry.prototype.constructor = THREE.TetrahedronGeometry;\r\n\t\r\n\t// File:src/extras/geometries/ParametricGeometry.js\r\n\t\r\n\t/**\r\n\t * @author zz85 / https://github.com/zz85\r\n\t * Parametric Surfaces Geometry\r\n\t * based on the brilliant article by @prideout http://prideout.net/blog/?p=44\r\n\t *\r\n\t * new THREE.ParametricGeometry( parametricFunction, uSegments, ySegements );\r\n\t *\r\n\t */\r\n\t\r\n\tTHREE.ParametricGeometry = function ( func, slices, stacks ) {\r\n\t\r\n\t\tTHREE.Geometry.call( this );\r\n\t\r\n\t\tthis.type = 'ParametricGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tfunc: func,\r\n\t\t\tslices: slices,\r\n\t\t\tstacks: stacks\r\n\t\t};\r\n\t\r\n\t\tvar verts = this.vertices;\r\n\t\tvar faces = this.faces;\r\n\t\tvar uvs = this.faceVertexUvs[ 0 ];\r\n\t\r\n\t\tvar i, j, p;\r\n\t\tvar u, v;\r\n\t\r\n\t\tvar sliceCount = slices + 1;\r\n\t\r\n\t\tfor ( i = 0; i <= stacks; i ++ ) {\r\n\t\r\n\t\t\tv = i / stacks;\r\n\t\r\n\t\t\tfor ( j = 0; j <= slices; j ++ ) {\r\n\t\r\n\t\t\t\tu = j / slices;\r\n\t\r\n\t\t\t\tp = func( u, v );\r\n\t\t\t\tverts.push( p );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar a, b, c, d;\r\n\t\tvar uva, uvb, uvc, uvd;\r\n\t\r\n\t\tfor ( i = 0; i < stacks; i ++ ) {\r\n\t\r\n\t\t\tfor ( j = 0; j < slices; j ++ ) {\r\n\t\r\n\t\t\t\ta = i * sliceCount + j;\r\n\t\t\t\tb = i * sliceCount + j + 1;\r\n\t\t\t\tc = ( i + 1 ) * sliceCount + j + 1;\r\n\t\t\t\td = ( i + 1 ) * sliceCount + j;\r\n\t\r\n\t\t\t\tuva = new THREE.Vector2( j / slices, i / stacks );\r\n\t\t\t\tuvb = new THREE.Vector2( ( j + 1 ) / slices, i / stacks );\r\n\t\t\t\tuvc = new THREE.Vector2( ( j + 1 ) / slices, ( i + 1 ) / stacks );\r\n\t\t\t\tuvd = new THREE.Vector2( j / slices, ( i + 1 ) / stacks );\r\n\t\r\n\t\t\t\tfaces.push( new THREE.Face3( a, b, d ) );\r\n\t\t\t\tuvs.push( [ uva, uvb, uvd ] );\r\n\t\r\n\t\t\t\tfaces.push( new THREE.Face3( b, c, d ) );\r\n\t\t\t\tuvs.push( [ uvb.clone(), uvc, uvd.clone() ] );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// console.log(this);\r\n\t\r\n\t\t// magic bullet\r\n\t\t// var diff = this.mergeVertices();\r\n\t\t// console.log('removed ', diff, ' vertices by merging');\r\n\t\r\n\t\tthis.computeFaceNormals();\r\n\t\tthis.computeVertexNormals();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.ParametricGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\tTHREE.ParametricGeometry.prototype.constructor = THREE.ParametricGeometry;\r\n\t\r\n\t// File:src/extras/geometries/WireframeGeometry.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.WireframeGeometry = function ( geometry ) {\r\n\t\r\n\t\tTHREE.BufferGeometry.call( this );\r\n\t\r\n\t\tvar edge = [ 0, 0 ], hash = {};\r\n\t\r\n\t\tfunction sortFunction( a, b ) {\r\n\t\r\n\t\t\treturn a - b;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar keys = [ 'a', 'b', 'c' ];\r\n\t\r\n\t\tif ( geometry instanceof THREE.Geometry ) {\r\n\t\r\n\t\t\tvar vertices = geometry.vertices;\r\n\t\t\tvar faces = geometry.faces;\r\n\t\t\tvar numEdges = 0;\r\n\t\r\n\t\t\t// allocate maximal size\r\n\t\t\tvar edges = new Uint32Array( 6 * faces.length );\r\n\t\r\n\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tvar face = faces[ i ];\r\n\t\r\n\t\t\t\tfor ( var j = 0; j < 3; j ++ ) {\r\n\t\r\n\t\t\t\t\tedge[ 0 ] = face[ keys[ j ] ];\r\n\t\t\t\t\tedge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];\r\n\t\t\t\t\tedge.sort( sortFunction );\r\n\t\r\n\t\t\t\t\tvar key = edge.toString();\r\n\t\r\n\t\t\t\t\tif ( hash[ key ] === undefined ) {\r\n\t\r\n\t\t\t\t\t\tedges[ 2 * numEdges ] = edge[ 0 ];\r\n\t\t\t\t\t\tedges[ 2 * numEdges + 1 ] = edge[ 1 ];\r\n\t\t\t\t\t\thash[ key ] = true;\r\n\t\t\t\t\t\tnumEdges ++;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar coords = new Float32Array( numEdges * 2 * 3 );\r\n\t\r\n\t\t\tfor ( var i = 0, l = numEdges; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tfor ( var j = 0; j < 2; j ++ ) {\r\n\t\r\n\t\t\t\t\tvar vertex = vertices[ edges [ 2 * i + j ] ];\r\n\t\r\n\t\t\t\t\tvar index = 6 * i + 3 * j;\r\n\t\t\t\t\tcoords[ index + 0 ] = vertex.x;\r\n\t\t\t\t\tcoords[ index + 1 ] = vertex.y;\r\n\t\t\t\t\tcoords[ index + 2 ] = vertex.z;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );\r\n\t\r\n\t\t} else if ( geometry instanceof THREE.BufferGeometry ) {\r\n\t\r\n\t\t\tif ( geometry.index !== null ) {\r\n\t\r\n\t\t\t\t// Indexed BufferGeometry\r\n\t\r\n\t\t\t\tvar indices = geometry.index.array;\r\n\t\t\t\tvar vertices = geometry.attributes.position;\r\n\t\t\t\tvar groups = geometry.groups;\r\n\t\t\t\tvar numEdges = 0;\r\n\t\r\n\t\t\t\tif ( groups.length === 0 ) {\r\n\t\r\n\t\t\t\t\tgeometry.addGroup( 0, indices.length );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// allocate maximal size\r\n\t\t\t\tvar edges = new Uint32Array( 2 * indices.length );\r\n\t\r\n\t\t\t\tfor ( var o = 0, ol = groups.length; o < ol; ++ o ) {\r\n\t\r\n\t\t\t\t\tvar group = groups[ o ];\r\n\t\r\n\t\t\t\t\tvar start = group.start;\r\n\t\t\t\t\tvar count = group.count;\r\n\t\r\n\t\t\t\t\tfor ( var i = start, il = start + count; i < il; i += 3 ) {\r\n\t\r\n\t\t\t\t\t\tfor ( var j = 0; j < 3; j ++ ) {\r\n\t\r\n\t\t\t\t\t\t\tedge[ 0 ] = indices[ i + j ];\r\n\t\t\t\t\t\t\tedge[ 1 ] = indices[ i + ( j + 1 ) % 3 ];\r\n\t\t\t\t\t\t\tedge.sort( sortFunction );\r\n\t\r\n\t\t\t\t\t\t\tvar key = edge.toString();\r\n\t\r\n\t\t\t\t\t\t\tif ( hash[ key ] === undefined ) {\r\n\t\r\n\t\t\t\t\t\t\t\tedges[ 2 * numEdges ] = edge[ 0 ];\r\n\t\t\t\t\t\t\t\tedges[ 2 * numEdges + 1 ] = edge[ 1 ];\r\n\t\t\t\t\t\t\t\thash[ key ] = true;\r\n\t\t\t\t\t\t\t\tnumEdges ++;\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar coords = new Float32Array( numEdges * 2 * 3 );\r\n\t\r\n\t\t\t\tfor ( var i = 0, l = numEdges; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\tfor ( var j = 0; j < 2; j ++ ) {\r\n\t\r\n\t\t\t\t\t\tvar index = 6 * i + 3 * j;\r\n\t\t\t\t\t\tvar index2 = edges[ 2 * i + j ];\r\n\t\r\n\t\t\t\t\t\tcoords[ index + 0 ] = vertices.getX( index2 );\r\n\t\t\t\t\t\tcoords[ index + 1 ] = vertices.getY( index2 );\r\n\t\t\t\t\t\tcoords[ index + 2 ] = vertices.getZ( index2 );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tthis.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\t// non-indexed BufferGeometry\r\n\t\r\n\t\t\t\tvar vertices = geometry.attributes.position.array;\r\n\t\t\t\tvar numEdges = vertices.length / 3;\r\n\t\t\t\tvar numTris = numEdges / 3;\r\n\t\r\n\t\t\t\tvar coords = new Float32Array( numEdges * 2 * 3 );\r\n\t\r\n\t\t\t\tfor ( var i = 0, l = numTris; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\tfor ( var j = 0; j < 3; j ++ ) {\r\n\t\r\n\t\t\t\t\t\tvar index = 18 * i + 6 * j;\r\n\t\r\n\t\t\t\t\t\tvar index1 = 9 * i + 3 * j;\r\n\t\t\t\t\t\tcoords[ index + 0 ] = vertices[ index1 ];\r\n\t\t\t\t\t\tcoords[ index + 1 ] = vertices[ index1 + 1 ];\r\n\t\t\t\t\t\tcoords[ index + 2 ] = vertices[ index1 + 2 ];\r\n\t\r\n\t\t\t\t\t\tvar index2 = 9 * i + 3 * ( ( j + 1 ) % 3 );\r\n\t\t\t\t\t\tcoords[ index + 3 ] = vertices[ index2 ];\r\n\t\t\t\t\t\tcoords[ index + 4 ] = vertices[ index2 + 1 ];\r\n\t\t\t\t\t\tcoords[ index + 5 ] = vertices[ index2 + 2 ];\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tthis.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.WireframeGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\n\tTHREE.WireframeGeometry.prototype.constructor = THREE.WireframeGeometry;\r\n\t\r\n\t// File:src/extras/helpers/AxisHelper.js\r\n\t\r\n\t/**\r\n\t * @author sroucheray / http://sroucheray.org/\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.AxisHelper = function ( size ) {\r\n\t\r\n\t\tsize = size || 1;\r\n\t\r\n\t\tvar vertices = new Float32Array( [\r\n\t\t\t0, 0, 0,  size, 0, 0,\r\n\t\t\t0, 0, 0,  0, size, 0,\r\n\t\t\t0, 0, 0,  0, 0, size\r\n\t\t] );\r\n\t\r\n\t\tvar colors = new Float32Array( [\r\n\t\t\t1, 0, 0,  1, 0.6, 0,\r\n\t\t\t0, 1, 0,  0.6, 1, 0,\r\n\t\t\t0, 0, 1,  0, 0.6, 1\r\n\t\t] );\r\n\t\r\n\t\tvar geometry = new THREE.BufferGeometry();\r\n\t\tgeometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\r\n\t\tgeometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );\r\n\t\r\n\t\tvar material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );\r\n\t\r\n\t\tTHREE.LineSegments.call( this, geometry, material );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.AxisHelper.prototype = Object.create( THREE.LineSegments.prototype );\r\n\tTHREE.AxisHelper.prototype.constructor = THREE.AxisHelper;\r\n\t\r\n\t// File:src/extras/helpers/ArrowHelper.js\r\n\t\r\n\t/**\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t * @author zz85 / http://github.com/zz85\r\n\t * @author bhouston / http://clara.io\r\n\t *\r\n\t * Creates an arrow for visualizing directions\r\n\t *\r\n\t * Parameters:\r\n\t *  dir - Vector3\r\n\t *  origin - Vector3\r\n\t *  length - Number\r\n\t *  color - color in hex value\r\n\t *  headLength - Number\r\n\t *  headWidth - Number\r\n\t */\r\n\t\r\n\tTHREE.ArrowHelper = ( function () {\r\n\t\r\n\t\tvar lineGeometry = new THREE.Geometry();\r\n\t\tlineGeometry.vertices.push( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 1, 0 ) );\r\n\t\r\n\t\tvar coneGeometry = new THREE.CylinderGeometry( 0, 0.5, 1, 5, 1 );\r\n\t\tconeGeometry.translate( 0, - 0.5, 0 );\r\n\t\r\n\t\treturn function ArrowHelper( dir, origin, length, color, headLength, headWidth ) {\r\n\t\r\n\t\t\t// dir is assumed to be normalized\r\n\t\r\n\t\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\t\tif ( color === undefined ) color = 0xffff00;\r\n\t\t\tif ( length === undefined ) length = 1;\r\n\t\t\tif ( headLength === undefined ) headLength = 0.2 * length;\r\n\t\t\tif ( headWidth === undefined ) headWidth = 0.2 * headLength;\r\n\t\r\n\t\t\tthis.position.copy( origin );\r\n\t\t\t\r\n\t\t\tthis.line = new THREE.Line( lineGeometry, new THREE.LineBasicMaterial( { color: color } ) );\r\n\t\t\tthis.line.matrixAutoUpdate = false;\r\n\t\t\tthis.add( this.line );\r\n\t\r\n\t\t\tthis.cone = new THREE.Mesh( coneGeometry, new THREE.MeshBasicMaterial( { color: color } ) );\r\n\t\t\tthis.cone.matrixAutoUpdate = false;\r\n\t\t\tthis.add( this.cone );\r\n\t\r\n\t\t\tthis.setDirection( dir );\r\n\t\t\tthis.setLength( length, headLength, headWidth );\r\n\t\r\n\t\t}\r\n\t\r\n\t}() );\r\n\t\r\n\tTHREE.ArrowHelper.prototype = Object.create( THREE.Object3D.prototype );\r\n\tTHREE.ArrowHelper.prototype.constructor = THREE.ArrowHelper;\r\n\t\r\n\tTHREE.ArrowHelper.prototype.setDirection = ( function () {\r\n\t\r\n\t\tvar axis = new THREE.Vector3();\r\n\t\tvar radians;\r\n\t\r\n\t\treturn function setDirection( dir ) {\r\n\t\r\n\t\t\t// dir is assumed to be normalized\r\n\t\r\n\t\t\tif ( dir.y > 0.99999 ) {\r\n\t\r\n\t\t\t\tthis.quaternion.set( 0, 0, 0, 1 );\r\n\t\r\n\t\t\t} else if ( dir.y < - 0.99999 ) {\r\n\t\r\n\t\t\t\tthis.quaternion.set( 1, 0, 0, 0 );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\taxis.set( dir.z, 0, - dir.x ).normalize();\r\n\t\r\n\t\t\t\tradians = Math.acos( dir.y );\r\n\t\r\n\t\t\t\tthis.quaternion.setFromAxisAngle( axis, radians );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t}() );\r\n\t\r\n\tTHREE.ArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {\r\n\t\r\n\t\tif ( headLength === undefined ) headLength = 0.2 * length;\r\n\t\tif ( headWidth === undefined ) headWidth = 0.2 * headLength;\r\n\t\r\n\t\tthis.line.scale.set( 1, Math.max( 0, length - headLength ), 1 );\r\n\t\tthis.line.updateMatrix();\r\n\t\r\n\t\tthis.cone.scale.set( headWidth, headLength, headWidth );\r\n\t\tthis.cone.position.y = length;\r\n\t\tthis.cone.updateMatrix();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.ArrowHelper.prototype.setColor = function ( color ) {\r\n\t\r\n\t\tthis.line.material.color.set( color );\r\n\t\tthis.cone.material.color.set( color );\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/helpers/BoxHelper.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.BoxHelper = function ( object ) {\r\n\t\r\n\t\tvar indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );\r\n\t\tvar positions = new Float32Array( 8 * 3 );\r\n\t\r\n\t\tvar geometry = new THREE.BufferGeometry();\r\n\t\tgeometry.setIndex( new THREE.BufferAttribute( indices, 1 ) );\r\n\t\tgeometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );\r\n\t\r\n\t\tTHREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: 0xffff00 } ) );\r\n\t\r\n\t\tif ( object !== undefined ) {\r\n\t\r\n\t\t\tthis.update( object );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.BoxHelper.prototype = Object.create( THREE.LineSegments.prototype );\r\n\tTHREE.BoxHelper.prototype.constructor = THREE.BoxHelper;\r\n\t\r\n\tTHREE.BoxHelper.prototype.update = ( function () {\r\n\t\r\n\t\tvar box = new THREE.Box3();\r\n\t\r\n\t\treturn function ( object ) {\r\n\t\r\n\t\t\tif ( object instanceof THREE.Box3 ) {\r\n\t\r\n\t\t\t\tbox.copy( object );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tbox.setFromObject( object );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( box.isEmpty() ) return;\r\n\t\r\n\t\t\tvar min = box.min;\r\n\t\t\tvar max = box.max;\r\n\t\r\n\t\t\t/*\r\n\t\t\t  5____4\r\n\t\t\t1/___0/|\r\n\t\t\t| 6__|_7\r\n\t\t\t2/___3/\r\n\t\r\n\t\t\t0: max.x, max.y, max.z\r\n\t\t\t1: min.x, max.y, max.z\r\n\t\t\t2: min.x, min.y, max.z\r\n\t\t\t3: max.x, min.y, max.z\r\n\t\t\t4: max.x, max.y, min.z\r\n\t\t\t5: min.x, max.y, min.z\r\n\t\t\t6: min.x, min.y, min.z\r\n\t\t\t7: max.x, min.y, min.z\r\n\t\t\t*/\r\n\t\r\n\t\t\tvar position = this.geometry.attributes.position;\r\n\t\t\tvar array = position.array;\r\n\t\r\n\t\t\tarray[  0 ] = max.x; array[  1 ] = max.y; array[  2 ] = max.z;\r\n\t\t\tarray[  3 ] = min.x; array[  4 ] = max.y; array[  5 ] = max.z;\r\n\t\t\tarray[  6 ] = min.x; array[  7 ] = min.y; array[  8 ] = max.z;\r\n\t\t\tarray[  9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;\r\n\t\t\tarray[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;\r\n\t\t\tarray[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;\r\n\t\t\tarray[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;\r\n\t\t\tarray[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;\r\n\t\r\n\t\t\tposition.needsUpdate = true;\r\n\t\r\n\t\t\tthis.geometry.computeBoundingSphere();\r\n\t\r\n\t\t};\r\n\t\r\n\t} )();\r\n\t\r\n\t// File:src/extras/helpers/BoundingBoxHelper.js\r\n\t\r\n\t/**\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t */\r\n\t\r\n\t// a helper to show the world-axis-aligned bounding box for an object\r\n\t\r\n\tTHREE.BoundingBoxHelper = function ( object, hex ) {\r\n\t\r\n\t\tvar color = ( hex !== undefined ) ? hex : 0x888888;\r\n\t\r\n\t\tthis.object = object;\r\n\t\r\n\t\tthis.box = new THREE.Box3();\r\n\t\r\n\t\tTHREE.Mesh.call( this, new THREE.BoxGeometry( 1, 1, 1 ), new THREE.MeshBasicMaterial( { color: color, wireframe: true } ) );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.BoundingBoxHelper.prototype = Object.create( THREE.Mesh.prototype );\r\n\tTHREE.BoundingBoxHelper.prototype.constructor = THREE.BoundingBoxHelper;\r\n\t\r\n\tTHREE.BoundingBoxHelper.prototype.update = function () {\r\n\t\r\n\t\tthis.box.setFromObject( this.object );\r\n\t\r\n\t\tthis.box.size( this.scale );\r\n\t\r\n\t\tthis.box.center( this.position );\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/helpers/CameraHelper.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t *\r\n\t *\t- shows frustum, line of sight and up of the camera\r\n\t *\t- suitable for fast updates\r\n\t * \t- based on frustum visualization in lightgl.js shadowmap example\r\n\t *\t\thttp://evanw.github.com/lightgl.js/tests/shadowmap.html\r\n\t */\r\n\t\r\n\tTHREE.CameraHelper = function ( camera ) {\r\n\t\r\n\t\tvar geometry = new THREE.Geometry();\r\n\t\tvar material = new THREE.LineBasicMaterial( { color: 0xffffff, vertexColors: THREE.FaceColors } );\r\n\t\r\n\t\tvar pointMap = {};\r\n\t\r\n\t\t// colors\r\n\t\r\n\t\tvar hexFrustum = 0xffaa00;\r\n\t\tvar hexCone = 0xff0000;\r\n\t\tvar hexUp = 0x00aaff;\r\n\t\tvar hexTarget = 0xffffff;\r\n\t\tvar hexCross = 0x333333;\r\n\t\r\n\t\t// near\r\n\t\r\n\t\taddLine( \"n1\", \"n2\", hexFrustum );\r\n\t\taddLine( \"n2\", \"n4\", hexFrustum );\r\n\t\taddLine( \"n4\", \"n3\", hexFrustum );\r\n\t\taddLine( \"n3\", \"n1\", hexFrustum );\r\n\t\r\n\t\t// far\r\n\t\r\n\t\taddLine( \"f1\", \"f2\", hexFrustum );\r\n\t\taddLine( \"f2\", \"f4\", hexFrustum );\r\n\t\taddLine( \"f4\", \"f3\", hexFrustum );\r\n\t\taddLine( \"f3\", \"f1\", hexFrustum );\r\n\t\r\n\t\t// sides\r\n\t\r\n\t\taddLine( \"n1\", \"f1\", hexFrustum );\r\n\t\taddLine( \"n2\", \"f2\", hexFrustum );\r\n\t\taddLine( \"n3\", \"f3\", hexFrustum );\r\n\t\taddLine( \"n4\", \"f4\", hexFrustum );\r\n\t\r\n\t\t// cone\r\n\t\r\n\t\taddLine( \"p\", \"n1\", hexCone );\r\n\t\taddLine( \"p\", \"n2\", hexCone );\r\n\t\taddLine( \"p\", \"n3\", hexCone );\r\n\t\taddLine( \"p\", \"n4\", hexCone );\r\n\t\r\n\t\t// up\r\n\t\r\n\t\taddLine( \"u1\", \"u2\", hexUp );\r\n\t\taddLine( \"u2\", \"u3\", hexUp );\r\n\t\taddLine( \"u3\", \"u1\", hexUp );\r\n\t\r\n\t\t// target\r\n\t\r\n\t\taddLine( \"c\", \"t\", hexTarget );\r\n\t\taddLine( \"p\", \"c\", hexCross );\r\n\t\r\n\t\t// cross\r\n\t\r\n\t\taddLine( \"cn1\", \"cn2\", hexCross );\r\n\t\taddLine( \"cn3\", \"cn4\", hexCross );\r\n\t\r\n\t\taddLine( \"cf1\", \"cf2\", hexCross );\r\n\t\taddLine( \"cf3\", \"cf4\", hexCross );\r\n\t\r\n\t\tfunction addLine( a, b, hex ) {\r\n\t\r\n\t\t\taddPoint( a, hex );\r\n\t\t\taddPoint( b, hex );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction addPoint( id, hex ) {\r\n\t\r\n\t\t\tgeometry.vertices.push( new THREE.Vector3() );\r\n\t\t\tgeometry.colors.push( new THREE.Color( hex ) );\r\n\t\r\n\t\t\tif ( pointMap[ id ] === undefined ) {\r\n\t\r\n\t\t\t\tpointMap[ id ] = [];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tpointMap[ id ].push( geometry.vertices.length - 1 );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tTHREE.LineSegments.call( this, geometry, material );\r\n\t\r\n\t\tthis.camera = camera;\r\n\t\tthis.camera.updateProjectionMatrix();\r\n\t\r\n\t\tthis.matrix = camera.matrixWorld;\r\n\t\tthis.matrixAutoUpdate = false;\r\n\t\r\n\t\tthis.pointMap = pointMap;\r\n\t\r\n\t\tthis.update();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.CameraHelper.prototype = Object.create( THREE.LineSegments.prototype );\r\n\tTHREE.CameraHelper.prototype.constructor = THREE.CameraHelper;\r\n\t\r\n\tTHREE.CameraHelper.prototype.update = function () {\r\n\t\r\n\t\tvar geometry, pointMap;\r\n\t\r\n\t\tvar vector = new THREE.Vector3();\r\n\t\tvar camera = new THREE.Camera();\r\n\t\r\n\t\tfunction setPoint( point, x, y, z ) {\r\n\t\r\n\t\t\tvector.set( x, y, z ).unproject( camera );\r\n\t\r\n\t\t\tvar points = pointMap[ point ];\r\n\t\r\n\t\t\tif ( points !== undefined ) {\r\n\t\r\n\t\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\tgeometry.vertices[ points[ i ] ].copy( vector );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn function () {\r\n\t\r\n\t\t\tgeometry = this.geometry;\r\n\t\t\tpointMap = this.pointMap;\r\n\t\r\n\t\t\tvar w = 1, h = 1;\r\n\t\r\n\t\t\t// we need just camera projection matrix\r\n\t\t\t// world matrix must be identity\r\n\t\r\n\t\t\tcamera.projectionMatrix.copy( this.camera.projectionMatrix );\r\n\t\r\n\t\t\t// center / target\r\n\t\r\n\t\t\tsetPoint( \"c\", 0, 0, - 1 );\r\n\t\t\tsetPoint( \"t\", 0, 0,  1 );\r\n\t\r\n\t\t\t// near\r\n\t\r\n\t\t\tsetPoint( \"n1\", - w, - h, - 1 );\r\n\t\t\tsetPoint( \"n2\",   w, - h, - 1 );\r\n\t\t\tsetPoint( \"n3\", - w,   h, - 1 );\r\n\t\t\tsetPoint( \"n4\",   w,   h, - 1 );\r\n\t\r\n\t\t\t// far\r\n\t\r\n\t\t\tsetPoint( \"f1\", - w, - h, 1 );\r\n\t\t\tsetPoint( \"f2\",   w, - h, 1 );\r\n\t\t\tsetPoint( \"f3\", - w,   h, 1 );\r\n\t\t\tsetPoint( \"f4\",   w,   h, 1 );\r\n\t\r\n\t\t\t// up\r\n\t\r\n\t\t\tsetPoint( \"u1\",   w * 0.7, h * 1.1, - 1 );\r\n\t\t\tsetPoint( \"u2\", - w * 0.7, h * 1.1, - 1 );\r\n\t\t\tsetPoint( \"u3\",         0, h * 2,   - 1 );\r\n\t\r\n\t\t\t// cross\r\n\t\r\n\t\t\tsetPoint( \"cf1\", - w,   0, 1 );\r\n\t\t\tsetPoint( \"cf2\",   w,   0, 1 );\r\n\t\t\tsetPoint( \"cf3\",   0, - h, 1 );\r\n\t\t\tsetPoint( \"cf4\",   0,   h, 1 );\r\n\t\r\n\t\t\tsetPoint( \"cn1\", - w,   0, - 1 );\r\n\t\t\tsetPoint( \"cn2\",   w,   0, - 1 );\r\n\t\t\tsetPoint( \"cn3\",   0, - h, - 1 );\r\n\t\t\tsetPoint( \"cn4\",   0,   h, - 1 );\r\n\t\r\n\t\t\tgeometry.verticesNeedUpdate = true;\r\n\t\r\n\t\t};\r\n\t\r\n\t}();\r\n\t\r\n\t// File:src/extras/helpers/DirectionalLightHelper.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t */\r\n\t\r\n\tTHREE.DirectionalLightHelper = function ( light, size ) {\r\n\t\r\n\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\tthis.light = light;\r\n\t\tthis.light.updateMatrixWorld();\r\n\t\r\n\t\tthis.matrix = light.matrixWorld;\r\n\t\tthis.matrixAutoUpdate = false;\r\n\t\r\n\t\tsize = size || 1;\r\n\t\r\n\t\tvar geometry = new THREE.Geometry();\r\n\t\tgeometry.vertices.push(\r\n\t\t\tnew THREE.Vector3( - size,   size, 0 ),\r\n\t\t\tnew THREE.Vector3(   size,   size, 0 ),\r\n\t\t\tnew THREE.Vector3(   size, - size, 0 ),\r\n\t\t\tnew THREE.Vector3( - size, - size, 0 ),\r\n\t\t\tnew THREE.Vector3( - size,   size, 0 )\r\n\t\t);\r\n\t\r\n\t\tvar material = new THREE.LineBasicMaterial( { fog: false } );\r\n\t\tmaterial.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\t\r\n\t\tthis.lightPlane = new THREE.Line( geometry, material );\r\n\t\tthis.add( this.lightPlane );\r\n\t\r\n\t\tgeometry = new THREE.Geometry();\r\n\t\tgeometry.vertices.push(\r\n\t\t\tnew THREE.Vector3(),\r\n\t\t\tnew THREE.Vector3()\r\n\t\t);\r\n\t\r\n\t\tmaterial = new THREE.LineBasicMaterial( { fog: false } );\r\n\t\tmaterial.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\t\r\n\t\tthis.targetLine = new THREE.Line( geometry, material );\r\n\t\tthis.add( this.targetLine );\r\n\t\r\n\t\tthis.update();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.DirectionalLightHelper.prototype = Object.create( THREE.Object3D.prototype );\r\n\tTHREE.DirectionalLightHelper.prototype.constructor = THREE.DirectionalLightHelper;\r\n\t\r\n\tTHREE.DirectionalLightHelper.prototype.dispose = function () {\r\n\t\r\n\t\tthis.lightPlane.geometry.dispose();\r\n\t\tthis.lightPlane.material.dispose();\r\n\t\tthis.targetLine.geometry.dispose();\r\n\t\tthis.targetLine.material.dispose();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.DirectionalLightHelper.prototype.update = function () {\r\n\t\r\n\t\tvar v1 = new THREE.Vector3();\r\n\t\tvar v2 = new THREE.Vector3();\r\n\t\tvar v3 = new THREE.Vector3();\r\n\t\r\n\t\treturn function () {\r\n\t\r\n\t\t\tv1.setFromMatrixPosition( this.light.matrixWorld );\r\n\t\t\tv2.setFromMatrixPosition( this.light.target.matrixWorld );\r\n\t\t\tv3.subVectors( v2, v1 );\r\n\t\r\n\t\t\tthis.lightPlane.lookAt( v3 );\r\n\t\t\tthis.lightPlane.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\t\r\n\t\t\tthis.targetLine.geometry.vertices[ 1 ].copy( v3 );\r\n\t\t\tthis.targetLine.geometry.verticesNeedUpdate = true;\r\n\t\t\tthis.targetLine.material.color.copy( this.lightPlane.material.color );\r\n\t\r\n\t\t};\r\n\t\r\n\t}();\r\n\t\r\n\t// File:src/extras/helpers/EdgesHelper.js\r\n\t\r\n\t/**\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t * @param object THREE.Mesh whose geometry will be used\r\n\t * @param hex line color\r\n\t * @param thresholdAngle the minimum angle (in degrees),\r\n\t * between the face normals of adjacent faces,\r\n\t * that is required to render an edge. A value of 10 means\r\n\t * an edge is only rendered if the angle is at least 10 degrees.\r\n\t */\r\n\t\r\n\tTHREE.EdgesHelper = function ( object, hex, thresholdAngle ) {\r\n\t\r\n\t\tvar color = ( hex !== undefined ) ? hex : 0xffffff;\r\n\t\r\n\t\tTHREE.LineSegments.call( this, new THREE.EdgesGeometry( object.geometry, thresholdAngle ), new THREE.LineBasicMaterial( { color: color } ) );\r\n\t\r\n\t\tthis.matrix = object.matrixWorld;\r\n\t\tthis.matrixAutoUpdate = false;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.EdgesHelper.prototype = Object.create( THREE.LineSegments.prototype );\r\n\tTHREE.EdgesHelper.prototype.constructor = THREE.EdgesHelper;\r\n\t\r\n\t// File:src/extras/helpers/FaceNormalsHelper.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t*/\r\n\t\r\n\tTHREE.FaceNormalsHelper = function ( object, size, hex, linewidth ) {\r\n\t\r\n\t\t// FaceNormalsHelper only supports THREE.Geometry\r\n\t\r\n\t\tthis.object = object;\r\n\t\r\n\t\tthis.size = ( size !== undefined ) ? size : 1;\r\n\t\r\n\t\tvar color = ( hex !== undefined ) ? hex : 0xffff00;\r\n\t\r\n\t\tvar width = ( linewidth !== undefined ) ? linewidth : 1;\r\n\t\r\n\t\t//\r\n\t\r\n\t\tvar nNormals = 0;\r\n\t\r\n\t\tvar objGeometry = this.object.geometry;\r\n\t\r\n\t\tif ( objGeometry instanceof THREE.Geometry ) {\r\n\t\r\n\t\t\tnNormals = objGeometry.faces.length;\r\n\t\r\n\t\t} else {\r\n\t\r\n\t\t\tconsole.warn( 'THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.' );\r\n\t\r\n\t\t}\r\n\t\r\n\t\t//\r\n\t\r\n\t\tvar geometry = new THREE.BufferGeometry();\r\n\t\r\n\t\tvar positions = new THREE.Float32Attribute( nNormals * 2 * 3, 3 );\r\n\t\r\n\t\tgeometry.addAttribute( 'position', positions );\r\n\t\r\n\t\tTHREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ) );\r\n\t\r\n\t\t//\r\n\t\r\n\t\tthis.matrixAutoUpdate = false;\r\n\t\tthis.update();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.FaceNormalsHelper.prototype = Object.create( THREE.LineSegments.prototype );\r\n\tTHREE.FaceNormalsHelper.prototype.constructor = THREE.FaceNormalsHelper;\r\n\t\r\n\tTHREE.FaceNormalsHelper.prototype.update = ( function () {\r\n\t\r\n\t\tvar v1 = new THREE.Vector3();\r\n\t\tvar v2 = new THREE.Vector3();\r\n\t\tvar normalMatrix = new THREE.Matrix3();\r\n\t\r\n\t\treturn function update() {\r\n\t\r\n\t\t\tthis.object.updateMatrixWorld( true );\r\n\t\r\n\t\t\tnormalMatrix.getNormalMatrix( this.object.matrixWorld );\r\n\t\r\n\t\t\tvar matrixWorld = this.object.matrixWorld;\r\n\t\r\n\t\t\tvar position = this.geometry.attributes.position;\r\n\t\r\n\t\t\t//\r\n\t\r\n\t\t\tvar objGeometry = this.object.geometry;\r\n\t\r\n\t\t\tvar vertices = objGeometry.vertices;\r\n\t\r\n\t\t\tvar faces = objGeometry.faces;\r\n\t\r\n\t\t\tvar idx = 0;\r\n\t\r\n\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tvar face = faces[ i ];\r\n\t\r\n\t\t\t\tvar normal = face.normal;\r\n\t\r\n\t\t\t\tv1.copy( vertices[ face.a ] )\r\n\t\t\t\t\t.add( vertices[ face.b ] )\r\n\t\t\t\t\t.add( vertices[ face.c ] )\r\n\t\t\t\t\t.divideScalar( 3 )\r\n\t\t\t\t\t.applyMatrix4( matrixWorld );\r\n\t\r\n\t\t\t\tv2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\r\n\t\r\n\t\t\t\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\r\n\t\r\n\t\t\t\tidx = idx + 1;\r\n\t\r\n\t\t\t\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\r\n\t\r\n\t\t\t\tidx = idx + 1;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tposition.needsUpdate = true;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t}\r\n\t\r\n\t}() );\r\n\t\r\n\t// File:src/extras/helpers/GridHelper.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.GridHelper = function ( size, step ) {\r\n\t\r\n\t\tvar geometry = new THREE.Geometry();\r\n\t\tvar material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );\r\n\t\r\n\t\tthis.color1 = new THREE.Color( 0x444444 );\r\n\t\tthis.color2 = new THREE.Color( 0x888888 );\r\n\t\r\n\t\tfor ( var i = - size; i <= size; i += step ) {\r\n\t\r\n\t\t\tgeometry.vertices.push(\r\n\t\t\t\tnew THREE.Vector3( - size, 0, i ), new THREE.Vector3( size, 0, i ),\r\n\t\t\t\tnew THREE.Vector3( i, 0, - size ), new THREE.Vector3( i, 0, size )\r\n\t\t\t);\r\n\t\r\n\t\t\tvar color = i === 0 ? this.color1 : this.color2;\r\n\t\r\n\t\t\tgeometry.colors.push( color, color, color, color );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tTHREE.LineSegments.call( this, geometry, material );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.GridHelper.prototype = Object.create( THREE.LineSegments.prototype );\r\n\tTHREE.GridHelper.prototype.constructor = THREE.GridHelper;\r\n\t\r\n\tTHREE.GridHelper.prototype.setColors = function( colorCenterLine, colorGrid ) {\r\n\t\r\n\t\tthis.color1.set( colorCenterLine );\r\n\t\tthis.color2.set( colorGrid );\r\n\t\r\n\t\tthis.geometry.colorsNeedUpdate = true;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/helpers/HemisphereLightHelper.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.HemisphereLightHelper = function ( light, sphereSize ) {\r\n\t\r\n\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\tthis.light = light;\r\n\t\tthis.light.updateMatrixWorld();\r\n\t\r\n\t\tthis.matrix = light.matrixWorld;\r\n\t\tthis.matrixAutoUpdate = false;\r\n\t\r\n\t\tthis.colors = [ new THREE.Color(), new THREE.Color() ];\r\n\t\r\n\t\tvar geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );\r\n\t\tgeometry.rotateX( - Math.PI / 2 );\r\n\t\r\n\t\tfor ( var i = 0, il = 8; i < il; i ++ ) {\r\n\t\r\n\t\t\tgeometry.faces[ i ].color = this.colors[ i < 4 ? 0 : 1 ];\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar material = new THREE.MeshBasicMaterial( { vertexColors: THREE.FaceColors, wireframe: true } );\r\n\t\r\n\t\tthis.lightSphere = new THREE.Mesh( geometry, material );\r\n\t\tthis.add( this.lightSphere );\r\n\t\r\n\t\tthis.update();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.HemisphereLightHelper.prototype = Object.create( THREE.Object3D.prototype );\r\n\tTHREE.HemisphereLightHelper.prototype.constructor = THREE.HemisphereLightHelper;\r\n\t\r\n\tTHREE.HemisphereLightHelper.prototype.dispose = function () {\r\n\t\r\n\t\tthis.lightSphere.geometry.dispose();\r\n\t\tthis.lightSphere.material.dispose();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.HemisphereLightHelper.prototype.update = function () {\r\n\t\r\n\t\tvar vector = new THREE.Vector3();\r\n\t\r\n\t\treturn function () {\r\n\t\r\n\t\t\tthis.colors[ 0 ].copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\t\t\tthis.colors[ 1 ].copy( this.light.groundColor ).multiplyScalar( this.light.intensity );\r\n\t\r\n\t\t\tthis.lightSphere.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );\r\n\t\t\tthis.lightSphere.geometry.colorsNeedUpdate = true;\r\n\t\r\n\t\t}\r\n\t\r\n\t}();\r\n\t\r\n\t// File:src/extras/helpers/PointLightHelper.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.PointLightHelper = function ( light, sphereSize ) {\r\n\t\r\n\t\tthis.light = light;\r\n\t\tthis.light.updateMatrixWorld();\r\n\t\r\n\t\tvar geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );\r\n\t\tvar material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );\r\n\t\tmaterial.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\t\r\n\t\tTHREE.Mesh.call( this, geometry, material );\r\n\t\r\n\t\tthis.matrix = this.light.matrixWorld;\r\n\t\tthis.matrixAutoUpdate = false;\r\n\t\r\n\t\t/*\r\n\t\tvar distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );\r\n\t\tvar distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );\r\n\t\r\n\t\tthis.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );\r\n\t\tthis.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );\r\n\t\r\n\t\tvar d = light.distance;\r\n\t\r\n\t\tif ( d === 0.0 ) {\r\n\t\r\n\t\t\tthis.lightDistance.visible = false;\r\n\t\r\n\t\t} else {\r\n\t\r\n\t\t\tthis.lightDistance.scale.set( d, d, d );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.add( this.lightDistance );\r\n\t\t*/\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.PointLightHelper.prototype = Object.create( THREE.Mesh.prototype );\r\n\tTHREE.PointLightHelper.prototype.constructor = THREE.PointLightHelper;\r\n\t\r\n\tTHREE.PointLightHelper.prototype.dispose = function () {\r\n\t\r\n\t\tthis.geometry.dispose();\r\n\t\tthis.material.dispose();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.PointLightHelper.prototype.update = function () {\r\n\t\r\n\t\tthis.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\t\r\n\t\t/*\r\n\t\tvar d = this.light.distance;\r\n\t\r\n\t\tif ( d === 0.0 ) {\r\n\t\r\n\t\t\tthis.lightDistance.visible = false;\r\n\t\r\n\t\t} else {\r\n\t\r\n\t\t\tthis.lightDistance.visible = true;\r\n\t\t\tthis.lightDistance.scale.set( d, d, d );\r\n\t\r\n\t\t}\r\n\t\t*/\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/helpers/SkeletonHelper.js\r\n\t\r\n\t/**\r\n\t * @author Sean Griffin / http://twitter.com/sgrif\r\n\t * @author Michael Guerrero / http://realitymeltdown.com\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author ikerr / http://verold.com\r\n\t */\r\n\t\r\n\tTHREE.SkeletonHelper = function ( object ) {\r\n\t\r\n\t\tthis.bones = this.getBoneList( object );\r\n\t\r\n\t\tvar geometry = new THREE.Geometry();\r\n\t\r\n\t\tfor ( var i = 0; i < this.bones.length; i ++ ) {\r\n\t\r\n\t\t\tvar bone = this.bones[ i ];\r\n\t\r\n\t\t\tif ( bone.parent instanceof THREE.Bone ) {\r\n\t\r\n\t\t\t\tgeometry.vertices.push( new THREE.Vector3() );\r\n\t\t\t\tgeometry.vertices.push( new THREE.Vector3() );\r\n\t\t\t\tgeometry.colors.push( new THREE.Color( 0, 0, 1 ) );\r\n\t\t\t\tgeometry.colors.push( new THREE.Color( 0, 1, 0 ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tgeometry.dynamic = true;\r\n\t\r\n\t\tvar material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors, depthTest: false, depthWrite: false, transparent: true } );\r\n\t\r\n\t\tTHREE.LineSegments.call( this, geometry, material );\r\n\t\r\n\t\tthis.root = object;\r\n\t\r\n\t\tthis.matrix = object.matrixWorld;\r\n\t\tthis.matrixAutoUpdate = false;\r\n\t\r\n\t\tthis.update();\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\tTHREE.SkeletonHelper.prototype = Object.create( THREE.LineSegments.prototype );\r\n\tTHREE.SkeletonHelper.prototype.constructor = THREE.SkeletonHelper;\r\n\t\r\n\tTHREE.SkeletonHelper.prototype.getBoneList = function( object ) {\r\n\t\r\n\t\tvar boneList = [];\r\n\t\r\n\t\tif ( object instanceof THREE.Bone ) {\r\n\t\r\n\t\t\tboneList.push( object );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfor ( var i = 0; i < object.children.length; i ++ ) {\r\n\t\r\n\t\t\tboneList.push.apply( boneList, this.getBoneList( object.children[ i ] ) );\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn boneList;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.SkeletonHelper.prototype.update = function () {\r\n\t\r\n\t\tvar geometry = this.geometry;\r\n\t\r\n\t\tvar matrixWorldInv = new THREE.Matrix4().getInverse( this.root.matrixWorld );\r\n\t\r\n\t\tvar boneMatrix = new THREE.Matrix4();\r\n\t\r\n\t\tvar j = 0;\r\n\t\r\n\t\tfor ( var i = 0; i < this.bones.length; i ++ ) {\r\n\t\r\n\t\t\tvar bone = this.bones[ i ];\r\n\t\r\n\t\t\tif ( bone.parent instanceof THREE.Bone ) {\r\n\t\r\n\t\t\t\tboneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );\r\n\t\t\t\tgeometry.vertices[ j ].setFromMatrixPosition( boneMatrix );\r\n\t\r\n\t\t\t\tboneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );\r\n\t\t\t\tgeometry.vertices[ j + 1 ].setFromMatrixPosition( boneMatrix );\r\n\t\r\n\t\t\t\tj += 2;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tgeometry.verticesNeedUpdate = true;\r\n\t\r\n\t\tgeometry.computeBoundingSphere();\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/helpers/SpotLightHelper.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t*/\r\n\t\r\n\tTHREE.SpotLightHelper = function ( light ) {\r\n\t\r\n\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\tthis.light = light;\r\n\t\tthis.light.updateMatrixWorld();\r\n\t\r\n\t\tthis.matrix = light.matrixWorld;\r\n\t\tthis.matrixAutoUpdate = false;\r\n\t\r\n\t\tvar geometry = new THREE.BufferGeometry();\r\n\t\r\n\t\tvar positions = [\r\n\t\t\t0, 0, 0,   0,   0,   1,\r\n\t\t\t0, 0, 0,   1,   0,   1,\r\n\t\t\t0, 0, 0, - 1,   0,   1,\r\n\t\t\t0, 0, 0,   0,   1,   1,\r\n\t\t\t0, 0, 0,   0, - 1,   1\r\n\t\t];\r\n\t\r\n\t\tfor ( var i = 0, j = 1, l = 32; i < l; i ++, j ++ ) {\r\n\t\r\n\t\t\tvar p1 = ( i / l ) * Math.PI * 2;\r\n\t\t\tvar p2 = ( j / l ) * Math.PI * 2;\r\n\t\r\n\t\t\tpositions.push(\r\n\t\t\t\tMath.cos( p1 ), Math.sin( p1 ), 1,\r\n\t\t\t\tMath.cos( p2 ), Math.sin( p2 ), 1\r\n\t\t\t);\r\n\t\r\n\t\t}\r\n\t\r\n\t\tgeometry.addAttribute( 'position', new THREE.Float32Attribute( positions, 3 ) );\r\n\t\r\n\t\tvar material = new THREE.LineBasicMaterial( { fog: false } );\r\n\t\r\n\t\tthis.cone = new THREE.LineSegments( geometry, material );\r\n\t\tthis.add( this.cone );\r\n\t\r\n\t\tthis.update();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.SpotLightHelper.prototype = Object.create( THREE.Object3D.prototype );\r\n\tTHREE.SpotLightHelper.prototype.constructor = THREE.SpotLightHelper;\r\n\t\r\n\tTHREE.SpotLightHelper.prototype.dispose = function () {\r\n\t\r\n\t\tthis.cone.geometry.dispose();\r\n\t\tthis.cone.material.dispose();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.SpotLightHelper.prototype.update = function () {\r\n\t\r\n\t\tvar vector = new THREE.Vector3();\r\n\t\tvar vector2 = new THREE.Vector3();\r\n\t\r\n\t\treturn function () {\r\n\t\r\n\t\t\tvar coneLength = this.light.distance ? this.light.distance : 1000;\r\n\t\t\tvar coneWidth = coneLength * Math.tan( this.light.angle );\r\n\t\r\n\t\t\tthis.cone.scale.set( coneWidth, coneWidth, coneLength );\r\n\t\r\n\t\t\tvector.setFromMatrixPosition( this.light.matrixWorld );\r\n\t\t\tvector2.setFromMatrixPosition( this.light.target.matrixWorld );\r\n\t\r\n\t\t\tthis.cone.lookAt( vector2.sub( vector ) );\r\n\t\r\n\t\t\tthis.cone.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\t\r\n\t\t};\r\n\t\r\n\t}();\r\n\t\r\n\t// File:src/extras/helpers/VertexNormalsHelper.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t*/\r\n\t\r\n\tTHREE.VertexNormalsHelper = function ( object, size, hex, linewidth ) {\r\n\t\r\n\t\tthis.object = object;\r\n\t\r\n\t\tthis.size = ( size !== undefined ) ? size : 1;\r\n\t\r\n\t\tvar color = ( hex !== undefined ) ? hex : 0xff0000;\r\n\t\r\n\t\tvar width = ( linewidth !== undefined ) ? linewidth : 1;\r\n\t\r\n\t\t//\r\n\t\r\n\t\tvar nNormals = 0;\r\n\t\r\n\t\tvar objGeometry = this.object.geometry;\r\n\t\r\n\t\tif ( objGeometry instanceof THREE.Geometry ) {\r\n\t\r\n\t\t\tnNormals = objGeometry.faces.length * 3;\r\n\t\r\n\t\t} else if ( objGeometry instanceof THREE.BufferGeometry ) {\r\n\t\r\n\t\t\tnNormals = objGeometry.attributes.normal.count\r\n\t\r\n\t\t}\r\n\t\r\n\t\t//\r\n\t\r\n\t\tvar geometry = new THREE.BufferGeometry();\r\n\t\r\n\t\tvar positions = new THREE.Float32Attribute( nNormals * 2 * 3, 3 );\r\n\t\r\n\t\tgeometry.addAttribute( 'position', positions );\r\n\t\r\n\t\tTHREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ) );\r\n\t\r\n\t\t//\r\n\t\r\n\t\tthis.matrixAutoUpdate = false;\r\n\t\r\n\t\tthis.update();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.VertexNormalsHelper.prototype = Object.create( THREE.LineSegments.prototype );\r\n\tTHREE.VertexNormalsHelper.prototype.constructor = THREE.VertexNormalsHelper;\r\n\t\r\n\tTHREE.VertexNormalsHelper.prototype.update = ( function () {\r\n\t\r\n\t\tvar v1 = new THREE.Vector3();\r\n\t\tvar v2 = new THREE.Vector3();\r\n\t\tvar normalMatrix = new THREE.Matrix3();\r\n\t\r\n\t\treturn function update() {\r\n\t\r\n\t\t\tvar keys = [ 'a', 'b', 'c' ];\r\n\t\r\n\t\t\tthis.object.updateMatrixWorld( true );\r\n\t\r\n\t\t\tnormalMatrix.getNormalMatrix( this.object.matrixWorld );\r\n\t\r\n\t\t\tvar matrixWorld = this.object.matrixWorld;\r\n\t\r\n\t\t\tvar position = this.geometry.attributes.position;\r\n\t\r\n\t\t\t//\r\n\t\r\n\t\t\tvar objGeometry = this.object.geometry;\r\n\t\r\n\t\t\tif ( objGeometry instanceof THREE.Geometry ) {\r\n\t\r\n\t\t\t\tvar vertices = objGeometry.vertices;\r\n\t\r\n\t\t\t\tvar faces = objGeometry.faces;\r\n\t\r\n\t\t\t\tvar idx = 0;\r\n\t\r\n\t\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\tvar face = faces[ i ];\r\n\t\r\n\t\t\t\t\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\r\n\t\r\n\t\t\t\t\t\tvar vertex = vertices[ face[ keys[ j ] ] ];\r\n\t\r\n\t\t\t\t\t\tvar normal = face.vertexNormals[ j ];\r\n\t\r\n\t\t\t\t\t\tv1.copy( vertex ).applyMatrix4( matrixWorld );\r\n\t\r\n\t\t\t\t\t\tv2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\r\n\t\r\n\t\t\t\t\t\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\r\n\t\r\n\t\t\t\t\t\tidx = idx + 1;\r\n\t\r\n\t\t\t\t\t\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\r\n\t\r\n\t\t\t\t\t\tidx = idx + 1;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else if ( objGeometry instanceof THREE.BufferGeometry ) {\r\n\t\r\n\t\t\t\tvar objPos = objGeometry.attributes.position;\r\n\t\r\n\t\t\t\tvar objNorm = objGeometry.attributes.normal;\r\n\t\r\n\t\t\t\tvar idx = 0;\r\n\t\r\n\t\t\t\t// for simplicity, ignore index and drawcalls, and render every normal\r\n\t\r\n\t\t\t\tfor ( var j = 0, jl = objPos.count; j < jl; j ++ ) {\r\n\t\r\n\t\t\t\t\tv1.set( objPos.getX( j ), objPos.getY( j ), objPos.getZ( j ) ).applyMatrix4( matrixWorld );\r\n\t\r\n\t\t\t\t\tv2.set( objNorm.getX( j ), objNorm.getY( j ), objNorm.getZ( j ) );\r\n\t\r\n\t\t\t\t\tv2.applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\r\n\t\r\n\t\t\t\t\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\r\n\t\r\n\t\t\t\t\tidx = idx + 1;\r\n\t\r\n\t\t\t\t\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\r\n\t\r\n\t\t\t\t\tidx = idx + 1;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tposition.needsUpdate = true;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t}\r\n\t\r\n\t}() );\r\n\t\r\n\t// File:src/extras/helpers/WireframeHelper.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.WireframeHelper = function ( object, hex ) {\r\n\t\r\n\t\tvar color = ( hex !== undefined ) ? hex : 0xffffff;\r\n\t\r\n\t\tTHREE.LineSegments.call( this, new THREE.WireframeGeometry( object.geometry ), new THREE.LineBasicMaterial( { color: color } ) );\r\n\t\r\n\t\tthis.matrix = object.matrixWorld;\r\n\t\tthis.matrixAutoUpdate = false;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.WireframeHelper.prototype = Object.create( THREE.LineSegments.prototype );\r\n\tTHREE.WireframeHelper.prototype.constructor = THREE.WireframeHelper;\r\n\t\r\n\t// File:src/extras/objects/ImmediateRenderObject.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.ImmediateRenderObject = function ( material ) {\r\n\t\r\n\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\tthis.material = material;\r\n\t\tthis.render = function ( renderCallback ) {};\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.ImmediateRenderObject.prototype = Object.create( THREE.Object3D.prototype );\r\n\tTHREE.ImmediateRenderObject.prototype.constructor = THREE.ImmediateRenderObject;\r\n\t\r\n\t// File:src/extras/objects/MorphBlendMesh.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.MorphBlendMesh = function( geometry, material ) {\r\n\t\r\n\t\tTHREE.Mesh.call( this, geometry, material );\r\n\t\r\n\t\tthis.animationsMap = {};\r\n\t\tthis.animationsList = [];\r\n\t\r\n\t\t// prepare default animation\r\n\t\t// (all frames played together in 1 second)\r\n\t\r\n\t\tvar numFrames = this.geometry.morphTargets.length;\r\n\t\r\n\t\tvar name = \"__default\";\r\n\t\r\n\t\tvar startFrame = 0;\r\n\t\tvar endFrame = numFrames - 1;\r\n\t\r\n\t\tvar fps = numFrames / 1;\r\n\t\r\n\t\tthis.createAnimation( name, startFrame, endFrame, fps );\r\n\t\tthis.setAnimationWeight( name, 1 );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MorphBlendMesh.prototype = Object.create( THREE.Mesh.prototype );\r\n\tTHREE.MorphBlendMesh.prototype.constructor = THREE.MorphBlendMesh;\r\n\t\r\n\tTHREE.MorphBlendMesh.prototype.createAnimation = function ( name, start, end, fps ) {\r\n\t\r\n\t\tvar animation = {\r\n\t\r\n\t\t\tstart: start,\r\n\t\t\tend: end,\r\n\t\r\n\t\t\tlength: end - start + 1,\r\n\t\r\n\t\t\tfps: fps,\r\n\t\t\tduration: ( end - start ) / fps,\r\n\t\r\n\t\t\tlastFrame: 0,\r\n\t\t\tcurrentFrame: 0,\r\n\t\r\n\t\t\tactive: false,\r\n\t\r\n\t\t\ttime: 0,\r\n\t\t\tdirection: 1,\r\n\t\t\tweight: 1,\r\n\t\r\n\t\t\tdirectionBackwards: false,\r\n\t\t\tmirroredLoop: false\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.animationsMap[ name ] = animation;\r\n\t\tthis.animationsList.push( animation );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MorphBlendMesh.prototype.autoCreateAnimations = function ( fps ) {\r\n\t\r\n\t\tvar pattern = /([a-z]+)_?(\\d+)/i;\r\n\t\r\n\t\tvar firstAnimation, frameRanges = {};\r\n\t\r\n\t\tvar geometry = this.geometry;\r\n\t\r\n\t\tfor ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {\r\n\t\r\n\t\t\tvar morph = geometry.morphTargets[ i ];\r\n\t\t\tvar chunks = morph.name.match( pattern );\r\n\t\r\n\t\t\tif ( chunks && chunks.length > 1 ) {\r\n\t\r\n\t\t\t\tvar name = chunks[ 1 ];\r\n\t\r\n\t\t\t\tif ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: - Infinity };\r\n\t\r\n\t\t\t\tvar range = frameRanges[ name ];\r\n\t\r\n\t\t\t\tif ( i < range.start ) range.start = i;\r\n\t\t\t\tif ( i > range.end ) range.end = i;\r\n\t\r\n\t\t\t\tif ( ! firstAnimation ) firstAnimation = name;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfor ( var name in frameRanges ) {\r\n\t\r\n\t\t\tvar range = frameRanges[ name ];\r\n\t\t\tthis.createAnimation( name, range.start, range.end, fps );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.firstAnimation = firstAnimation;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function ( name ) {\r\n\t\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\t\r\n\t\tif ( animation ) {\r\n\t\r\n\t\t\tanimation.direction = 1;\r\n\t\t\tanimation.directionBackwards = false;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function ( name ) {\r\n\t\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\t\r\n\t\tif ( animation ) {\r\n\t\r\n\t\t\tanimation.direction = - 1;\r\n\t\t\tanimation.directionBackwards = true;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MorphBlendMesh.prototype.setAnimationFPS = function ( name, fps ) {\r\n\t\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\t\r\n\t\tif ( animation ) {\r\n\t\r\n\t\t\tanimation.fps = fps;\r\n\t\t\tanimation.duration = ( animation.end - animation.start ) / animation.fps;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MorphBlendMesh.prototype.setAnimationDuration = function ( name, duration ) {\r\n\t\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\t\r\n\t\tif ( animation ) {\r\n\t\r\n\t\t\tanimation.duration = duration;\r\n\t\t\tanimation.fps = ( animation.end - animation.start ) / animation.duration;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MorphBlendMesh.prototype.setAnimationWeight = function ( name, weight ) {\r\n\t\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\t\r\n\t\tif ( animation ) {\r\n\t\r\n\t\t\tanimation.weight = weight;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MorphBlendMesh.prototype.setAnimationTime = function ( name, time ) {\r\n\t\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\t\r\n\t\tif ( animation ) {\r\n\t\r\n\t\t\tanimation.time = time;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MorphBlendMesh.prototype.getAnimationTime = function ( name ) {\r\n\t\r\n\t\tvar time = 0;\r\n\t\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\t\r\n\t\tif ( animation ) {\r\n\t\r\n\t\t\ttime = animation.time;\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn time;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MorphBlendMesh.prototype.getAnimationDuration = function ( name ) {\r\n\t\r\n\t\tvar duration = - 1;\r\n\t\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\t\r\n\t\tif ( animation ) {\r\n\t\r\n\t\t\tduration = animation.duration;\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn duration;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MorphBlendMesh.prototype.playAnimation = function ( name ) {\r\n\t\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\t\r\n\t\tif ( animation ) {\r\n\t\r\n\t\t\tanimation.time = 0;\r\n\t\t\tanimation.active = true;\r\n\t\r\n\t\t} else {\r\n\t\r\n\t\t\tconsole.warn( \"THREE.MorphBlendMesh: animation[\" + name + \"] undefined in .playAnimation()\" );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MorphBlendMesh.prototype.stopAnimation = function ( name ) {\r\n\t\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\t\r\n\t\tif ( animation ) {\r\n\t\r\n\t\t\tanimation.active = false;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MorphBlendMesh.prototype.update = function ( delta ) {\r\n\t\r\n\t\tfor ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {\r\n\t\r\n\t\t\tvar animation = this.animationsList[ i ];\r\n\t\r\n\t\t\tif ( ! animation.active ) continue;\r\n\t\r\n\t\t\tvar frameTime = animation.duration / animation.length;\r\n\t\r\n\t\t\tanimation.time += animation.direction * delta;\r\n\t\r\n\t\t\tif ( animation.mirroredLoop ) {\r\n\t\r\n\t\t\t\tif ( animation.time > animation.duration || animation.time < 0 ) {\r\n\t\r\n\t\t\t\t\tanimation.direction *= - 1;\r\n\t\r\n\t\t\t\t\tif ( animation.time > animation.duration ) {\r\n\t\r\n\t\t\t\t\t\tanimation.time = animation.duration;\r\n\t\t\t\t\t\tanimation.directionBackwards = true;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( animation.time < 0 ) {\r\n\t\r\n\t\t\t\t\t\tanimation.time = 0;\r\n\t\t\t\t\t\tanimation.directionBackwards = false;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tanimation.time = animation.time % animation.duration;\r\n\t\r\n\t\t\t\tif ( animation.time < 0 ) animation.time += animation.duration;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar keyframe = animation.start + THREE.Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );\r\n\t\t\tvar weight = animation.weight;\r\n\t\r\n\t\t\tif ( keyframe !== animation.currentFrame ) {\r\n\t\r\n\t\t\t\tthis.morphTargetInfluences[ animation.lastFrame ] = 0;\r\n\t\t\t\tthis.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;\r\n\t\r\n\t\t\t\tthis.morphTargetInfluences[ keyframe ] = 0;\r\n\t\r\n\t\t\t\tanimation.lastFrame = animation.currentFrame;\r\n\t\t\t\tanimation.currentFrame = keyframe;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar mix = ( animation.time % frameTime ) / frameTime;\r\n\t\r\n\t\t\tif ( animation.directionBackwards ) mix = 1 - mix;\r\n\t\r\n\t\t\tif ( animation.currentFrame !== animation.lastFrame ) {\r\n\t\r\n\t\t\t\tthis.morphTargetInfluences[ animation.currentFrame ] = mix * weight;\r\n\t\t\t\tthis.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tthis.morphTargetInfluences[ animation.currentFrame ] = weight;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\t// Export the THREE object for **Node.js**, with\r\n\t// backwards-compatibility for the old `require()` API. If we're in\r\n\t// the browser, add `_` as a global object via a string identifier,\r\n\t// for Closure Compiler \"advanced\" mode.\r\n\tif (true) {\r\n\t  if (typeof module !== 'undefined' && module.exports) {\r\n\t    exports = module.exports = THREE;\r\n\t  }\r\n\t  exports.THREE = THREE;\r\n\t} else {\r\n\t  this['THREE'] = THREE;\r\n\t}\r\n\n\n/***/ },\n/* 62 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _getPrototypeOf = __webpack_require__(63);\n\t\n\tvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\t\n\tvar _classCallCheck2 = __webpack_require__(54);\n\t\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\t\n\tvar _possibleConstructorReturn2 = __webpack_require__(67);\n\t\n\tvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\t\n\tvar _inherits2 = __webpack_require__(88);\n\t\n\tvar _inherits3 = _interopRequireDefault(_inherits2);\n\t\n\tvar _three = __webpack_require__(61);\n\t\n\tvar _three2 = _interopRequireDefault(_three);\n\t\n\tvar _refractionF = __webpack_require__(96);\n\t\n\tvar _refractionF2 = _interopRequireDefault(_refractionF);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar bump = __webpack_require__(97);\n\t\n\tvar Particle = function (_THREE$Mesh) {\n\t    (0, _inherits3.default)(Particle, _THREE$Mesh);\n\t\n\t    function Particle() {\n\t        (0, _classCallCheck3.default)(this, Particle);\n\t\n\t        var geo = new _three2.default.CylinderBufferGeometry(0, 30, 500, 30, 30, true);\n\t        geo.translate(0, 250, 0);\n\t\n\t        var renderTarget = new _three2.default.WebGLRenderTarget(512, 512, { depthBuffer: false, stencilBuffer: false });\n\t\n\t        var mat = new _three2.default.ShaderMaterial({\n\t            uniforms: {\n\t                tex_bump: { value: new _three2.default.TextureLoader().load(bump) },\n\t                tex_scene: { value: renderTarget },\n\t                vScale: { value: new _three2.default.Vector2(0.03, 0.03) },\n\t                resolution: { value: new _three2.default.Vector2(window.innerWidth, window.innerHeight) },\n\t                emissive: { value: new _three2.default.Color(0xFF4400) },\n\t                emissiveMap: { value: new _three2.default.TextureLoader().load(bump) },\n\t                refraction: { value: 0.45 },\n\t                opacity: { value: 0.9 },\n\t                offset: { value: new _three2.default.Vector2(0, 0) },\n\t                fresnelMix: { value: 1 },\n\t                fresnelBias: { value: 0.2 },\n\t                fresnelPow: { value: 5 }\n\t            },\n\t            vertexShader: ['varying vec2 vUv;', 'varying vec3 vEye;', 'varying vec3 vWorldNormal;', 'void main() {', 'vUv = uv;', 'vec4 p = vec4( position, 1. );', 'vEye = normalize( vec3( modelViewMatrix * p ));', 'vWorldNormal = normalize( normalMatrix * normal );', 'gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n\t            fragmentShader: _refractionF2.default\n\t        });\n\t        mat.transparent = true;\n\t\n\t        var _this = (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(Particle).call(this, geo, mat));\n\t\n\t        _this.renderTarget = renderTarget;\n\t        _this.material = mat;\n\t        return _this;\n\t    }\n\t\n\t    return Particle;\n\t}(_three2.default.Mesh);\n\t\n\texports.default = Particle;\n\n/***/ },\n/* 63 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = { \"default\": __webpack_require__(64), __esModule: true };\n\n/***/ },\n/* 64 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(65);\n\tmodule.exports = __webpack_require__(16).Object.getPrototypeOf;\n\n/***/ },\n/* 65 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 19.1.2.9 Object.getPrototypeOf(O)\n\tvar toObject        = __webpack_require__(48)\n\t  , $getPrototypeOf = __webpack_require__(47);\n\t\n\t__webpack_require__(66)('getPrototypeOf', function(){\n\t  return function getPrototypeOf(it){\n\t    return $getPrototypeOf(toObject(it));\n\t  };\n\t});\n\n/***/ },\n/* 66 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// most Object methods by ES6 should accept primitives\n\tvar $export = __webpack_require__(14)\n\t  , core    = __webpack_require__(16)\n\t  , fails   = __webpack_require__(25);\n\tmodule.exports = function(KEY, exec){\n\t  var fn  = (core.Object || {})[KEY] || Object[KEY]\n\t    , exp = {};\n\t  exp[KEY] = exec(fn);\n\t  $export($export.S + $export.F * fails(function(){ fn(1); }), 'Object', exp);\n\t};\n\n/***/ },\n/* 67 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\texports.__esModule = true;\n\t\n\tvar _typeof2 = __webpack_require__(68);\n\t\n\tvar _typeof3 = _interopRequireDefault(_typeof2);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = function (self, call) {\n\t  if (!self) {\n\t    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n\t  }\n\t\n\t  return call && ((typeof call === \"undefined\" ? \"undefined\" : (0, _typeof3.default)(call)) === \"object\" || typeof call === \"function\") ? call : self;\n\t};\n\n/***/ },\n/* 68 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\texports.__esModule = true;\n\t\n\tvar _iterator = __webpack_require__(69);\n\t\n\tvar _iterator2 = _interopRequireDefault(_iterator);\n\t\n\tvar _symbol = __webpack_require__(72);\n\t\n\tvar _symbol2 = _interopRequireDefault(_symbol);\n\t\n\tvar _typeof = typeof _symbol2.default === \"function\" && typeof _iterator2.default === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === \"function\" && obj.constructor === _symbol2.default ? \"symbol\" : typeof obj; };\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = typeof _symbol2.default === \"function\" && _typeof(_iterator2.default) === \"symbol\" ? function (obj) {\n\t  return typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj);\n\t} : function (obj) {\n\t  return obj && typeof _symbol2.default === \"function\" && obj.constructor === _symbol2.default ? \"symbol\" : typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj);\n\t};\n\n/***/ },\n/* 69 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = { \"default\": __webpack_require__(70), __esModule: true };\n\n/***/ },\n/* 70 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(49);\n\t__webpack_require__(3);\n\tmodule.exports = __webpack_require__(71).f('iterator');\n\n/***/ },\n/* 71 */\n/***/ function(module, exports, __webpack_require__) {\n\n\texports.f = __webpack_require__(46);\n\n/***/ },\n/* 72 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = { \"default\": __webpack_require__(73), __esModule: true };\n\n/***/ },\n/* 73 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(74);\n\t__webpack_require__(85);\n\t__webpack_require__(86);\n\t__webpack_require__(87);\n\tmodule.exports = __webpack_require__(16).Symbol;\n\n/***/ },\n/* 74 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t// ECMAScript 6 symbols shim\n\tvar global         = __webpack_require__(15)\n\t  , has            = __webpack_require__(30)\n\t  , DESCRIPTORS    = __webpack_require__(24)\n\t  , $export        = __webpack_require__(14)\n\t  , redefine       = __webpack_require__(29)\n\t  , META           = __webpack_require__(75).KEY\n\t  , $fails         = __webpack_require__(25)\n\t  , shared         = __webpack_require__(41)\n\t  , setToStringTag = __webpack_require__(45)\n\t  , uid            = __webpack_require__(42)\n\t  , wks            = __webpack_require__(46)\n\t  , wksExt         = __webpack_require__(71)\n\t  , wksDefine      = __webpack_require__(76)\n\t  , keyOf          = __webpack_require__(77)\n\t  , enumKeys       = __webpack_require__(78)\n\t  , isArray        = __webpack_require__(81)\n\t  , anObject       = __webpack_require__(21)\n\t  , toIObject      = __webpack_require__(8)\n\t  , toPrimitive    = __webpack_require__(27)\n\t  , createDesc     = __webpack_require__(28)\n\t  , _create        = __webpack_require__(32)\n\t  , gOPNExt        = __webpack_require__(82)\n\t  , $GOPD          = __webpack_require__(84)\n\t  , $DP            = __webpack_require__(20)\n\t  , $keys          = __webpack_require__(34)\n\t  , gOPD           = $GOPD.f\n\t  , dP             = $DP.f\n\t  , gOPN           = gOPNExt.f\n\t  , $Symbol        = global.Symbol\n\t  , $JSON          = global.JSON\n\t  , _stringify     = $JSON && $JSON.stringify\n\t  , PROTOTYPE      = 'prototype'\n\t  , HIDDEN         = wks('_hidden')\n\t  , TO_PRIMITIVE   = wks('toPrimitive')\n\t  , isEnum         = {}.propertyIsEnumerable\n\t  , SymbolRegistry = shared('symbol-registry')\n\t  , AllSymbols     = shared('symbols')\n\t  , OPSymbols      = shared('op-symbols')\n\t  , ObjectProto    = Object[PROTOTYPE]\n\t  , USE_NATIVE     = typeof $Symbol == 'function'\n\t  , QObject        = global.QObject;\n\t// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173\n\tvar setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;\n\t\n\t// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687\n\tvar setSymbolDesc = DESCRIPTORS && $fails(function(){\n\t  return _create(dP({}, 'a', {\n\t    get: function(){ return dP(this, 'a', {value: 7}).a; }\n\t  })).a != 7;\n\t}) ? function(it, key, D){\n\t  var protoDesc = gOPD(ObjectProto, key);\n\t  if(protoDesc)delete ObjectProto[key];\n\t  dP(it, key, D);\n\t  if(protoDesc && it !== ObjectProto)dP(ObjectProto, key, protoDesc);\n\t} : dP;\n\t\n\tvar wrap = function(tag){\n\t  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);\n\t  sym._k = tag;\n\t  return sym;\n\t};\n\t\n\tvar isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function(it){\n\t  return typeof it == 'symbol';\n\t} : function(it){\n\t  return it instanceof $Symbol;\n\t};\n\t\n\tvar $defineProperty = function defineProperty(it, key, D){\n\t  if(it === ObjectProto)$defineProperty(OPSymbols, key, D);\n\t  anObject(it);\n\t  key = toPrimitive(key, true);\n\t  anObject(D);\n\t  if(has(AllSymbols, key)){\n\t    if(!D.enumerable){\n\t      if(!has(it, HIDDEN))dP(it, HIDDEN, createDesc(1, {}));\n\t      it[HIDDEN][key] = true;\n\t    } else {\n\t      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;\n\t      D = _create(D, {enumerable: createDesc(0, false)});\n\t    } return setSymbolDesc(it, key, D);\n\t  } return dP(it, key, D);\n\t};\n\tvar $defineProperties = function defineProperties(it, P){\n\t  anObject(it);\n\t  var keys = enumKeys(P = toIObject(P))\n\t    , i    = 0\n\t    , l = keys.length\n\t    , key;\n\t  while(l > i)$defineProperty(it, key = keys[i++], P[key]);\n\t  return it;\n\t};\n\tvar $create = function create(it, P){\n\t  return P === undefined ? _create(it) : $defineProperties(_create(it), P);\n\t};\n\tvar $propertyIsEnumerable = function propertyIsEnumerable(key){\n\t  var E = isEnum.call(this, key = toPrimitive(key, true));\n\t  if(this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return false;\n\t  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;\n\t};\n\tvar $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){\n\t  it  = toIObject(it);\n\t  key = toPrimitive(key, true);\n\t  if(it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return;\n\t  var D = gOPD(it, key);\n\t  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;\n\t  return D;\n\t};\n\tvar $getOwnPropertyNames = function getOwnPropertyNames(it){\n\t  var names  = gOPN(toIObject(it))\n\t    , result = []\n\t    , i      = 0\n\t    , key;\n\t  while(names.length > i){\n\t    if(!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META)result.push(key);\n\t  } return result;\n\t};\n\tvar $getOwnPropertySymbols = function getOwnPropertySymbols(it){\n\t  var IS_OP  = it === ObjectProto\n\t    , names  = gOPN(IS_OP ? OPSymbols : toIObject(it))\n\t    , result = []\n\t    , i      = 0\n\t    , key;\n\t  while(names.length > i){\n\t    if(has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true))result.push(AllSymbols[key]);\n\t  } return result;\n\t};\n\t\n\t// 19.4.1.1 Symbol([description])\n\tif(!USE_NATIVE){\n\t  $Symbol = function Symbol(){\n\t    if(this instanceof $Symbol)throw TypeError('Symbol is not a constructor!');\n\t    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);\n\t    var $set = function(value){\n\t      if(this === ObjectProto)$set.call(OPSymbols, value);\n\t      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;\n\t      setSymbolDesc(this, tag, createDesc(1, value));\n\t    };\n\t    if(DESCRIPTORS && setter)setSymbolDesc(ObjectProto, tag, {configurable: true, set: $set});\n\t    return wrap(tag);\n\t  };\n\t  redefine($Symbol[PROTOTYPE], 'toString', function toString(){\n\t    return this._k;\n\t  });\n\t\n\t  $GOPD.f = $getOwnPropertyDescriptor;\n\t  $DP.f   = $defineProperty;\n\t  __webpack_require__(83).f = gOPNExt.f = $getOwnPropertyNames;\n\t  __webpack_require__(80).f  = $propertyIsEnumerable;\n\t  __webpack_require__(79).f = $getOwnPropertySymbols;\n\t\n\t  if(DESCRIPTORS && !__webpack_require__(13)){\n\t    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);\n\t  }\n\t\n\t  wksExt.f = function(name){\n\t    return wrap(wks(name));\n\t  }\n\t}\n\t\n\t$export($export.G + $export.W + $export.F * !USE_NATIVE, {Symbol: $Symbol});\n\t\n\tfor(var symbols = (\n\t  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14\n\t  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'\n\t).split(','), i = 0; symbols.length > i; )wks(symbols[i++]);\n\t\n\tfor(var symbols = $keys(wks.store), i = 0; symbols.length > i; )wksDefine(symbols[i++]);\n\t\n\t$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {\n\t  // 19.4.2.1 Symbol.for(key)\n\t  'for': function(key){\n\t    return has(SymbolRegistry, key += '')\n\t      ? SymbolRegistry[key]\n\t      : SymbolRegistry[key] = $Symbol(key);\n\t  },\n\t  // 19.4.2.5 Symbol.keyFor(sym)\n\t  keyFor: function keyFor(key){\n\t    if(isSymbol(key))return keyOf(SymbolRegistry, key);\n\t    throw TypeError(key + ' is not a symbol!');\n\t  },\n\t  useSetter: function(){ setter = true; },\n\t  useSimple: function(){ setter = false; }\n\t});\n\t\n\t$export($export.S + $export.F * !USE_NATIVE, 'Object', {\n\t  // 19.1.2.2 Object.create(O [, Properties])\n\t  create: $create,\n\t  // 19.1.2.4 Object.defineProperty(O, P, Attributes)\n\t  defineProperty: $defineProperty,\n\t  // 19.1.2.3 Object.defineProperties(O, Properties)\n\t  defineProperties: $defineProperties,\n\t  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)\n\t  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,\n\t  // 19.1.2.7 Object.getOwnPropertyNames(O)\n\t  getOwnPropertyNames: $getOwnPropertyNames,\n\t  // 19.1.2.8 Object.getOwnPropertySymbols(O)\n\t  getOwnPropertySymbols: $getOwnPropertySymbols\n\t});\n\t\n\t// 24.3.2 JSON.stringify(value [, replacer [, space]])\n\t$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function(){\n\t  var S = $Symbol();\n\t  // MS Edge converts symbol values to JSON as {}\n\t  // WebKit converts symbol values to JSON as null\n\t  // V8 throws on boxed symbols\n\t  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';\n\t})), 'JSON', {\n\t  stringify: function stringify(it){\n\t    if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined\n\t    var args = [it]\n\t      , i    = 1\n\t      , replacer, $replacer;\n\t    while(arguments.length > i)args.push(arguments[i++]);\n\t    replacer = args[1];\n\t    if(typeof replacer == 'function')$replacer = replacer;\n\t    if($replacer || !isArray(replacer))replacer = function(key, value){\n\t      if($replacer)value = $replacer.call(this, key, value);\n\t      if(!isSymbol(value))return value;\n\t    };\n\t    args[1] = replacer;\n\t    return _stringify.apply($JSON, args);\n\t  }\n\t});\n\t\n\t// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)\n\t$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(19)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);\n\t// 19.4.3.5 Symbol.prototype[@@toStringTag]\n\tsetToStringTag($Symbol, 'Symbol');\n\t// 20.2.1.9 Math[@@toStringTag]\n\tsetToStringTag(Math, 'Math', true);\n\t// 24.3.3 JSON[@@toStringTag]\n\tsetToStringTag(global.JSON, 'JSON', true);\n\n/***/ },\n/* 75 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar META     = __webpack_require__(42)('meta')\n\t  , isObject = __webpack_require__(22)\n\t  , has      = __webpack_require__(30)\n\t  , setDesc  = __webpack_require__(20).f\n\t  , id       = 0;\n\tvar isExtensible = Object.isExtensible || function(){\n\t  return true;\n\t};\n\tvar FREEZE = !__webpack_require__(25)(function(){\n\t  return isExtensible(Object.preventExtensions({}));\n\t});\n\tvar setMeta = function(it){\n\t  setDesc(it, META, {value: {\n\t    i: 'O' + ++id, // object ID\n\t    w: {}          // weak collections IDs\n\t  }});\n\t};\n\tvar fastKey = function(it, create){\n\t  // return primitive with prefix\n\t  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;\n\t  if(!has(it, META)){\n\t    // can't set metadata to uncaught frozen object\n\t    if(!isExtensible(it))return 'F';\n\t    // not necessary to add metadata\n\t    if(!create)return 'E';\n\t    // add missing metadata\n\t    setMeta(it);\n\t  // return object ID\n\t  } return it[META].i;\n\t};\n\tvar getWeak = function(it, create){\n\t  if(!has(it, META)){\n\t    // can't set metadata to uncaught frozen object\n\t    if(!isExtensible(it))return true;\n\t    // not necessary to add metadata\n\t    if(!create)return false;\n\t    // add missing metadata\n\t    setMeta(it);\n\t  // return hash weak collections IDs\n\t  } return it[META].w;\n\t};\n\t// add metadata on freeze-family methods calling\n\tvar onFreeze = function(it){\n\t  if(FREEZE && meta.NEED && isExtensible(it) && !has(it, META))setMeta(it);\n\t  return it;\n\t};\n\tvar meta = module.exports = {\n\t  KEY:      META,\n\t  NEED:     false,\n\t  fastKey:  fastKey,\n\t  getWeak:  getWeak,\n\t  onFreeze: onFreeze\n\t};\n\n/***/ },\n/* 76 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar global         = __webpack_require__(15)\r\n\t  , core           = __webpack_require__(16)\r\n\t  , LIBRARY        = __webpack_require__(13)\r\n\t  , wksExt         = __webpack_require__(71)\r\n\t  , defineProperty = __webpack_require__(20).f;\r\n\tmodule.exports = function(name){\r\n\t  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});\r\n\t  if(name.charAt(0) != '_' && !(name in $Symbol))defineProperty($Symbol, name, {value: wksExt.f(name)});\r\n\t};\n\n/***/ },\n/* 77 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar getKeys   = __webpack_require__(34)\n\t  , toIObject = __webpack_require__(8);\n\tmodule.exports = function(object, el){\n\t  var O      = toIObject(object)\n\t    , keys   = getKeys(O)\n\t    , length = keys.length\n\t    , index  = 0\n\t    , key;\n\t  while(length > index)if(O[key = keys[index++]] === el)return key;\n\t};\n\n/***/ },\n/* 78 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// all enumerable object keys, includes symbols\n\tvar getKeys = __webpack_require__(34)\n\t  , gOPS    = __webpack_require__(79)\n\t  , pIE     = __webpack_require__(80);\n\tmodule.exports = function(it){\n\t  var result     = getKeys(it)\n\t    , getSymbols = gOPS.f;\n\t  if(getSymbols){\n\t    var symbols = getSymbols(it)\n\t      , isEnum  = pIE.f\n\t      , i       = 0\n\t      , key;\n\t    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))result.push(key);\n\t  } return result;\n\t};\n\n/***/ },\n/* 79 */\n/***/ function(module, exports) {\n\n\texports.f = Object.getOwnPropertySymbols;\n\n/***/ },\n/* 80 */\n/***/ function(module, exports) {\n\n\texports.f = {}.propertyIsEnumerable;\n\n/***/ },\n/* 81 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 7.2.2 IsArray(argument)\n\tvar cof = __webpack_require__(10);\n\tmodule.exports = Array.isArray || function isArray(arg){\n\t  return cof(arg) == 'Array';\n\t};\n\n/***/ },\n/* 82 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window\n\tvar toIObject = __webpack_require__(8)\n\t  , gOPN      = __webpack_require__(83).f\n\t  , toString  = {}.toString;\n\t\n\tvar windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames\n\t  ? Object.getOwnPropertyNames(window) : [];\n\t\n\tvar getWindowNames = function(it){\n\t  try {\n\t    return gOPN(it);\n\t  } catch(e){\n\t    return windowNames.slice();\n\t  }\n\t};\n\t\n\tmodule.exports.f = function getOwnPropertyNames(it){\n\t  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));\n\t};\n\n\n/***/ },\n/* 83 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)\r\n\tvar $keys      = __webpack_require__(35)\r\n\t  , hiddenKeys = __webpack_require__(43).concat('length', 'prototype');\r\n\t\r\n\texports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O){\r\n\t  return $keys(O, hiddenKeys);\r\n\t};\n\n/***/ },\n/* 84 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar pIE            = __webpack_require__(80)\r\n\t  , createDesc     = __webpack_require__(28)\r\n\t  , toIObject      = __webpack_require__(8)\r\n\t  , toPrimitive    = __webpack_require__(27)\r\n\t  , has            = __webpack_require__(30)\r\n\t  , IE8_DOM_DEFINE = __webpack_require__(23)\r\n\t  , gOPD           = Object.getOwnPropertyDescriptor;\r\n\t\r\n\texports.f = __webpack_require__(24) ? gOPD : function getOwnPropertyDescriptor(O, P){\r\n\t  O = toIObject(O);\r\n\t  P = toPrimitive(P, true);\r\n\t  if(IE8_DOM_DEFINE)try {\r\n\t    return gOPD(O, P);\r\n\t  } catch(e){ /* empty */ }\r\n\t  if(has(O, P))return createDesc(!pIE.f.call(O, P), O[P]);\r\n\t};\n\n/***/ },\n/* 85 */\n/***/ function(module, exports) {\n\n\n\n/***/ },\n/* 86 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(76)('asyncIterator');\n\n/***/ },\n/* 87 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(76)('observable');\n\n/***/ },\n/* 88 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\texports.__esModule = true;\n\t\n\tvar _setPrototypeOf = __webpack_require__(89);\n\t\n\tvar _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);\n\t\n\tvar _create = __webpack_require__(93);\n\t\n\tvar _create2 = _interopRequireDefault(_create);\n\t\n\tvar _typeof2 = __webpack_require__(68);\n\t\n\tvar _typeof3 = _interopRequireDefault(_typeof2);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = function (subClass, superClass) {\n\t  if (typeof superClass !== \"function\" && superClass !== null) {\n\t    throw new TypeError(\"Super expression must either be null or a function, not \" + (typeof superClass === \"undefined\" ? \"undefined\" : (0, _typeof3.default)(superClass)));\n\t  }\n\t\n\t  subClass.prototype = (0, _create2.default)(superClass && superClass.prototype, {\n\t    constructor: {\n\t      value: subClass,\n\t      enumerable: false,\n\t      writable: true,\n\t      configurable: true\n\t    }\n\t  });\n\t  if (superClass) _setPrototypeOf2.default ? (0, _setPrototypeOf2.default)(subClass, superClass) : subClass.__proto__ = superClass;\n\t};\n\n/***/ },\n/* 89 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = { \"default\": __webpack_require__(90), __esModule: true };\n\n/***/ },\n/* 90 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(91);\n\tmodule.exports = __webpack_require__(16).Object.setPrototypeOf;\n\n/***/ },\n/* 91 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 19.1.3.19 Object.setPrototypeOf(O, proto)\n\tvar $export = __webpack_require__(14);\n\t$export($export.S, 'Object', {setPrototypeOf: __webpack_require__(92).set});\n\n/***/ },\n/* 92 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// Works with __proto__ only. Old v8 can't work with null proto objects.\n\t/* eslint-disable no-proto */\n\tvar isObject = __webpack_require__(22)\n\t  , anObject = __webpack_require__(21);\n\tvar check = function(O, proto){\n\t  anObject(O);\n\t  if(!isObject(proto) && proto !== null)throw TypeError(proto + \": can't set as prototype!\");\n\t};\n\tmodule.exports = {\n\t  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line\n\t    function(test, buggy, set){\n\t      try {\n\t        set = __webpack_require__(17)(Function.call, __webpack_require__(84).f(Object.prototype, '__proto__').set, 2);\n\t        set(test, []);\n\t        buggy = !(test instanceof Array);\n\t      } catch(e){ buggy = true; }\n\t      return function setPrototypeOf(O, proto){\n\t        check(O, proto);\n\t        if(buggy)O.__proto__ = proto;\n\t        else set(O, proto);\n\t        return O;\n\t      };\n\t    }({}, false) : undefined),\n\t  check: check\n\t};\n\n/***/ },\n/* 93 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = { \"default\": __webpack_require__(94), __esModule: true };\n\n/***/ },\n/* 94 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(95);\n\tvar $Object = __webpack_require__(16).Object;\n\tmodule.exports = function create(P, D){\n\t  return $Object.create(P, D);\n\t};\n\n/***/ },\n/* 95 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar $export = __webpack_require__(14)\r\n\t// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\r\n\t$export($export.S, 'Object', {create: __webpack_require__(32)});\n\n/***/ },\n/* 96 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.default = \"// precision mediump float;\\n\\nuniform sampler2D tex_bump;\\nuniform sampler2D tex_scene;\\nuniform sampler2D emissiveMap;\\nuniform vec2 vScale;\\nuniform vec2 resolution;\\nuniform vec3 emissive;\\nuniform float refraction;\\nuniform float opacity;\\nuniform vec2 offset;\\nuniform float fresnelMix;\\nuniform float fresnelBias;\\nuniform float fresnelPow;\\n\\nvarying vec2 vUv;\\nvarying vec3 vEye;\\nvarying vec3 vWorldNormal;\\n\\nfloat Fresnel(const in float NdotL, const in float fresnelBias, const in float fresnelPow)\\n\\n{\\n\\n  float facing = (1.0 - NdotL);\\n\\n  return max(fresnelBias +\\n\\n             (1.0 - fresnelBias) * pow(facing, fresnelPow), 0.0);\\n\\n}\\n\\nvoid main(void)\\n{\\n    vec3 totalEmissiveRadiance = emissive;\\n\\n    // fetch bump texture, unpack from [0..1] to [-1..1]\\n\\n    vec4 bumpTex = 2.0 * texture2D(tex_bump, mod((vUv + offset) * vec2(4, 8), 1.0).xy) - 1.0;\\n\\n    // displace texture coordinates\\n\\n    vec2 ss = vec2(gl_FragCoord.x/resolution.x, gl_FragCoord.y/resolution.y);\\n\\n    vec2 newUV = ss + bumpTex.xy * vScale;\\n\\n    float NdotL = dot(vEye, vWorldNormal * vec3(0.07, 0.07, 1));\\n\\n    float fresnel = Fresnel(1.0 - NdotL, fresnelBias, fresnelPow);\\n\\n    vec3 refractionColor = ( (fresnel * fresnelMix) * texture2D(tex_scene, newUV)).rgb;\\n\\n    //vec3 refractionColor = vec3(1.0 - fresnel, 1.0 - fresnel, 1.0 - fresnel);\\n\\n    // fetch refraction map\\n    vec4 emissiveColor = texture2D( emissiveMap, mod(vUv * vec2(4, 8), 1.0) );\\n\\n    totalEmissiveRadiance *= emissiveColor.rgb;\\n\\n    vec3 color = mix(refractionColor, totalEmissiveRadiance, 1.0 - refraction);\\n\\n    gl_FragColor = vec4(color, opacity);\\n\\n}\";\n\n/***/ },\n/* 97 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__.p + \"textures/crystal-b40baa88da921fc8383f334d76573135.jpg\";\n\n/***/ },\n/* 98 */\n/***/ function(module, exports) {\n\n\t// stats.js - http://github.com/mrdoob/stats.js\r\n\tvar Stats=function(){function h(a){c.appendChild(a.dom);return a}function k(a){for(var d=0;d<c.children.length;d++)c.children[d].style.display=d===a?\"block\":\"none\";l=a}var l=0,c=document.createElement(\"div\");c.style.cssText=\"position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000\";c.addEventListener(\"click\",function(a){a.preventDefault();k(++l%c.children.length)},!1);var g=(performance||Date).now(),e=g,a=0,r=h(new Stats.Panel(\"FPS\",\"#0ff\",\"#002\")),f=h(new Stats.Panel(\"MS\",\"#0f0\",\"#020\"));\r\n\tif(self.performance&&self.performance.memory)var t=h(new Stats.Panel(\"MB\",\"#f08\",\"#201\"));k(0);return{REVISION:16,dom:c,addPanel:h,showPanel:k,begin:function(){g=(performance||Date).now()},end:function(){a++;var c=(performance||Date).now();f.update(c-g,200);if(c>e+1E3&&(r.update(1E3*a/(c-e),100),e=c,a=0,t)){var d=performance.memory;t.update(d.usedJSHeapSize/1048576,d.jsHeapSizeLimit/1048576)}return c},update:function(){g=this.end()},domElement:c,setMode:k}};\r\n\tStats.Panel=function(h,k,l){var c=Infinity,g=0,e=Math.round,a=e(window.devicePixelRatio||1),r=80*a,f=48*a,t=3*a,u=2*a,d=3*a,m=15*a,n=74*a,p=30*a,q=document.createElement(\"canvas\");q.width=r;q.height=f;q.style.cssText=\"width:80px;height:48px\";var b=q.getContext(\"2d\");b.font=\"bold \"+9*a+\"px Helvetica,Arial,sans-serif\";b.textBaseline=\"top\";b.fillStyle=l;b.fillRect(0,0,r,f);b.fillStyle=k;b.fillText(h,t,u);b.fillRect(d,m,n,p);b.fillStyle=l;b.globalAlpha=.9;b.fillRect(d,m,n,p);return{dom:q,update:function(f,\r\n\tv){c=Math.min(c,f);g=Math.max(g,f);b.fillStyle=l;b.globalAlpha=1;b.fillRect(0,0,r,m);b.fillStyle=k;b.fillText(e(f)+\" \"+h+\" (\"+e(c)+\"-\"+e(g)+\")\",t,u);b.drawImage(q,d+a,m,n-a,p,d,m,n-a,p);b.fillRect(d+n-a,m,a,p);b.fillStyle=l;b.globalAlpha=.9;b.fillRect(d+n-a,m,a,e((1-f/v)*p))}}};\"object\"===typeof module&&(module.exports=Stats);\r\n\n\n/***/ },\n/* 99 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__.p + \"textures/checkerboard-8aacea3931a7790b21a29179bfaad52c.png\";\n\n/***/ },\n/* 100 */\n/***/ function(module, exports) {\n\n\t/**\r\n\t * @author qiao / https://github.com/qiao\r\n\t * @author mrdoob / http://mrdoob.com\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t * @author erich666 / http://erichaines.com\r\n\t */\r\n\t\r\n\t// This set of controls performs orbiting, dollying (zooming), and panning.\r\n\t// Unlike TrackballControls, it maintains the \"up\" direction object.up (+Y by default).\r\n\t//\r\n\t//    Orbit - left mouse / touch: one finger move\r\n\t//    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish\r\n\t//    Pan - right mouse, or arrow keys / touch: three finter swipe\r\n\t\r\n\tTHREE.OrbitControls = function ( object, domElement ) {\r\n\t\r\n\t\tthis.object = object;\r\n\t\r\n\t\tthis.domElement = ( domElement !== undefined ) ? domElement : document;\r\n\t\r\n\t\t// Set to false to disable this control\r\n\t\tthis.enabled = true;\r\n\t\r\n\t\t// \"target\" sets the location of focus, where the object orbits around\r\n\t\tthis.target = new THREE.Vector3();\r\n\t\r\n\t\t// How far you can dolly in and out ( PerspectiveCamera only )\r\n\t\tthis.minDistance = 0;\r\n\t\tthis.maxDistance = Infinity;\r\n\t\r\n\t\t// How far you can zoom in and out ( OrthographicCamera only )\r\n\t\tthis.minZoom = 0;\r\n\t\tthis.maxZoom = Infinity;\r\n\t\r\n\t\t// How far you can orbit vertically, upper and lower limits.\r\n\t\t// Range is 0 to Math.PI radians.\r\n\t\tthis.minPolarAngle = 0; // radians\r\n\t\tthis.maxPolarAngle = Math.PI; // radians\r\n\t\r\n\t\t// How far you can orbit horizontally, upper and lower limits.\r\n\t\t// If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].\r\n\t\tthis.minAzimuthAngle = - Infinity; // radians\r\n\t\tthis.maxAzimuthAngle = Infinity; // radians\r\n\t\r\n\t\t// Set to true to enable damping (inertia)\r\n\t\t// If damping is enabled, you must call controls.update() in your animation loop\r\n\t\tthis.enableDamping = false;\r\n\t\tthis.dampingFactor = 0.25;\r\n\t\r\n\t\t// This option actually enables dollying in and out; left as \"zoom\" for backwards compatibility.\r\n\t\t// Set to false to disable zooming\r\n\t\tthis.enableZoom = true;\r\n\t\tthis.zoomSpeed = 1.0;\r\n\t\r\n\t\t// Set to false to disable rotating\r\n\t\tthis.enableRotate = true;\r\n\t\tthis.rotateSpeed = 1.0;\r\n\t\r\n\t\t// Set to false to disable panning\r\n\t\tthis.enablePan = true;\r\n\t\tthis.keyPanSpeed = 7.0;\t// pixels moved per arrow key push\r\n\t\r\n\t\t// Set to true to automatically rotate around the target\r\n\t\t// If auto-rotate is enabled, you must call controls.update() in your animation loop\r\n\t\tthis.autoRotate = false;\r\n\t\tthis.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60\r\n\t\r\n\t\t// Set to false to disable use of the keys\r\n\t\tthis.enableKeys = true;\r\n\t\r\n\t\t// The four arrow keys\r\n\t\tthis.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };\r\n\t\r\n\t\t// Mouse buttons\r\n\t\tthis.mouseButtons = { ORBIT: THREE.MOUSE.LEFT, ZOOM: THREE.MOUSE.MIDDLE, PAN: THREE.MOUSE.RIGHT };\r\n\t\r\n\t\t// for reset\r\n\t\tthis.target0 = this.target.clone();\r\n\t\tthis.position0 = this.object.position.clone();\r\n\t\tthis.zoom0 = this.object.zoom;\r\n\t\r\n\t\t//\r\n\t\t// public methods\r\n\t\t//\r\n\t\r\n\t\tthis.getPolarAngle = function () {\r\n\t\r\n\t\t\treturn phi;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.getAzimuthalAngle = function () {\r\n\t\r\n\t\t\treturn theta;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.reset = function () {\r\n\t\r\n\t\t\tscope.target.copy( scope.target0 );\r\n\t\t\tscope.object.position.copy( scope.position0 );\r\n\t\t\tscope.object.zoom = scope.zoom0;\r\n\t\r\n\t\t\tscope.object.updateProjectionMatrix();\r\n\t\t\tscope.dispatchEvent( changeEvent );\r\n\t\r\n\t\t\tscope.update();\r\n\t\r\n\t\t\tstate = STATE.NONE;\r\n\t\r\n\t\t};\r\n\t\r\n\t\t// this method is exposed, but perhaps it would be better if we can make it private...\r\n\t\tthis.update = function() {\r\n\t\r\n\t\t\tvar offset = new THREE.Vector3();\r\n\t\r\n\t\t\t// so camera.up is the orbit axis\r\n\t\t\tvar quat = new THREE.Quaternion().setFromUnitVectors( object.up, new THREE.Vector3( 0, 1, 0 ) );\r\n\t\t\tvar quatInverse = quat.clone().inverse();\r\n\t\r\n\t\t\tvar lastPosition = new THREE.Vector3();\r\n\t\t\tvar lastQuaternion = new THREE.Quaternion();\r\n\t\r\n\t\t\treturn function () {\r\n\t\r\n\t\t\t\tvar position = scope.object.position;\r\n\t\r\n\t\t\t\toffset.copy( position ).sub( scope.target );\r\n\t\r\n\t\t\t\t// rotate offset to \"y-axis-is-up\" space\r\n\t\t\t\toffset.applyQuaternion( quat );\r\n\t\r\n\t\t\t\t// angle from z-axis around y-axis\r\n\t\t\t\tspherical.setFromVector3( offset );\r\n\t\r\n\t\t\t\tif ( scope.autoRotate && state === STATE.NONE ) {\r\n\t\r\n\t\t\t\t\trotateLeft( getAutoRotationAngle() );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tspherical.theta += sphericalDelta.theta;\r\n\t\t\t\tspherical.phi += sphericalDelta.phi;\r\n\t\r\n\t\t\t\t// restrict theta to be between desired limits\r\n\t\t\t\tspherical.theta = Math.max( scope.minAzimuthAngle, Math.min( scope.maxAzimuthAngle, spherical.theta ) );\r\n\t\r\n\t\t\t\t// restrict phi to be between desired limits\r\n\t\t\t\tspherical.phi = Math.max( scope.minPolarAngle, Math.min( scope.maxPolarAngle, spherical.phi ) );\r\n\t\r\n\t\t\t\tspherical.makeSafe();\r\n\t\r\n\t\r\n\t\t\t\tspherical.radius *= scale;\r\n\t\r\n\t\t\t\t// restrict radius to be between desired limits\r\n\t\t\t\tspherical.radius = Math.max( scope.minDistance, Math.min( scope.maxDistance, spherical.radius ) );\r\n\t\r\n\t\t\t\t// move target to panned location\r\n\t\t\t\tscope.target.add( panOffset );\r\n\t\r\n\t\t\t\toffset.setFromSpherical( spherical );\r\n\t\r\n\t\t\t\t// rotate offset back to \"camera-up-vector-is-up\" space\r\n\t\t\t\toffset.applyQuaternion( quatInverse );\r\n\t\r\n\t\t\t\tposition.copy( scope.target ).add( offset );\r\n\t\r\n\t\t\t\tscope.object.lookAt( scope.target );\r\n\t\r\n\t\t\t\tif ( scope.enableDamping === true ) {\r\n\t\r\n\t\t\t\t\tsphericalDelta.theta *= ( 1 - scope.dampingFactor );\r\n\t\t\t\t\tsphericalDelta.phi *= ( 1 - scope.dampingFactor );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tsphericalDelta.set( 0, 0, 0 );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tscale = 1;\r\n\t\t\t\tpanOffset.set( 0, 0, 0 );\r\n\t\r\n\t\t\t\t// update condition is:\r\n\t\t\t\t// min(camera displacement, camera rotation in radians)^2 > EPS\r\n\t\t\t\t// using small-angle approximation cos(x/2) = 1 - x^2 / 8\r\n\t\r\n\t\t\t\tif ( zoomChanged ||\r\n\t\t\t\t\tlastPosition.distanceToSquared( scope.object.position ) > EPS ||\r\n\t\t\t\t\t8 * ( 1 - lastQuaternion.dot( scope.object.quaternion ) ) > EPS ) {\r\n\t\r\n\t\t\t\t\tscope.dispatchEvent( changeEvent );\r\n\t\r\n\t\t\t\t\tlastPosition.copy( scope.object.position );\r\n\t\t\t\t\tlastQuaternion.copy( scope.object.quaternion );\r\n\t\t\t\t\tzoomChanged = false;\r\n\t\r\n\t\t\t\t\treturn true;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn false;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}();\r\n\t\r\n\t\tthis.dispose = function() {\r\n\t\r\n\t\t\tscope.domElement.removeEventListener( 'contextmenu', onContextMenu, false );\r\n\t\t\tscope.domElement.removeEventListener( 'mousedown', onMouseDown, false );\r\n\t\t\tscope.domElement.removeEventListener( 'mousewheel', onMouseWheel, false );\r\n\t\t\tscope.domElement.removeEventListener( 'MozMousePixelScroll', onMouseWheel, false ); // firefox\r\n\t\r\n\t\t\tscope.domElement.removeEventListener( 'touchstart', onTouchStart, false );\r\n\t\t\tscope.domElement.removeEventListener( 'touchend', onTouchEnd, false );\r\n\t\t\tscope.domElement.removeEventListener( 'touchmove', onTouchMove, false );\r\n\t\r\n\t\t\tdocument.removeEventListener( 'mousemove', onMouseMove, false );\r\n\t\t\tdocument.removeEventListener( 'mouseup', onMouseUp, false );\r\n\t\t\tdocument.removeEventListener( 'mouseout', onMouseUp, false );\r\n\t\r\n\t\t\twindow.removeEventListener( 'keydown', onKeyDown, false );\r\n\t\r\n\t\t\t//scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?\r\n\t\r\n\t\t};\r\n\t\r\n\t\t//\r\n\t\t// internals\r\n\t\t//\r\n\t\r\n\t\tvar scope = this;\r\n\t\r\n\t\tvar changeEvent = { type: 'change' };\r\n\t\tvar startEvent = { type: 'start' };\r\n\t\tvar endEvent = { type: 'end' };\r\n\t\r\n\t\tvar STATE = { NONE : - 1, ROTATE : 0, DOLLY : 1, PAN : 2, TOUCH_ROTATE : 3, TOUCH_DOLLY : 4, TOUCH_PAN : 5 };\r\n\t\r\n\t\tvar state = STATE.NONE;\r\n\t\r\n\t\tvar EPS = 0.000001;\r\n\t\r\n\t\t// current position in spherical coordinates\r\n\t\tvar spherical = new THREE.Spherical();\r\n\t\tvar sphericalDelta = new THREE.Spherical();\r\n\t\r\n\t\tvar scale = 1;\r\n\t\tvar panOffset = new THREE.Vector3();\r\n\t\tvar zoomChanged = false;\r\n\t\r\n\t\tvar rotateStart = new THREE.Vector2();\r\n\t\tvar rotateEnd = new THREE.Vector2();\r\n\t\tvar rotateDelta = new THREE.Vector2();\r\n\t\r\n\t\tvar panStart = new THREE.Vector2();\r\n\t\tvar panEnd = new THREE.Vector2();\r\n\t\tvar panDelta = new THREE.Vector2();\r\n\t\r\n\t\tvar dollyStart = new THREE.Vector2();\r\n\t\tvar dollyEnd = new THREE.Vector2();\r\n\t\tvar dollyDelta = new THREE.Vector2();\r\n\t\r\n\t\tfunction getAutoRotationAngle() {\r\n\t\r\n\t\t\treturn 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction getZoomScale() {\r\n\t\r\n\t\t\treturn Math.pow( 0.95, scope.zoomSpeed );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction rotateLeft( angle ) {\r\n\t\r\n\t\t\tsphericalDelta.theta -= angle;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction rotateUp( angle ) {\r\n\t\r\n\t\t\tsphericalDelta.phi -= angle;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar panLeft = function() {\r\n\t\r\n\t\t\tvar v = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function panLeft( distance, objectMatrix ) {\r\n\t\r\n\t\t\t\tv.setFromMatrixColumn( objectMatrix, 0 ); // get X column of objectMatrix\r\n\t\t\t\tv.multiplyScalar( - distance );\r\n\t\r\n\t\t\t\tpanOffset.add( v );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}();\r\n\t\r\n\t\tvar panUp = function() {\r\n\t\r\n\t\t\tvar v = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function panUp( distance, objectMatrix ) {\r\n\t\r\n\t\t\t\tv.setFromMatrixColumn( objectMatrix, 1 ); // get Y column of objectMatrix\r\n\t\t\t\tv.multiplyScalar( distance );\r\n\t\r\n\t\t\t\tpanOffset.add( v );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}();\r\n\t\r\n\t\t// deltaX and deltaY are in pixels; right and down are positive\r\n\t\tvar pan = function() {\r\n\t\r\n\t\t\tvar offset = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function( deltaX, deltaY ) {\r\n\t\r\n\t\t\t\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\r\n\t\r\n\t\t\t\tif ( scope.object instanceof THREE.PerspectiveCamera ) {\r\n\t\r\n\t\t\t\t\t// perspective\r\n\t\t\t\t\tvar position = scope.object.position;\r\n\t\t\t\t\toffset.copy( position ).sub( scope.target );\r\n\t\t\t\t\tvar targetDistance = offset.length();\r\n\t\r\n\t\t\t\t\t// half of the fov is center to top of screen\r\n\t\t\t\t\ttargetDistance *= Math.tan( ( scope.object.fov / 2 ) * Math.PI / 180.0 );\r\n\t\r\n\t\t\t\t\t// we actually don't use screenWidth, since perspective camera is fixed to screen height\r\n\t\t\t\t\tpanLeft( 2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix );\r\n\t\t\t\t\tpanUp( 2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix );\r\n\t\r\n\t\t\t\t} else if ( scope.object instanceof THREE.OrthographicCamera ) {\r\n\t\r\n\t\t\t\t\t// orthographic\r\n\t\t\t\t\tpanLeft( deltaX * ( scope.object.right - scope.object.left ) / scope.object.zoom / element.clientWidth, scope.object.matrix );\r\n\t\t\t\t\tpanUp( deltaY * ( scope.object.top - scope.object.bottom ) / scope.object.zoom / element.clientHeight, scope.object.matrix );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t// camera neither orthographic nor perspective\r\n\t\t\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );\r\n\t\t\t\t\tscope.enablePan = false;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}();\r\n\t\r\n\t\tfunction dollyIn( dollyScale ) {\r\n\t\r\n\t\t\tif ( scope.object instanceof THREE.PerspectiveCamera ) {\r\n\t\r\n\t\t\t\tscale /= dollyScale;\r\n\t\r\n\t\t\t} else if ( scope.object instanceof THREE.OrthographicCamera ) {\r\n\t\r\n\t\t\t\tscope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom * dollyScale ) );\r\n\t\t\t\tscope.object.updateProjectionMatrix();\r\n\t\t\t\tzoomChanged = true;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );\r\n\t\t\t\tscope.enableZoom = false;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction dollyOut( dollyScale ) {\r\n\t\r\n\t\t\tif ( scope.object instanceof THREE.PerspectiveCamera ) {\r\n\t\r\n\t\t\t\tscale *= dollyScale;\r\n\t\r\n\t\t\t} else if ( scope.object instanceof THREE.OrthographicCamera ) {\r\n\t\r\n\t\t\t\tscope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom / dollyScale ) );\r\n\t\t\t\tscope.object.updateProjectionMatrix();\r\n\t\t\t\tzoomChanged = true;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );\r\n\t\t\t\tscope.enableZoom = false;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\t//\r\n\t\t// event callbacks - update the object state\r\n\t\t//\r\n\t\r\n\t\tfunction handleMouseDownRotate( event ) {\r\n\t\r\n\t\t\t//console.log( 'handleMouseDownRotate' );\r\n\t\r\n\t\t\trotateStart.set( event.clientX, event.clientY );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction handleMouseDownDolly( event ) {\r\n\t\r\n\t\t\t//console.log( 'handleMouseDownDolly' );\r\n\t\r\n\t\t\tdollyStart.set( event.clientX, event.clientY );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction handleMouseDownPan( event ) {\r\n\t\r\n\t\t\t//console.log( 'handleMouseDownPan' );\r\n\t\r\n\t\t\tpanStart.set( event.clientX, event.clientY );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction handleMouseMoveRotate( event ) {\r\n\t\r\n\t\t\t//console.log( 'handleMouseMoveRotate' );\r\n\t\r\n\t\t\trotateEnd.set( event.clientX, event.clientY );\r\n\t\t\trotateDelta.subVectors( rotateEnd, rotateStart );\r\n\t\r\n\t\t\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\r\n\t\r\n\t\t\t// rotating across whole screen goes 360 degrees around\r\n\t\t\trotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );\r\n\t\r\n\t\t\t// rotating up and down along whole screen attempts to go 360, but limited to 180\r\n\t\t\trotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );\r\n\t\r\n\t\t\trotateStart.copy( rotateEnd );\r\n\t\r\n\t\t\tscope.update();\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction handleMouseMoveDolly( event ) {\r\n\t\r\n\t\t\t//console.log( 'handleMouseMoveDolly' );\r\n\t\r\n\t\t\tdollyEnd.set( event.clientX, event.clientY );\r\n\t\r\n\t\t\tdollyDelta.subVectors( dollyEnd, dollyStart );\r\n\t\r\n\t\t\tif ( dollyDelta.y > 0 ) {\r\n\t\r\n\t\t\t\tdollyIn( getZoomScale() );\r\n\t\r\n\t\t\t} else if ( dollyDelta.y < 0 ) {\r\n\t\r\n\t\t\t\tdollyOut( getZoomScale() );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tdollyStart.copy( dollyEnd );\r\n\t\r\n\t\t\tscope.update();\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction handleMouseMovePan( event ) {\r\n\t\r\n\t\t\t//console.log( 'handleMouseMovePan' );\r\n\t\r\n\t\t\tpanEnd.set( event.clientX, event.clientY );\r\n\t\r\n\t\t\tpanDelta.subVectors( panEnd, panStart );\r\n\t\r\n\t\t\tpan( panDelta.x, panDelta.y );\r\n\t\r\n\t\t\tpanStart.copy( panEnd );\r\n\t\r\n\t\t\tscope.update();\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction handleMouseUp( event ) {\r\n\t\r\n\t\t\t//console.log( 'handleMouseUp' );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction handleMouseWheel( event ) {\r\n\t\r\n\t\t\t//console.log( 'handleMouseWheel' );\r\n\t\r\n\t\t\tvar delta = 0;\r\n\t\r\n\t\t\tif ( event.wheelDelta !== undefined ) {\r\n\t\r\n\t\t\t\t// WebKit / Opera / Explorer 9\r\n\t\r\n\t\t\t\tdelta = event.wheelDelta;\r\n\t\r\n\t\t\t} else if ( event.detail !== undefined ) {\r\n\t\r\n\t\t\t\t// Firefox\r\n\t\r\n\t\t\t\tdelta = - event.detail;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( delta > 0 ) {\r\n\t\r\n\t\t\t\tdollyOut( getZoomScale() );\r\n\t\r\n\t\t\t} else if ( delta < 0 ) {\r\n\t\r\n\t\t\t\tdollyIn( getZoomScale() );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tscope.update();\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction handleKeyDown( event ) {\r\n\t\r\n\t\t\t//console.log( 'handleKeyDown' );\r\n\t\r\n\t\t\tswitch ( event.keyCode ) {\r\n\t\r\n\t\t\t\tcase scope.keys.UP:\r\n\t\t\t\t\tpan( 0, scope.keyPanSpeed );\r\n\t\t\t\t\tscope.update();\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\tcase scope.keys.BOTTOM:\r\n\t\t\t\t\tpan( 0, - scope.keyPanSpeed );\r\n\t\t\t\t\tscope.update();\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\tcase scope.keys.LEFT:\r\n\t\t\t\t\tpan( scope.keyPanSpeed, 0 );\r\n\t\t\t\t\tscope.update();\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\tcase scope.keys.RIGHT:\r\n\t\t\t\t\tpan( - scope.keyPanSpeed, 0 );\r\n\t\t\t\t\tscope.update();\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction handleTouchStartRotate( event ) {\r\n\t\r\n\t\t\t//console.log( 'handleTouchStartRotate' );\r\n\t\r\n\t\t\trotateStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction handleTouchStartDolly( event ) {\r\n\t\r\n\t\t\t//console.log( 'handleTouchStartDolly' );\r\n\t\r\n\t\t\tvar dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\r\n\t\t\tvar dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\r\n\t\r\n\t\t\tvar distance = Math.sqrt( dx * dx + dy * dy );\r\n\t\r\n\t\t\tdollyStart.set( 0, distance );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction handleTouchStartPan( event ) {\r\n\t\r\n\t\t\t//console.log( 'handleTouchStartPan' );\r\n\t\r\n\t\t\tpanStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction handleTouchMoveRotate( event ) {\r\n\t\r\n\t\t\t//console.log( 'handleTouchMoveRotate' );\r\n\t\r\n\t\t\trotateEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\r\n\t\t\trotateDelta.subVectors( rotateEnd, rotateStart );\r\n\t\r\n\t\t\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\r\n\t\r\n\t\t\t// rotating across whole screen goes 360 degrees around\r\n\t\t\trotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );\r\n\t\r\n\t\t\t// rotating up and down along whole screen attempts to go 360, but limited to 180\r\n\t\t\trotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );\r\n\t\r\n\t\t\trotateStart.copy( rotateEnd );\r\n\t\r\n\t\t\tscope.update();\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction handleTouchMoveDolly( event ) {\r\n\t\r\n\t\t\t//console.log( 'handleTouchMoveDolly' );\r\n\t\r\n\t\t\tvar dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\r\n\t\t\tvar dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\r\n\t\r\n\t\t\tvar distance = Math.sqrt( dx * dx + dy * dy );\r\n\t\r\n\t\t\tdollyEnd.set( 0, distance );\r\n\t\r\n\t\t\tdollyDelta.subVectors( dollyEnd, dollyStart );\r\n\t\r\n\t\t\tif ( dollyDelta.y > 0 ) {\r\n\t\r\n\t\t\t\tdollyOut( getZoomScale() );\r\n\t\r\n\t\t\t} else if ( dollyDelta.y < 0 ) {\r\n\t\r\n\t\t\t\tdollyIn( getZoomScale() );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tdollyStart.copy( dollyEnd );\r\n\t\r\n\t\t\tscope.update();\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction handleTouchMovePan( event ) {\r\n\t\r\n\t\t\t//console.log( 'handleTouchMovePan' );\r\n\t\r\n\t\t\tpanEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\r\n\t\r\n\t\t\tpanDelta.subVectors( panEnd, panStart );\r\n\t\r\n\t\t\tpan( panDelta.x, panDelta.y );\r\n\t\r\n\t\t\tpanStart.copy( panEnd );\r\n\t\r\n\t\t\tscope.update();\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction handleTouchEnd( event ) {\r\n\t\r\n\t\t\t//console.log( 'handleTouchEnd' );\r\n\t\r\n\t\t}\r\n\t\r\n\t\t//\r\n\t\t// event handlers - FSM: listen for events and reset state\r\n\t\t//\r\n\t\r\n\t\tfunction onMouseDown( event ) {\r\n\t\r\n\t\t\tif ( scope.enabled === false ) return;\r\n\t\r\n\t\t\tevent.preventDefault();\r\n\t\r\n\t\t\tif ( event.button === scope.mouseButtons.ORBIT ) {\r\n\t\r\n\t\t\t\tif ( scope.enableRotate === false ) return;\r\n\t\r\n\t\t\t\thandleMouseDownRotate( event );\r\n\t\r\n\t\t\t\tstate = STATE.ROTATE;\r\n\t\r\n\t\t\t} else if ( event.button === scope.mouseButtons.ZOOM ) {\r\n\t\r\n\t\t\t\tif ( scope.enableZoom === false ) return;\r\n\t\r\n\t\t\t\thandleMouseDownDolly( event );\r\n\t\r\n\t\t\t\tstate = STATE.DOLLY;\r\n\t\r\n\t\t\t} else if ( event.button === scope.mouseButtons.PAN ) {\r\n\t\r\n\t\t\t\tif ( scope.enablePan === false ) return;\r\n\t\r\n\t\t\t\thandleMouseDownPan( event );\r\n\t\r\n\t\t\t\tstate = STATE.PAN;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( state !== STATE.NONE ) {\r\n\t\r\n\t\t\t\tdocument.addEventListener( 'mousemove', onMouseMove, false );\r\n\t\t\t\tdocument.addEventListener( 'mouseup', onMouseUp, false );\r\n\t\t\t\tdocument.addEventListener( 'mouseout', onMouseUp, false );\r\n\t\r\n\t\t\t\tscope.dispatchEvent( startEvent );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction onMouseMove( event ) {\r\n\t\r\n\t\t\tif ( scope.enabled === false ) return;\r\n\t\r\n\t\t\tevent.preventDefault();\r\n\t\r\n\t\t\tif ( state === STATE.ROTATE ) {\r\n\t\r\n\t\t\t\tif ( scope.enableRotate === false ) return;\r\n\t\r\n\t\t\t\thandleMouseMoveRotate( event );\r\n\t\r\n\t\t\t} else if ( state === STATE.DOLLY ) {\r\n\t\r\n\t\t\t\tif ( scope.enableZoom === false ) return;\r\n\t\r\n\t\t\t\thandleMouseMoveDolly( event );\r\n\t\r\n\t\t\t} else if ( state === STATE.PAN ) {\r\n\t\r\n\t\t\t\tif ( scope.enablePan === false ) return;\r\n\t\r\n\t\t\t\thandleMouseMovePan( event );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction onMouseUp( event ) {\r\n\t\r\n\t\t\tif ( scope.enabled === false ) return;\r\n\t\r\n\t\t\thandleMouseUp( event );\r\n\t\r\n\t\t\tdocument.removeEventListener( 'mousemove', onMouseMove, false );\r\n\t\t\tdocument.removeEventListener( 'mouseup', onMouseUp, false );\r\n\t\t\tdocument.removeEventListener( 'mouseout', onMouseUp, false );\r\n\t\r\n\t\t\tscope.dispatchEvent( endEvent );\r\n\t\r\n\t\t\tstate = STATE.NONE;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction onMouseWheel( event ) {\r\n\t\r\n\t\t\tif ( scope.enabled === false || scope.enableZoom === false || ( state !== STATE.NONE && state !== STATE.ROTATE ) ) return;\r\n\t\r\n\t\t\tevent.preventDefault();\r\n\t\t\tevent.stopPropagation();\r\n\t\r\n\t\t\thandleMouseWheel( event );\r\n\t\r\n\t\t\tscope.dispatchEvent( startEvent ); // not sure why these are here...\r\n\t\t\tscope.dispatchEvent( endEvent );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction onKeyDown( event ) {\r\n\t\r\n\t\t\tif ( scope.enabled === false || scope.enableKeys === false || scope.enablePan === false ) return;\r\n\t\r\n\t\t\thandleKeyDown( event );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction onTouchStart( event ) {\r\n\t\r\n\t\t\tif ( scope.enabled === false ) return;\r\n\t\r\n\t\t\tswitch ( event.touches.length ) {\r\n\t\r\n\t\t\t\tcase 1:\t// one-fingered touch: rotate\r\n\t\r\n\t\t\t\t\tif ( scope.enableRotate === false ) return;\r\n\t\r\n\t\t\t\t\thandleTouchStartRotate( event );\r\n\t\r\n\t\t\t\t\tstate = STATE.TOUCH_ROTATE;\r\n\t\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\tcase 2:\t// two-fingered touch: dolly\r\n\t\r\n\t\t\t\t\tif ( scope.enableZoom === false ) return;\r\n\t\r\n\t\t\t\t\thandleTouchStartDolly( event );\r\n\t\r\n\t\t\t\t\tstate = STATE.TOUCH_DOLLY;\r\n\t\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\tcase 3: // three-fingered touch: pan\r\n\t\r\n\t\t\t\t\tif ( scope.enablePan === false ) return;\r\n\t\r\n\t\t\t\t\thandleTouchStartPan( event );\r\n\t\r\n\t\t\t\t\tstate = STATE.TOUCH_PAN;\r\n\t\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\tdefault:\r\n\t\r\n\t\t\t\t\tstate = STATE.NONE;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( state !== STATE.NONE ) {\r\n\t\r\n\t\t\t\tscope.dispatchEvent( startEvent );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction onTouchMove( event ) {\r\n\t\r\n\t\t\tif ( scope.enabled === false ) return;\r\n\t\r\n\t\t\tevent.preventDefault();\r\n\t\t\tevent.stopPropagation();\r\n\t\r\n\t\t\tswitch ( event.touches.length ) {\r\n\t\r\n\t\t\t\tcase 1: // one-fingered touch: rotate\r\n\t\r\n\t\t\t\t\tif ( scope.enableRotate === false ) return;\r\n\t\t\t\t\tif ( state !== STATE.TOUCH_ROTATE ) return; // is this needed?...\r\n\t\r\n\t\t\t\t\thandleTouchMoveRotate( event );\r\n\t\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\tcase 2: // two-fingered touch: dolly\r\n\t\r\n\t\t\t\t\tif ( scope.enableZoom === false ) return;\r\n\t\t\t\t\tif ( state !== STATE.TOUCH_DOLLY ) return; // is this needed?...\r\n\t\r\n\t\t\t\t\thandleTouchMoveDolly( event );\r\n\t\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\tcase 3: // three-fingered touch: pan\r\n\t\r\n\t\t\t\t\tif ( scope.enablePan === false ) return;\r\n\t\t\t\t\tif ( state !== STATE.TOUCH_PAN ) return; // is this needed?...\r\n\t\r\n\t\t\t\t\thandleTouchMovePan( event );\r\n\t\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\tdefault:\r\n\t\r\n\t\t\t\t\tstate = STATE.NONE;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction onTouchEnd( event ) {\r\n\t\r\n\t\t\tif ( scope.enabled === false ) return;\r\n\t\r\n\t\t\thandleTouchEnd( event );\r\n\t\r\n\t\t\tscope.dispatchEvent( endEvent );\r\n\t\r\n\t\t\tstate = STATE.NONE;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction onContextMenu( event ) {\r\n\t\r\n\t\t\tevent.preventDefault();\r\n\t\r\n\t\t}\r\n\t\r\n\t\t//\r\n\t\r\n\t\tscope.domElement.addEventListener( 'contextmenu', onContextMenu, false );\r\n\t\r\n\t\tscope.domElement.addEventListener( 'mousedown', onMouseDown, false );\r\n\t\tscope.domElement.addEventListener( 'mousewheel', onMouseWheel, false );\r\n\t\tscope.domElement.addEventListener( 'MozMousePixelScroll', onMouseWheel, false ); // firefox\r\n\t\r\n\t\tscope.domElement.addEventListener( 'touchstart', onTouchStart, false );\r\n\t\tscope.domElement.addEventListener( 'touchend', onTouchEnd, false );\r\n\t\tscope.domElement.addEventListener( 'touchmove', onTouchMove, false );\r\n\t\r\n\t\twindow.addEventListener( 'keydown', onKeyDown, false );\r\n\t\r\n\t\t// force an update at start\r\n\t\r\n\t\tthis.update();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.OrbitControls.prototype = Object.create( THREE.EventDispatcher.prototype );\r\n\tTHREE.OrbitControls.prototype.constructor = THREE.OrbitControls;\r\n\t\r\n\tObject.defineProperties( THREE.OrbitControls.prototype, {\r\n\t\r\n\t\tcenter: {\r\n\t\r\n\t\t\tget: function () {\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .center has been renamed to .target' );\r\n\t\t\t\treturn this.target;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// backward compatibility\r\n\t\r\n\t\tnoZoom: {\r\n\t\r\n\t\t\tget: function () {\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.' );\r\n\t\t\t\treturn ! this.enableZoom;\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t\tset: function ( value ) {\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.' );\r\n\t\t\t\tthis.enableZoom = ! value;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tnoRotate: {\r\n\t\r\n\t\t\tget: function () {\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.' );\r\n\t\t\t\treturn ! this.enableRotate;\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t\tset: function ( value ) {\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.' );\r\n\t\t\t\tthis.enableRotate = ! value;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tnoPan: {\r\n\t\r\n\t\t\tget: function () {\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.' );\r\n\t\t\t\treturn ! this.enablePan;\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t\tset: function ( value ) {\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.' );\r\n\t\t\t\tthis.enablePan = ! value;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tnoKeys: {\r\n\t\r\n\t\t\tget: function () {\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.' );\r\n\t\t\t\treturn ! this.enableKeys;\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t\tset: function ( value ) {\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.' );\r\n\t\t\t\tthis.enableKeys = ! value;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tstaticMoving : {\r\n\t\r\n\t\t\tget: function () {\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.' );\r\n\t\t\t\treturn ! this.constraint.enableDamping;\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t\tset: function ( value ) {\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.' );\r\n\t\t\t\tthis.constraint.enableDamping = ! value;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdynamicDampingFactor : {\r\n\t\r\n\t\t\tget: function () {\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.' );\r\n\t\t\t\treturn this.constraint.dampingFactor;\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t\tset: function ( value ) {\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.' );\r\n\t\t\t\tthis.constraint.dampingFactor = value;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t} );\r\n\n\n/***/ },\n/* 101 */\n/***/ function(module, exports) {\n\n\t/**\r\n\t * dat-gui JavaScript Controller Library\r\n\t * http://code.google.com/p/dat-gui\r\n\t *\r\n\t * Copyright 2011 Data Arts Team, Google Creative Lab\r\n\t *\r\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n\t * you may not use this file except in compliance with the License.\r\n\t * You may obtain a copy of the License at\r\n\t *\r\n\t * http://www.apache.org/licenses/LICENSE-2.0\r\n\t */\r\n\tvar dat=dat||{};dat.gui=dat.gui||{};dat.utils=dat.utils||{};dat.controllers=dat.controllers||{};dat.dom=dat.dom||{};dat.color=dat.color||{};dat.utils.css=function(){return{load:function(e,a){var a=a||document,c=a.createElement(\"link\");c.type=\"text/css\";c.rel=\"stylesheet\";c.href=e;a.getElementsByTagName(\"head\")[0].appendChild(c)},inject:function(e,a){var a=a||document,c=document.createElement(\"style\");c.type=\"text/css\";c.innerHTML=e;a.getElementsByTagName(\"head\")[0].appendChild(c)}}}();\r\n\tdat.utils.common=function(){var e=Array.prototype.forEach,a=Array.prototype.slice;return{BREAK:{},extend:function(c){this.each(a.call(arguments,1),function(a){for(var f in a)this.isUndefined(a[f])||(c[f]=a[f])},this);return c},defaults:function(c){this.each(a.call(arguments,1),function(a){for(var f in a)this.isUndefined(c[f])&&(c[f]=a[f])},this);return c},compose:function(){var c=a.call(arguments);return function(){for(var d=a.call(arguments),f=c.length-1;f>=0;f--)d=[c[f].apply(this,d)];return d[0]}},\r\n\teach:function(a,d,f){if(e&&a.forEach===e)a.forEach(d,f);else if(a.length===a.length+0)for(var b=0,n=a.length;b<n;b++){if(b in a&&d.call(f,a[b],b)===this.BREAK)break}else for(b in a)if(d.call(f,a[b],b)===this.BREAK)break},defer:function(a){setTimeout(a,0)},toArray:function(c){return c.toArray?c.toArray():a.call(c)},isUndefined:function(a){return a===void 0},isNull:function(a){return a===null},isNaN:function(a){return a!==a},isArray:Array.isArray||function(a){return a.constructor===Array},isObject:function(a){return a===\r\n\tObject(a)},isNumber:function(a){return a===a+0},isString:function(a){return a===a+\"\"},isBoolean:function(a){return a===false||a===true},isFunction:function(a){return Object.prototype.toString.call(a)===\"[object Function]\"}}}();\r\n\tdat.controllers.Controller=function(e){var a=function(a,d){this.initialValue=a[d];this.domElement=document.createElement(\"div\");this.object=a;this.property=d;this.__onFinishChange=this.__onChange=void 0};e.extend(a.prototype,{onChange:function(a){this.__onChange=a;return this},onFinishChange:function(a){this.__onFinishChange=a;return this},setValue:function(a){this.object[this.property]=a;this.__onChange&&this.__onChange.call(this,a);this.updateDisplay();return this},getValue:function(){return this.object[this.property]},\r\n\tupdateDisplay:function(){return this},isModified:function(){return this.initialValue!==this.getValue()}});return a}(dat.utils.common);\r\n\tdat.dom.dom=function(e){function a(b){if(b===\"0\"||e.isUndefined(b))return 0;b=b.match(d);return!e.isNull(b)?parseFloat(b[1]):0}var c={};e.each({HTMLEvents:[\"change\"],MouseEvents:[\"click\",\"mousemove\",\"mousedown\",\"mouseup\",\"mouseover\"],KeyboardEvents:[\"keydown\"]},function(b,a){e.each(b,function(b){c[b]=a})});var d=/(\\d+(\\.\\d+)?)px/,f={makeSelectable:function(b,a){if(!(b===void 0||b.style===void 0))b.onselectstart=a?function(){return false}:function(){},b.style.MozUserSelect=a?\"auto\":\"none\",b.style.KhtmlUserSelect=\r\n\ta?\"auto\":\"none\",b.unselectable=a?\"on\":\"off\"},makeFullscreen:function(b,a,d){e.isUndefined(a)&&(a=true);e.isUndefined(d)&&(d=true);b.style.position=\"absolute\";if(a)b.style.left=0,b.style.right=0;if(d)b.style.top=0,b.style.bottom=0},fakeEvent:function(b,a,d,f){var d=d||{},m=c[a];if(!m)throw Error(\"Event type \"+a+\" not supported.\");var l=document.createEvent(m);switch(m){case \"MouseEvents\":l.initMouseEvent(a,d.bubbles||false,d.cancelable||true,window,d.clickCount||1,0,0,d.x||d.clientX||0,d.y||d.clientY||\r\n\t0,false,false,false,false,0,null);break;case \"KeyboardEvents\":m=l.initKeyboardEvent||l.initKeyEvent;e.defaults(d,{cancelable:true,ctrlKey:false,altKey:false,shiftKey:false,metaKey:false,keyCode:void 0,charCode:void 0});m(a,d.bubbles||false,d.cancelable,window,d.ctrlKey,d.altKey,d.shiftKey,d.metaKey,d.keyCode,d.charCode);break;default:l.initEvent(a,d.bubbles||false,d.cancelable||true)}e.defaults(l,f);b.dispatchEvent(l)},bind:function(b,a,d,c){b.addEventListener?b.addEventListener(a,d,c||false):b.attachEvent&&\r\n\tb.attachEvent(\"on\"+a,d);return f},unbind:function(b,a,d,c){b.removeEventListener?b.removeEventListener(a,d,c||false):b.detachEvent&&b.detachEvent(\"on\"+a,d);return f},addClass:function(b,a){if(b.className===void 0)b.className=a;else if(b.className!==a){var d=b.className.split(/ +/);if(d.indexOf(a)==-1)d.push(a),b.className=d.join(\" \").replace(/^\\s+/,\"\").replace(/\\s+$/,\"\")}return f},removeClass:function(b,a){if(a){if(b.className!==void 0)if(b.className===a)b.removeAttribute(\"class\");else{var d=b.className.split(/ +/),\r\n\tc=d.indexOf(a);if(c!=-1)d.splice(c,1),b.className=d.join(\" \")}}else b.className=void 0;return f},hasClass:function(a,d){return RegExp(\"(?:^|\\\\s+)\"+d+\"(?:\\\\s+|$)\").test(a.className)||false},getWidth:function(b){b=getComputedStyle(b);return a(b[\"border-left-width\"])+a(b[\"border-right-width\"])+a(b[\"padding-left\"])+a(b[\"padding-right\"])+a(b.width)},getHeight:function(b){b=getComputedStyle(b);return a(b[\"border-top-width\"])+a(b[\"border-bottom-width\"])+a(b[\"padding-top\"])+a(b[\"padding-bottom\"])+a(b.height)},\r\n\tgetOffset:function(a){var d={left:0,top:0};if(a.offsetParent){do d.left+=a.offsetLeft,d.top+=a.offsetTop;while(a=a.offsetParent)}return d},isActive:function(a){return a===document.activeElement&&(a.type||a.href)}};return f}(dat.utils.common);\r\n\tdat.controllers.OptionController=function(e,a,c){var d=function(f,b,e){d.superclass.call(this,f,b);var h=this;this.__select=document.createElement(\"select\");if(c.isArray(e)){var j={};c.each(e,function(a){j[a]=a});e=j}c.each(e,function(a,b){var d=document.createElement(\"option\");d.innerHTML=b;d.setAttribute(\"value\",a);h.__select.appendChild(d)});this.updateDisplay();a.bind(this.__select,\"change\",function(){h.setValue(this.options[this.selectedIndex].value)});this.domElement.appendChild(this.__select)};\r\n\td.superclass=e;c.extend(d.prototype,e.prototype,{setValue:function(a){a=d.superclass.prototype.setValue.call(this,a);this.__onFinishChange&&this.__onFinishChange.call(this,this.getValue());return a},updateDisplay:function(){this.__select.value=this.getValue();return d.superclass.prototype.updateDisplay.call(this)}});return d}(dat.controllers.Controller,dat.dom.dom,dat.utils.common);\r\n\tdat.controllers.NumberController=function(e,a){var c=function(d,f,b){c.superclass.call(this,d,f);b=b||{};this.__min=b.min;this.__max=b.max;this.__step=b.step;d=this.__impliedStep=a.isUndefined(this.__step)?this.initialValue==0?1:Math.pow(10,Math.floor(Math.log(this.initialValue)/Math.LN10))/10:this.__step;d=d.toString();this.__precision=d.indexOf(\".\")>-1?d.length-d.indexOf(\".\")-1:0};c.superclass=e;a.extend(c.prototype,e.prototype,{setValue:function(a){if(this.__min!==void 0&&a<this.__min)a=this.__min;\r\n\telse if(this.__max!==void 0&&a>this.__max)a=this.__max;this.__step!==void 0&&a%this.__step!=0&&(a=Math.round(a/this.__step)*this.__step);return c.superclass.prototype.setValue.call(this,a)},min:function(a){this.__min=a;return this},max:function(a){this.__max=a;return this},step:function(a){this.__step=a;return this}});return c}(dat.controllers.Controller,dat.utils.common);\r\n\tdat.controllers.NumberControllerBox=function(e,a,c){var d=function(f,b,e){function h(){var a=parseFloat(l.__input.value);c.isNaN(a)||l.setValue(a)}function j(a){var b=o-a.clientY;l.setValue(l.getValue()+b*l.__impliedStep);o=a.clientY}function m(){a.unbind(window,\"mousemove\",j);a.unbind(window,\"mouseup\",m)}this.__truncationSuspended=false;d.superclass.call(this,f,b,e);var l=this,o;this.__input=document.createElement(\"input\");this.__input.setAttribute(\"type\",\"text\");a.bind(this.__input,\"change\",h);\r\n\ta.bind(this.__input,\"blur\",function(){h();l.__onFinishChange&&l.__onFinishChange.call(l,l.getValue())});a.bind(this.__input,\"mousedown\",function(b){a.bind(window,\"mousemove\",j);a.bind(window,\"mouseup\",m);o=b.clientY});a.bind(this.__input,\"keydown\",function(a){if(a.keyCode===13)l.__truncationSuspended=true,this.blur(),l.__truncationSuspended=false});this.updateDisplay();this.domElement.appendChild(this.__input)};d.superclass=e;c.extend(d.prototype,e.prototype,{updateDisplay:function(){var a=this.__input,\r\n\tb;if(this.__truncationSuspended)b=this.getValue();else{b=this.getValue();var c=Math.pow(10,this.__precision);b=Math.round(b*c)/c}a.value=b;return d.superclass.prototype.updateDisplay.call(this)}});return d}(dat.controllers.NumberController,dat.dom.dom,dat.utils.common);\r\n\tdat.controllers.NumberControllerSlider=function(e,a,c,d,f){var b=function(d,c,f,e,l){function o(b){b.preventDefault();var d=a.getOffset(g.__background),c=a.getWidth(g.__background);g.setValue(g.__min+(g.__max-g.__min)*((b.clientX-d.left)/(d.left+c-d.left)));return false}function y(){a.unbind(window,\"mousemove\",o);a.unbind(window,\"mouseup\",y);g.__onFinishChange&&g.__onFinishChange.call(g,g.getValue())}b.superclass.call(this,d,c,{min:f,max:e,step:l});var g=this;this.__background=document.createElement(\"div\");\r\n\tthis.__foreground=document.createElement(\"div\");a.bind(this.__background,\"mousedown\",function(b){a.bind(window,\"mousemove\",o);a.bind(window,\"mouseup\",y);o(b)});a.addClass(this.__background,\"slider\");a.addClass(this.__foreground,\"slider-fg\");this.updateDisplay();this.__background.appendChild(this.__foreground);this.domElement.appendChild(this.__background)};b.superclass=e;b.useDefaultStyles=function(){c.inject(f)};d.extend(b.prototype,e.prototype,{updateDisplay:function(){this.__foreground.style.width=\r\n\t(this.getValue()-this.__min)/(this.__max-this.__min)*100+\"%\";return b.superclass.prototype.updateDisplay.call(this)}});return b}(dat.controllers.NumberController,dat.dom.dom,dat.utils.css,dat.utils.common,\".slider {\\n  box-shadow: inset 0 2px 4px rgba(0,0,0,0.15);\\n  height: 1em;\\n  border-radius: 1em;\\n  background-color: #eee;\\n  padding: 0 0.5em;\\n  overflow: hidden;\\n}\\n\\n.slider-fg {\\n  padding: 1px 0 2px 0;\\n  background-color: #aaa;\\n  height: 1em;\\n  margin-left: -0.5em;\\n  padding-right: 0.5em;\\n  border-radius: 1em 0 0 1em;\\n}\\n\\n.slider-fg:after {\\n  display: inline-block;\\n  border-radius: 1em;\\n  background-color: #fff;\\n  border:  1px solid #aaa;\\n  content: '';\\n  float: right;\\n  margin-right: -1em;\\n  margin-top: -1px;\\n  height: 0.9em;\\n  width: 0.9em;\\n}\");\r\n\tdat.controllers.FunctionController=function(e,a,c){var d=function(c,b,e){d.superclass.call(this,c,b);var h=this;this.__button=document.createElement(\"div\");this.__button.innerHTML=e===void 0?\"Fire\":e;a.bind(this.__button,\"click\",function(a){a.preventDefault();h.fire();return false});a.addClass(this.__button,\"button\");this.domElement.appendChild(this.__button)};d.superclass=e;c.extend(d.prototype,e.prototype,{fire:function(){this.__onChange&&this.__onChange.call(this);this.__onFinishChange&&this.__onFinishChange.call(this,\r\n\tthis.getValue());this.getValue().call(this.object)}});return d}(dat.controllers.Controller,dat.dom.dom,dat.utils.common);\r\n\tdat.controllers.BooleanController=function(e,a,c){var d=function(c,b){d.superclass.call(this,c,b);var e=this;this.__prev=this.getValue();this.__checkbox=document.createElement(\"input\");this.__checkbox.setAttribute(\"type\",\"checkbox\");a.bind(this.__checkbox,\"change\",function(){e.setValue(!e.__prev)},false);this.domElement.appendChild(this.__checkbox);this.updateDisplay()};d.superclass=e;c.extend(d.prototype,e.prototype,{setValue:function(a){a=d.superclass.prototype.setValue.call(this,a);this.__onFinishChange&&\r\n\tthis.__onFinishChange.call(this,this.getValue());this.__prev=this.getValue();return a},updateDisplay:function(){this.getValue()===true?(this.__checkbox.setAttribute(\"checked\",\"checked\"),this.__checkbox.checked=true):this.__checkbox.checked=false;return d.superclass.prototype.updateDisplay.call(this)}});return d}(dat.controllers.Controller,dat.dom.dom,dat.utils.common);\r\n\tdat.color.toString=function(e){return function(a){if(a.a==1||e.isUndefined(a.a)){for(a=a.hex.toString(16);a.length<6;)a=\"0\"+a;return\"#\"+a}else return\"rgba(\"+Math.round(a.r)+\",\"+Math.round(a.g)+\",\"+Math.round(a.b)+\",\"+a.a+\")\"}}(dat.utils.common);\r\n\tdat.color.interpret=function(e,a){var c,d,f=[{litmus:a.isString,conversions:{THREE_CHAR_HEX:{read:function(a){a=a.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);return a===null?false:{space:\"HEX\",hex:parseInt(\"0x\"+a[1].toString()+a[1].toString()+a[2].toString()+a[2].toString()+a[3].toString()+a[3].toString())}},write:e},SIX_CHAR_HEX:{read:function(a){a=a.match(/^#([A-F0-9]{6})$/i);return a===null?false:{space:\"HEX\",hex:parseInt(\"0x\"+a[1].toString())}},write:e},CSS_RGB:{read:function(a){a=a.match(/^rgb\\(\\s*(.+)\\s*,\\s*(.+)\\s*,\\s*(.+)\\s*\\)/);\r\n\treturn a===null?false:{space:\"RGB\",r:parseFloat(a[1]),g:parseFloat(a[2]),b:parseFloat(a[3])}},write:e},CSS_RGBA:{read:function(a){a=a.match(/^rgba\\(\\s*(.+)\\s*,\\s*(.+)\\s*,\\s*(.+)\\s*\\,\\s*(.+)\\s*\\)/);return a===null?false:{space:\"RGB\",r:parseFloat(a[1]),g:parseFloat(a[2]),b:parseFloat(a[3]),a:parseFloat(a[4])}},write:e}}},{litmus:a.isNumber,conversions:{HEX:{read:function(a){return{space:\"HEX\",hex:a,conversionName:\"HEX\"}},write:function(a){return a.hex}}}},{litmus:a.isArray,conversions:{RGB_ARRAY:{read:function(a){return a.length!=\r\n\t3?false:{space:\"RGB\",r:a[0],g:a[1],b:a[2]}},write:function(a){return[a.r,a.g,a.b]}},RGBA_ARRAY:{read:function(a){return a.length!=4?false:{space:\"RGB\",r:a[0],g:a[1],b:a[2],a:a[3]}},write:function(a){return[a.r,a.g,a.b,a.a]}}}},{litmus:a.isObject,conversions:{RGBA_OBJ:{read:function(b){return a.isNumber(b.r)&&a.isNumber(b.g)&&a.isNumber(b.b)&&a.isNumber(b.a)?{space:\"RGB\",r:b.r,g:b.g,b:b.b,a:b.a}:false},write:function(a){return{r:a.r,g:a.g,b:a.b,a:a.a}}},RGB_OBJ:{read:function(b){return a.isNumber(b.r)&&\r\n\ta.isNumber(b.g)&&a.isNumber(b.b)?{space:\"RGB\",r:b.r,g:b.g,b:b.b}:false},write:function(a){return{r:a.r,g:a.g,b:a.b}}},HSVA_OBJ:{read:function(b){return a.isNumber(b.h)&&a.isNumber(b.s)&&a.isNumber(b.v)&&a.isNumber(b.a)?{space:\"HSV\",h:b.h,s:b.s,v:b.v,a:b.a}:false},write:function(a){return{h:a.h,s:a.s,v:a.v,a:a.a}}},HSV_OBJ:{read:function(b){return a.isNumber(b.h)&&a.isNumber(b.s)&&a.isNumber(b.v)?{space:\"HSV\",h:b.h,s:b.s,v:b.v}:false},write:function(a){return{h:a.h,s:a.s,v:a.v}}}}}];return function(){d=\r\n\tfalse;var b=arguments.length>1?a.toArray(arguments):arguments[0];a.each(f,function(e){if(e.litmus(b))return a.each(e.conversions,function(e,f){c=e.read(b);if(d===false&&c!==false)return d=c,c.conversionName=f,c.conversion=e,a.BREAK}),a.BREAK});return d}}(dat.color.toString,dat.utils.common);\r\n\tdat.GUI=dat.gui.GUI=function(e,a,c,d,f,b,n,h,j,m,l,o,y,g,i){function q(a,b,r,c){if(b[r]===void 0)throw Error(\"Object \"+b+' has no property \"'+r+'\"');c.color?b=new l(b,r):(b=[b,r].concat(c.factoryArgs),b=d.apply(a,b));if(c.before instanceof f)c.before=c.before.__li;t(a,b);g.addClass(b.domElement,\"c\");r=document.createElement(\"span\");g.addClass(r,\"property-name\");r.innerHTML=b.property;var e=document.createElement(\"div\");e.appendChild(r);e.appendChild(b.domElement);c=s(a,e,c.before);g.addClass(c,k.CLASS_CONTROLLER_ROW);\r\n\tg.addClass(c,typeof b.getValue());p(a,c,b);a.__controllers.push(b);return b}function s(a,b,d){var c=document.createElement(\"li\");b&&c.appendChild(b);d?a.__ul.insertBefore(c,params.before):a.__ul.appendChild(c);a.onResize();return c}function p(a,d,c){c.__li=d;c.__gui=a;i.extend(c,{options:function(b){if(arguments.length>1)return c.remove(),q(a,c.object,c.property,{before:c.__li.nextElementSibling,factoryArgs:[i.toArray(arguments)]});if(i.isArray(b)||i.isObject(b))return c.remove(),q(a,c.object,c.property,\r\n\t{before:c.__li.nextElementSibling,factoryArgs:[b]})},name:function(a){c.__li.firstElementChild.firstElementChild.innerHTML=a;return c},listen:function(){c.__gui.listen(c);return c},remove:function(){c.__gui.remove(c);return c}});if(c instanceof j){var e=new h(c.object,c.property,{min:c.__min,max:c.__max,step:c.__step});i.each([\"updateDisplay\",\"onChange\",\"onFinishChange\"],function(a){var b=c[a],H=e[a];c[a]=e[a]=function(){var a=Array.prototype.slice.call(arguments);b.apply(c,a);return H.apply(e,a)}});\r\n\tg.addClass(d,\"has-slider\");c.domElement.insertBefore(e.domElement,c.domElement.firstElementChild)}else if(c instanceof h){var f=function(b){return i.isNumber(c.__min)&&i.isNumber(c.__max)?(c.remove(),q(a,c.object,c.property,{before:c.__li.nextElementSibling,factoryArgs:[c.__min,c.__max,c.__step]})):b};c.min=i.compose(f,c.min);c.max=i.compose(f,c.max)}else if(c instanceof b)g.bind(d,\"click\",function(){g.fakeEvent(c.__checkbox,\"click\")}),g.bind(c.__checkbox,\"click\",function(a){a.stopPropagation()});\r\n\telse if(c instanceof n)g.bind(d,\"click\",function(){g.fakeEvent(c.__button,\"click\")}),g.bind(d,\"mouseover\",function(){g.addClass(c.__button,\"hover\")}),g.bind(d,\"mouseout\",function(){g.removeClass(c.__button,\"hover\")});else if(c instanceof l)g.addClass(d,\"color\"),c.updateDisplay=i.compose(function(a){d.style.borderLeftColor=c.__color.toString();return a},c.updateDisplay),c.updateDisplay();c.setValue=i.compose(function(b){a.getRoot().__preset_select&&c.isModified()&&B(a.getRoot(),true);return b},c.setValue)}\r\n\tfunction t(a,b){var c=a.getRoot(),d=c.__rememberedObjects.indexOf(b.object);if(d!=-1){var e=c.__rememberedObjectIndecesToControllers[d];e===void 0&&(e={},c.__rememberedObjectIndecesToControllers[d]=e);e[b.property]=b;if(c.load&&c.load.remembered){c=c.load.remembered;if(c[a.preset])c=c[a.preset];else if(c[w])c=c[w];else return;if(c[d]&&c[d][b.property]!==void 0)d=c[d][b.property],b.initialValue=d,b.setValue(d)}}}function I(a){var b=a.__save_row=document.createElement(\"li\");g.addClass(a.domElement,\r\n\t\"has-save\");a.__ul.insertBefore(b,a.__ul.firstChild);g.addClass(b,\"save-row\");var c=document.createElement(\"span\");c.innerHTML=\"&nbsp;\";g.addClass(c,\"button gears\");var d=document.createElement(\"span\");d.innerHTML=\"Save\";g.addClass(d,\"button\");g.addClass(d,\"save\");var e=document.createElement(\"span\");e.innerHTML=\"New\";g.addClass(e,\"button\");g.addClass(e,\"save-as\");var f=document.createElement(\"span\");f.innerHTML=\"Revert\";g.addClass(f,\"button\");g.addClass(f,\"revert\");var m=a.__preset_select=document.createElement(\"select\");\r\n\ta.load&&a.load.remembered?i.each(a.load.remembered,function(b,c){C(a,c,c==a.preset)}):C(a,w,false);g.bind(m,\"change\",function(){for(var b=0;b<a.__preset_select.length;b++)a.__preset_select[b].innerHTML=a.__preset_select[b].value;a.preset=this.value});b.appendChild(m);b.appendChild(c);b.appendChild(d);b.appendChild(e);b.appendChild(f);if(u){var b=document.getElementById(\"dg-save-locally\"),l=document.getElementById(\"dg-local-explain\");b.style.display=\"block\";b=document.getElementById(\"dg-local-storage\");\r\n\tlocalStorage.getItem(document.location.href+\".isLocal\")===\"true\"&&b.setAttribute(\"checked\",\"checked\");var o=function(){l.style.display=a.useLocalStorage?\"block\":\"none\"};o();g.bind(b,\"change\",function(){a.useLocalStorage=!a.useLocalStorage;o()})}var h=document.getElementById(\"dg-new-constructor\");g.bind(h,\"keydown\",function(a){a.metaKey&&(a.which===67||a.keyCode==67)&&x.hide()});g.bind(c,\"click\",function(){h.innerHTML=JSON.stringify(a.getSaveObject(),void 0,2);x.show();h.focus();h.select()});g.bind(d,\r\n\t\"click\",function(){a.save()});g.bind(e,\"click\",function(){var b=prompt(\"Enter a new preset name.\");b&&a.saveAs(b)});g.bind(f,\"click\",function(){a.revert()})}function J(a){function b(f){f.preventDefault();e=f.clientX;g.addClass(a.__closeButton,k.CLASS_DRAG);g.bind(window,\"mousemove\",c);g.bind(window,\"mouseup\",d);return false}function c(b){b.preventDefault();a.width+=e-b.clientX;a.onResize();e=b.clientX;return false}function d(){g.removeClass(a.__closeButton,k.CLASS_DRAG);g.unbind(window,\"mousemove\",\r\n\tc);g.unbind(window,\"mouseup\",d)}a.__resize_handle=document.createElement(\"div\");i.extend(a.__resize_handle.style,{width:\"6px\",marginLeft:\"-3px\",height:\"200px\",cursor:\"ew-resize\",position:\"absolute\"});var e;g.bind(a.__resize_handle,\"mousedown\",b);g.bind(a.__closeButton,\"mousedown\",b);a.domElement.insertBefore(a.__resize_handle,a.domElement.firstElementChild)}function D(a,b){a.domElement.style.width=b+\"px\";if(a.__save_row&&a.autoPlace)a.__save_row.style.width=b+\"px\";if(a.__closeButton)a.__closeButton.style.width=\r\n\tb+\"px\"}function z(a,b){var c={};i.each(a.__rememberedObjects,function(d,e){var f={};i.each(a.__rememberedObjectIndecesToControllers[e],function(a,c){f[c]=b?a.initialValue:a.getValue()});c[e]=f});return c}function C(a,b,c){var d=document.createElement(\"option\");d.innerHTML=b;d.value=b;a.__preset_select.appendChild(d);if(c)a.__preset_select.selectedIndex=a.__preset_select.length-1}function B(a,b){var c=a.__preset_select[a.__preset_select.selectedIndex];c.innerHTML=b?c.value+\"*\":c.value}function E(a){a.length!=\r\n\t0&&o(function(){E(a)});i.each(a,function(a){a.updateDisplay()})}e.inject(c);var w=\"Default\",u;try{u=\"localStorage\"in window&&window.localStorage!==null}catch(K){u=false}var x,F=true,v,A=false,G=[],k=function(a){function b(){localStorage.setItem(document.location.href+\".gui\",JSON.stringify(d.getSaveObject()))}function c(){var a=d.getRoot();a.width+=1;i.defer(function(){a.width-=1})}var d=this;this.domElement=document.createElement(\"div\");this.__ul=document.createElement(\"ul\");this.domElement.appendChild(this.__ul);\r\n\tg.addClass(this.domElement,\"dg\");this.__folders={};this.__controllers=[];this.__rememberedObjects=[];this.__rememberedObjectIndecesToControllers=[];this.__listening=[];a=a||{};a=i.defaults(a,{autoPlace:true,width:k.DEFAULT_WIDTH});a=i.defaults(a,{resizable:a.autoPlace,hideable:a.autoPlace});if(i.isUndefined(a.load))a.load={preset:w};else if(a.preset)a.load.preset=a.preset;i.isUndefined(a.parent)&&a.hideable&&G.push(this);a.resizable=i.isUndefined(a.parent)&&a.resizable;if(a.autoPlace&&i.isUndefined(a.scrollable))a.scrollable=\r\n\ttrue;var e=u&&localStorage.getItem(document.location.href+\".isLocal\")===\"true\";Object.defineProperties(this,{parent:{get:function(){return a.parent}},scrollable:{get:function(){return a.scrollable}},autoPlace:{get:function(){return a.autoPlace}},preset:{get:function(){return d.parent?d.getRoot().preset:a.load.preset},set:function(b){d.parent?d.getRoot().preset=b:a.load.preset=b;for(b=0;b<this.__preset_select.length;b++)if(this.__preset_select[b].value==this.preset)this.__preset_select.selectedIndex=\r\n\tb;d.revert()}},width:{get:function(){return a.width},set:function(b){a.width=b;D(d,b)}},name:{get:function(){return a.name},set:function(b){a.name=b;if(m)m.innerHTML=a.name}},closed:{get:function(){return a.closed},set:function(b){a.closed=b;a.closed?g.addClass(d.__ul,k.CLASS_CLOSED):g.removeClass(d.__ul,k.CLASS_CLOSED);this.onResize();if(d.__closeButton)d.__closeButton.innerHTML=b?k.TEXT_OPEN:k.TEXT_CLOSED}},load:{get:function(){return a.load}},useLocalStorage:{get:function(){return e},set:function(a){u&&\r\n\t((e=a)?g.bind(window,\"unload\",b):g.unbind(window,\"unload\",b),localStorage.setItem(document.location.href+\".isLocal\",a))}}});if(i.isUndefined(a.parent)){a.closed=false;g.addClass(this.domElement,k.CLASS_MAIN);g.makeSelectable(this.domElement,false);if(u&&e){d.useLocalStorage=true;var f=localStorage.getItem(document.location.href+\".gui\");if(f)a.load=JSON.parse(f)}this.__closeButton=document.createElement(\"div\");this.__closeButton.innerHTML=k.TEXT_CLOSED;g.addClass(this.__closeButton,k.CLASS_CLOSE_BUTTON);\r\n\tthis.domElement.appendChild(this.__closeButton);g.bind(this.__closeButton,\"click\",function(){d.closed=!d.closed})}else{if(a.closed===void 0)a.closed=true;var m=document.createTextNode(a.name);g.addClass(m,\"controller-name\");f=s(d,m);g.addClass(this.__ul,k.CLASS_CLOSED);g.addClass(f,\"title\");g.bind(f,\"click\",function(a){a.preventDefault();d.closed=!d.closed;return false});if(!a.closed)this.closed=false}a.autoPlace&&(i.isUndefined(a.parent)&&(F&&(v=document.createElement(\"div\"),g.addClass(v,\"dg\"),g.addClass(v,\r\n\tk.CLASS_AUTO_PLACE_CONTAINER),document.body.appendChild(v),F=false),v.appendChild(this.domElement),g.addClass(this.domElement,k.CLASS_AUTO_PLACE)),this.parent||D(d,a.width));g.bind(window,\"resize\",function(){d.onResize()});g.bind(this.__ul,\"webkitTransitionEnd\",function(){d.onResize()});g.bind(this.__ul,\"transitionend\",function(){d.onResize()});g.bind(this.__ul,\"oTransitionEnd\",function(){d.onResize()});this.onResize();a.resizable&&J(this);d.getRoot();a.parent||c()};k.toggleHide=function(){A=!A;i.each(G,\r\n\tfunction(a){a.domElement.style.zIndex=A?-999:999;a.domElement.style.opacity=A?0:1})};k.CLASS_AUTO_PLACE=\"a\";k.CLASS_AUTO_PLACE_CONTAINER=\"ac\";k.CLASS_MAIN=\"main\";k.CLASS_CONTROLLER_ROW=\"cr\";k.CLASS_TOO_TALL=\"taller-than-window\";k.CLASS_CLOSED=\"closed\";k.CLASS_CLOSE_BUTTON=\"close-button\";k.CLASS_DRAG=\"drag\";k.DEFAULT_WIDTH=245;k.TEXT_CLOSED=\"Close Controls\";k.TEXT_OPEN=\"Open Controls\";g.bind(window,\"keydown\",function(a){document.activeElement.type!==\"text\"&&(a.which===72||a.keyCode==72)&&k.toggleHide()},\r\n\tfalse);i.extend(k.prototype,{add:function(a,b){return q(this,a,b,{factoryArgs:Array.prototype.slice.call(arguments,2)})},addColor:function(a,b){return q(this,a,b,{color:true})},remove:function(a){this.__ul.removeChild(a.__li);this.__controllers.slice(this.__controllers.indexOf(a),1);var b=this;i.defer(function(){b.onResize()})},destroy:function(){this.autoPlace&&v.removeChild(this.domElement)},addFolder:function(a){if(this.__folders[a]!==void 0)throw Error('You already have a folder in this GUI by the name \"'+\r\n\ta+'\"');var b={name:a,parent:this};b.autoPlace=this.autoPlace;if(this.load&&this.load.folders&&this.load.folders[a])b.closed=this.load.folders[a].closed,b.load=this.load.folders[a];b=new k(b);this.__folders[a]=b;a=s(this,b.domElement);g.addClass(a,\"folder\");return b},open:function(){this.closed=false},close:function(){this.closed=true},onResize:function(){var a=this.getRoot();if(a.scrollable){var b=g.getOffset(a.__ul).top,c=0;i.each(a.__ul.childNodes,function(b){a.autoPlace&&b===a.__save_row||(c+=\r\n\tg.getHeight(b))});window.innerHeight-b-20<c?(g.addClass(a.domElement,k.CLASS_TOO_TALL),a.__ul.style.height=window.innerHeight-b-20+\"px\"):(g.removeClass(a.domElement,k.CLASS_TOO_TALL),a.__ul.style.height=\"auto\")}a.__resize_handle&&i.defer(function(){a.__resize_handle.style.height=a.__ul.offsetHeight+\"px\"});if(a.__closeButton)a.__closeButton.style.width=a.width+\"px\"},remember:function(){if(i.isUndefined(x))x=new y,x.domElement.innerHTML=a;if(this.parent)throw Error(\"You can only call remember on a top level GUI.\");\r\n\tvar b=this;i.each(Array.prototype.slice.call(arguments),function(a){b.__rememberedObjects.length==0&&I(b);b.__rememberedObjects.indexOf(a)==-1&&b.__rememberedObjects.push(a)});this.autoPlace&&D(this,this.width)},getRoot:function(){for(var a=this;a.parent;)a=a.parent;return a},getSaveObject:function(){var a=this.load;a.closed=this.closed;if(this.__rememberedObjects.length>0){a.preset=this.preset;if(!a.remembered)a.remembered={};a.remembered[this.preset]=z(this)}a.folders={};i.each(this.__folders,function(b,\r\n\tc){a.folders[c]=b.getSaveObject()});return a},save:function(){if(!this.load.remembered)this.load.remembered={};this.load.remembered[this.preset]=z(this);B(this,false)},saveAs:function(a){if(!this.load.remembered)this.load.remembered={},this.load.remembered[w]=z(this,true);this.load.remembered[a]=z(this);this.preset=a;C(this,a,true)},revert:function(a){i.each(this.__controllers,function(b){this.getRoot().load.remembered?t(a||this.getRoot(),b):b.setValue(b.initialValue)},this);i.each(this.__folders,\r\n\tfunction(a){a.revert(a)});a||B(this.getRoot(),false)},listen:function(a){var b=this.__listening.length==0;this.__listening.push(a);b&&E(this.__listening)}});return k}(dat.utils.css,'<div id=\"dg-save\" class=\"dg dialogue\">\\n\\n  Here\\'s the new load parameter for your <code>GUI</code>\\'s constructor:\\n\\n  <textarea id=\"dg-new-constructor\"></textarea>\\n\\n  <div id=\"dg-save-locally\">\\n\\n    <input id=\"dg-local-storage\" type=\"checkbox\"/> Automatically save\\n    values to <code>localStorage</code> on exit.\\n\\n    <div id=\"dg-local-explain\">The values saved to <code>localStorage</code> will\\n      override those passed to <code>dat.GUI</code>\\'s constructor. This makes it\\n      easier to work incrementally, but <code>localStorage</code> is fragile,\\n      and your friends may not see the same values you do.\\n      \\n    </div>\\n    \\n  </div>\\n\\n</div>',\r\n\t\".dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity 0.1s linear;-o-transition:opacity 0.1s linear;-moz-transition:opacity 0.1s linear;transition:opacity 0.1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity 0.1s linear;-o-transition:opacity 0.1s linear;-moz-transition:opacity 0.1s linear;transition:opacity 0.1s linear;border:0;position:absolute;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-x:hidden}.dg.a.has-save ul{margin-top:27px}.dg.a.has-save ul.closed{margin-top:0}.dg.a .save-row{position:fixed;top:0;z-index:1002}.dg li{-webkit-transition:height 0.1s ease-out;-o-transition:height 0.1s ease-out;-moz-transition:height 0.1s ease-out;transition:height 0.1s ease-out}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;overflow:hidden;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li > *{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .c{float:left;width:60%}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:9px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2fa1d6}.dg .cr.number input[type=text]{color:#2fa1d6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2fa1d6}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}\\n\",\r\n\tdat.controllers.factory=function(e,a,c,d,f,b,n){return function(h,j,m,l){var o=h[j];if(n.isArray(m)||n.isObject(m))return new e(h,j,m);if(n.isNumber(o))return n.isNumber(m)&&n.isNumber(l)?new c(h,j,m,l):new a(h,j,{min:m,max:l});if(n.isString(o))return new d(h,j);if(n.isFunction(o))return new f(h,j,\"\");if(n.isBoolean(o))return new b(h,j)}}(dat.controllers.OptionController,dat.controllers.NumberControllerBox,dat.controllers.NumberControllerSlider,dat.controllers.StringController=function(e,a,c){var d=\r\n\tfunction(c,b){function e(){h.setValue(h.__input.value)}d.superclass.call(this,c,b);var h=this;this.__input=document.createElement(\"input\");this.__input.setAttribute(\"type\",\"text\");a.bind(this.__input,\"keyup\",e);a.bind(this.__input,\"change\",e);a.bind(this.__input,\"blur\",function(){h.__onFinishChange&&h.__onFinishChange.call(h,h.getValue())});a.bind(this.__input,\"keydown\",function(a){a.keyCode===13&&this.blur()});this.updateDisplay();this.domElement.appendChild(this.__input)};d.superclass=e;c.extend(d.prototype,\r\n\te.prototype,{updateDisplay:function(){if(!a.isActive(this.__input))this.__input.value=this.getValue();return d.superclass.prototype.updateDisplay.call(this)}});return d}(dat.controllers.Controller,dat.dom.dom,dat.utils.common),dat.controllers.FunctionController,dat.controllers.BooleanController,dat.utils.common),dat.controllers.Controller,dat.controllers.BooleanController,dat.controllers.FunctionController,dat.controllers.NumberControllerBox,dat.controllers.NumberControllerSlider,dat.controllers.OptionController,\r\n\tdat.controllers.ColorController=function(e,a,c,d,f){function b(a,b,c,d){a.style.background=\"\";f.each(j,function(e){a.style.cssText+=\"background: \"+e+\"linear-gradient(\"+b+\", \"+c+\" 0%, \"+d+\" 100%); \"})}function n(a){a.style.background=\"\";a.style.cssText+=\"background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);\";a.style.cssText+=\"background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);\";\r\n\ta.style.cssText+=\"background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);\";a.style.cssText+=\"background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);\";a.style.cssText+=\"background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);\"}var h=function(e,l){function o(b){q(b);a.bind(window,\"mousemove\",q);a.bind(window,\r\n\t\"mouseup\",j)}function j(){a.unbind(window,\"mousemove\",q);a.unbind(window,\"mouseup\",j)}function g(){var a=d(this.value);a!==false?(p.__color.__state=a,p.setValue(p.__color.toOriginal())):this.value=p.__color.toString()}function i(){a.unbind(window,\"mousemove\",s);a.unbind(window,\"mouseup\",i)}function q(b){b.preventDefault();var c=a.getWidth(p.__saturation_field),d=a.getOffset(p.__saturation_field),e=(b.clientX-d.left+document.body.scrollLeft)/c,b=1-(b.clientY-d.top+document.body.scrollTop)/c;b>1?b=\r\n\t1:b<0&&(b=0);e>1?e=1:e<0&&(e=0);p.__color.v=b;p.__color.s=e;p.setValue(p.__color.toOriginal());return false}function s(b){b.preventDefault();var c=a.getHeight(p.__hue_field),d=a.getOffset(p.__hue_field),b=1-(b.clientY-d.top+document.body.scrollTop)/c;b>1?b=1:b<0&&(b=0);p.__color.h=b*360;p.setValue(p.__color.toOriginal());return false}h.superclass.call(this,e,l);this.__color=new c(this.getValue());this.__temp=new c(0);var p=this;this.domElement=document.createElement(\"div\");a.makeSelectable(this.domElement,\r\n\tfalse);this.__selector=document.createElement(\"div\");this.__selector.className=\"selector\";this.__saturation_field=document.createElement(\"div\");this.__saturation_field.className=\"saturation-field\";this.__field_knob=document.createElement(\"div\");this.__field_knob.className=\"field-knob\";this.__field_knob_border=\"2px solid \";this.__hue_knob=document.createElement(\"div\");this.__hue_knob.className=\"hue-knob\";this.__hue_field=document.createElement(\"div\");this.__hue_field.className=\"hue-field\";this.__input=\r\n\tdocument.createElement(\"input\");this.__input.type=\"text\";this.__input_textShadow=\"0 1px 1px \";a.bind(this.__input,\"keydown\",function(a){a.keyCode===13&&g.call(this)});a.bind(this.__input,\"blur\",g);a.bind(this.__selector,\"mousedown\",function(){a.addClass(this,\"drag\").bind(window,\"mouseup\",function(){a.removeClass(p.__selector,\"drag\")})});var t=document.createElement(\"div\");f.extend(this.__selector.style,{width:\"122px\",height:\"102px\",padding:\"3px\",backgroundColor:\"#222\",boxShadow:\"0px 1px 3px rgba(0,0,0,0.3)\"});\r\n\tf.extend(this.__field_knob.style,{position:\"absolute\",width:\"12px\",height:\"12px\",border:this.__field_knob_border+(this.__color.v<0.5?\"#fff\":\"#000\"),boxShadow:\"0px 1px 3px rgba(0,0,0,0.5)\",borderRadius:\"12px\",zIndex:1});f.extend(this.__hue_knob.style,{position:\"absolute\",width:\"15px\",height:\"2px\",borderRight:\"4px solid #fff\",zIndex:1});f.extend(this.__saturation_field.style,{width:\"100px\",height:\"100px\",border:\"1px solid #555\",marginRight:\"3px\",display:\"inline-block\",cursor:\"pointer\"});f.extend(t.style,\r\n\t{width:\"100%\",height:\"100%\",background:\"none\"});b(t,\"top\",\"rgba(0,0,0,0)\",\"#000\");f.extend(this.__hue_field.style,{width:\"15px\",height:\"100px\",display:\"inline-block\",border:\"1px solid #555\",cursor:\"ns-resize\"});n(this.__hue_field);f.extend(this.__input.style,{outline:\"none\",textAlign:\"center\",color:\"#fff\",border:0,fontWeight:\"bold\",textShadow:this.__input_textShadow+\"rgba(0,0,0,0.7)\"});a.bind(this.__saturation_field,\"mousedown\",o);a.bind(this.__field_knob,\"mousedown\",o);a.bind(this.__hue_field,\"mousedown\",\r\n\tfunction(b){s(b);a.bind(window,\"mousemove\",s);a.bind(window,\"mouseup\",i)});this.__saturation_field.appendChild(t);this.__selector.appendChild(this.__field_knob);this.__selector.appendChild(this.__saturation_field);this.__selector.appendChild(this.__hue_field);this.__hue_field.appendChild(this.__hue_knob);this.domElement.appendChild(this.__input);this.domElement.appendChild(this.__selector);this.updateDisplay()};h.superclass=e;f.extend(h.prototype,e.prototype,{updateDisplay:function(){var a=d(this.getValue());\r\n\tif(a!==false){var e=false;f.each(c.COMPONENTS,function(b){if(!f.isUndefined(a[b])&&!f.isUndefined(this.__color.__state[b])&&a[b]!==this.__color.__state[b])return e=true,{}},this);e&&f.extend(this.__color.__state,a)}f.extend(this.__temp.__state,this.__color.__state);this.__temp.a=1;var h=this.__color.v<0.5||this.__color.s>0.5?255:0,j=255-h;f.extend(this.__field_knob.style,{marginLeft:100*this.__color.s-7+\"px\",marginTop:100*(1-this.__color.v)-7+\"px\",backgroundColor:this.__temp.toString(),border:this.__field_knob_border+\r\n\t\"rgb(\"+h+\",\"+h+\",\"+h+\")\"});this.__hue_knob.style.marginTop=(1-this.__color.h/360)*100+\"px\";this.__temp.s=1;this.__temp.v=1;b(this.__saturation_field,\"left\",\"#fff\",this.__temp.toString());f.extend(this.__input.style,{backgroundColor:this.__input.value=this.__color.toString(),color:\"rgb(\"+h+\",\"+h+\",\"+h+\")\",textShadow:this.__input_textShadow+\"rgba(\"+j+\",\"+j+\",\"+j+\",.7)\"})}});var j=[\"-moz-\",\"-o-\",\"-webkit-\",\"-ms-\",\"\"];return h}(dat.controllers.Controller,dat.dom.dom,dat.color.Color=function(e,a,c,d){function f(a,\r\n\tb,c){Object.defineProperty(a,b,{get:function(){if(this.__state.space===\"RGB\")return this.__state[b];n(this,b,c);return this.__state[b]},set:function(a){if(this.__state.space!==\"RGB\")n(this,b,c),this.__state.space=\"RGB\";this.__state[b]=a}})}function b(a,b){Object.defineProperty(a,b,{get:function(){if(this.__state.space===\"HSV\")return this.__state[b];h(this);return this.__state[b]},set:function(a){if(this.__state.space!==\"HSV\")h(this),this.__state.space=\"HSV\";this.__state[b]=a}})}function n(b,c,e){if(b.__state.space===\r\n\t\"HEX\")b.__state[c]=a.component_from_hex(b.__state.hex,e);else if(b.__state.space===\"HSV\")d.extend(b.__state,a.hsv_to_rgb(b.__state.h,b.__state.s,b.__state.v));else throw\"Corrupted color state\";}function h(b){var c=a.rgb_to_hsv(b.r,b.g,b.b);d.extend(b.__state,{s:c.s,v:c.v});if(d.isNaN(c.h)){if(d.isUndefined(b.__state.h))b.__state.h=0}else b.__state.h=c.h}var j=function(){this.__state=e.apply(this,arguments);if(this.__state===false)throw\"Failed to interpret color arguments\";this.__state.a=this.__state.a||\r\n\t1};j.COMPONENTS=\"r,g,b,h,s,v,hex,a\".split(\",\");d.extend(j.prototype,{toString:function(){return c(this)},toOriginal:function(){return this.__state.conversion.write(this)}});f(j.prototype,\"r\",2);f(j.prototype,\"g\",1);f(j.prototype,\"b\",0);b(j.prototype,\"h\");b(j.prototype,\"s\");b(j.prototype,\"v\");Object.defineProperty(j.prototype,\"a\",{get:function(){return this.__state.a},set:function(a){this.__state.a=a}});Object.defineProperty(j.prototype,\"hex\",{get:function(){if(!this.__state.space!==\"HEX\")this.__state.hex=\r\n\ta.rgb_to_hex(this.r,this.g,this.b);return this.__state.hex},set:function(a){this.__state.space=\"HEX\";this.__state.hex=a}});return j}(dat.color.interpret,dat.color.math=function(){var e;return{hsv_to_rgb:function(a,c,d){var e=a/60-Math.floor(a/60),b=d*(1-c),n=d*(1-e*c),c=d*(1-(1-e)*c),a=[[d,c,b],[n,d,b],[b,d,c],[b,n,d],[c,b,d],[d,b,n]][Math.floor(a/60)%6];return{r:a[0]*255,g:a[1]*255,b:a[2]*255}},rgb_to_hsv:function(a,c,d){var e=Math.min(a,c,d),b=Math.max(a,c,d),e=b-e;if(b==0)return{h:NaN,s:0,v:0};\r\n\ta=a==b?(c-d)/e:c==b?2+(d-a)/e:4+(a-c)/e;a/=6;a<0&&(a+=1);return{h:a*360,s:e/b,v:b/255}},rgb_to_hex:function(a,c,d){a=this.hex_with_component(0,2,a);a=this.hex_with_component(a,1,c);return a=this.hex_with_component(a,0,d)},component_from_hex:function(a,c){return a>>c*8&255},hex_with_component:function(a,c,d){return d<<(e=c*8)|a&~(255<<e)}}}(),dat.color.toString,dat.utils.common),dat.color.interpret,dat.utils.common),dat.utils.requestAnimationFrame=function(){return window.requestAnimationFrame||window.webkitRequestAnimationFrame||\r\n\twindow.mozRequestAnimationFrame||window.oRequestAnimationFrame||window.msRequestAnimationFrame||function(e){window.setTimeout(e,1E3/60)}}(),dat.dom.CenteredDiv=function(e,a){var c=function(){this.backgroundElement=document.createElement(\"div\");a.extend(this.backgroundElement.style,{backgroundColor:\"rgba(0,0,0,0.8)\",top:0,left:0,display:\"none\",zIndex:\"1000\",opacity:0,WebkitTransition:\"opacity 0.2s linear\"});e.makeFullscreen(this.backgroundElement);this.backgroundElement.style.position=\"fixed\";this.domElement=\r\n\tdocument.createElement(\"div\");a.extend(this.domElement.style,{position:\"fixed\",display:\"none\",zIndex:\"1001\",opacity:0,WebkitTransition:\"-webkit-transform 0.2s ease-out, opacity 0.2s linear\"});document.body.appendChild(this.backgroundElement);document.body.appendChild(this.domElement);var c=this;e.bind(this.backgroundElement,\"click\",function(){c.hide()})};c.prototype.show=function(){var c=this;this.backgroundElement.style.display=\"block\";this.domElement.style.display=\"block\";this.domElement.style.opacity=\r\n\t0;this.domElement.style.webkitTransform=\"scale(1.1)\";this.layout();a.defer(function(){c.backgroundElement.style.opacity=1;c.domElement.style.opacity=1;c.domElement.style.webkitTransform=\"scale(1)\"})};c.prototype.hide=function(){var a=this,c=function(){a.domElement.style.display=\"none\";a.backgroundElement.style.display=\"none\";e.unbind(a.domElement,\"webkitTransitionEnd\",c);e.unbind(a.domElement,\"transitionend\",c);e.unbind(a.domElement,\"oTransitionEnd\",c)};e.bind(this.domElement,\"webkitTransitionEnd\",\r\n\tc);e.bind(this.domElement,\"transitionend\",c);e.bind(this.domElement,\"oTransitionEnd\",c);this.backgroundElement.style.opacity=0;this.domElement.style.opacity=0;this.domElement.style.webkitTransform=\"scale(1.1)\"};c.prototype.layout=function(){this.domElement.style.left=window.innerWidth/2-e.getWidth(this.domElement)/2+\"px\";this.domElement.style.top=window.innerHeight/2-e.getHeight(this.domElement)/2+\"px\"};return c}(dat.dom.dom,dat.utils.common),dat.dom.dom,dat.utils.common);\n\t\n\t/*** EXPORTS FROM exports-loader ***/\n\tmodule.exports = dat;\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** js/main-842c7e0d80f94aae4b1e.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"./\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 842c7e0d80f94aae4b1e\n **/","import html from '../index.html';\nimport styles from '../css/style.css';\nimport THREE from 'three';\nconst scene = require('../textures/checkerboard.png');\nglobal.THREE = THREE;\nimport Particle from './particle';\nrequire('three/examples/js/controls/OrbitControls');\nimport Stats from 'three/examples/js/libs/stats.min';\nconst dat = require('exports?dat!three/examples/js/libs/dat.gui.min');\n\nconst stats = new Stats();\nstats.showPanel(0); // 0: fps, 1: ms, 2: mb, 3+: custom\ndocument.body.appendChild(stats.dom);\n\nclass App {\n\n    constructor() {\n        this.scene = new THREE.Scene();\n\n        this.camera = new THREE.PerspectiveCamera(75,\n            window.innerWidth / window.innerHeight, 1, 10000);\n        this.camera.position.z = 1000;\n\n        this.stars = [];\n\n        for (let i = 0, l = 4; i < l; i++) {\n            this.stars[i] = this.buildStar();\n            this.scene.add(this.stars[i]);\n        }\n\n        const geometry = new THREE.BoxBufferGeometry(5000, 5000, 5000);\n        this.material = new THREE.MeshBasicMaterial({\n            side: THREE.BackSide,\n            map: new THREE.TextureLoader().load(scene),\n            precision: 'highp',\n        });\n        const cube = new THREE.Mesh(geometry, this.material);\n        cube.position.set(0, 0, 0);\n        this.scene.add(cube);\n\n\n        /*\n        const light = new THREE.DirectionalLight(0xffffff);\n\n        light.position.set(0, 100, 60);\n        light.castShadow = true;\n        light.shadow.camera.left = -60;\n        light.shadow.camera.top = -60;\n        light.shadow.camera.right = 60;\n        light.shadow.camera.bottom = 60;\n        light.shadow.camera.near = 1;\n        light.shadow.camera.far = 1000;\n        light.shadow.bias = -.0001\n        light.shadow.mapSize.width = light.shadow.mapSize.height = 1024;\n\n        this.scene.add(light);\n        */\n\n        // this.light = new THREE.DirectionalLight(0xffffff, 1);\n        // this.scene.add(this.light);\n        // this.light = new THREE.HemisphereLight(0xffffff, 0xffffff, 1.5);\n        // this.scene.add(this.light);\n\n        /*\n        const canvas = document.createElement('canvas');\n        canvas.width = 512;\n        canvas.height = 512;\n        const ctx = canvas.getContext('2d');\n\n        const gradient = ctx.createLinearGradient(0, 0, 512, 512);\n        gradient.addColorStop(0, '#111166');\n        gradient.addColorStop(1, '#333399');\n\n        ctx.fillStyle = gradient;\n        ctx.rect(0, 0, 512, 512);\n        ctx.fill();\n\n        const shadowTexture = new THREE.Texture(canvas);\n        shadowTexture.needsUpdate = true;\n\n        const skyGeo = new THREE.SphereGeometry(5000, 25, 25);\n        this.sky = new THREE.Mesh(skyGeo, new THREE.MeshBasicMaterial({\n            map: shadowTexture,\n            color: 0xFFFFFF,\n        }));\n        this.sky.material.side = THREE.BackSide;\n        this.scene.add(this.sky);\n        */\n\n        this.renderer = new THREE.WebGLRenderer({\n            canvas: document.getElementById('canvas'),\n            antialias: true,\n        });\n        this.renderer.setSize(window.innerWidth, window.innerHeight);\n\n        let controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);\n\n        this.render = this.render.bind(this);\n        this.resize = this.resize.bind(this);\n        this.bindEvents = this.bindEvents.bind(this);\n        this.update = this.update.bind(this);\n\n        this.bindEvents();\n\n        this.render();\n\n        this.params = {\n            color1: 0xFF4400,\n            color2: 0xFF4400,\n            color3: 0xFF4400,\n            color4: 0xFF4400,\n            intensity: 0.45,\n            scale: 0.03,\n            opacity: 0.9,\n            fresnel: 1,\n            fresnelBias: 0.2,\n            fresnelPow: 5,\n        };\n\n        const gui = new dat.GUI();\n        const color = gui.addColor(this.params, 'color1');\n        color.onChange((v) => {\n            for (const child of this.stars[0].children) {\n                child.material.uniforms.emissive.value = new THREE.Color(v);\n            }\n        });\n        const color2 = gui.addColor(this.params, 'color2');\n        color2.onChange((v) => {\n            for (const child of this.stars[1].children) {\n                child.material.uniforms.emissive.value = new THREE.Color(v);\n            }\n        });\n        const color3 = gui.addColor(this.params, 'color3');\n        color3.onChange((v) => {\n            for (const child of this.stars[2].children) {\n                child.material.uniforms.emissive.value = new THREE.Color(v);\n            }\n        });\n        const color4 = gui.addColor(this.params, 'color4');\n        color4.onChange((v) => {\n            for (const child of this.stars[3].children) {\n                child.material.uniforms.emissive.value = new THREE.Color(v);\n            }\n        });\n\n        const r = gui.addFolder('refraction');\n        r.open();\n        const refraction = r.add(this.params, 'intensity', 0, 1);\n        refraction.onChange((v) => {\n            for (const star of this.stars) {\n                for (const child of star.children) {\n                    child.material.uniforms.refraction.value = v;\n                }\n            }\n        });\n        const opacity = gui.add(this.params, 'opacity', 0, 1);\n        opacity.onChange((v) => {\n            for (const star of this.stars) {\n                for (const child of star.children) {\n                    child.material.uniforms.opacity.value = v;\n                }\n            }\n        });\n        const refractionIntensity = r.add(this.params, 'scale', 0, 0.1);\n        refractionIntensity.onChange((v) => {\n            for (const star of this.stars) {\n                for (const child of star.children) {\n                    child.material.uniforms.vScale.value = new THREE.Vector2(v, v);\n                }\n            }\n        });\n        const fresnel = gui.add(this.params, 'fresnel', 0, 1);\n        fresnel.onChange((v) => {\n            for (const star of this.stars) {\n                for (const child of star.children) {\n                    child.material.uniforms.fresnelMix.value = v;\n                }\n            }\n        });\n        const fresnelBias = gui.add(this.params, 'fresnelBias', 0, 1);\n        fresnelBias.onChange((v) => {\n            for (const star of this.stars) {\n                for (const child of star.children) {\n                    child.material.uniforms.fresnelBias.value = v;\n                }\n            }\n        });\n        const fresnelPow = gui.add(this.params, 'fresnelPow', 0, 10);\n        fresnelPow.onChange((v) => {\n            for (const star of this.stars) {\n                for (const child of star.children) {\n                    child.material.uniforms.fresnelPow.value = v;\n                }\n            }\n        });\n    }\n\n    bindEvents() {\n        window.addEventListener('resize', this.resize);\n    }\n\n    buildStar() {\n        const obj = new THREE.Object3D();\n\n        obj.position.set(500 - Math.random()*1000, 500 - Math.random()*1000, 500 - Math.random()*1000);\n\n        for (let i = 0; i < 10; i++) {\n            const particle = new Particle();\n            particle.rotation.set(Math.PI * Math.random(), Math.PI * Math.random(), Math.PI * Math.random());\n            // particle.camera.position.copy(obj.position);\n            // this.scene.add(new THREE.CameraHelper(particle.camera));\n            obj.add(particle);\n        }\n\n        return obj;\n    }\n\n    resize() {\n        this.renderer.setSize(window.innerWidth, window.innerHeight);\n        this.camera.aspect = window.innerWidth / window.innerHeight;\n        this.camera.updateProjectionMatrix();\n        for (const child of this.star.children) {\n            child.material.uniforms.resolution.value = new THREE.Vector2(window.innerWidth, window.innerHeight);\n        }\n    }\n\n    update() {\n        const stars = this.stars.slice();\n\n        stars.sort((a, b) => {\n            const pb = b.getWorldPosition();\n            pb.project(this.camera);\n            const pa = a.getWorldPosition();\n            pa.project(this.camera);\n            return pb.z - pa.z;\n        });\n\n        for (const star of stars) {\n            star.visible = false;\n        }\n\n        for (const star of stars) {\n            star.rotation.y += Math.PI / 360;\n            star.rotation.x += Math.PI / 360;\n\n            const children = star.children.slice();\n            children.sort((a, b) => {\n                b.translateY(250);\n                const pb = b.getWorldPosition();\n                b.translateY(-250);\n                pb.project(this.camera);\n                a.translateY(250);\n                const pa = a.getWorldPosition();\n                a.translateY(-250);\n                pa.project(this.camera);\n                return pb.z - pa.z;\n            });\n\n            star.visible = true;\n\n            for (const child of children) {\n                child.visible = false;\n            }\n\n            for (const child of children) {\n                this.renderer.render(this.scene, this.camera, child.renderTarget);\n                child.visible = true;\n                child.material.uniforms.offset.value.add(new THREE.Vector2(0.001, 0.001));\n            }\n        }\n    }\n\n    render() {\n        stats.begin();\n\n        this.update();\n\n        this.renderer.render(this.scene, this.camera);\n\n\n        stats.end();\n\n        requestAnimationFrame(this.render);\n    }\n}\n\nconst app = new App();\n\n\n\n/** WEBPACK FOOTER **\n ** ./web/js/index.js\n **/","module.exports = { \"default\": require(\"core-js/library/fn/get-iterator\"), __esModule: true };\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/core-js/get-iterator.js\n ** module id = 1\n ** module chunks = 0\n **/","require('../modules/web.dom.iterable');\nrequire('../modules/es6.string.iterator');\nmodule.exports = require('../modules/core.get-iterator');\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/fn/get-iterator.js\n ** module id = 2\n ** module chunks = 0\n **/","require('./es6.array.iterator');\nvar global        = require('./_global')\n  , hide          = require('./_hide')\n  , Iterators     = require('./_iterators')\n  , TO_STRING_TAG = require('./_wks')('toStringTag');\n\nfor(var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++){\n  var NAME       = collections[i]\n    , Collection = global[NAME]\n    , proto      = Collection && Collection.prototype;\n  if(proto && !proto[TO_STRING_TAG])hide(proto, TO_STRING_TAG, NAME);\n  Iterators[NAME] = Iterators.Array;\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/web.dom.iterable.js\n ** module id = 3\n ** module chunks = 0\n **/","'use strict';\nvar addToUnscopables = require('./_add-to-unscopables')\n  , step             = require('./_iter-step')\n  , Iterators        = require('./_iterators')\n  , toIObject        = require('./_to-iobject');\n\n// 22.1.3.4 Array.prototype.entries()\n// 22.1.3.13 Array.prototype.keys()\n// 22.1.3.29 Array.prototype.values()\n// 22.1.3.30 Array.prototype[@@iterator]()\nmodule.exports = require('./_iter-define')(Array, 'Array', function(iterated, kind){\n  this._t = toIObject(iterated); // target\n  this._i = 0;                   // next index\n  this._k = kind;                // kind\n// 22.1.5.2.1 %ArrayIteratorPrototype%.next()\n}, function(){\n  var O     = this._t\n    , kind  = this._k\n    , index = this._i++;\n  if(!O || index >= O.length){\n    this._t = undefined;\n    return step(1);\n  }\n  if(kind == 'keys'  )return step(0, index);\n  if(kind == 'values')return step(0, O[index]);\n  return step(0, [index, O[index]]);\n}, 'values');\n\n// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)\nIterators.Arguments = Iterators.Array;\n\naddToUnscopables('keys');\naddToUnscopables('values');\naddToUnscopables('entries');\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/es6.array.iterator.js\n ** module id = 4\n ** module chunks = 0\n **/","module.exports = function(){ /* empty */ };\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_add-to-unscopables.js\n ** module id = 5\n ** module chunks = 0\n **/","module.exports = function(done, value){\n  return {value: value, done: !!done};\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_iter-step.js\n ** module id = 6\n ** module chunks = 0\n **/","module.exports = {};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_iterators.js\n ** module id = 7\n ** module chunks = 0\n **/","// to indexed object, toObject with fallback for non-array-like ES3 strings\nvar IObject = require('./_iobject')\n  , defined = require('./_defined');\nmodule.exports = function(it){\n  return IObject(defined(it));\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_to-iobject.js\n ** module id = 8\n ** module chunks = 0\n **/","// fallback for non-array-like ES3 and non-enumerable old V8 strings\nvar cof = require('./_cof');\nmodule.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){\n  return cof(it) == 'String' ? it.split('') : Object(it);\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_iobject.js\n ** module id = 9\n ** module chunks = 0\n **/","var toString = {}.toString;\n\nmodule.exports = function(it){\n  return toString.call(it).slice(8, -1);\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_cof.js\n ** module id = 10\n ** module chunks = 0\n **/","// 7.2.1 RequireObjectCoercible(argument)\nmodule.exports = function(it){\n  if(it == undefined)throw TypeError(\"Can't call method on  \" + it);\n  return it;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_defined.js\n ** module id = 11\n ** module chunks = 0\n **/","'use strict';\nvar LIBRARY        = require('./_library')\n  , $export        = require('./_export')\n  , redefine       = require('./_redefine')\n  , hide           = require('./_hide')\n  , has            = require('./_has')\n  , Iterators      = require('./_iterators')\n  , $iterCreate    = require('./_iter-create')\n  , setToStringTag = require('./_set-to-string-tag')\n  , getPrototypeOf = require('./_object-gpo')\n  , ITERATOR       = require('./_wks')('iterator')\n  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`\n  , FF_ITERATOR    = '@@iterator'\n  , KEYS           = 'keys'\n  , VALUES         = 'values';\n\nvar returnThis = function(){ return this; };\n\nmodule.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){\n  $iterCreate(Constructor, NAME, next);\n  var getMethod = function(kind){\n    if(!BUGGY && kind in proto)return proto[kind];\n    switch(kind){\n      case KEYS: return function keys(){ return new Constructor(this, kind); };\n      case VALUES: return function values(){ return new Constructor(this, kind); };\n    } return function entries(){ return new Constructor(this, kind); };\n  };\n  var TAG        = NAME + ' Iterator'\n    , DEF_VALUES = DEFAULT == VALUES\n    , VALUES_BUG = false\n    , proto      = Base.prototype\n    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]\n    , $default   = $native || getMethod(DEFAULT)\n    , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined\n    , $anyNative = NAME == 'Array' ? proto.entries || $native : $native\n    , methods, key, IteratorPrototype;\n  // Fix native\n  if($anyNative){\n    IteratorPrototype = getPrototypeOf($anyNative.call(new Base));\n    if(IteratorPrototype !== Object.prototype){\n      // Set @@toStringTag to native iterators\n      setToStringTag(IteratorPrototype, TAG, true);\n      // fix for some old engines\n      if(!LIBRARY && !has(IteratorPrototype, ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);\n    }\n  }\n  // fix Array#{values, @@iterator}.name in V8 / FF\n  if(DEF_VALUES && $native && $native.name !== VALUES){\n    VALUES_BUG = true;\n    $default = function values(){ return $native.call(this); };\n  }\n  // Define iterator\n  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){\n    hide(proto, ITERATOR, $default);\n  }\n  // Plug for library\n  Iterators[NAME] = $default;\n  Iterators[TAG]  = returnThis;\n  if(DEFAULT){\n    methods = {\n      values:  DEF_VALUES ? $default : getMethod(VALUES),\n      keys:    IS_SET     ? $default : getMethod(KEYS),\n      entries: $entries\n    };\n    if(FORCED)for(key in methods){\n      if(!(key in proto))redefine(proto, key, methods[key]);\n    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);\n  }\n  return methods;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_iter-define.js\n ** module id = 12\n ** module chunks = 0\n **/","module.exports = true;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_library.js\n ** module id = 13\n ** module chunks = 0\n **/","var global    = require('./_global')\n  , core      = require('./_core')\n  , ctx       = require('./_ctx')\n  , hide      = require('./_hide')\n  , PROTOTYPE = 'prototype';\n\nvar $export = function(type, name, source){\n  var IS_FORCED = type & $export.F\n    , IS_GLOBAL = type & $export.G\n    , IS_STATIC = type & $export.S\n    , IS_PROTO  = type & $export.P\n    , IS_BIND   = type & $export.B\n    , IS_WRAP   = type & $export.W\n    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})\n    , expProto  = exports[PROTOTYPE]\n    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]\n    , key, own, out;\n  if(IS_GLOBAL)source = name;\n  for(key in source){\n    // contains in native\n    own = !IS_FORCED && target && target[key] !== undefined;\n    if(own && key in exports)continue;\n    // export native or passed\n    out = own ? target[key] : source[key];\n    // prevent global pollution for namespaces\n    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]\n    // bind timers to global for call from export context\n    : IS_BIND && own ? ctx(out, global)\n    // wrap global constructors for prevent change them in library\n    : IS_WRAP && target[key] == out ? (function(C){\n      var F = function(a, b, c){\n        if(this instanceof C){\n          switch(arguments.length){\n            case 0: return new C;\n            case 1: return new C(a);\n            case 2: return new C(a, b);\n          } return new C(a, b, c);\n        } return C.apply(this, arguments);\n      };\n      F[PROTOTYPE] = C[PROTOTYPE];\n      return F;\n    // make static versions for prototype methods\n    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;\n    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%\n    if(IS_PROTO){\n      (exports.virtual || (exports.virtual = {}))[key] = out;\n      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%\n      if(type & $export.R && expProto && !expProto[key])hide(expProto, key, out);\n    }\n  }\n};\n// type bitmap\n$export.F = 1;   // forced\n$export.G = 2;   // global\n$export.S = 4;   // static\n$export.P = 8;   // proto\n$export.B = 16;  // bind\n$export.W = 32;  // wrap\n$export.U = 64;  // safe\n$export.R = 128; // real proto method for `library` \nmodule.exports = $export;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_export.js\n ** module id = 14\n ** module chunks = 0\n **/","// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nvar global = module.exports = typeof window != 'undefined' && window.Math == Math\n  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();\nif(typeof __g == 'number')__g = global; // eslint-disable-line no-undef\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_global.js\n ** module id = 15\n ** module chunks = 0\n **/","var core = module.exports = {version: '2.4.0'};\nif(typeof __e == 'number')__e = core; // eslint-disable-line no-undef\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_core.js\n ** module id = 16\n ** module chunks = 0\n **/","// optional / simple context binding\nvar aFunction = require('./_a-function');\nmodule.exports = function(fn, that, length){\n  aFunction(fn);\n  if(that === undefined)return fn;\n  switch(length){\n    case 1: return function(a){\n      return fn.call(that, a);\n    };\n    case 2: return function(a, b){\n      return fn.call(that, a, b);\n    };\n    case 3: return function(a, b, c){\n      return fn.call(that, a, b, c);\n    };\n  }\n  return function(/* ...args */){\n    return fn.apply(that, arguments);\n  };\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_ctx.js\n ** module id = 17\n ** module chunks = 0\n **/","module.exports = function(it){\n  if(typeof it != 'function')throw TypeError(it + ' is not a function!');\n  return it;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_a-function.js\n ** module id = 18\n ** module chunks = 0\n **/","var dP         = require('./_object-dp')\n  , createDesc = require('./_property-desc');\nmodule.exports = require('./_descriptors') ? function(object, key, value){\n  return dP.f(object, key, createDesc(1, value));\n} : function(object, key, value){\n  object[key] = value;\n  return object;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_hide.js\n ** module id = 19\n ** module chunks = 0\n **/","var anObject       = require('./_an-object')\n  , IE8_DOM_DEFINE = require('./_ie8-dom-define')\n  , toPrimitive    = require('./_to-primitive')\n  , dP             = Object.defineProperty;\n\nexports.f = require('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes){\n  anObject(O);\n  P = toPrimitive(P, true);\n  anObject(Attributes);\n  if(IE8_DOM_DEFINE)try {\n    return dP(O, P, Attributes);\n  } catch(e){ /* empty */ }\n  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');\n  if('value' in Attributes)O[P] = Attributes.value;\n  return O;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_object-dp.js\n ** module id = 20\n ** module chunks = 0\n **/","var isObject = require('./_is-object');\nmodule.exports = function(it){\n  if(!isObject(it))throw TypeError(it + ' is not an object!');\n  return it;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_an-object.js\n ** module id = 21\n ** module chunks = 0\n **/","module.exports = function(it){\n  return typeof it === 'object' ? it !== null : typeof it === 'function';\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_is-object.js\n ** module id = 22\n ** module chunks = 0\n **/","module.exports = !require('./_descriptors') && !require('./_fails')(function(){\r\n  return Object.defineProperty(require('./_dom-create')('div'), 'a', {get: function(){ return 7; }}).a != 7;\r\n});\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_ie8-dom-define.js\n ** module id = 23\n ** module chunks = 0\n **/","// Thank's IE8 for his funny defineProperty\nmodule.exports = !require('./_fails')(function(){\n  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;\n});\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_descriptors.js\n ** module id = 24\n ** module chunks = 0\n **/","module.exports = function(exec){\n  try {\n    return !!exec();\n  } catch(e){\n    return true;\n  }\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_fails.js\n ** module id = 25\n ** module chunks = 0\n **/","var isObject = require('./_is-object')\n  , document = require('./_global').document\n  // in old IE typeof document.createElement is 'object'\n  , is = isObject(document) && isObject(document.createElement);\nmodule.exports = function(it){\n  return is ? document.createElement(it) : {};\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_dom-create.js\n ** module id = 26\n ** module chunks = 0\n **/","// 7.1.1 ToPrimitive(input [, PreferredType])\nvar isObject = require('./_is-object');\n// instead of the ES6 spec version, we didn't implement @@toPrimitive case\n// and the second argument - flag - preferred type is a string\nmodule.exports = function(it, S){\n  if(!isObject(it))return it;\n  var fn, val;\n  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;\n  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;\n  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;\n  throw TypeError(\"Can't convert object to primitive value\");\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_to-primitive.js\n ** module id = 27\n ** module chunks = 0\n **/","module.exports = function(bitmap, value){\n  return {\n    enumerable  : !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable    : !(bitmap & 4),\n    value       : value\n  };\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_property-desc.js\n ** module id = 28\n ** module chunks = 0\n **/","module.exports = require('./_hide');\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_redefine.js\n ** module id = 29\n ** module chunks = 0\n **/","var hasOwnProperty = {}.hasOwnProperty;\nmodule.exports = function(it, key){\n  return hasOwnProperty.call(it, key);\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_has.js\n ** module id = 30\n ** module chunks = 0\n **/","'use strict';\nvar create         = require('./_object-create')\n  , descriptor     = require('./_property-desc')\n  , setToStringTag = require('./_set-to-string-tag')\n  , IteratorPrototype = {};\n\n// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\nrequire('./_hide')(IteratorPrototype, require('./_wks')('iterator'), function(){ return this; });\n\nmodule.exports = function(Constructor, NAME, next){\n  Constructor.prototype = create(IteratorPrototype, {next: descriptor(1, next)});\n  setToStringTag(Constructor, NAME + ' Iterator');\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_iter-create.js\n ** module id = 31\n ** module chunks = 0\n **/","// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\r\nvar anObject    = require('./_an-object')\r\n  , dPs         = require('./_object-dps')\r\n  , enumBugKeys = require('./_enum-bug-keys')\r\n  , IE_PROTO    = require('./_shared-key')('IE_PROTO')\r\n  , Empty       = function(){ /* empty */ }\r\n  , PROTOTYPE   = 'prototype';\r\n\r\n// Create object with fake `null` prototype: use iframe Object with cleared prototype\r\nvar createDict = function(){\r\n  // Thrash, waste and sodomy: IE GC bug\r\n  var iframe = require('./_dom-create')('iframe')\r\n    , i      = enumBugKeys.length\r\n    , gt     = '>'\r\n    , iframeDocument;\r\n  iframe.style.display = 'none';\r\n  require('./_html').appendChild(iframe);\r\n  iframe.src = 'javascript:'; // eslint-disable-line no-script-url\r\n  // createDict = iframe.contentWindow.Object;\r\n  // html.removeChild(iframe);\r\n  iframeDocument = iframe.contentWindow.document;\r\n  iframeDocument.open();\r\n  iframeDocument.write('<script>document.F=Object</script' + gt);\r\n  iframeDocument.close();\r\n  createDict = iframeDocument.F;\r\n  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];\r\n  return createDict();\r\n};\r\n\r\nmodule.exports = Object.create || function create(O, Properties){\r\n  var result;\r\n  if(O !== null){\r\n    Empty[PROTOTYPE] = anObject(O);\r\n    result = new Empty;\r\n    Empty[PROTOTYPE] = null;\r\n    // add \"__proto__\" for Object.getPrototypeOf polyfill\r\n    result[IE_PROTO] = O;\r\n  } else result = createDict();\r\n  return Properties === undefined ? result : dPs(result, Properties);\r\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_object-create.js\n ** module id = 32\n ** module chunks = 0\n **/","var dP       = require('./_object-dp')\r\n  , anObject = require('./_an-object')\r\n  , getKeys  = require('./_object-keys');\r\n\r\nmodule.exports = require('./_descriptors') ? Object.defineProperties : function defineProperties(O, Properties){\r\n  anObject(O);\r\n  var keys   = getKeys(Properties)\r\n    , length = keys.length\r\n    , i = 0\r\n    , P;\r\n  while(length > i)dP.f(O, P = keys[i++], Properties[P]);\r\n  return O;\r\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_object-dps.js\n ** module id = 33\n ** module chunks = 0\n **/","// 19.1.2.14 / 15.2.3.14 Object.keys(O)\r\nvar $keys       = require('./_object-keys-internal')\r\n  , enumBugKeys = require('./_enum-bug-keys');\r\n\r\nmodule.exports = Object.keys || function keys(O){\r\n  return $keys(O, enumBugKeys);\r\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_object-keys.js\n ** module id = 34\n ** module chunks = 0\n **/","var has          = require('./_has')\r\n  , toIObject    = require('./_to-iobject')\r\n  , arrayIndexOf = require('./_array-includes')(false)\r\n  , IE_PROTO     = require('./_shared-key')('IE_PROTO');\r\n\r\nmodule.exports = function(object, names){\r\n  var O      = toIObject(object)\r\n    , i      = 0\r\n    , result = []\r\n    , key;\r\n  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);\r\n  // Don't enum bug & hidden keys\r\n  while(names.length > i)if(has(O, key = names[i++])){\r\n    ~arrayIndexOf(result, key) || result.push(key);\r\n  }\r\n  return result;\r\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_object-keys-internal.js\n ** module id = 35\n ** module chunks = 0\n **/","// false -> Array#indexOf\n// true  -> Array#includes\nvar toIObject = require('./_to-iobject')\n  , toLength  = require('./_to-length')\n  , toIndex   = require('./_to-index');\nmodule.exports = function(IS_INCLUDES){\n  return function($this, el, fromIndex){\n    var O      = toIObject($this)\n      , length = toLength(O.length)\n      , index  = toIndex(fromIndex, length)\n      , value;\n    // Array#includes uses SameValueZero equality algorithm\n    if(IS_INCLUDES && el != el)while(length > index){\n      value = O[index++];\n      if(value != value)return true;\n    // Array#toIndex ignores holes, Array#includes - not\n    } else for(;length > index; index++)if(IS_INCLUDES || index in O){\n      if(O[index] === el)return IS_INCLUDES || index || 0;\n    } return !IS_INCLUDES && -1;\n  };\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_array-includes.js\n ** module id = 36\n ** module chunks = 0\n **/","// 7.1.15 ToLength\nvar toInteger = require('./_to-integer')\n  , min       = Math.min;\nmodule.exports = function(it){\n  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_to-length.js\n ** module id = 37\n ** module chunks = 0\n **/","// 7.1.4 ToInteger\nvar ceil  = Math.ceil\n  , floor = Math.floor;\nmodule.exports = function(it){\n  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_to-integer.js\n ** module id = 38\n ** module chunks = 0\n **/","var toInteger = require('./_to-integer')\n  , max       = Math.max\n  , min       = Math.min;\nmodule.exports = function(index, length){\n  index = toInteger(index);\n  return index < 0 ? max(index + length, 0) : min(index, length);\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_to-index.js\n ** module id = 39\n ** module chunks = 0\n **/","var shared = require('./_shared')('keys')\r\n  , uid    = require('./_uid');\r\nmodule.exports = function(key){\r\n  return shared[key] || (shared[key] = uid(key));\r\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_shared-key.js\n ** module id = 40\n ** module chunks = 0\n **/","var global = require('./_global')\n  , SHARED = '__core-js_shared__'\n  , store  = global[SHARED] || (global[SHARED] = {});\nmodule.exports = function(key){\n  return store[key] || (store[key] = {});\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_shared.js\n ** module id = 41\n ** module chunks = 0\n **/","var id = 0\n  , px = Math.random();\nmodule.exports = function(key){\n  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_uid.js\n ** module id = 42\n ** module chunks = 0\n **/","// IE 8- don't enum bug keys\r\nmodule.exports = (\r\n  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'\r\n).split(',');\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_enum-bug-keys.js\n ** module id = 43\n ** module chunks = 0\n **/","module.exports = require('./_global').document && document.documentElement;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_html.js\n ** module id = 44\n ** module chunks = 0\n **/","var def = require('./_object-dp').f\n  , has = require('./_has')\n  , TAG = require('./_wks')('toStringTag');\n\nmodule.exports = function(it, tag, stat){\n  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_set-to-string-tag.js\n ** module id = 45\n ** module chunks = 0\n **/","var store      = require('./_shared')('wks')\n  , uid        = require('./_uid')\n  , Symbol     = require('./_global').Symbol\n  , USE_SYMBOL = typeof Symbol == 'function';\n\nvar $exports = module.exports = function(name){\n  return store[name] || (store[name] =\n    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));\n};\n\n$exports.store = store;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_wks.js\n ** module id = 46\n ** module chunks = 0\n **/","// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)\r\nvar has         = require('./_has')\r\n  , toObject    = require('./_to-object')\r\n  , IE_PROTO    = require('./_shared-key')('IE_PROTO')\r\n  , ObjectProto = Object.prototype;\r\n\r\nmodule.exports = Object.getPrototypeOf || function(O){\r\n  O = toObject(O);\r\n  if(has(O, IE_PROTO))return O[IE_PROTO];\r\n  if(typeof O.constructor == 'function' && O instanceof O.constructor){\r\n    return O.constructor.prototype;\r\n  } return O instanceof Object ? ObjectProto : null;\r\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_object-gpo.js\n ** module id = 47\n ** module chunks = 0\n **/","// 7.1.13 ToObject(argument)\nvar defined = require('./_defined');\nmodule.exports = function(it){\n  return Object(defined(it));\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_to-object.js\n ** module id = 48\n ** module chunks = 0\n **/","'use strict';\nvar $at  = require('./_string-at')(true);\n\n// 21.1.3.27 String.prototype[@@iterator]()\nrequire('./_iter-define')(String, 'String', function(iterated){\n  this._t = String(iterated); // target\n  this._i = 0;                // next index\n// 21.1.5.2.1 %StringIteratorPrototype%.next()\n}, function(){\n  var O     = this._t\n    , index = this._i\n    , point;\n  if(index >= O.length)return {value: undefined, done: true};\n  point = $at(O, index);\n  this._i += point.length;\n  return {value: point, done: false};\n});\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/es6.string.iterator.js\n ** module id = 49\n ** module chunks = 0\n **/","var toInteger = require('./_to-integer')\n  , defined   = require('./_defined');\n// true  -> String#at\n// false -> String#codePointAt\nmodule.exports = function(TO_STRING){\n  return function(that, pos){\n    var s = String(defined(that))\n      , i = toInteger(pos)\n      , l = s.length\n      , a, b;\n    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;\n    a = s.charCodeAt(i);\n    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff\n      ? TO_STRING ? s.charAt(i) : a\n      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;\n  };\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_string-at.js\n ** module id = 50\n ** module chunks = 0\n **/","var anObject = require('./_an-object')\n  , get      = require('./core.get-iterator-method');\nmodule.exports = require('./_core').getIterator = function(it){\n  var iterFn = get(it);\n  if(typeof iterFn != 'function')throw TypeError(it + ' is not iterable!');\n  return anObject(iterFn.call(it));\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/core.get-iterator.js\n ** module id = 51\n ** module chunks = 0\n **/","var classof   = require('./_classof')\n  , ITERATOR  = require('./_wks')('iterator')\n  , Iterators = require('./_iterators');\nmodule.exports = require('./_core').getIteratorMethod = function(it){\n  if(it != undefined)return it[ITERATOR]\n    || it['@@iterator']\n    || Iterators[classof(it)];\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/core.get-iterator-method.js\n ** module id = 52\n ** module chunks = 0\n **/","// getting tag from 19.1.3.6 Object.prototype.toString()\nvar cof = require('./_cof')\n  , TAG = require('./_wks')('toStringTag')\n  // ES3 wrong here\n  , ARG = cof(function(){ return arguments; }()) == 'Arguments';\n\n// fallback for IE11 Script Access Denied error\nvar tryGet = function(it, key){\n  try {\n    return it[key];\n  } catch(e){ /* empty */ }\n};\n\nmodule.exports = function(it){\n  var O, T, B;\n  return it === undefined ? 'Undefined' : it === null ? 'Null'\n    // @@toStringTag case\n    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T\n    // builtinTag case\n    : ARG ? cof(O)\n    // ES3 arguments fallback\n    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_classof.js\n ** module id = 53\n ** module chunks = 0\n **/","\"use strict\";\n\nexports.__esModule = true;\n\nexports.default = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/helpers/classCallCheck.js\n ** module id = 54\n ** module chunks = 0\n **/","\"use strict\";\n\nexports.__esModule = true;\n\nvar _defineProperty = require(\"babel-runtime/core-js/object/define-property\");\n\nvar _defineProperty2 = _interopRequireDefault(_defineProperty);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      (0, _defineProperty2.default)(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/helpers/createClass.js\n ** module id = 55\n ** module chunks = 0\n **/","module.exports = { \"default\": require(\"core-js/library/fn/object/define-property\"), __esModule: true };\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/core-js/object/define-property.js\n ** module id = 56\n ** module chunks = 0\n **/","require('../../modules/es6.object.define-property');\nvar $Object = require('../../modules/_core').Object;\nmodule.exports = function defineProperty(it, key, desc){\n  return $Object.defineProperty(it, key, desc);\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/fn/object/define-property.js\n ** module id = 57\n ** module chunks = 0\n **/","var $export = require('./_export');\r\n// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)\r\n$export($export.S + $export.F * !require('./_descriptors'), 'Object', {defineProperty: require('./_object-dp').f});\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/es6.object.define-property.js\n ** module id = 58\n ** module chunks = 0\n **/","module.exports = \"<!DOCTYPE html> <html> <head> <meta charset=UTF-8> <title>Particles</title> </head> <body> <canvas id=canvas width=100% height=100%></canvas> </body> </html>\";\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./web/index.html\n ** module id = 59\n ** module chunks = 0\n **/","var self = self || {};// File:src/Three.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nvar THREE = { REVISION: '76' };\r\n\r\n//\r\n\r\nif ( typeof define === 'function' && define.amd ) {\r\n\r\n\tdefine( 'three', THREE );\r\n\r\n} else if ( 'undefined' !== typeof exports && 'undefined' !== typeof module ) {\r\n\r\n\tmodule.exports = THREE;\r\n\r\n}\r\n\r\n//\r\n\r\nif ( Number.EPSILON === undefined ) {\r\n\r\n\tNumber.EPSILON = Math.pow( 2, - 52 );\r\n\r\n}\r\n\r\n//\r\n\r\nif ( Math.sign === undefined ) {\r\n\r\n\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign\r\n\r\n\tMath.sign = function ( x ) {\r\n\r\n\t\treturn ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : + x;\r\n\r\n\t};\r\n\r\n}\r\n\r\nif ( Function.prototype.name === undefined && Object.defineProperty !== undefined ) {\r\n\r\n\t// Missing in IE9-11.\r\n\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name\r\n\r\n\tObject.defineProperty( Function.prototype, 'name', {\r\n\r\n\t\tget: function () {\r\n\r\n\t\t\treturn this.toString().match( /^\\s*function\\s*(\\S*)\\s*\\(/ )[ 1 ];\r\n\r\n\t\t}\r\n\r\n\t} );\r\n\r\n}\r\n\r\nif ( Object.assign === undefined ) {\r\n\r\n\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\r\n\r\n\tObject.defineProperty( Object, 'assign', {\r\n\r\n\t\twritable: true,\r\n\t\tconfigurable: true,\r\n\r\n\t\tvalue: function ( target ) {\r\n\r\n\t\t\t'use strict';\r\n\r\n\t\t\tif ( target === undefined || target === null ) {\r\n\r\n\t\t\t\tthrow new TypeError( \"Cannot convert first argument to object\" );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar to = Object( target );\r\n\r\n\t\t\tfor ( var i = 1, n = arguments.length; i !== n; ++ i ) {\r\n\r\n\t\t\t\tvar nextSource = arguments[ i ];\r\n\r\n\t\t\t\tif ( nextSource === undefined || nextSource === null ) continue;\r\n\r\n\t\t\t\tnextSource = Object( nextSource );\r\n\r\n\t\t\t\tvar keysArray = Object.keys( nextSource );\r\n\r\n\t\t\t\tfor ( var nextIndex = 0, len = keysArray.length; nextIndex !== len; ++ nextIndex ) {\r\n\r\n\t\t\t\t\tvar nextKey = keysArray[ nextIndex ];\r\n\t\t\t\t\tvar desc = Object.getOwnPropertyDescriptor( nextSource, nextKey );\r\n\r\n\t\t\t\t\tif ( desc !== undefined && desc.enumerable ) {\r\n\r\n\t\t\t\t\t\tto[ nextKey ] = nextSource[ nextKey ];\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn to;\r\n\r\n\t\t}\r\n\r\n\t} );\r\n\r\n}\r\n\r\n// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent.button\r\n\r\nTHREE.MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };\r\n\r\n// GL STATE CONSTANTS\r\n\r\nTHREE.CullFaceNone = 0;\r\nTHREE.CullFaceBack = 1;\r\nTHREE.CullFaceFront = 2;\r\nTHREE.CullFaceFrontBack = 3;\r\n\r\nTHREE.FrontFaceDirectionCW = 0;\r\nTHREE.FrontFaceDirectionCCW = 1;\r\n\r\n// SHADOWING TYPES\r\n\r\nTHREE.BasicShadowMap = 0;\r\nTHREE.PCFShadowMap = 1;\r\nTHREE.PCFSoftShadowMap = 2;\r\n\r\n// MATERIAL CONSTANTS\r\n\r\n// side\r\n\r\nTHREE.FrontSide = 0;\r\nTHREE.BackSide = 1;\r\nTHREE.DoubleSide = 2;\r\n\r\n// shading\r\n\r\nTHREE.FlatShading = 1;\r\nTHREE.SmoothShading = 2;\r\n\r\n// colors\r\n\r\nTHREE.NoColors = 0;\r\nTHREE.FaceColors = 1;\r\nTHREE.VertexColors = 2;\r\n\r\n// blending modes\r\n\r\nTHREE.NoBlending = 0;\r\nTHREE.NormalBlending = 1;\r\nTHREE.AdditiveBlending = 2;\r\nTHREE.SubtractiveBlending = 3;\r\nTHREE.MultiplyBlending = 4;\r\nTHREE.CustomBlending = 5;\r\n\r\n// custom blending equations\r\n// (numbers start from 100 not to clash with other\r\n// mappings to OpenGL constants defined in Texture.js)\r\n\r\nTHREE.AddEquation = 100;\r\nTHREE.SubtractEquation = 101;\r\nTHREE.ReverseSubtractEquation = 102;\r\nTHREE.MinEquation = 103;\r\nTHREE.MaxEquation = 104;\r\n\r\n// custom blending destination factors\r\n\r\nTHREE.ZeroFactor = 200;\r\nTHREE.OneFactor = 201;\r\nTHREE.SrcColorFactor = 202;\r\nTHREE.OneMinusSrcColorFactor = 203;\r\nTHREE.SrcAlphaFactor = 204;\r\nTHREE.OneMinusSrcAlphaFactor = 205;\r\nTHREE.DstAlphaFactor = 206;\r\nTHREE.OneMinusDstAlphaFactor = 207;\r\n\r\n// custom blending source factors\r\n\r\n//THREE.ZeroFactor = 200;\r\n//THREE.OneFactor = 201;\r\n//THREE.SrcAlphaFactor = 204;\r\n//THREE.OneMinusSrcAlphaFactor = 205;\r\n//THREE.DstAlphaFactor = 206;\r\n//THREE.OneMinusDstAlphaFactor = 207;\r\nTHREE.DstColorFactor = 208;\r\nTHREE.OneMinusDstColorFactor = 209;\r\nTHREE.SrcAlphaSaturateFactor = 210;\r\n\r\n// depth modes\r\n\r\nTHREE.NeverDepth = 0;\r\nTHREE.AlwaysDepth = 1;\r\nTHREE.LessDepth = 2;\r\nTHREE.LessEqualDepth = 3;\r\nTHREE.EqualDepth = 4;\r\nTHREE.GreaterEqualDepth = 5;\r\nTHREE.GreaterDepth = 6;\r\nTHREE.NotEqualDepth = 7;\r\n\r\n\r\n// TEXTURE CONSTANTS\r\n\r\nTHREE.MultiplyOperation = 0;\r\nTHREE.MixOperation = 1;\r\nTHREE.AddOperation = 2;\r\n\r\n// Tone Mapping modes\r\n\r\nTHREE.NoToneMapping = 0; // do not do any tone mapping, not even exposure (required for special purpose passes.)\r\nTHREE.LinearToneMapping = 1; // only apply exposure.\r\nTHREE.ReinhardToneMapping = 2;\r\nTHREE.Uncharted2ToneMapping = 3; // John Hable\r\nTHREE.CineonToneMapping = 4;  // optimized filmic operator by Jim Hejl and Richard Burgess-Dawson\r\n\r\n// Mapping modes\r\n\r\nTHREE.UVMapping = 300;\r\n\r\nTHREE.CubeReflectionMapping = 301;\r\nTHREE.CubeRefractionMapping = 302;\r\n\r\nTHREE.EquirectangularReflectionMapping = 303;\r\nTHREE.EquirectangularRefractionMapping = 304;\r\n\r\nTHREE.SphericalReflectionMapping = 305;\r\nTHREE.CubeUVReflectionMapping = 306;\r\nTHREE.CubeUVRefractionMapping = 307;\r\n\r\n// Wrapping modes\r\n\r\nTHREE.RepeatWrapping = 1000;\r\nTHREE.ClampToEdgeWrapping = 1001;\r\nTHREE.MirroredRepeatWrapping = 1002;\r\n\r\n// Filters\r\n\r\nTHREE.NearestFilter = 1003;\r\nTHREE.NearestMipMapNearestFilter = 1004;\r\nTHREE.NearestMipMapLinearFilter = 1005;\r\nTHREE.LinearFilter = 1006;\r\nTHREE.LinearMipMapNearestFilter = 1007;\r\nTHREE.LinearMipMapLinearFilter = 1008;\r\n\r\n// Data types\r\n\r\nTHREE.UnsignedByteType = 1009;\r\nTHREE.ByteType = 1010;\r\nTHREE.ShortType = 1011;\r\nTHREE.UnsignedShortType = 1012;\r\nTHREE.IntType = 1013;\r\nTHREE.UnsignedIntType = 1014;\r\nTHREE.FloatType = 1015;\r\nTHREE.HalfFloatType = 1025;\r\n\r\n// Pixel types\r\n\r\n//THREE.UnsignedByteType = 1009;\r\nTHREE.UnsignedShort4444Type = 1016;\r\nTHREE.UnsignedShort5551Type = 1017;\r\nTHREE.UnsignedShort565Type = 1018;\r\n\r\n// Pixel formats\r\n\r\nTHREE.AlphaFormat = 1019;\r\nTHREE.RGBFormat = 1020;\r\nTHREE.RGBAFormat = 1021;\r\nTHREE.LuminanceFormat = 1022;\r\nTHREE.LuminanceAlphaFormat = 1023;\r\n// THREE.RGBEFormat handled as THREE.RGBAFormat in shaders\r\nTHREE.RGBEFormat = THREE.RGBAFormat; //1024;\r\nTHREE.DepthFormat = 1026;\r\n\r\n// DDS / ST3C Compressed texture formats\r\n\r\nTHREE.RGB_S3TC_DXT1_Format = 2001;\r\nTHREE.RGBA_S3TC_DXT1_Format = 2002;\r\nTHREE.RGBA_S3TC_DXT3_Format = 2003;\r\nTHREE.RGBA_S3TC_DXT5_Format = 2004;\r\n\r\n\r\n// PVRTC compressed texture formats\r\n\r\nTHREE.RGB_PVRTC_4BPPV1_Format = 2100;\r\nTHREE.RGB_PVRTC_2BPPV1_Format = 2101;\r\nTHREE.RGBA_PVRTC_4BPPV1_Format = 2102;\r\nTHREE.RGBA_PVRTC_2BPPV1_Format = 2103;\r\n\r\n// ETC compressed texture formats\r\n\r\nTHREE.RGB_ETC1_Format = 2151;\r\n\r\n// Loop styles for AnimationAction\r\n\r\nTHREE.LoopOnce = 2200;\r\nTHREE.LoopRepeat = 2201;\r\nTHREE.LoopPingPong = 2202;\r\n\r\n// Interpolation\r\n\r\nTHREE.InterpolateDiscrete = 2300;\r\nTHREE.InterpolateLinear = 2301;\r\nTHREE.InterpolateSmooth = 2302;\r\n\r\n// Interpolant ending modes\r\n\r\nTHREE.ZeroCurvatureEnding = 2400;\r\nTHREE.ZeroSlopeEnding = 2401;\r\nTHREE.WrapAroundEnding = 2402;\r\n\r\n// Triangle Draw modes\r\n\r\nTHREE.TrianglesDrawMode = 0;\r\nTHREE.TriangleStripDrawMode = 1;\r\nTHREE.TriangleFanDrawMode = 2;\r\n\r\n// Texture Encodings\r\n\r\nTHREE.LinearEncoding = 3000; // No encoding at all.\r\nTHREE.sRGBEncoding = 3001;\r\nTHREE.GammaEncoding = 3007; // uses GAMMA_FACTOR, for backwards compatibility with WebGLRenderer.gammaInput/gammaOutput\r\n\r\n// The following Texture Encodings are for RGB-only (no alpha) HDR light emission sources.\r\n// These encodings should not specified as output encodings except in rare situations.\r\nTHREE.RGBEEncoding = 3002; // AKA Radiance.\r\nTHREE.LogLuvEncoding = 3003;\r\nTHREE.RGBM7Encoding = 3004;\r\nTHREE.RGBM16Encoding = 3005;\r\nTHREE.RGBDEncoding = 3006; // MaxRange is 256.\r\n\r\n// Depth packing strategies\r\n\r\nTHREE.BasicDepthPacking = 3200;  // for writing to float textures for high precision or for visualizing results in RGB buffers\r\nTHREE.RGBADepthPacking = 3201; // for packing into RGBA buffers.\r\n\r\n// File:src/math/Color.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Color = function ( color ) {\r\n\r\n\tif ( arguments.length === 3 ) {\r\n\r\n\t\treturn this.fromArray( arguments );\r\n\r\n\t}\r\n\r\n\treturn this.set( color );\r\n\r\n};\r\n\r\nTHREE.Color.prototype = {\r\n\r\n\tconstructor: THREE.Color,\r\n\r\n\tr: 1, g: 1, b: 1,\r\n\r\n\tset: function ( value ) {\r\n\r\n\t\tif ( value instanceof THREE.Color ) {\r\n\r\n\t\t\tthis.copy( value );\r\n\r\n\t\t} else if ( typeof value === 'number' ) {\r\n\r\n\t\t\tthis.setHex( value );\r\n\r\n\t\t} else if ( typeof value === 'string' ) {\r\n\r\n\t\t\tthis.setStyle( value );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetScalar: function ( scalar ) {\r\n\r\n\t\tthis.r = scalar;\r\n\t\tthis.g = scalar;\r\n\t\tthis.b = scalar;\r\n\r\n\t},\r\n\r\n\tsetHex: function ( hex ) {\r\n\r\n\t\thex = Math.floor( hex );\r\n\r\n\t\tthis.r = ( hex >> 16 & 255 ) / 255;\r\n\t\tthis.g = ( hex >> 8 & 255 ) / 255;\r\n\t\tthis.b = ( hex & 255 ) / 255;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetRGB: function ( r, g, b ) {\r\n\r\n\t\tthis.r = r;\r\n\t\tthis.g = g;\r\n\t\tthis.b = b;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetHSL: function () {\r\n\r\n\t\tfunction hue2rgb( p, q, t ) {\r\n\r\n\t\t\tif ( t < 0 ) t += 1;\r\n\t\t\tif ( t > 1 ) t -= 1;\r\n\t\t\tif ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;\r\n\t\t\tif ( t < 1 / 2 ) return q;\r\n\t\t\tif ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );\r\n\t\t\treturn p;\r\n\r\n\t\t}\r\n\r\n\t\treturn function ( h, s, l ) {\r\n\r\n\t\t\t// h,s,l ranges are in 0.0 - 1.0\r\n\t\t\th = THREE.Math.euclideanModulo( h, 1 );\r\n\t\t\ts = THREE.Math.clamp( s, 0, 1 );\r\n\t\t\tl = THREE.Math.clamp( l, 0, 1 );\r\n\r\n\t\t\tif ( s === 0 ) {\r\n\r\n\t\t\t\tthis.r = this.g = this.b = l;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tvar p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );\r\n\t\t\t\tvar q = ( 2 * l ) - p;\r\n\r\n\t\t\t\tthis.r = hue2rgb( q, p, h + 1 / 3 );\r\n\t\t\t\tthis.g = hue2rgb( q, p, h );\r\n\t\t\t\tthis.b = hue2rgb( q, p, h - 1 / 3 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tsetStyle: function ( style ) {\r\n\r\n\t\tfunction handleAlpha( string ) {\r\n\r\n\t\t\tif ( string === undefined ) return;\r\n\r\n\t\t\tif ( parseFloat( string ) < 1 ) {\r\n\r\n\t\t\t\tconsole.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\r\n\t\tvar m;\r\n\r\n\t\tif ( m = /^((?:rgb|hsl)a?)\\(\\s*([^\\)]*)\\)/.exec( style ) ) {\r\n\r\n\t\t\t// rgb / hsl\r\n\r\n\t\t\tvar color;\r\n\t\t\tvar name = m[ 1 ];\r\n\t\t\tvar components = m[ 2 ];\r\n\r\n\t\t\tswitch ( name ) {\r\n\r\n\t\t\t\tcase 'rgb':\r\n\t\t\t\tcase 'rgba':\r\n\r\n\t\t\t\t\tif ( color = /^(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\r\n\r\n\t\t\t\t\t\t// rgb(255,0,0) rgba(255,0,0,0.5)\r\n\t\t\t\t\t\tthis.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;\r\n\t\t\t\t\t\tthis.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;\r\n\t\t\t\t\t\tthis.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;\r\n\r\n\t\t\t\t\t\thandleAlpha( color[ 5 ] );\r\n\r\n\t\t\t\t\t\treturn this;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( color = /^(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\r\n\r\n\t\t\t\t\t\t// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)\r\n\t\t\t\t\t\tthis.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;\r\n\t\t\t\t\t\tthis.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;\r\n\t\t\t\t\t\tthis.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;\r\n\r\n\t\t\t\t\t\thandleAlpha( color[ 5 ] );\r\n\r\n\t\t\t\t\t\treturn this;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'hsl':\r\n\t\t\t\tcase 'hsla':\r\n\r\n\t\t\t\t\tif ( color = /^([0-9]*\\.?[0-9]+)\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\r\n\r\n\t\t\t\t\t\t// hsl(120,50%,50%) hsla(120,50%,50%,0.5)\r\n\t\t\t\t\t\tvar h = parseFloat( color[ 1 ] ) / 360;\r\n\t\t\t\t\t\tvar s = parseInt( color[ 2 ], 10 ) / 100;\r\n\t\t\t\t\t\tvar l = parseInt( color[ 3 ], 10 ) / 100;\r\n\r\n\t\t\t\t\t\thandleAlpha( color[ 5 ] );\r\n\r\n\t\t\t\t\t\treturn this.setHSL( h, s, l );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( m = /^\\#([A-Fa-f0-9]+)$/.exec( style ) ) {\r\n\r\n\t\t\t// hex color\r\n\r\n\t\t\tvar hex = m[ 1 ];\r\n\t\t\tvar size = hex.length;\r\n\r\n\t\t\tif ( size === 3 ) {\r\n\r\n\t\t\t\t// #ff0\r\n\t\t\t\tthis.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;\r\n\t\t\t\tthis.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;\r\n\t\t\t\tthis.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;\r\n\r\n\t\t\t\treturn this;\r\n\r\n\t\t\t} else if ( size === 6 ) {\r\n\r\n\t\t\t\t// #ff0000\r\n\t\t\t\tthis.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;\r\n\t\t\t\tthis.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;\r\n\t\t\t\tthis.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;\r\n\r\n\t\t\t\treturn this;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( style && style.length > 0 ) {\r\n\r\n\t\t\t// color keywords\r\n\t\t\tvar hex = THREE.ColorKeywords[ style ];\r\n\r\n\t\t\tif ( hex !== undefined ) {\r\n\r\n\t\t\t\t// red\r\n\t\t\t\tthis.setHex( hex );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// unknown color\r\n\t\t\t\tconsole.warn( 'THREE.Color: Unknown color ' + style );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor( this.r, this.g, this.b );\r\n\r\n\t},\r\n\r\n\tcopy: function ( color ) {\r\n\r\n\t\tthis.r = color.r;\r\n\t\tthis.g = color.g;\r\n\t\tthis.b = color.b;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopyGammaToLinear: function ( color, gammaFactor ) {\r\n\r\n\t\tif ( gammaFactor === undefined ) gammaFactor = 2.0;\r\n\r\n\t\tthis.r = Math.pow( color.r, gammaFactor );\r\n\t\tthis.g = Math.pow( color.g, gammaFactor );\r\n\t\tthis.b = Math.pow( color.b, gammaFactor );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopyLinearToGamma: function ( color, gammaFactor ) {\r\n\r\n\t\tif ( gammaFactor === undefined ) gammaFactor = 2.0;\r\n\r\n\t\tvar safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;\r\n\r\n\t\tthis.r = Math.pow( color.r, safeInverse );\r\n\t\tthis.g = Math.pow( color.g, safeInverse );\r\n\t\tthis.b = Math.pow( color.b, safeInverse );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tconvertGammaToLinear: function () {\r\n\r\n\t\tvar r = this.r, g = this.g, b = this.b;\r\n\r\n\t\tthis.r = r * r;\r\n\t\tthis.g = g * g;\r\n\t\tthis.b = b * b;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tconvertLinearToGamma: function () {\r\n\r\n\t\tthis.r = Math.sqrt( this.r );\r\n\t\tthis.g = Math.sqrt( this.g );\r\n\t\tthis.b = Math.sqrt( this.b );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetHex: function () {\r\n\r\n\t\treturn ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;\r\n\r\n\t},\r\n\r\n\tgetHexString: function () {\r\n\r\n\t\treturn ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );\r\n\r\n\t},\r\n\r\n\tgetHSL: function ( optionalTarget ) {\r\n\r\n\t\t// h,s,l ranges are in 0.0 - 1.0\r\n\r\n\t\tvar hsl = optionalTarget || { h: 0, s: 0, l: 0 };\r\n\r\n\t\tvar r = this.r, g = this.g, b = this.b;\r\n\r\n\t\tvar max = Math.max( r, g, b );\r\n\t\tvar min = Math.min( r, g, b );\r\n\r\n\t\tvar hue, saturation;\r\n\t\tvar lightness = ( min + max ) / 2.0;\r\n\r\n\t\tif ( min === max ) {\r\n\r\n\t\t\thue = 0;\r\n\t\t\tsaturation = 0;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tvar delta = max - min;\r\n\r\n\t\t\tsaturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );\r\n\r\n\t\t\tswitch ( max ) {\r\n\r\n\t\t\t\tcase r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;\r\n\t\t\t\tcase g: hue = ( b - r ) / delta + 2; break;\r\n\t\t\t\tcase b: hue = ( r - g ) / delta + 4; break;\r\n\r\n\t\t\t}\r\n\r\n\t\t\thue /= 6;\r\n\r\n\t\t}\r\n\r\n\t\thsl.h = hue;\r\n\t\thsl.s = saturation;\r\n\t\thsl.l = lightness;\r\n\r\n\t\treturn hsl;\r\n\r\n\t},\r\n\r\n\tgetStyle: function () {\r\n\r\n\t\treturn 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';\r\n\r\n\t},\r\n\r\n\toffsetHSL: function ( h, s, l ) {\r\n\r\n\t\tvar hsl = this.getHSL();\r\n\r\n\t\thsl.h += h; hsl.s += s; hsl.l += l;\r\n\r\n\t\tthis.setHSL( hsl.h, hsl.s, hsl.l );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tadd: function ( color ) {\r\n\r\n\t\tthis.r += color.r;\r\n\t\tthis.g += color.g;\r\n\t\tthis.b += color.b;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddColors: function ( color1, color2 ) {\r\n\r\n\t\tthis.r = color1.r + color2.r;\r\n\t\tthis.g = color1.g + color2.g;\r\n\t\tthis.b = color1.b + color2.b;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddScalar: function ( s ) {\r\n\r\n\t\tthis.r += s;\r\n\t\tthis.g += s;\r\n\t\tthis.b += s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiply: function ( color ) {\r\n\r\n\t\tthis.r *= color.r;\r\n\t\tthis.g *= color.g;\r\n\t\tthis.b *= color.b;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyScalar: function ( s ) {\r\n\r\n\t\tthis.r *= s;\r\n\t\tthis.g *= s;\r\n\t\tthis.b *= s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tlerp: function ( color, alpha ) {\r\n\r\n\t\tthis.r += ( color.r - this.r ) * alpha;\r\n\t\tthis.g += ( color.g - this.g ) * alpha;\r\n\t\tthis.b += ( color.b - this.b ) * alpha;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( c ) {\r\n\r\n\t\treturn ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );\r\n\r\n\t},\r\n\r\n\tfromArray: function ( array, offset ) {\r\n\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tthis.r = array[ offset ];\r\n\t\tthis.g = array[ offset + 1 ];\r\n\t\tthis.b = array[ offset + 2 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoArray: function ( array, offset ) {\r\n\r\n\t\tif ( array === undefined ) array = [];\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tarray[ offset ] = this.r;\r\n\t\tarray[ offset + 1 ] = this.g;\r\n\t\tarray[ offset + 2 ] = this.b;\r\n\r\n\t\treturn array;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,\r\n'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,\r\n'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,\r\n'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,\r\n'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,\r\n'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,\r\n'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,\r\n'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,\r\n'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,\r\n'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,\r\n'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,\r\n'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,\r\n'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,\r\n'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,\r\n'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,\r\n'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,\r\n'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,\r\n'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,\r\n'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,\r\n'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,\r\n'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,\r\n'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,\r\n'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,\r\n'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };\r\n\r\n// File:src/math/Quaternion.js\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n * @author bhouston / http://clara.io\r\n */\r\n\r\nTHREE.Quaternion = function ( x, y, z, w ) {\r\n\r\n\tthis._x = x || 0;\r\n\tthis._y = y || 0;\r\n\tthis._z = z || 0;\r\n\tthis._w = ( w !== undefined ) ? w : 1;\r\n\r\n};\r\n\r\nTHREE.Quaternion.prototype = {\r\n\r\n\tconstructor: THREE.Quaternion,\r\n\r\n\tget x () {\r\n\r\n\t\treturn this._x;\r\n\r\n\t},\r\n\r\n\tset x ( value ) {\r\n\r\n\t\tthis._x = value;\r\n\t\tthis.onChangeCallback();\r\n\r\n\t},\r\n\r\n\tget y () {\r\n\r\n\t\treturn this._y;\r\n\r\n\t},\r\n\r\n\tset y ( value ) {\r\n\r\n\t\tthis._y = value;\r\n\t\tthis.onChangeCallback();\r\n\r\n\t},\r\n\r\n\tget z () {\r\n\r\n\t\treturn this._z;\r\n\r\n\t},\r\n\r\n\tset z ( value ) {\r\n\r\n\t\tthis._z = value;\r\n\t\tthis.onChangeCallback();\r\n\r\n\t},\r\n\r\n\tget w () {\r\n\r\n\t\treturn this._w;\r\n\r\n\t},\r\n\r\n\tset w ( value ) {\r\n\r\n\t\tthis._w = value;\r\n\t\tthis.onChangeCallback();\r\n\r\n\t},\r\n\r\n\tset: function ( x, y, z, w ) {\r\n\r\n\t\tthis._x = x;\r\n\t\tthis._y = y;\r\n\t\tthis._z = z;\r\n\t\tthis._w = w;\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor( this._x, this._y, this._z, this._w );\r\n\r\n\t},\r\n\r\n\tcopy: function ( quaternion ) {\r\n\r\n\t\tthis._x = quaternion.x;\r\n\t\tthis._y = quaternion.y;\r\n\t\tthis._z = quaternion.z;\r\n\t\tthis._w = quaternion.w;\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromEuler: function ( euler, update ) {\r\n\r\n\t\tif ( euler instanceof THREE.Euler === false ) {\r\n\r\n\t\t\tthrow new Error( 'THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );\r\n\r\n\t\t}\r\n\r\n\t\t// http://www.mathworks.com/matlabcentral/fileexchange/\r\n\t\t// \t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\r\n\t\t//\tcontent/SpinCalc.m\r\n\r\n\t\tvar c1 = Math.cos( euler._x / 2 );\r\n\t\tvar c2 = Math.cos( euler._y / 2 );\r\n\t\tvar c3 = Math.cos( euler._z / 2 );\r\n\t\tvar s1 = Math.sin( euler._x / 2 );\r\n\t\tvar s2 = Math.sin( euler._y / 2 );\r\n\t\tvar s3 = Math.sin( euler._z / 2 );\r\n\r\n\t\tvar order = euler.order;\r\n\r\n\t\tif ( order === 'XYZ' ) {\r\n\r\n\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\r\n\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\r\n\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\r\n\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\r\n\r\n\t\t} else if ( order === 'YXZ' ) {\r\n\r\n\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\r\n\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\r\n\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\r\n\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\r\n\r\n\t\t} else if ( order === 'ZXY' ) {\r\n\r\n\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\r\n\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\r\n\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\r\n\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\r\n\r\n\t\t} else if ( order === 'ZYX' ) {\r\n\r\n\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\r\n\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\r\n\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\r\n\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\r\n\r\n\t\t} else if ( order === 'YZX' ) {\r\n\r\n\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\r\n\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\r\n\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\r\n\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\r\n\r\n\t\t} else if ( order === 'XZY' ) {\r\n\r\n\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\r\n\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\r\n\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\r\n\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\r\n\r\n\t\t}\r\n\r\n\t\tif ( update !== false ) this.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromAxisAngle: function ( axis, angle ) {\r\n\r\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\r\n\r\n\t\t// assumes axis is normalized\r\n\r\n\t\tvar halfAngle = angle / 2, s = Math.sin( halfAngle );\r\n\r\n\t\tthis._x = axis.x * s;\r\n\t\tthis._y = axis.y * s;\r\n\t\tthis._z = axis.z * s;\r\n\t\tthis._w = Math.cos( halfAngle );\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromRotationMatrix: function ( m ) {\r\n\r\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\r\n\r\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\r\n\r\n\t\tvar te = m.elements,\r\n\r\n\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\r\n\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\r\n\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],\r\n\r\n\t\t\ttrace = m11 + m22 + m33,\r\n\t\t\ts;\r\n\r\n\t\tif ( trace > 0 ) {\r\n\r\n\t\t\ts = 0.5 / Math.sqrt( trace + 1.0 );\r\n\r\n\t\t\tthis._w = 0.25 / s;\r\n\t\t\tthis._x = ( m32 - m23 ) * s;\r\n\t\t\tthis._y = ( m13 - m31 ) * s;\r\n\t\t\tthis._z = ( m21 - m12 ) * s;\r\n\r\n\t\t} else if ( m11 > m22 && m11 > m33 ) {\r\n\r\n\t\t\ts = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );\r\n\r\n\t\t\tthis._w = ( m32 - m23 ) / s;\r\n\t\t\tthis._x = 0.25 * s;\r\n\t\t\tthis._y = ( m12 + m21 ) / s;\r\n\t\t\tthis._z = ( m13 + m31 ) / s;\r\n\r\n\t\t} else if ( m22 > m33 ) {\r\n\r\n\t\t\ts = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );\r\n\r\n\t\t\tthis._w = ( m13 - m31 ) / s;\r\n\t\t\tthis._x = ( m12 + m21 ) / s;\r\n\t\t\tthis._y = 0.25 * s;\r\n\t\t\tthis._z = ( m23 + m32 ) / s;\r\n\r\n\t\t} else {\r\n\r\n\t\t\ts = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );\r\n\r\n\t\t\tthis._w = ( m21 - m12 ) / s;\r\n\t\t\tthis._x = ( m13 + m31 ) / s;\r\n\t\t\tthis._y = ( m23 + m32 ) / s;\r\n\t\t\tthis._z = 0.25 * s;\r\n\r\n\t\t}\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromUnitVectors: function () {\r\n\r\n\t\t// http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final\r\n\r\n\t\t// assumes direction vectors vFrom and vTo are normalized\r\n\r\n\t\tvar v1, r;\r\n\r\n\t\tvar EPS = 0.000001;\r\n\r\n\t\treturn function ( vFrom, vTo ) {\r\n\r\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\r\n\t\t\tr = vFrom.dot( vTo ) + 1;\r\n\r\n\t\t\tif ( r < EPS ) {\r\n\r\n\t\t\t\tr = 0;\r\n\r\n\t\t\t\tif ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {\r\n\r\n\t\t\t\t\tv1.set( - vFrom.y, vFrom.x, 0 );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tv1.set( 0, - vFrom.z, vFrom.y );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tv1.crossVectors( vFrom, vTo );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis._x = v1.x;\r\n\t\t\tthis._y = v1.y;\r\n\t\t\tthis._z = v1.z;\r\n\t\t\tthis._w = r;\r\n\r\n\t\t\tthis.normalize();\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tinverse: function () {\r\n\r\n\t\tthis.conjugate().normalize();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tconjugate: function () {\r\n\r\n\t\tthis._x *= - 1;\r\n\t\tthis._y *= - 1;\r\n\t\tthis._z *= - 1;\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdot: function ( v ) {\r\n\r\n\t\treturn this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;\r\n\r\n\t},\r\n\r\n\tlengthSq: function () {\r\n\r\n\t\treturn this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\r\n\r\n\t},\r\n\r\n\tlength: function () {\r\n\r\n\t\treturn Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );\r\n\r\n\t},\r\n\r\n\tnormalize: function () {\r\n\r\n\t\tvar l = this.length();\r\n\r\n\t\tif ( l === 0 ) {\r\n\r\n\t\t\tthis._x = 0;\r\n\t\t\tthis._y = 0;\r\n\t\t\tthis._z = 0;\r\n\t\t\tthis._w = 1;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tl = 1 / l;\r\n\r\n\t\t\tthis._x = this._x * l;\r\n\t\t\tthis._y = this._y * l;\r\n\t\t\tthis._z = this._z * l;\r\n\t\t\tthis._w = this._w * l;\r\n\r\n\t\t}\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiply: function ( q, p ) {\r\n\r\n\t\tif ( p !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );\r\n\t\t\treturn this.multiplyQuaternions( q, p );\r\n\r\n\t\t}\r\n\r\n\t\treturn this.multiplyQuaternions( this, q );\r\n\r\n\t},\r\n\r\n\tmultiplyQuaternions: function ( a, b ) {\r\n\r\n\t\t// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\r\n\r\n\t\tvar qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;\r\n\t\tvar qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;\r\n\r\n\t\tthis._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\r\n\t\tthis._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\r\n\t\tthis._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\r\n\t\tthis._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tslerp: function ( qb, t ) {\r\n\r\n\t\tif ( t === 0 ) return this;\r\n\t\tif ( t === 1 ) return this.copy( qb );\r\n\r\n\t\tvar x = this._x, y = this._y, z = this._z, w = this._w;\r\n\r\n\t\t// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\r\n\r\n\t\tvar cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;\r\n\r\n\t\tif ( cosHalfTheta < 0 ) {\r\n\r\n\t\t\tthis._w = - qb._w;\r\n\t\t\tthis._x = - qb._x;\r\n\t\t\tthis._y = - qb._y;\r\n\t\t\tthis._z = - qb._z;\r\n\r\n\t\t\tcosHalfTheta = - cosHalfTheta;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.copy( qb );\r\n\r\n\t\t}\r\n\r\n\t\tif ( cosHalfTheta >= 1.0 ) {\r\n\r\n\t\t\tthis._w = w;\r\n\t\t\tthis._x = x;\r\n\t\t\tthis._y = y;\r\n\t\t\tthis._z = z;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\tvar sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );\r\n\r\n\t\tif ( Math.abs( sinHalfTheta ) < 0.001 ) {\r\n\r\n\t\t\tthis._w = 0.5 * ( w + this._w );\r\n\t\t\tthis._x = 0.5 * ( x + this._x );\r\n\t\t\tthis._y = 0.5 * ( y + this._y );\r\n\t\t\tthis._z = 0.5 * ( z + this._z );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\tvar halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );\r\n\t\tvar ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,\r\n\t\tratioB = Math.sin( t * halfTheta ) / sinHalfTheta;\r\n\r\n\t\tthis._w = ( w * ratioA + this._w * ratioB );\r\n\t\tthis._x = ( x * ratioA + this._x * ratioB );\r\n\t\tthis._y = ( y * ratioA + this._y * ratioB );\r\n\t\tthis._z = ( z * ratioA + this._z * ratioB );\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( quaternion ) {\r\n\r\n\t\treturn ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );\r\n\r\n\t},\r\n\r\n\tfromArray: function ( array, offset ) {\r\n\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tthis._x = array[ offset ];\r\n\t\tthis._y = array[ offset + 1 ];\r\n\t\tthis._z = array[ offset + 2 ];\r\n\t\tthis._w = array[ offset + 3 ];\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoArray: function ( array, offset ) {\r\n\r\n\t\tif ( array === undefined ) array = [];\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tarray[ offset ] = this._x;\r\n\t\tarray[ offset + 1 ] = this._y;\r\n\t\tarray[ offset + 2 ] = this._z;\r\n\t\tarray[ offset + 3 ] = this._w;\r\n\r\n\t\treturn array;\r\n\r\n\t},\r\n\r\n\tonChange: function ( callback ) {\r\n\r\n\t\tthis.onChangeCallback = callback;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tonChangeCallback: function () {}\r\n\r\n};\r\n\r\nObject.assign( THREE.Quaternion, {\r\n\r\n\tslerp: function( qa, qb, qm, t ) {\r\n\r\n\t\treturn qm.copy( qa ).slerp( qb, t );\r\n\r\n\t},\r\n\r\n\tslerpFlat: function(\r\n\t\t\tdst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {\r\n\r\n\t\t// fuzz-free, array-based Quaternion SLERP operation\r\n\r\n\t\tvar x0 = src0[ srcOffset0 + 0 ],\r\n\t\t\ty0 = src0[ srcOffset0 + 1 ],\r\n\t\t\tz0 = src0[ srcOffset0 + 2 ],\r\n\t\t\tw0 = src0[ srcOffset0 + 3 ],\r\n\r\n\t\t\tx1 = src1[ srcOffset1 + 0 ],\r\n\t\t\ty1 = src1[ srcOffset1 + 1 ],\r\n\t\t\tz1 = src1[ srcOffset1 + 2 ],\r\n\t\t\tw1 = src1[ srcOffset1 + 3 ];\r\n\r\n\t\tif ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {\r\n\r\n\t\t\tvar s = 1 - t,\r\n\r\n\t\t\t\tcos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,\r\n\r\n\t\t\t\tdir = ( cos >= 0 ? 1 : - 1 ),\r\n\t\t\t\tsqrSin = 1 - cos * cos;\r\n\r\n\t\t\t// Skip the Slerp for tiny steps to avoid numeric problems:\r\n\t\t\tif ( sqrSin > Number.EPSILON ) {\r\n\r\n\t\t\t\tvar sin = Math.sqrt( sqrSin ),\r\n\t\t\t\t\tlen = Math.atan2( sin, cos * dir );\r\n\r\n\t\t\t\ts = Math.sin( s * len ) / sin;\r\n\t\t\t\tt = Math.sin( t * len ) / sin;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar tDir = t * dir;\r\n\r\n\t\t\tx0 = x0 * s + x1 * tDir;\r\n\t\t\ty0 = y0 * s + y1 * tDir;\r\n\t\t\tz0 = z0 * s + z1 * tDir;\r\n\t\t\tw0 = w0 * s + w1 * tDir;\r\n\r\n\t\t\t// Normalize in case we just did a lerp:\r\n\t\t\tif ( s === 1 - t ) {\r\n\r\n\t\t\t\tvar f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );\r\n\r\n\t\t\t\tx0 *= f;\r\n\t\t\t\ty0 *= f;\r\n\t\t\t\tz0 *= f;\r\n\t\t\t\tw0 *= f;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tdst[ dstOffset ] = x0;\r\n\t\tdst[ dstOffset + 1 ] = y0;\r\n\t\tdst[ dstOffset + 2 ] = z0;\r\n\t\tdst[ dstOffset + 3 ] = w0;\r\n\r\n\t}\r\n\r\n} );\r\n\r\n// File:src/math/Vector2.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author philogb / http://blog.thejit.org/\r\n * @author egraether / http://egraether.com/\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n */\r\n\r\nTHREE.Vector2 = function ( x, y ) {\r\n\r\n\tthis.x = x || 0;\r\n\tthis.y = y || 0;\r\n\r\n};\r\n\r\nTHREE.Vector2.prototype = {\r\n\r\n\tconstructor: THREE.Vector2,\r\n\r\n\tget width() {\r\n\r\n\t\treturn this.x;\r\n\r\n\t},\r\n\r\n\tset width( value ) {\r\n\r\n\t\tthis.x = value;\r\n\r\n\t},\r\n\r\n\tget height() {\r\n\r\n\t\treturn this.y;\r\n\r\n\t},\r\n\r\n\tset height( value ) {\r\n\r\n\t\tthis.y = value;\r\n\r\n\t},\r\n\r\n\t//\r\n\r\n\tset: function ( x, y ) {\r\n\r\n\t\tthis.x = x;\r\n\t\tthis.y = y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetScalar: function ( scalar ) {\r\n\r\n\t\tthis.x = scalar;\r\n\t\tthis.y = scalar;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetX: function ( x ) {\r\n\r\n\t\tthis.x = x;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetY: function ( y ) {\r\n\r\n\t\tthis.y = y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetComponent: function ( index, value ) {\r\n\r\n\t\tswitch ( index ) {\r\n\r\n\t\t\tcase 0: this.x = value; break;\r\n\t\t\tcase 1: this.y = value; break;\r\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tgetComponent: function ( index ) {\r\n\r\n\t\tswitch ( index ) {\r\n\r\n\t\t\tcase 0: return this.x;\r\n\t\t\tcase 1: return this.y;\r\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor( this.x, this.y );\r\n\r\n\t},\r\n\r\n\tcopy: function ( v ) {\r\n\r\n\t\tthis.x = v.x;\r\n\t\tthis.y = v.y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tadd: function ( v, w ) {\r\n\r\n\t\tif ( w !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\r\n\t\t\treturn this.addVectors( v, w );\r\n\r\n\t\t}\r\n\r\n\t\tthis.x += v.x;\r\n\t\tthis.y += v.y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddScalar: function ( s ) {\r\n\r\n\t\tthis.x += s;\r\n\t\tthis.y += s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddVectors: function ( a, b ) {\r\n\r\n\t\tthis.x = a.x + b.x;\r\n\t\tthis.y = a.y + b.y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddScaledVector: function ( v, s ) {\r\n\r\n\t\tthis.x += v.x * s;\r\n\t\tthis.y += v.y * s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsub: function ( v, w ) {\r\n\r\n\t\tif ( w !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\r\n\t\t\treturn this.subVectors( v, w );\r\n\r\n\t\t}\r\n\r\n\t\tthis.x -= v.x;\r\n\t\tthis.y -= v.y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsubScalar: function ( s ) {\r\n\r\n\t\tthis.x -= s;\r\n\t\tthis.y -= s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsubVectors: function ( a, b ) {\r\n\r\n\t\tthis.x = a.x - b.x;\r\n\t\tthis.y = a.y - b.y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiply: function ( v ) {\r\n\r\n\t\tthis.x *= v.x;\r\n\t\tthis.y *= v.y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyScalar: function ( scalar ) {\r\n\r\n\t\tif ( isFinite( scalar ) ) {\r\n\r\n\t\t\tthis.x *= scalar;\r\n\t\t\tthis.y *= scalar;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.x = 0;\r\n\t\t\tthis.y = 0;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdivide: function ( v ) {\r\n\r\n\t\tthis.x /= v.x;\r\n\t\tthis.y /= v.y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdivideScalar: function ( scalar ) {\r\n\r\n\t\treturn this.multiplyScalar( 1 / scalar );\r\n\r\n\t},\r\n\r\n\tmin: function ( v ) {\r\n\r\n\t\tthis.x = Math.min( this.x, v.x );\r\n\t\tthis.y = Math.min( this.y, v.y );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmax: function ( v ) {\r\n\r\n\t\tthis.x = Math.max( this.x, v.x );\r\n\t\tthis.y = Math.max( this.y, v.y );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclamp: function ( min, max ) {\r\n\r\n\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\r\n\r\n\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\r\n\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclampScalar: function () {\r\n\r\n\t\tvar min, max;\r\n\r\n\t\treturn function clampScalar( minVal, maxVal ) {\r\n\r\n\t\t\tif ( min === undefined ) {\r\n\r\n\t\t\t\tmin = new THREE.Vector2();\r\n\t\t\t\tmax = new THREE.Vector2();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmin.set( minVal, minVal );\r\n\t\t\tmax.set( maxVal, maxVal );\r\n\r\n\t\t\treturn this.clamp( min, max );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tclampLength: function ( min, max ) {\r\n\r\n\t\tvar length = this.length();\r\n\r\n\t\tthis.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tfloor: function () {\r\n\r\n\t\tthis.x = Math.floor( this.x );\r\n\t\tthis.y = Math.floor( this.y );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tceil: function () {\r\n\r\n\t\tthis.x = Math.ceil( this.x );\r\n\t\tthis.y = Math.ceil( this.y );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tround: function () {\r\n\r\n\t\tthis.x = Math.round( this.x );\r\n\t\tthis.y = Math.round( this.y );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\troundToZero: function () {\r\n\r\n\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\r\n\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tnegate: function () {\r\n\r\n\t\tthis.x = - this.x;\r\n\t\tthis.y = - this.y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdot: function ( v ) {\r\n\r\n\t\treturn this.x * v.x + this.y * v.y;\r\n\r\n\t},\r\n\r\n\tlengthSq: function () {\r\n\r\n\t\treturn this.x * this.x + this.y * this.y;\r\n\r\n\t},\r\n\r\n\tlength: function () {\r\n\r\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y );\r\n\r\n\t},\r\n\r\n\tlengthManhattan: function() {\r\n\r\n\t\treturn Math.abs( this.x ) + Math.abs( this.y );\r\n\r\n\t},\r\n\r\n\tnormalize: function () {\r\n\r\n\t\treturn this.divideScalar( this.length() );\r\n\r\n\t},\r\n\r\n\tangle: function () {\r\n\r\n\t\t// computes the angle in radians with respect to the positive x-axis\r\n\r\n\t\tvar angle = Math.atan2( this.y, this.x );\r\n\r\n\t\tif ( angle < 0 ) angle += 2 * Math.PI;\r\n\r\n\t\treturn angle;\r\n\r\n\t},\r\n\r\n\tdistanceTo: function ( v ) {\r\n\r\n\t\treturn Math.sqrt( this.distanceToSquared( v ) );\r\n\r\n\t},\r\n\r\n\tdistanceToSquared: function ( v ) {\r\n\r\n\t\tvar dx = this.x - v.x, dy = this.y - v.y;\r\n\t\treturn dx * dx + dy * dy;\r\n\r\n\t},\r\n\r\n\tsetLength: function ( length ) {\r\n\r\n\t\treturn this.multiplyScalar( length / this.length() );\r\n\r\n\t},\r\n\r\n\tlerp: function ( v, alpha ) {\r\n\r\n\t\tthis.x += ( v.x - this.x ) * alpha;\r\n\t\tthis.y += ( v.y - this.y ) * alpha;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tlerpVectors: function ( v1, v2, alpha ) {\r\n\r\n\t\tthis.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( v ) {\r\n\r\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) );\r\n\r\n\t},\r\n\r\n\tfromArray: function ( array, offset ) {\r\n\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tthis.x = array[ offset ];\r\n\t\tthis.y = array[ offset + 1 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoArray: function ( array, offset ) {\r\n\r\n\t\tif ( array === undefined ) array = [];\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tarray[ offset ] = this.x;\r\n\t\tarray[ offset + 1 ] = this.y;\r\n\r\n\t\treturn array;\r\n\r\n\t},\r\n\r\n\tfromAttribute: function ( attribute, index, offset ) {\r\n\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tindex = index * attribute.itemSize + offset;\r\n\r\n\t\tthis.x = attribute.array[ index ];\r\n\t\tthis.y = attribute.array[ index + 1 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\trotateAround: function ( center, angle ) {\r\n\r\n\t\tvar c = Math.cos( angle ), s = Math.sin( angle );\r\n\r\n\t\tvar x = this.x - center.x;\r\n\t\tvar y = this.y - center.y;\r\n\r\n\t\tthis.x = x * c - y * s + center.x;\r\n\t\tthis.y = x * s + y * c + center.y;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/math/Vector3.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author *kile / http://kile.stravaganza.org/\r\n * @author philogb / http://blog.thejit.org/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author egraether / http://egraether.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\n\r\nTHREE.Vector3 = function ( x, y, z ) {\r\n\r\n\tthis.x = x || 0;\r\n\tthis.y = y || 0;\r\n\tthis.z = z || 0;\r\n\r\n};\r\n\r\nTHREE.Vector3.prototype = {\r\n\r\n\tconstructor: THREE.Vector3,\r\n\r\n\tset: function ( x, y, z ) {\r\n\r\n\t\tthis.x = x;\r\n\t\tthis.y = y;\r\n\t\tthis.z = z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetScalar: function ( scalar ) {\r\n\r\n\t\tthis.x = scalar;\r\n\t\tthis.y = scalar;\r\n\t\tthis.z = scalar;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetX: function ( x ) {\r\n\r\n\t\tthis.x = x;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetY: function ( y ) {\r\n\r\n\t\tthis.y = y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetZ: function ( z ) {\r\n\r\n\t\tthis.z = z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetComponent: function ( index, value ) {\r\n\r\n\t\tswitch ( index ) {\r\n\r\n\t\t\tcase 0: this.x = value; break;\r\n\t\t\tcase 1: this.y = value; break;\r\n\t\t\tcase 2: this.z = value; break;\r\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tgetComponent: function ( index ) {\r\n\r\n\t\tswitch ( index ) {\r\n\r\n\t\t\tcase 0: return this.x;\r\n\t\t\tcase 1: return this.y;\r\n\t\t\tcase 2: return this.z;\r\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor( this.x, this.y, this.z );\r\n\r\n\t},\r\n\r\n\tcopy: function ( v ) {\r\n\r\n\t\tthis.x = v.x;\r\n\t\tthis.y = v.y;\r\n\t\tthis.z = v.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tadd: function ( v, w ) {\r\n\r\n\t\tif ( w !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\r\n\t\t\treturn this.addVectors( v, w );\r\n\r\n\t\t}\r\n\r\n\t\tthis.x += v.x;\r\n\t\tthis.y += v.y;\r\n\t\tthis.z += v.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddScalar: function ( s ) {\r\n\r\n\t\tthis.x += s;\r\n\t\tthis.y += s;\r\n\t\tthis.z += s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddVectors: function ( a, b ) {\r\n\r\n\t\tthis.x = a.x + b.x;\r\n\t\tthis.y = a.y + b.y;\r\n\t\tthis.z = a.z + b.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddScaledVector: function ( v, s ) {\r\n\r\n\t\tthis.x += v.x * s;\r\n\t\tthis.y += v.y * s;\r\n\t\tthis.z += v.z * s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsub: function ( v, w ) {\r\n\r\n\t\tif ( w !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\r\n\t\t\treturn this.subVectors( v, w );\r\n\r\n\t\t}\r\n\r\n\t\tthis.x -= v.x;\r\n\t\tthis.y -= v.y;\r\n\t\tthis.z -= v.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsubScalar: function ( s ) {\r\n\r\n\t\tthis.x -= s;\r\n\t\tthis.y -= s;\r\n\t\tthis.z -= s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsubVectors: function ( a, b ) {\r\n\r\n\t\tthis.x = a.x - b.x;\r\n\t\tthis.y = a.y - b.y;\r\n\t\tthis.z = a.z - b.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiply: function ( v, w ) {\r\n\r\n\t\tif ( w !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );\r\n\t\t\treturn this.multiplyVectors( v, w );\r\n\r\n\t\t}\r\n\r\n\t\tthis.x *= v.x;\r\n\t\tthis.y *= v.y;\r\n\t\tthis.z *= v.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyScalar: function ( scalar ) {\r\n\r\n\t\tif ( isFinite( scalar ) ) {\r\n\r\n\t\t\tthis.x *= scalar;\r\n\t\t\tthis.y *= scalar;\r\n\t\t\tthis.z *= scalar;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.x = 0;\r\n\t\t\tthis.y = 0;\r\n\t\t\tthis.z = 0;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyVectors: function ( a, b ) {\r\n\r\n\t\tthis.x = a.x * b.x;\r\n\t\tthis.y = a.y * b.y;\r\n\t\tthis.z = a.z * b.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tapplyEuler: function () {\r\n\r\n\t\tvar quaternion;\r\n\r\n\t\treturn function applyEuler( euler ) {\r\n\r\n\t\t\tif ( euler instanceof THREE.Euler === false ) {\r\n\r\n\t\t\t\tconsole.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( quaternion === undefined ) quaternion = new THREE.Quaternion();\r\n\r\n\t\t\tthis.applyQuaternion( quaternion.setFromEuler( euler ) );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tapplyAxisAngle: function () {\r\n\r\n\t\tvar quaternion;\r\n\r\n\t\treturn function applyAxisAngle( axis, angle ) {\r\n\r\n\t\t\tif ( quaternion === undefined ) quaternion = new THREE.Quaternion();\r\n\r\n\t\t\tthis.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tapplyMatrix3: function ( m ) {\r\n\r\n\t\tvar x = this.x;\r\n\t\tvar y = this.y;\r\n\t\tvar z = this.z;\r\n\r\n\t\tvar e = m.elements;\r\n\r\n\t\tthis.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;\r\n\t\tthis.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;\r\n\t\tthis.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tapplyMatrix4: function ( m ) {\r\n\r\n\t\t// input: THREE.Matrix4 affine matrix\r\n\r\n\t\tvar x = this.x, y = this.y, z = this.z;\r\n\r\n\t\tvar e = m.elements;\r\n\r\n\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ];\r\n\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ];\r\n\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tapplyProjection: function ( m ) {\r\n\r\n\t\t// input: THREE.Matrix4 projection matrix\r\n\r\n\t\tvar x = this.x, y = this.y, z = this.z;\r\n\r\n\t\tvar e = m.elements;\r\n\t\tvar d = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] ); // perspective divide\r\n\r\n\t\tthis.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ] ) * d;\r\n\t\tthis.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ] ) * d;\r\n\t\tthis.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * d;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tapplyQuaternion: function ( q ) {\r\n\r\n\t\tvar x = this.x;\r\n\t\tvar y = this.y;\r\n\t\tvar z = this.z;\r\n\r\n\t\tvar qx = q.x;\r\n\t\tvar qy = q.y;\r\n\t\tvar qz = q.z;\r\n\t\tvar qw = q.w;\r\n\r\n\t\t// calculate quat * vector\r\n\r\n\t\tvar ix =  qw * x + qy * z - qz * y;\r\n\t\tvar iy =  qw * y + qz * x - qx * z;\r\n\t\tvar iz =  qw * z + qx * y - qy * x;\r\n\t\tvar iw = - qx * x - qy * y - qz * z;\r\n\r\n\t\t// calculate result * inverse quat\r\n\r\n\t\tthis.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;\r\n\t\tthis.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;\r\n\t\tthis.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tproject: function () {\r\n\r\n\t\tvar matrix;\r\n\r\n\t\treturn function project( camera ) {\r\n\r\n\t\t\tif ( matrix === undefined ) matrix = new THREE.Matrix4();\r\n\r\n\t\t\tmatrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );\r\n\t\t\treturn this.applyProjection( matrix );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tunproject: function () {\r\n\r\n\t\tvar matrix;\r\n\r\n\t\treturn function unproject( camera ) {\r\n\r\n\t\t\tif ( matrix === undefined ) matrix = new THREE.Matrix4();\r\n\r\n\t\t\tmatrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );\r\n\t\t\treturn this.applyProjection( matrix );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\ttransformDirection: function ( m ) {\r\n\r\n\t\t// input: THREE.Matrix4 affine matrix\r\n\t\t// vector interpreted as a direction\r\n\r\n\t\tvar x = this.x, y = this.y, z = this.z;\r\n\r\n\t\tvar e = m.elements;\r\n\r\n\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z;\r\n\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z;\r\n\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;\r\n\r\n\t\tthis.normalize();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdivide: function ( v ) {\r\n\r\n\t\tthis.x /= v.x;\r\n\t\tthis.y /= v.y;\r\n\t\tthis.z /= v.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdivideScalar: function ( scalar ) {\r\n\r\n\t\treturn this.multiplyScalar( 1 / scalar );\r\n\r\n\t},\r\n\r\n\tmin: function ( v ) {\r\n\r\n\t\tthis.x = Math.min( this.x, v.x );\r\n\t\tthis.y = Math.min( this.y, v.y );\r\n\t\tthis.z = Math.min( this.z, v.z );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmax: function ( v ) {\r\n\r\n\t\tthis.x = Math.max( this.x, v.x );\r\n\t\tthis.y = Math.max( this.y, v.y );\r\n\t\tthis.z = Math.max( this.z, v.z );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclamp: function ( min, max ) {\r\n\r\n\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\r\n\r\n\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\r\n\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\r\n\t\tthis.z = Math.max( min.z, Math.min( max.z, this.z ) );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclampScalar: function () {\r\n\r\n\t\tvar min, max;\r\n\r\n\t\treturn function clampScalar( minVal, maxVal ) {\r\n\r\n\t\t\tif ( min === undefined ) {\r\n\r\n\t\t\t\tmin = new THREE.Vector3();\r\n\t\t\t\tmax = new THREE.Vector3();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmin.set( minVal, minVal, minVal );\r\n\t\t\tmax.set( maxVal, maxVal, maxVal );\r\n\r\n\t\t\treturn this.clamp( min, max );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tclampLength: function ( min, max ) {\r\n\r\n\t\tvar length = this.length();\r\n\r\n\t\tthis.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tfloor: function () {\r\n\r\n\t\tthis.x = Math.floor( this.x );\r\n\t\tthis.y = Math.floor( this.y );\r\n\t\tthis.z = Math.floor( this.z );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tceil: function () {\r\n\r\n\t\tthis.x = Math.ceil( this.x );\r\n\t\tthis.y = Math.ceil( this.y );\r\n\t\tthis.z = Math.ceil( this.z );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tround: function () {\r\n\r\n\t\tthis.x = Math.round( this.x );\r\n\t\tthis.y = Math.round( this.y );\r\n\t\tthis.z = Math.round( this.z );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\troundToZero: function () {\r\n\r\n\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\r\n\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\r\n\t\tthis.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tnegate: function () {\r\n\r\n\t\tthis.x = - this.x;\r\n\t\tthis.y = - this.y;\r\n\t\tthis.z = - this.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdot: function ( v ) {\r\n\r\n\t\treturn this.x * v.x + this.y * v.y + this.z * v.z;\r\n\r\n\t},\r\n\r\n\tlengthSq: function () {\r\n\r\n\t\treturn this.x * this.x + this.y * this.y + this.z * this.z;\r\n\r\n\t},\r\n\r\n\tlength: function () {\r\n\r\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );\r\n\r\n\t},\r\n\r\n\tlengthManhattan: function () {\r\n\r\n\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );\r\n\r\n\t},\r\n\r\n\tnormalize: function () {\r\n\r\n\t\treturn this.divideScalar( this.length() );\r\n\r\n\t},\r\n\r\n\tsetLength: function ( length ) {\r\n\r\n\t\treturn this.multiplyScalar( length / this.length() );\r\n\r\n\t},\r\n\r\n\tlerp: function ( v, alpha ) {\r\n\r\n\t\tthis.x += ( v.x - this.x ) * alpha;\r\n\t\tthis.y += ( v.y - this.y ) * alpha;\r\n\t\tthis.z += ( v.z - this.z ) * alpha;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tlerpVectors: function ( v1, v2, alpha ) {\r\n\r\n\t\tthis.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcross: function ( v, w ) {\r\n\r\n\t\tif ( w !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );\r\n\t\t\treturn this.crossVectors( v, w );\r\n\r\n\t\t}\r\n\r\n\t\tvar x = this.x, y = this.y, z = this.z;\r\n\r\n\t\tthis.x = y * v.z - z * v.y;\r\n\t\tthis.y = z * v.x - x * v.z;\r\n\t\tthis.z = x * v.y - y * v.x;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcrossVectors: function ( a, b ) {\r\n\r\n\t\tvar ax = a.x, ay = a.y, az = a.z;\r\n\t\tvar bx = b.x, by = b.y, bz = b.z;\r\n\r\n\t\tthis.x = ay * bz - az * by;\r\n\t\tthis.y = az * bx - ax * bz;\r\n\t\tthis.z = ax * by - ay * bx;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tprojectOnVector: function () {\r\n\r\n\t\tvar v1, dot;\r\n\r\n\t\treturn function projectOnVector( vector ) {\r\n\r\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\r\n\t\t\tv1.copy( vector ).normalize();\r\n\r\n\t\t\tdot = this.dot( v1 );\r\n\r\n\t\t\treturn this.copy( v1 ).multiplyScalar( dot );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tprojectOnPlane: function () {\r\n\r\n\t\tvar v1;\r\n\r\n\t\treturn function projectOnPlane( planeNormal ) {\r\n\r\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\r\n\t\t\tv1.copy( this ).projectOnVector( planeNormal );\r\n\r\n\t\t\treturn this.sub( v1 );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\treflect: function () {\r\n\r\n\t\t// reflect incident vector off plane orthogonal to normal\r\n\t\t// normal is assumed to have unit length\r\n\r\n\t\tvar v1;\r\n\r\n\t\treturn function reflect( normal ) {\r\n\r\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\r\n\t\t\treturn this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tangleTo: function ( v ) {\r\n\r\n\t\tvar theta = this.dot( v ) / ( Math.sqrt( this.lengthSq() * v.lengthSq() ) );\r\n\r\n\t\t// clamp, to handle numerical problems\r\n\r\n\t\treturn Math.acos( THREE.Math.clamp( theta, - 1, 1 ) );\r\n\r\n\t},\r\n\r\n\tdistanceTo: function ( v ) {\r\n\r\n\t\treturn Math.sqrt( this.distanceToSquared( v ) );\r\n\r\n\t},\r\n\r\n\tdistanceToSquared: function ( v ) {\r\n\r\n\t\tvar dx = this.x - v.x;\r\n\t\tvar dy = this.y - v.y;\r\n\t\tvar dz = this.z - v.z;\r\n\r\n\t\treturn dx * dx + dy * dy + dz * dz;\r\n\r\n\t},\r\n\r\n\tsetFromSpherical: function( s ) {\r\n\r\n\t\tvar sinPhiRadius = Math.sin( s.phi ) * s.radius;\r\n\r\n\t\tthis.x = sinPhiRadius * Math.sin( s.theta );\r\n\t\tthis.y = Math.cos( s.phi ) * s.radius;\r\n\t\tthis.z = sinPhiRadius * Math.cos( s.theta );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromMatrixPosition: function ( m ) {\r\n\r\n\t\treturn this.setFromMatrixColumn( m, 3 );\r\n\r\n\t},\r\n\r\n\tsetFromMatrixScale: function ( m ) {\r\n\r\n\t\tvar sx = this.setFromMatrixColumn( m, 0 ).length();\r\n\t\tvar sy = this.setFromMatrixColumn( m, 1 ).length();\r\n\t\tvar sz = this.setFromMatrixColumn( m, 2 ).length();\r\n\r\n\t\tthis.x = sx;\r\n\t\tthis.y = sy;\r\n\t\tthis.z = sz;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromMatrixColumn: function ( m, index ) {\r\n\r\n\t\tif ( typeof m === 'number' ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.Vector3: setFromMatrixColumn now expects ( matrix, index ).' );\r\n\r\n\t\t\tm = arguments[ 1 ];\r\n\t\t\tindex = arguments[ 0 ];\r\n\r\n\t\t}\r\n\r\n\t\treturn this.fromArray( m.elements, index * 4 );\r\n\r\n\t},\r\n\r\n\tequals: function ( v ) {\r\n\r\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );\r\n\r\n\t},\r\n\r\n\tfromArray: function ( array, offset ) {\r\n\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tthis.x = array[ offset ];\r\n\t\tthis.y = array[ offset + 1 ];\r\n\t\tthis.z = array[ offset + 2 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoArray: function ( array, offset ) {\r\n\r\n\t\tif ( array === undefined ) array = [];\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tarray[ offset ] = this.x;\r\n\t\tarray[ offset + 1 ] = this.y;\r\n\t\tarray[ offset + 2 ] = this.z;\r\n\r\n\t\treturn array;\r\n\r\n\t},\r\n\r\n\tfromAttribute: function ( attribute, index, offset ) {\r\n\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tindex = index * attribute.itemSize + offset;\r\n\r\n\t\tthis.x = attribute.array[ index ];\r\n\t\tthis.y = attribute.array[ index + 1 ];\r\n\t\tthis.z = attribute.array[ index + 2 ];\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/math/Vector4.js\r\n\r\n/**\r\n * @author supereggbert / http://www.paulbrunt.co.uk/\r\n * @author philogb / http://blog.thejit.org/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author egraether / http://egraether.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\n\r\nTHREE.Vector4 = function ( x, y, z, w ) {\r\n\r\n\tthis.x = x || 0;\r\n\tthis.y = y || 0;\r\n\tthis.z = z || 0;\r\n\tthis.w = ( w !== undefined ) ? w : 1;\r\n\r\n};\r\n\r\nTHREE.Vector4.prototype = {\r\n\r\n\tconstructor: THREE.Vector4,\r\n\r\n\tset: function ( x, y, z, w ) {\r\n\r\n\t\tthis.x = x;\r\n\t\tthis.y = y;\r\n\t\tthis.z = z;\r\n\t\tthis.w = w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetScalar: function ( scalar ) {\r\n\r\n\t\tthis.x = scalar;\r\n\t\tthis.y = scalar;\r\n\t\tthis.z = scalar;\r\n\t\tthis.w = scalar;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetX: function ( x ) {\r\n\r\n\t\tthis.x = x;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetY: function ( y ) {\r\n\r\n\t\tthis.y = y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetZ: function ( z ) {\r\n\r\n\t\tthis.z = z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetW: function ( w ) {\r\n\r\n\t\tthis.w = w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetComponent: function ( index, value ) {\r\n\r\n\t\tswitch ( index ) {\r\n\r\n\t\t\tcase 0: this.x = value; break;\r\n\t\t\tcase 1: this.y = value; break;\r\n\t\t\tcase 2: this.z = value; break;\r\n\t\t\tcase 3: this.w = value; break;\r\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tgetComponent: function ( index ) {\r\n\r\n\t\tswitch ( index ) {\r\n\r\n\t\t\tcase 0: return this.x;\r\n\t\t\tcase 1: return this.y;\r\n\t\t\tcase 2: return this.z;\r\n\t\t\tcase 3: return this.w;\r\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor( this.x, this.y, this.z, this.w );\r\n\r\n\t},\r\n\r\n\tcopy: function ( v ) {\r\n\r\n\t\tthis.x = v.x;\r\n\t\tthis.y = v.y;\r\n\t\tthis.z = v.z;\r\n\t\tthis.w = ( v.w !== undefined ) ? v.w : 1;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tadd: function ( v, w ) {\r\n\r\n\t\tif ( w !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\r\n\t\t\treturn this.addVectors( v, w );\r\n\r\n\t\t}\r\n\r\n\t\tthis.x += v.x;\r\n\t\tthis.y += v.y;\r\n\t\tthis.z += v.z;\r\n\t\tthis.w += v.w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddScalar: function ( s ) {\r\n\r\n\t\tthis.x += s;\r\n\t\tthis.y += s;\r\n\t\tthis.z += s;\r\n\t\tthis.w += s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddVectors: function ( a, b ) {\r\n\r\n\t\tthis.x = a.x + b.x;\r\n\t\tthis.y = a.y + b.y;\r\n\t\tthis.z = a.z + b.z;\r\n\t\tthis.w = a.w + b.w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddScaledVector: function ( v, s ) {\r\n\r\n\t\tthis.x += v.x * s;\r\n\t\tthis.y += v.y * s;\r\n\t\tthis.z += v.z * s;\r\n\t\tthis.w += v.w * s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsub: function ( v, w ) {\r\n\r\n\t\tif ( w !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\r\n\t\t\treturn this.subVectors( v, w );\r\n\r\n\t\t}\r\n\r\n\t\tthis.x -= v.x;\r\n\t\tthis.y -= v.y;\r\n\t\tthis.z -= v.z;\r\n\t\tthis.w -= v.w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsubScalar: function ( s ) {\r\n\r\n\t\tthis.x -= s;\r\n\t\tthis.y -= s;\r\n\t\tthis.z -= s;\r\n\t\tthis.w -= s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsubVectors: function ( a, b ) {\r\n\r\n\t\tthis.x = a.x - b.x;\r\n\t\tthis.y = a.y - b.y;\r\n\t\tthis.z = a.z - b.z;\r\n\t\tthis.w = a.w - b.w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyScalar: function ( scalar ) {\r\n\r\n\t\tif ( isFinite( scalar ) ) {\r\n\r\n\t\t\tthis.x *= scalar;\r\n\t\t\tthis.y *= scalar;\r\n\t\t\tthis.z *= scalar;\r\n\t\t\tthis.w *= scalar;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.x = 0;\r\n\t\t\tthis.y = 0;\r\n\t\t\tthis.z = 0;\r\n\t\t\tthis.w = 0;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tapplyMatrix4: function ( m ) {\r\n\r\n\t\tvar x = this.x;\r\n\t\tvar y = this.y;\r\n\t\tvar z = this.z;\r\n\t\tvar w = this.w;\r\n\r\n\t\tvar e = m.elements;\r\n\r\n\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;\r\n\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;\r\n\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;\r\n\t\tthis.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdivideScalar: function ( scalar ) {\r\n\r\n\t\treturn this.multiplyScalar( 1 / scalar );\r\n\r\n\t},\r\n\r\n\tsetAxisAngleFromQuaternion: function ( q ) {\r\n\r\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm\r\n\r\n\t\t// q is assumed to be normalized\r\n\r\n\t\tthis.w = 2 * Math.acos( q.w );\r\n\r\n\t\tvar s = Math.sqrt( 1 - q.w * q.w );\r\n\r\n\t\tif ( s < 0.0001 ) {\r\n\r\n\t\t\t this.x = 1;\r\n\t\t\t this.y = 0;\r\n\t\t\t this.z = 0;\r\n\r\n\t\t} else {\r\n\r\n\t\t\t this.x = q.x / s;\r\n\t\t\t this.y = q.y / s;\r\n\t\t\t this.z = q.z / s;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetAxisAngleFromRotationMatrix: function ( m ) {\r\n\r\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm\r\n\r\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\r\n\r\n\t\tvar angle, x, y, z,\t\t// variables for result\r\n\t\t\tepsilon = 0.01,\t\t// margin to allow for rounding errors\r\n\t\t\tepsilon2 = 0.1,\t\t// margin to distinguish between 0 and 180 degrees\r\n\r\n\t\t\tte = m.elements,\r\n\r\n\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\r\n\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\r\n\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\r\n\r\n\t\tif ( ( Math.abs( m12 - m21 ) < epsilon ) &&\r\n\t\t     ( Math.abs( m13 - m31 ) < epsilon ) &&\r\n\t\t     ( Math.abs( m23 - m32 ) < epsilon ) ) {\r\n\r\n\t\t\t// singularity found\r\n\t\t\t// first check for identity matrix which must have +1 for all terms\r\n\t\t\t// in leading diagonal and zero in other terms\r\n\r\n\t\t\tif ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&\r\n\t\t\t     ( Math.abs( m13 + m31 ) < epsilon2 ) &&\r\n\t\t\t     ( Math.abs( m23 + m32 ) < epsilon2 ) &&\r\n\t\t\t     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {\r\n\r\n\t\t\t\t// this singularity is identity matrix so angle = 0\r\n\r\n\t\t\t\tthis.set( 1, 0, 0, 0 );\r\n\r\n\t\t\t\treturn this; // zero angle, arbitrary axis\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// otherwise this singularity is angle = 180\r\n\r\n\t\t\tangle = Math.PI;\r\n\r\n\t\t\tvar xx = ( m11 + 1 ) / 2;\r\n\t\t\tvar yy = ( m22 + 1 ) / 2;\r\n\t\t\tvar zz = ( m33 + 1 ) / 2;\r\n\t\t\tvar xy = ( m12 + m21 ) / 4;\r\n\t\t\tvar xz = ( m13 + m31 ) / 4;\r\n\t\t\tvar yz = ( m23 + m32 ) / 4;\r\n\r\n\t\t\tif ( ( xx > yy ) && ( xx > zz ) ) {\r\n\r\n\t\t\t\t// m11 is the largest diagonal term\r\n\r\n\t\t\t\tif ( xx < epsilon ) {\r\n\r\n\t\t\t\t\tx = 0;\r\n\t\t\t\t\ty = 0.707106781;\r\n\t\t\t\t\tz = 0.707106781;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tx = Math.sqrt( xx );\r\n\t\t\t\t\ty = xy / x;\r\n\t\t\t\t\tz = xz / x;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( yy > zz ) {\r\n\r\n\t\t\t\t// m22 is the largest diagonal term\r\n\r\n\t\t\t\tif ( yy < epsilon ) {\r\n\r\n\t\t\t\t\tx = 0.707106781;\r\n\t\t\t\t\ty = 0;\r\n\t\t\t\t\tz = 0.707106781;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\ty = Math.sqrt( yy );\r\n\t\t\t\t\tx = xy / y;\r\n\t\t\t\t\tz = yz / y;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// m33 is the largest diagonal term so base result on this\r\n\r\n\t\t\t\tif ( zz < epsilon ) {\r\n\r\n\t\t\t\t\tx = 0.707106781;\r\n\t\t\t\t\ty = 0.707106781;\r\n\t\t\t\t\tz = 0;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tz = Math.sqrt( zz );\r\n\t\t\t\t\tx = xz / z;\r\n\t\t\t\t\ty = yz / z;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.set( x, y, z, angle );\r\n\r\n\t\t\treturn this; // return 180 deg rotation\r\n\r\n\t\t}\r\n\r\n\t\t// as we have reached here there are no singularities so we can handle normally\r\n\r\n\t\tvar s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +\r\n\t\t                   ( m13 - m31 ) * ( m13 - m31 ) +\r\n\t\t                   ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize\r\n\r\n\t\tif ( Math.abs( s ) < 0.001 ) s = 1;\r\n\r\n\t\t// prevent divide by zero, should not happen if matrix is orthogonal and should be\r\n\t\t// caught by singularity test above, but I've left it in just in case\r\n\r\n\t\tthis.x = ( m32 - m23 ) / s;\r\n\t\tthis.y = ( m13 - m31 ) / s;\r\n\t\tthis.z = ( m21 - m12 ) / s;\r\n\t\tthis.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmin: function ( v ) {\r\n\r\n\t\tthis.x = Math.min( this.x, v.x );\r\n\t\tthis.y = Math.min( this.y, v.y );\r\n\t\tthis.z = Math.min( this.z, v.z );\r\n\t\tthis.w = Math.min( this.w, v.w );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmax: function ( v ) {\r\n\r\n\t\tthis.x = Math.max( this.x, v.x );\r\n\t\tthis.y = Math.max( this.y, v.y );\r\n\t\tthis.z = Math.max( this.z, v.z );\r\n\t\tthis.w = Math.max( this.w, v.w );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclamp: function ( min, max ) {\r\n\r\n\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\r\n\r\n\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\r\n\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\r\n\t\tthis.z = Math.max( min.z, Math.min( max.z, this.z ) );\r\n\t\tthis.w = Math.max( min.w, Math.min( max.w, this.w ) );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclampScalar: function () {\r\n\r\n\t\tvar min, max;\r\n\r\n\t\treturn function clampScalar( minVal, maxVal ) {\r\n\r\n\t\t\tif ( min === undefined ) {\r\n\r\n\t\t\t\tmin = new THREE.Vector4();\r\n\t\t\t\tmax = new THREE.Vector4();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmin.set( minVal, minVal, minVal, minVal );\r\n\t\t\tmax.set( maxVal, maxVal, maxVal, maxVal );\r\n\r\n\t\t\treturn this.clamp( min, max );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tfloor: function () {\r\n\r\n\t\tthis.x = Math.floor( this.x );\r\n\t\tthis.y = Math.floor( this.y );\r\n\t\tthis.z = Math.floor( this.z );\r\n\t\tthis.w = Math.floor( this.w );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tceil: function () {\r\n\r\n\t\tthis.x = Math.ceil( this.x );\r\n\t\tthis.y = Math.ceil( this.y );\r\n\t\tthis.z = Math.ceil( this.z );\r\n\t\tthis.w = Math.ceil( this.w );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tround: function () {\r\n\r\n\t\tthis.x = Math.round( this.x );\r\n\t\tthis.y = Math.round( this.y );\r\n\t\tthis.z = Math.round( this.z );\r\n\t\tthis.w = Math.round( this.w );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\troundToZero: function () {\r\n\r\n\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\r\n\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\r\n\t\tthis.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\r\n\t\tthis.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tnegate: function () {\r\n\r\n\t\tthis.x = - this.x;\r\n\t\tthis.y = - this.y;\r\n\t\tthis.z = - this.z;\r\n\t\tthis.w = - this.w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdot: function ( v ) {\r\n\r\n\t\treturn this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\r\n\r\n\t},\r\n\r\n\tlengthSq: function () {\r\n\r\n\t\treturn this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\r\n\r\n\t},\r\n\r\n\tlength: function () {\r\n\r\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );\r\n\r\n\t},\r\n\r\n\tlengthManhattan: function () {\r\n\r\n\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );\r\n\r\n\t},\r\n\r\n\tnormalize: function () {\r\n\r\n\t\treturn this.divideScalar( this.length() );\r\n\r\n\t},\r\n\r\n\tsetLength: function ( length ) {\r\n\r\n\t\treturn this.multiplyScalar( length / this.length() );\r\n\r\n\t},\r\n\r\n\tlerp: function ( v, alpha ) {\r\n\r\n\t\tthis.x += ( v.x - this.x ) * alpha;\r\n\t\tthis.y += ( v.y - this.y ) * alpha;\r\n\t\tthis.z += ( v.z - this.z ) * alpha;\r\n\t\tthis.w += ( v.w - this.w ) * alpha;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tlerpVectors: function ( v1, v2, alpha ) {\r\n\r\n\t\tthis.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( v ) {\r\n\r\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );\r\n\r\n\t},\r\n\r\n\tfromArray: function ( array, offset ) {\r\n\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tthis.x = array[ offset ];\r\n\t\tthis.y = array[ offset + 1 ];\r\n\t\tthis.z = array[ offset + 2 ];\r\n\t\tthis.w = array[ offset + 3 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoArray: function ( array, offset ) {\r\n\r\n\t\tif ( array === undefined ) array = [];\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tarray[ offset ] = this.x;\r\n\t\tarray[ offset + 1 ] = this.y;\r\n\t\tarray[ offset + 2 ] = this.z;\r\n\t\tarray[ offset + 3 ] = this.w;\r\n\r\n\t\treturn array;\r\n\r\n\t},\r\n\r\n\tfromAttribute: function ( attribute, index, offset ) {\r\n\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tindex = index * attribute.itemSize + offset;\r\n\r\n\t\tthis.x = attribute.array[ index ];\r\n\t\tthis.y = attribute.array[ index + 1 ];\r\n\t\tthis.z = attribute.array[ index + 2 ];\r\n\t\tthis.w = attribute.array[ index + 3 ];\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/math/Euler.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n * @author bhouston / http://clara.io\r\n */\r\n\r\nTHREE.Euler = function ( x, y, z, order ) {\r\n\r\n\tthis._x = x || 0;\r\n\tthis._y = y || 0;\r\n\tthis._z = z || 0;\r\n\tthis._order = order || THREE.Euler.DefaultOrder;\r\n\r\n};\r\n\r\nTHREE.Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];\r\n\r\nTHREE.Euler.DefaultOrder = 'XYZ';\r\n\r\nTHREE.Euler.prototype = {\r\n\r\n\tconstructor: THREE.Euler,\r\n\r\n\tget x () {\r\n\r\n\t\treturn this._x;\r\n\r\n\t},\r\n\r\n\tset x ( value ) {\r\n\r\n\t\tthis._x = value;\r\n\t\tthis.onChangeCallback();\r\n\r\n\t},\r\n\r\n\tget y () {\r\n\r\n\t\treturn this._y;\r\n\r\n\t},\r\n\r\n\tset y ( value ) {\r\n\r\n\t\tthis._y = value;\r\n\t\tthis.onChangeCallback();\r\n\r\n\t},\r\n\r\n\tget z () {\r\n\r\n\t\treturn this._z;\r\n\r\n\t},\r\n\r\n\tset z ( value ) {\r\n\r\n\t\tthis._z = value;\r\n\t\tthis.onChangeCallback();\r\n\r\n\t},\r\n\r\n\tget order () {\r\n\r\n\t\treturn this._order;\r\n\r\n\t},\r\n\r\n\tset order ( value ) {\r\n\r\n\t\tthis._order = value;\r\n\t\tthis.onChangeCallback();\r\n\r\n\t},\r\n\r\n\tset: function ( x, y, z, order ) {\r\n\r\n\t\tthis._x = x;\r\n\t\tthis._y = y;\r\n\t\tthis._z = z;\r\n\t\tthis._order = order || this._order;\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor( this._x, this._y, this._z, this._order );\r\n\r\n\t},\r\n\r\n\tcopy: function ( euler ) {\r\n\r\n\t\tthis._x = euler._x;\r\n\t\tthis._y = euler._y;\r\n\t\tthis._z = euler._z;\r\n\t\tthis._order = euler._order;\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromRotationMatrix: function ( m, order, update ) {\r\n\r\n\t\tvar clamp = THREE.Math.clamp;\r\n\r\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\r\n\r\n\t\tvar te = m.elements;\r\n\t\tvar m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];\r\n\t\tvar m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];\r\n\t\tvar m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\r\n\r\n\t\torder = order || this._order;\r\n\r\n\t\tif ( order === 'XYZ' ) {\r\n\r\n\t\t\tthis._y = Math.asin( clamp( m13, - 1, 1 ) );\r\n\r\n\t\t\tif ( Math.abs( m13 ) < 0.99999 ) {\r\n\r\n\t\t\t\tthis._x = Math.atan2( - m23, m33 );\r\n\t\t\t\tthis._z = Math.atan2( - m12, m11 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis._x = Math.atan2( m32, m22 );\r\n\t\t\t\tthis._z = 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( order === 'YXZ' ) {\r\n\r\n\t\t\tthis._x = Math.asin( - clamp( m23, - 1, 1 ) );\r\n\r\n\t\t\tif ( Math.abs( m23 ) < 0.99999 ) {\r\n\r\n\t\t\t\tthis._y = Math.atan2( m13, m33 );\r\n\t\t\t\tthis._z = Math.atan2( m21, m22 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis._y = Math.atan2( - m31, m11 );\r\n\t\t\t\tthis._z = 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( order === 'ZXY' ) {\r\n\r\n\t\t\tthis._x = Math.asin( clamp( m32, - 1, 1 ) );\r\n\r\n\t\t\tif ( Math.abs( m32 ) < 0.99999 ) {\r\n\r\n\t\t\t\tthis._y = Math.atan2( - m31, m33 );\r\n\t\t\t\tthis._z = Math.atan2( - m12, m22 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis._y = 0;\r\n\t\t\t\tthis._z = Math.atan2( m21, m11 );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( order === 'ZYX' ) {\r\n\r\n\t\t\tthis._y = Math.asin( - clamp( m31, - 1, 1 ) );\r\n\r\n\t\t\tif ( Math.abs( m31 ) < 0.99999 ) {\r\n\r\n\t\t\t\tthis._x = Math.atan2( m32, m33 );\r\n\t\t\t\tthis._z = Math.atan2( m21, m11 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis._x = 0;\r\n\t\t\t\tthis._z = Math.atan2( - m12, m22 );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( order === 'YZX' ) {\r\n\r\n\t\t\tthis._z = Math.asin( clamp( m21, - 1, 1 ) );\r\n\r\n\t\t\tif ( Math.abs( m21 ) < 0.99999 ) {\r\n\r\n\t\t\t\tthis._x = Math.atan2( - m23, m22 );\r\n\t\t\t\tthis._y = Math.atan2( - m31, m11 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis._x = 0;\r\n\t\t\t\tthis._y = Math.atan2( m13, m33 );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( order === 'XZY' ) {\r\n\r\n\t\t\tthis._z = Math.asin( - clamp( m12, - 1, 1 ) );\r\n\r\n\t\t\tif ( Math.abs( m12 ) < 0.99999 ) {\r\n\r\n\t\t\t\tthis._x = Math.atan2( m32, m22 );\r\n\t\t\t\tthis._y = Math.atan2( m13, m11 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis._x = Math.atan2( - m23, m33 );\r\n\t\t\t\tthis._y = 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconsole.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order );\r\n\r\n\t\t}\r\n\r\n\t\tthis._order = order;\r\n\r\n\t\tif ( update !== false ) this.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromQuaternion: function () {\r\n\r\n\t\tvar matrix;\r\n\r\n\t\treturn function ( q, order, update ) {\r\n\r\n\t\t\tif ( matrix === undefined ) matrix = new THREE.Matrix4();\r\n\t\t\tmatrix.makeRotationFromQuaternion( q );\r\n\t\t\tthis.setFromRotationMatrix( matrix, order, update );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tsetFromVector3: function ( v, order ) {\r\n\r\n\t\treturn this.set( v.x, v.y, v.z, order || this._order );\r\n\r\n\t},\r\n\r\n\treorder: function () {\r\n\r\n\t\t// WARNING: this discards revolution information -bhouston\r\n\r\n\t\tvar q = new THREE.Quaternion();\r\n\r\n\t\treturn function ( newOrder ) {\r\n\r\n\t\t\tq.setFromEuler( this );\r\n\t\t\tthis.setFromQuaternion( q, newOrder );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tequals: function ( euler ) {\r\n\r\n\t\treturn ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );\r\n\r\n\t},\r\n\r\n\tfromArray: function ( array ) {\r\n\r\n\t\tthis._x = array[ 0 ];\r\n\t\tthis._y = array[ 1 ];\r\n\t\tthis._z = array[ 2 ];\r\n\t\tif ( array[ 3 ] !== undefined ) this._order = array[ 3 ];\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoArray: function ( array, offset ) {\r\n\r\n\t\tif ( array === undefined ) array = [];\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tarray[ offset ] = this._x;\r\n\t\tarray[ offset + 1 ] = this._y;\r\n\t\tarray[ offset + 2 ] = this._z;\r\n\t\tarray[ offset + 3 ] = this._order;\r\n\r\n\t\treturn array;\r\n\r\n\t},\r\n\r\n\ttoVector3: function ( optionalResult ) {\r\n\r\n\t\tif ( optionalResult ) {\r\n\r\n\t\t\treturn optionalResult.set( this._x, this._y, this._z );\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn new THREE.Vector3( this._x, this._y, this._z );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tonChange: function ( callback ) {\r\n\r\n\t\tthis.onChangeCallback = callback;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tonChangeCallback: function () {}\r\n\r\n};\r\n\r\n// File:src/math/Line3.js\r\n\r\n/**\r\n * @author bhouston / http://clara.io\r\n */\r\n\r\nTHREE.Line3 = function ( start, end ) {\r\n\r\n\tthis.start = ( start !== undefined ) ? start : new THREE.Vector3();\r\n\tthis.end = ( end !== undefined ) ? end : new THREE.Vector3();\r\n\r\n};\r\n\r\nTHREE.Line3.prototype = {\r\n\r\n\tconstructor: THREE.Line3,\r\n\r\n\tset: function ( start, end ) {\r\n\r\n\t\tthis.start.copy( start );\r\n\t\tthis.end.copy( end );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\r\n\t},\r\n\r\n\tcopy: function ( line ) {\r\n\r\n\t\tthis.start.copy( line.start );\r\n\t\tthis.end.copy( line.end );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcenter: function ( optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\treturn result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );\r\n\r\n\t},\r\n\r\n\tdelta: function ( optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\treturn result.subVectors( this.end, this.start );\r\n\r\n\t},\r\n\r\n\tdistanceSq: function () {\r\n\r\n\t\treturn this.start.distanceToSquared( this.end );\r\n\r\n\t},\r\n\r\n\tdistance: function () {\r\n\r\n\t\treturn this.start.distanceTo( this.end );\r\n\r\n\t},\r\n\r\n\tat: function ( t, optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\r\n\t\treturn this.delta( result ).multiplyScalar( t ).add( this.start );\r\n\r\n\t},\r\n\r\n\tclosestPointToPointParameter: function () {\r\n\r\n\t\tvar startP = new THREE.Vector3();\r\n\t\tvar startEnd = new THREE.Vector3();\r\n\r\n\t\treturn function ( point, clampToLine ) {\r\n\r\n\t\t\tstartP.subVectors( point, this.start );\r\n\t\t\tstartEnd.subVectors( this.end, this.start );\r\n\r\n\t\t\tvar startEnd2 = startEnd.dot( startEnd );\r\n\t\t\tvar startEnd_startP = startEnd.dot( startP );\r\n\r\n\t\t\tvar t = startEnd_startP / startEnd2;\r\n\r\n\t\t\tif ( clampToLine ) {\r\n\r\n\t\t\t\tt = THREE.Math.clamp( t, 0, 1 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn t;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tclosestPointToPoint: function ( point, clampToLine, optionalTarget ) {\r\n\r\n\t\tvar t = this.closestPointToPointParameter( point, clampToLine );\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\r\n\t\treturn this.delta( result ).multiplyScalar( t ).add( this.start );\r\n\r\n\t},\r\n\r\n\tapplyMatrix4: function ( matrix ) {\r\n\r\n\t\tthis.start.applyMatrix4( matrix );\r\n\t\tthis.end.applyMatrix4( matrix );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( line ) {\r\n\r\n\t\treturn line.start.equals( this.start ) && line.end.equals( this.end );\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/math/Box2.js\r\n\r\n/**\r\n * @author bhouston / http://clara.io\r\n */\r\n\r\nTHREE.Box2 = function ( min, max ) {\r\n\r\n\tthis.min = ( min !== undefined ) ? min : new THREE.Vector2( + Infinity, + Infinity );\r\n\tthis.max = ( max !== undefined ) ? max : new THREE.Vector2( - Infinity, - Infinity );\r\n\r\n};\r\n\r\nTHREE.Box2.prototype = {\r\n\r\n\tconstructor: THREE.Box2,\r\n\r\n\tset: function ( min, max ) {\r\n\r\n\t\tthis.min.copy( min );\r\n\t\tthis.max.copy( max );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromPoints: function ( points ) {\r\n\r\n\t\tthis.makeEmpty();\r\n\r\n\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\r\n\r\n\t\t\tthis.expandByPoint( points[ i ] );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromCenterAndSize: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector2();\r\n\r\n\t\treturn function ( center, size ) {\r\n\r\n\t\t\tvar halfSize = v1.copy( size ).multiplyScalar( 0.5 );\r\n\t\t\tthis.min.copy( center ).sub( halfSize );\r\n\t\t\tthis.max.copy( center ).add( halfSize );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\r\n\t},\r\n\r\n\tcopy: function ( box ) {\r\n\r\n\t\tthis.min.copy( box.min );\r\n\t\tthis.max.copy( box.max );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakeEmpty: function () {\r\n\r\n\t\tthis.min.x = this.min.y = + Infinity;\r\n\t\tthis.max.x = this.max.y = - Infinity;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tisEmpty: function () {\r\n\r\n\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\r\n\r\n\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );\r\n\r\n\t},\r\n\r\n\tcenter: function ( optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector2();\r\n\t\treturn result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\r\n\r\n\t},\r\n\r\n\tsize: function ( optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector2();\r\n\t\treturn result.subVectors( this.max, this.min );\r\n\r\n\t},\r\n\r\n\texpandByPoint: function ( point ) {\r\n\r\n\t\tthis.min.min( point );\r\n\t\tthis.max.max( point );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\texpandByVector: function ( vector ) {\r\n\r\n\t\tthis.min.sub( vector );\r\n\t\tthis.max.add( vector );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\texpandByScalar: function ( scalar ) {\r\n\r\n\t\tthis.min.addScalar( - scalar );\r\n\t\tthis.max.addScalar( scalar );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcontainsPoint: function ( point ) {\r\n\r\n\t\tif ( point.x < this.min.x || point.x > this.max.x ||\r\n\t\t     point.y < this.min.y || point.y > this.max.y ) {\r\n\r\n\t\t\treturn false;\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t},\r\n\r\n\tcontainsBox: function ( box ) {\r\n\r\n\t\tif ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&\r\n\t\t     ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) ) {\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\r\n\t},\r\n\r\n\tgetParameter: function ( point, optionalTarget ) {\r\n\r\n\t\t// This can potentially have a divide by zero if the box\r\n\t\t// has a size dimension of 0.\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector2();\r\n\r\n\t\treturn result.set(\r\n\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\r\n\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y )\r\n\t\t);\r\n\r\n\t},\r\n\r\n\tintersectsBox: function ( box ) {\r\n\r\n\t\t// using 6 splitting planes to rule out intersections.\r\n\r\n\t\tif ( box.max.x < this.min.x || box.min.x > this.max.x ||\r\n\t\t     box.max.y < this.min.y || box.min.y > this.max.y ) {\r\n\r\n\t\t\treturn false;\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t},\r\n\r\n\tclampPoint: function ( point, optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector2();\r\n\t\treturn result.copy( point ).clamp( this.min, this.max );\r\n\r\n\t},\r\n\r\n\tdistanceToPoint: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector2();\r\n\r\n\t\treturn function ( point ) {\r\n\r\n\t\t\tvar clampedPoint = v1.copy( point ).clamp( this.min, this.max );\r\n\t\t\treturn clampedPoint.sub( point ).length();\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tintersect: function ( box ) {\r\n\r\n\t\tthis.min.max( box.min );\r\n\t\tthis.max.min( box.max );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tunion: function ( box ) {\r\n\r\n\t\tthis.min.min( box.min );\r\n\t\tthis.max.max( box.max );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttranslate: function ( offset ) {\r\n\r\n\t\tthis.min.add( offset );\r\n\t\tthis.max.add( offset );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( box ) {\r\n\r\n\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/math/Box3.js\r\n\r\n/**\r\n * @author bhouston / http://clara.io\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\n\r\nTHREE.Box3 = function ( min, max ) {\r\n\r\n\tthis.min = ( min !== undefined ) ? min : new THREE.Vector3( + Infinity, + Infinity, + Infinity );\r\n\tthis.max = ( max !== undefined ) ? max : new THREE.Vector3( - Infinity, - Infinity, - Infinity );\r\n\r\n};\r\n\r\nTHREE.Box3.prototype = {\r\n\r\n\tconstructor: THREE.Box3,\r\n\r\n\tset: function ( min, max ) {\r\n\r\n\t\tthis.min.copy( min );\r\n\t\tthis.max.copy( max );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromArray: function ( array ) {\r\n\r\n\t\tvar minX = + Infinity;\r\n\t\tvar minY = + Infinity;\r\n\t\tvar minZ = + Infinity;\r\n\r\n\t\tvar maxX = - Infinity;\r\n\t\tvar maxY = - Infinity;\r\n\t\tvar maxZ = - Infinity;\r\n\r\n\t\tfor ( var i = 0, l = array.length; i < l; i += 3 ) {\r\n\r\n\t\t\tvar x = array[ i ];\r\n\t\t\tvar y = array[ i + 1 ];\r\n\t\t\tvar z = array[ i + 2 ];\r\n\r\n\t\t\tif ( x < minX ) minX = x;\r\n\t\t\tif ( y < minY ) minY = y;\r\n\t\t\tif ( z < minZ ) minZ = z;\r\n\r\n\t\t\tif ( x > maxX ) maxX = x;\r\n\t\t\tif ( y > maxY ) maxY = y;\r\n\t\t\tif ( z > maxZ ) maxZ = z;\r\n\r\n\t\t}\r\n\r\n\t\tthis.min.set( minX, minY, minZ );\r\n\t\tthis.max.set( maxX, maxY, maxZ );\r\n\r\n\t},\r\n\r\n\tsetFromPoints: function ( points ) {\r\n\r\n\t\tthis.makeEmpty();\r\n\r\n\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\r\n\r\n\t\t\tthis.expandByPoint( points[ i ] );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromCenterAndSize: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function ( center, size ) {\r\n\r\n\t\t\tvar halfSize = v1.copy( size ).multiplyScalar( 0.5 );\r\n\r\n\t\t\tthis.min.copy( center ).sub( halfSize );\r\n\t\t\tthis.max.copy( center ).add( halfSize );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tsetFromObject: function () {\r\n\r\n\t\t// Computes the world-axis-aligned bounding box of an object (including its children),\r\n\t\t// accounting for both the object's, and children's, world transforms\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function ( object ) {\r\n\r\n\t\t\tvar scope = this;\r\n\r\n\t\t\tobject.updateMatrixWorld( true );\r\n\r\n\t\t\tthis.makeEmpty();\r\n\r\n\t\t\tobject.traverse( function ( node ) {\r\n\r\n\t\t\t\tvar geometry = node.geometry;\r\n\r\n\t\t\t\tif ( geometry !== undefined ) {\r\n\r\n\t\t\t\t\tif ( geometry instanceof THREE.Geometry ) {\r\n\r\n\t\t\t\t\t\tvar vertices = geometry.vertices;\r\n\r\n\t\t\t\t\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\t\t\tv1.copy( vertices[ i ] );\r\n\t\t\t\t\t\t\tv1.applyMatrix4( node.matrixWorld );\r\n\r\n\t\t\t\t\t\t\tscope.expandByPoint( v1 );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( geometry instanceof THREE.BufferGeometry && geometry.attributes[ 'position' ] !== undefined ) {\r\n\r\n\t\t\t\t\t\tvar positions = geometry.attributes[ 'position' ].array;\r\n\r\n\t\t\t\t\t\tfor ( var i = 0, il = positions.length; i < il; i += 3 ) {\r\n\r\n\t\t\t\t\t\t\tv1.fromArray( positions, i );\r\n\t\t\t\t\t\t\tv1.applyMatrix4( node.matrixWorld );\r\n\r\n\t\t\t\t\t\t\tscope.expandByPoint( v1 );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\r\n\t},\r\n\r\n\tcopy: function ( box ) {\r\n\r\n\t\tthis.min.copy( box.min );\r\n\t\tthis.max.copy( box.max );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakeEmpty: function () {\r\n\r\n\t\tthis.min.x = this.min.y = this.min.z = + Infinity;\r\n\t\tthis.max.x = this.max.y = this.max.z = - Infinity;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tisEmpty: function () {\r\n\r\n\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\r\n\r\n\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );\r\n\r\n\t},\r\n\r\n\tcenter: function ( optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\treturn result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\r\n\r\n\t},\r\n\r\n\tsize: function ( optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\treturn result.subVectors( this.max, this.min );\r\n\r\n\t},\r\n\r\n\texpandByPoint: function ( point ) {\r\n\r\n\t\tthis.min.min( point );\r\n\t\tthis.max.max( point );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\texpandByVector: function ( vector ) {\r\n\r\n\t\tthis.min.sub( vector );\r\n\t\tthis.max.add( vector );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\texpandByScalar: function ( scalar ) {\r\n\r\n\t\tthis.min.addScalar( - scalar );\r\n\t\tthis.max.addScalar( scalar );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcontainsPoint: function ( point ) {\r\n\r\n\t\tif ( point.x < this.min.x || point.x > this.max.x ||\r\n\t\t\t\t point.y < this.min.y || point.y > this.max.y ||\r\n\t\t\t\t point.z < this.min.z || point.z > this.max.z ) {\r\n\r\n\t\t\treturn false;\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t},\r\n\r\n\tcontainsBox: function ( box ) {\r\n\r\n\t\tif ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&\r\n\t\t\t ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) &&\r\n\t\t\t ( this.min.z <= box.min.z ) && ( box.max.z <= this.max.z ) ) {\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\r\n\t},\r\n\r\n\tgetParameter: function ( point, optionalTarget ) {\r\n\r\n\t\t// This can potentially have a divide by zero if the box\r\n\t\t// has a size dimension of 0.\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\r\n\t\treturn result.set(\r\n\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\r\n\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y ),\r\n\t\t\t( point.z - this.min.z ) / ( this.max.z - this.min.z )\r\n\t\t);\r\n\r\n\t},\r\n\r\n\tintersectsBox: function ( box ) {\r\n\r\n\t\t// using 6 splitting planes to rule out intersections.\r\n\r\n\t\tif ( box.max.x < this.min.x || box.min.x > this.max.x ||\r\n\t\t\t\t box.max.y < this.min.y || box.min.y > this.max.y ||\r\n\t\t\t\t box.max.z < this.min.z || box.min.z > this.max.z ) {\r\n\r\n\t\t\treturn false;\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t},\r\n\r\n\tintersectsSphere: ( function () {\r\n\r\n\t\tvar closestPoint;\r\n\r\n\t\treturn function intersectsSphere( sphere ) {\r\n\r\n\t\t\tif ( closestPoint === undefined ) closestPoint = new THREE.Vector3();\r\n\r\n\t\t\t// Find the point on the AABB closest to the sphere center.\r\n\t\t\tthis.clampPoint( sphere.center, closestPoint );\r\n\r\n\t\t\t// If that point is inside the sphere, the AABB and sphere intersect.\r\n\t\t\treturn closestPoint.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );\r\n\r\n\t\t};\r\n\r\n\t} )(),\r\n\r\n\tintersectsPlane: function ( plane ) {\r\n\r\n\t\t// We compute the minimum and maximum dot product values. If those values\r\n\t\t// are on the same side (back or front) of the plane, then there is no intersection.\r\n\r\n\t\tvar min, max;\r\n\r\n\t\tif ( plane.normal.x > 0 ) {\r\n\r\n\t\t\tmin = plane.normal.x * this.min.x;\r\n\t\t\tmax = plane.normal.x * this.max.x;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tmin = plane.normal.x * this.max.x;\r\n\t\t\tmax = plane.normal.x * this.min.x;\r\n\r\n\t\t}\r\n\r\n\t\tif ( plane.normal.y > 0 ) {\r\n\r\n\t\t\tmin += plane.normal.y * this.min.y;\r\n\t\t\tmax += plane.normal.y * this.max.y;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tmin += plane.normal.y * this.max.y;\r\n\t\t\tmax += plane.normal.y * this.min.y;\r\n\r\n\t\t}\r\n\r\n\t\tif ( plane.normal.z > 0 ) {\r\n\r\n\t\t\tmin += plane.normal.z * this.min.z;\r\n\t\t\tmax += plane.normal.z * this.max.z;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tmin += plane.normal.z * this.max.z;\r\n\t\t\tmax += plane.normal.z * this.min.z;\r\n\r\n\t\t}\r\n\r\n\t\treturn ( min <= plane.constant && max >= plane.constant );\r\n\r\n\t},\r\n\r\n\tclampPoint: function ( point, optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\treturn result.copy( point ).clamp( this.min, this.max );\r\n\r\n\t},\r\n\r\n\tdistanceToPoint: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function ( point ) {\r\n\r\n\t\t\tvar clampedPoint = v1.copy( point ).clamp( this.min, this.max );\r\n\t\t\treturn clampedPoint.sub( point ).length();\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tgetBoundingSphere: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function ( optionalTarget ) {\r\n\r\n\t\t\tvar result = optionalTarget || new THREE.Sphere();\r\n\r\n\t\t\tresult.center = this.center();\r\n\t\t\tresult.radius = this.size( v1 ).length() * 0.5;\r\n\r\n\t\t\treturn result;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tintersect: function ( box ) {\r\n\r\n\t\tthis.min.max( box.min );\r\n\t\tthis.max.min( box.max );\r\n\r\n\t\t// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.\r\n\t\tif( this.isEmpty() ) this.makeEmpty();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tunion: function ( box ) {\r\n\r\n\t\tthis.min.min( box.min );\r\n\t\tthis.max.max( box.max );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tapplyMatrix4: function () {\r\n\r\n\t\tvar points = [\r\n\t\t\tnew THREE.Vector3(),\r\n\t\t\tnew THREE.Vector3(),\r\n\t\t\tnew THREE.Vector3(),\r\n\t\t\tnew THREE.Vector3(),\r\n\t\t\tnew THREE.Vector3(),\r\n\t\t\tnew THREE.Vector3(),\r\n\t\t\tnew THREE.Vector3(),\r\n\t\t\tnew THREE.Vector3()\r\n\t\t];\r\n\r\n\t\treturn function ( matrix ) {\r\n\r\n\t\t\t// transform of empty box is an empty box.\r\n\t\t\tif( this.isEmpty() ) return this;\r\n\r\n\t\t\t// NOTE: I am using a binary pattern to specify all 2^3 combinations below\r\n\t\t\tpoints[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000\r\n\t\t\tpoints[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001\r\n\t\t\tpoints[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010\r\n\t\t\tpoints[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011\r\n\t\t\tpoints[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100\r\n\t\t\tpoints[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101\r\n\t\t\tpoints[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110\r\n\t\t\tpoints[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );\t// 111\r\n\r\n\t\t\tthis.setFromPoints( points );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\ttranslate: function ( offset ) {\r\n\r\n\t\tthis.min.add( offset );\r\n\t\tthis.max.add( offset );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( box ) {\r\n\r\n\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/math/Matrix3.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n * @author bhouston / http://clara.io\r\n * @author tschw\r\n */\r\n\r\nTHREE.Matrix3 = function () {\r\n\r\n\tthis.elements = new Float32Array( [\r\n\r\n\t\t1, 0, 0,\r\n\t\t0, 1, 0,\r\n\t\t0, 0, 1\r\n\r\n\t] );\r\n\r\n\tif ( arguments.length > 0 ) {\r\n\r\n\t\tconsole.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.Matrix3.prototype = {\r\n\r\n\tconstructor: THREE.Matrix3,\r\n\r\n\tset: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tte[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;\r\n\t\tte[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;\r\n\t\tte[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tidentity: function () {\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\t1, 0, 0,\r\n\t\t\t0, 1, 0,\r\n\t\t\t0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor().fromArray( this.elements );\r\n\r\n\t},\r\n\r\n\tcopy: function ( m ) {\r\n\r\n\t\tvar me = m.elements;\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\tme[ 0 ], me[ 3 ], me[ 6 ],\r\n\t\t\tme[ 1 ], me[ 4 ], me[ 7 ],\r\n\t\t\tme[ 2 ], me[ 5 ], me[ 8 ]\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromMatrix4: function( m ) {\r\n\r\n\t\tvar me = m.elements;\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\tme[ 0 ], me[ 4 ], me[  8 ],\r\n\t\t\tme[ 1 ], me[ 5 ], me[  9 ],\r\n\t\t\tme[ 2 ], me[ 6 ], me[ 10 ]\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tapplyToVector3Array: function () {\r\n\r\n\t\tvar v1;\r\n\r\n\t\treturn function ( array, offset, length ) {\r\n\r\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\t\tif ( length === undefined ) length = array.length;\r\n\r\n\t\t\tfor ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {\r\n\r\n\t\t\t\tv1.fromArray( array, j );\r\n\t\t\t\tv1.applyMatrix3( this );\r\n\t\t\t\tv1.toArray( array, j );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn array;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tapplyToBuffer: function () {\r\n\r\n\t\tvar v1;\r\n\r\n\t\treturn function applyToBuffer( buffer, offset, length ) {\r\n\r\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\t\tif ( length === undefined ) length = buffer.length / buffer.itemSize;\r\n\r\n\t\t\tfor ( var i = 0, j = offset; i < length; i ++, j ++ ) {\r\n\r\n\t\t\t\tv1.x = buffer.getX( j );\r\n\t\t\t\tv1.y = buffer.getY( j );\r\n\t\t\t\tv1.z = buffer.getZ( j );\r\n\r\n\t\t\t\tv1.applyMatrix3( this );\r\n\r\n\t\t\t\tbuffer.setXYZ( v1.x, v1.y, v1.z );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn buffer;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tmultiplyScalar: function ( s ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tte[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;\r\n\t\tte[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;\r\n\t\tte[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdeterminant: function () {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tvar a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],\r\n\t\t\td = te[ 3 ], e = te[ 4 ], f = te[ 5 ],\r\n\t\t\tg = te[ 6 ], h = te[ 7 ], i = te[ 8 ];\r\n\r\n\t\treturn a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;\r\n\r\n\t},\r\n\r\n\tgetInverse: function ( matrix, throwOnDegenerate ) {\r\n\r\n\t\tif ( matrix instanceof THREE.Matrix4 ) {\r\n\r\n\t\t\tconsole.error( \"THREE.Matrix3.getInverse no longer takes a Matrix4 argument.\" );\r\n\r\n\t\t}\r\n\r\n\t\tvar me = matrix.elements,\r\n\t\t\tte = this.elements,\r\n\r\n\t\t\tn11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ],\r\n\t\t\tn12 = me[ 3 ], n22 = me[ 4 ], n32 = me[ 5 ],\r\n\t\t\tn13 = me[ 6 ], n23 = me[ 7 ], n33 = me[ 8 ],\r\n\r\n\t\t\tt11 = n33 * n22 - n32 * n23,\r\n\t\t\tt12 = n32 * n13 - n33 * n12,\r\n\t\t\tt13 = n23 * n12 - n22 * n13,\r\n\r\n\t\t\tdet = n11 * t11 + n21 * t12 + n31 * t13;\r\n\r\n\t\tif ( det === 0 ) {\r\n\r\n\t\t\tvar msg = \"THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0\";\r\n\r\n\t\t\tif ( throwOnDegenerate || false ) {\r\n\r\n\t\t\t\tthrow new Error( msg );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tconsole.warn( msg );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this.identity();\r\n\t\t}\r\n\r\n\t\tte[ 0 ] = t11;\r\n\t\tte[ 1 ] = n31 * n23 - n33 * n21;\r\n\t\tte[ 2 ] = n32 * n21 - n31 * n22;\r\n\r\n\t\tte[ 3 ] = t12;\r\n\t\tte[ 4 ] = n33 * n11 - n31 * n13;\r\n\t\tte[ 5 ] = n31 * n12 - n32 * n11;\r\n\r\n\t\tte[ 6 ] = t13;\r\n\t\tte[ 7 ] = n21 * n13 - n23 * n11;\r\n\t\tte[ 8 ] = n22 * n11 - n21 * n12;\r\n\r\n\t\treturn this.multiplyScalar( 1 / det );\r\n\r\n\t},\r\n\r\n\ttranspose: function () {\r\n\r\n\t\tvar tmp, m = this.elements;\r\n\r\n\t\ttmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;\r\n\t\ttmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;\r\n\t\ttmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tflattenToArrayOffset: function ( array, offset ) {\r\n\r\n\t\tconsole.warn( \"THREE.Matrix3: .flattenToArrayOffset is deprecated \" +\r\n\t\t\t\t\"- just use .toArray instead.\" );\r\n\r\n\t\treturn this.toArray( array, offset );\r\n\r\n\t},\r\n\r\n\tgetNormalMatrix: function ( matrix4 ) {\r\n\r\n\t\treturn this.setFromMatrix4( matrix4 ).getInverse( this ).transpose();\r\n\r\n\t},\r\n\r\n\ttransposeIntoArray: function ( r ) {\r\n\r\n\t\tvar m = this.elements;\r\n\r\n\t\tr[ 0 ] = m[ 0 ];\r\n\t\tr[ 1 ] = m[ 3 ];\r\n\t\tr[ 2 ] = m[ 6 ];\r\n\t\tr[ 3 ] = m[ 1 ];\r\n\t\tr[ 4 ] = m[ 4 ];\r\n\t\tr[ 5 ] = m[ 7 ];\r\n\t\tr[ 6 ] = m[ 2 ];\r\n\t\tr[ 7 ] = m[ 5 ];\r\n\t\tr[ 8 ] = m[ 8 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tfromArray: function ( array ) {\r\n\r\n\t\tthis.elements.set( array );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoArray: function ( array, offset ) {\r\n\r\n\t\tif ( array === undefined ) array = [];\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tarray[ offset ] = te[ 0 ];\r\n\t\tarray[ offset + 1 ] = te[ 1 ];\r\n\t\tarray[ offset + 2 ] = te[ 2 ];\r\n\r\n\t\tarray[ offset + 3 ] = te[ 3 ];\r\n\t\tarray[ offset + 4 ] = te[ 4 ];\r\n\t\tarray[ offset + 5 ] = te[ 5 ];\r\n\r\n\t\tarray[ offset + 6 ] = te[ 6 ];\r\n\t\tarray[ offset + 7 ] = te[ 7 ];\r\n\t\tarray[ offset + 8 ]  = te[ 8 ];\r\n\r\n\t\treturn array;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/math/Matrix4.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author supereggbert / http://www.paulbrunt.co.uk/\r\n * @author philogb / http://blog.thejit.org/\r\n * @author jordi_ros / http://plattsoft.com\r\n * @author D1plo1d / http://github.com/D1plo1d\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author timknip / http://www.floorplanner.com/\r\n * @author bhouston / http://clara.io\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\n\r\nTHREE.Matrix4 = function () {\r\n\r\n\tthis.elements = new Float32Array( [\r\n\r\n\t\t1, 0, 0, 0,\r\n\t\t0, 1, 0, 0,\r\n\t\t0, 0, 1, 0,\r\n\t\t0, 0, 0, 1\r\n\r\n\t] );\r\n\r\n\tif ( arguments.length > 0 ) {\r\n\r\n\t\tconsole.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.Matrix4.prototype = {\r\n\r\n\tconstructor: THREE.Matrix4,\r\n\r\n\tset: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tte[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;\r\n\t\tte[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;\r\n\t\tte[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;\r\n\t\tte[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tidentity: function () {\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\t1, 0, 0, 0,\r\n\t\t\t0, 1, 0, 0,\r\n\t\t\t0, 0, 1, 0,\r\n\t\t\t0, 0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new THREE.Matrix4().fromArray( this.elements );\r\n\r\n\t},\r\n\r\n\tcopy: function ( m ) {\r\n\r\n\t\tthis.elements.set( m.elements );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopyPosition: function ( m ) {\r\n\r\n\t\tvar te = this.elements;\r\n\t\tvar me = m.elements;\r\n\r\n\t\tte[ 12 ] = me[ 12 ];\r\n\t\tte[ 13 ] = me[ 13 ];\r\n\t\tte[ 14 ] = me[ 14 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\textractBasis: function ( xAxis, yAxis, zAxis ) {\r\n\r\n\t\txAxis.setFromMatrixColumn( this, 0 );\r\n\t\tyAxis.setFromMatrixColumn( this, 1 );\r\n\t\tzAxis.setFromMatrixColumn( this, 2 );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakeBasis: function ( xAxis, yAxis, zAxis ) {\r\n\r\n\t\tthis.set(\r\n\t\t\txAxis.x, yAxis.x, zAxis.x, 0,\r\n\t\t\txAxis.y, yAxis.y, zAxis.y, 0,\r\n\t\t\txAxis.z, yAxis.z, zAxis.z, 0,\r\n\t\t\t0,       0,       0,       1\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\textractRotation: function () {\r\n\r\n\t\tvar v1;\r\n\r\n\t\treturn function ( m ) {\r\n\r\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\r\n\t\t\tvar te = this.elements;\r\n\t\t\tvar me = m.elements;\r\n\r\n\t\t\tvar scaleX = 1 / v1.setFromMatrixColumn( m, 0 ).length();\r\n\t\t\tvar scaleY = 1 / v1.setFromMatrixColumn( m, 1 ).length();\r\n\t\t\tvar scaleZ = 1 / v1.setFromMatrixColumn( m, 2 ).length();\r\n\r\n\t\t\tte[ 0 ] = me[ 0 ] * scaleX;\r\n\t\t\tte[ 1 ] = me[ 1 ] * scaleX;\r\n\t\t\tte[ 2 ] = me[ 2 ] * scaleX;\r\n\r\n\t\t\tte[ 4 ] = me[ 4 ] * scaleY;\r\n\t\t\tte[ 5 ] = me[ 5 ] * scaleY;\r\n\t\t\tte[ 6 ] = me[ 6 ] * scaleY;\r\n\r\n\t\t\tte[ 8 ] = me[ 8 ] * scaleZ;\r\n\t\t\tte[ 9 ] = me[ 9 ] * scaleZ;\r\n\t\t\tte[ 10 ] = me[ 10 ] * scaleZ;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tmakeRotationFromEuler: function ( euler ) {\r\n\r\n\t\tif ( euler instanceof THREE.Euler === false ) {\r\n\r\n\t\t\tconsole.error( 'THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );\r\n\r\n\t\t}\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tvar x = euler.x, y = euler.y, z = euler.z;\r\n\t\tvar a = Math.cos( x ), b = Math.sin( x );\r\n\t\tvar c = Math.cos( y ), d = Math.sin( y );\r\n\t\tvar e = Math.cos( z ), f = Math.sin( z );\r\n\r\n\t\tif ( euler.order === 'XYZ' ) {\r\n\r\n\t\t\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\r\n\r\n\t\t\tte[ 0 ] = c * e;\r\n\t\t\tte[ 4 ] = - c * f;\r\n\t\t\tte[ 8 ] = d;\r\n\r\n\t\t\tte[ 1 ] = af + be * d;\r\n\t\t\tte[ 5 ] = ae - bf * d;\r\n\t\t\tte[ 9 ] = - b * c;\r\n\r\n\t\t\tte[ 2 ] = bf - ae * d;\r\n\t\t\tte[ 6 ] = be + af * d;\r\n\t\t\tte[ 10 ] = a * c;\r\n\r\n\t\t} else if ( euler.order === 'YXZ' ) {\r\n\r\n\t\t\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\r\n\r\n\t\t\tte[ 0 ] = ce + df * b;\r\n\t\t\tte[ 4 ] = de * b - cf;\r\n\t\t\tte[ 8 ] = a * d;\r\n\r\n\t\t\tte[ 1 ] = a * f;\r\n\t\t\tte[ 5 ] = a * e;\r\n\t\t\tte[ 9 ] = - b;\r\n\r\n\t\t\tte[ 2 ] = cf * b - de;\r\n\t\t\tte[ 6 ] = df + ce * b;\r\n\t\t\tte[ 10 ] = a * c;\r\n\r\n\t\t} else if ( euler.order === 'ZXY' ) {\r\n\r\n\t\t\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\r\n\r\n\t\t\tte[ 0 ] = ce - df * b;\r\n\t\t\tte[ 4 ] = - a * f;\r\n\t\t\tte[ 8 ] = de + cf * b;\r\n\r\n\t\t\tte[ 1 ] = cf + de * b;\r\n\t\t\tte[ 5 ] = a * e;\r\n\t\t\tte[ 9 ] = df - ce * b;\r\n\r\n\t\t\tte[ 2 ] = - a * d;\r\n\t\t\tte[ 6 ] = b;\r\n\t\t\tte[ 10 ] = a * c;\r\n\r\n\t\t} else if ( euler.order === 'ZYX' ) {\r\n\r\n\t\t\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\r\n\r\n\t\t\tte[ 0 ] = c * e;\r\n\t\t\tte[ 4 ] = be * d - af;\r\n\t\t\tte[ 8 ] = ae * d + bf;\r\n\r\n\t\t\tte[ 1 ] = c * f;\r\n\t\t\tte[ 5 ] = bf * d + ae;\r\n\t\t\tte[ 9 ] = af * d - be;\r\n\r\n\t\t\tte[ 2 ] = - d;\r\n\t\t\tte[ 6 ] = b * c;\r\n\t\t\tte[ 10 ] = a * c;\r\n\r\n\t\t} else if ( euler.order === 'YZX' ) {\r\n\r\n\t\t\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\r\n\r\n\t\t\tte[ 0 ] = c * e;\r\n\t\t\tte[ 4 ] = bd - ac * f;\r\n\t\t\tte[ 8 ] = bc * f + ad;\r\n\r\n\t\t\tte[ 1 ] = f;\r\n\t\t\tte[ 5 ] = a * e;\r\n\t\t\tte[ 9 ] = - b * e;\r\n\r\n\t\t\tte[ 2 ] = - d * e;\r\n\t\t\tte[ 6 ] = ad * f + bc;\r\n\t\t\tte[ 10 ] = ac - bd * f;\r\n\r\n\t\t} else if ( euler.order === 'XZY' ) {\r\n\r\n\t\t\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\r\n\r\n\t\t\tte[ 0 ] = c * e;\r\n\t\t\tte[ 4 ] = - f;\r\n\t\t\tte[ 8 ] = d * e;\r\n\r\n\t\t\tte[ 1 ] = ac * f + bd;\r\n\t\t\tte[ 5 ] = a * e;\r\n\t\t\tte[ 9 ] = ad * f - bc;\r\n\r\n\t\t\tte[ 2 ] = bc * f - ad;\r\n\t\t\tte[ 6 ] = b * e;\r\n\t\t\tte[ 10 ] = bd * f + ac;\r\n\r\n\t\t}\r\n\r\n\t\t// last column\r\n\t\tte[ 3 ] = 0;\r\n\t\tte[ 7 ] = 0;\r\n\t\tte[ 11 ] = 0;\r\n\r\n\t\t// bottom row\r\n\t\tte[ 12 ] = 0;\r\n\t\tte[ 13 ] = 0;\r\n\t\tte[ 14 ] = 0;\r\n\t\tte[ 15 ] = 1;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakeRotationFromQuaternion: function ( q ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tvar x = q.x, y = q.y, z = q.z, w = q.w;\r\n\t\tvar x2 = x + x, y2 = y + y, z2 = z + z;\r\n\t\tvar xx = x * x2, xy = x * y2, xz = x * z2;\r\n\t\tvar yy = y * y2, yz = y * z2, zz = z * z2;\r\n\t\tvar wx = w * x2, wy = w * y2, wz = w * z2;\r\n\r\n\t\tte[ 0 ] = 1 - ( yy + zz );\r\n\t\tte[ 4 ] = xy - wz;\r\n\t\tte[ 8 ] = xz + wy;\r\n\r\n\t\tte[ 1 ] = xy + wz;\r\n\t\tte[ 5 ] = 1 - ( xx + zz );\r\n\t\tte[ 9 ] = yz - wx;\r\n\r\n\t\tte[ 2 ] = xz - wy;\r\n\t\tte[ 6 ] = yz + wx;\r\n\t\tte[ 10 ] = 1 - ( xx + yy );\r\n\r\n\t\t// last column\r\n\t\tte[ 3 ] = 0;\r\n\t\tte[ 7 ] = 0;\r\n\t\tte[ 11 ] = 0;\r\n\r\n\t\t// bottom row\r\n\t\tte[ 12 ] = 0;\r\n\t\tte[ 13 ] = 0;\r\n\t\tte[ 14 ] = 0;\r\n\t\tte[ 15 ] = 1;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tlookAt: function () {\r\n\r\n\t\tvar x, y, z;\r\n\r\n\t\treturn function ( eye, target, up ) {\r\n\r\n\t\t\tif ( x === undefined ) x = new THREE.Vector3();\r\n\t\t\tif ( y === undefined ) y = new THREE.Vector3();\r\n\t\t\tif ( z === undefined ) z = new THREE.Vector3();\r\n\r\n\t\t\tvar te = this.elements;\r\n\r\n\t\t\tz.subVectors( eye, target ).normalize();\r\n\r\n\t\t\tif ( z.lengthSq() === 0 ) {\r\n\r\n\t\t\t\tz.z = 1;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tx.crossVectors( up, z ).normalize();\r\n\r\n\t\t\tif ( x.lengthSq() === 0 ) {\r\n\r\n\t\t\t\tz.x += 0.0001;\r\n\t\t\t\tx.crossVectors( up, z ).normalize();\r\n\r\n\t\t\t}\r\n\r\n\t\t\ty.crossVectors( z, x );\r\n\r\n\r\n\t\t\tte[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;\r\n\t\t\tte[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;\r\n\t\t\tte[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tmultiply: function ( m, n ) {\r\n\r\n\t\tif ( n !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );\r\n\t\t\treturn this.multiplyMatrices( m, n );\r\n\r\n\t\t}\r\n\r\n\t\treturn this.multiplyMatrices( this, m );\r\n\r\n\t},\r\n\r\n\tpremultiply: function ( m ) {\r\n\r\n\t\treturn this.multiplyMatrices( m, this );\r\n\r\n\t},\r\n\r\n\tmultiplyMatrices: function ( a, b ) {\r\n\r\n\t\tvar ae = a.elements;\r\n\t\tvar be = b.elements;\r\n\t\tvar te = this.elements;\r\n\r\n\t\tvar a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];\r\n\t\tvar a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];\r\n\t\tvar a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];\r\n\t\tvar a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];\r\n\r\n\t\tvar b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];\r\n\t\tvar b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];\r\n\t\tvar b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];\r\n\t\tvar b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];\r\n\r\n\t\tte[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\r\n\t\tte[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\r\n\t\tte[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\r\n\t\tte[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\r\n\r\n\t\tte[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\r\n\t\tte[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\r\n\t\tte[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\r\n\t\tte[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\r\n\r\n\t\tte[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\r\n\t\tte[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\r\n\t\tte[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\r\n\t\tte[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\r\n\r\n\t\tte[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\r\n\t\tte[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\r\n\t\tte[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\r\n\t\tte[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyToArray: function ( a, b, r ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tthis.multiplyMatrices( a, b );\r\n\r\n\t\tr[ 0 ] = te[ 0 ]; r[ 1 ] = te[ 1 ]; r[ 2 ] = te[ 2 ]; r[ 3 ] = te[ 3 ];\r\n\t\tr[ 4 ] = te[ 4 ]; r[ 5 ] = te[ 5 ]; r[ 6 ] = te[ 6 ]; r[ 7 ] = te[ 7 ];\r\n\t\tr[ 8 ]  = te[ 8 ]; r[ 9 ]  = te[ 9 ]; r[ 10 ] = te[ 10 ]; r[ 11 ] = te[ 11 ];\r\n\t\tr[ 12 ] = te[ 12 ]; r[ 13 ] = te[ 13 ]; r[ 14 ] = te[ 14 ]; r[ 15 ] = te[ 15 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyScalar: function ( s ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tte[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;\r\n\t\tte[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;\r\n\t\tte[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;\r\n\t\tte[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tapplyToVector3Array: function () {\r\n\r\n\t\tvar v1;\r\n\r\n\t\treturn function ( array, offset, length ) {\r\n\r\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\t\tif ( length === undefined ) length = array.length;\r\n\r\n\t\t\tfor ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {\r\n\r\n\t\t\t\tv1.fromArray( array, j );\r\n\t\t\t\tv1.applyMatrix4( this );\r\n\t\t\t\tv1.toArray( array, j );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn array;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tapplyToBuffer: function () {\r\n\r\n\t\tvar v1;\r\n\r\n\t\treturn function applyToBuffer( buffer, offset, length ) {\r\n\r\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\t\tif ( length === undefined ) length = buffer.length / buffer.itemSize;\r\n\r\n\t\t\tfor ( var i = 0, j = offset; i < length; i ++, j ++ ) {\r\n\r\n\t\t\t\tv1.x = buffer.getX( j );\r\n\t\t\t\tv1.y = buffer.getY( j );\r\n\t\t\t\tv1.z = buffer.getZ( j );\r\n\r\n\t\t\t\tv1.applyMatrix4( this );\r\n\r\n\t\t\t\tbuffer.setXYZ( v1.x, v1.y, v1.z );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn buffer;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tdeterminant: function () {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tvar n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];\r\n\t\tvar n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];\r\n\t\tvar n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];\r\n\t\tvar n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];\r\n\r\n\t\t//TODO: make this more efficient\r\n\t\t//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )\r\n\r\n\t\treturn (\r\n\t\t\tn41 * (\r\n\t\t\t\t+ n14 * n23 * n32\r\n\t\t\t\t - n13 * n24 * n32\r\n\t\t\t\t - n14 * n22 * n33\r\n\t\t\t\t + n12 * n24 * n33\r\n\t\t\t\t + n13 * n22 * n34\r\n\t\t\t\t - n12 * n23 * n34\r\n\t\t\t) +\r\n\t\t\tn42 * (\r\n\t\t\t\t+ n11 * n23 * n34\r\n\t\t\t\t - n11 * n24 * n33\r\n\t\t\t\t + n14 * n21 * n33\r\n\t\t\t\t - n13 * n21 * n34\r\n\t\t\t\t + n13 * n24 * n31\r\n\t\t\t\t - n14 * n23 * n31\r\n\t\t\t) +\r\n\t\t\tn43 * (\r\n\t\t\t\t+ n11 * n24 * n32\r\n\t\t\t\t - n11 * n22 * n34\r\n\t\t\t\t - n14 * n21 * n32\r\n\t\t\t\t + n12 * n21 * n34\r\n\t\t\t\t + n14 * n22 * n31\r\n\t\t\t\t - n12 * n24 * n31\r\n\t\t\t) +\r\n\t\t\tn44 * (\r\n\t\t\t\t- n13 * n22 * n31\r\n\t\t\t\t - n11 * n23 * n32\r\n\t\t\t\t + n11 * n22 * n33\r\n\t\t\t\t + n13 * n21 * n32\r\n\t\t\t\t - n12 * n21 * n33\r\n\t\t\t\t + n12 * n23 * n31\r\n\t\t\t)\r\n\r\n\t\t);\r\n\r\n\t},\r\n\r\n\ttranspose: function () {\r\n\r\n\t\tvar te = this.elements;\r\n\t\tvar tmp;\r\n\r\n\t\ttmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;\r\n\t\ttmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;\r\n\t\ttmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;\r\n\r\n\t\ttmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;\r\n\t\ttmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;\r\n\t\ttmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tflattenToArrayOffset: function ( array, offset ) {\r\n\r\n\t\tconsole.warn( \"THREE.Matrix3: .flattenToArrayOffset is deprecated \" +\r\n\t\t\t\t\"- just use .toArray instead.\" );\r\n\r\n\t\treturn this.toArray( array, offset );\r\n\r\n\t},\r\n\r\n\tgetPosition: function () {\r\n\r\n\t\tvar v1;\r\n\r\n\t\treturn function () {\r\n\r\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\t\t\tconsole.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );\r\n\r\n\t\t\treturn v1.setFromMatrixColumn( this, 3 );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tsetPosition: function ( v ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tte[ 12 ] = v.x;\r\n\t\tte[ 13 ] = v.y;\r\n\t\tte[ 14 ] = v.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetInverse: function ( m, throwOnDegenerate ) {\r\n\r\n\t\t// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\r\n\t\tvar te = this.elements,\r\n\t\t\tme = m.elements,\r\n\r\n\t\t\tn11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ], n41 = me[ 3 ],\r\n\t\t\tn12 = me[ 4 ], n22 = me[ 5 ], n32 = me[ 6 ], n42 = me[ 7 ],\r\n\t\t\tn13 = me[ 8 ], n23 = me[ 9 ], n33 = me[ 10 ], n43 = me[ 11 ],\r\n\t\t\tn14 = me[ 12 ], n24 = me[ 13 ], n34 = me[ 14 ], n44 = me[ 15 ],\r\n\r\n\t\t\tt11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,\r\n\t\t\tt12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,\r\n\t\t\tt13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,\r\n\t\t\tt14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\r\n\r\n\t\tvar det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;\r\n\r\n\t\tif ( det === 0 ) {\r\n\r\n\t\t\tvar msg = \"THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0\";\r\n\r\n\t\t\tif ( throwOnDegenerate || false ) {\r\n\r\n\t\t\t\tthrow new Error( msg );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tconsole.warn( msg );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this.identity();\r\n\r\n\t\t}\r\n\r\n\t\tte[ 0 ] = t11;\r\n\t\tte[ 1 ] = n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44;\r\n\t\tte[ 2 ] = n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44;\r\n\t\tte[ 3 ] = n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43;\r\n\r\n\t\tte[ 4 ] = t12;\r\n\t\tte[ 5 ] = n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44;\r\n\t\tte[ 6 ] = n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44;\r\n\t\tte[ 7 ] = n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43;\r\n\r\n\t\tte[ 8 ] = t13;\r\n\t\tte[ 9 ] = n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44;\r\n\t\tte[ 10 ] = n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44;\r\n\t\tte[ 11 ] = n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43;\r\n\r\n\t\tte[ 12 ] = t14;\r\n\t\tte[ 13 ] = n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34;\r\n\t\tte[ 14 ] = n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34;\r\n\t\tte[ 15 ] = n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33;\r\n\r\n\t\treturn this.multiplyScalar( 1 / det );\r\n\r\n\t},\r\n\r\n\tscale: function ( v ) {\r\n\r\n\t\tvar te = this.elements;\r\n\t\tvar x = v.x, y = v.y, z = v.z;\r\n\r\n\t\tte[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;\r\n\t\tte[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;\r\n\t\tte[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;\r\n\t\tte[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetMaxScaleOnAxis: function () {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tvar scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];\r\n\t\tvar scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];\r\n\t\tvar scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];\r\n\r\n\t\treturn Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );\r\n\r\n\t},\r\n\r\n\tmakeTranslation: function ( x, y, z ) {\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\t1, 0, 0, x,\r\n\t\t\t0, 1, 0, y,\r\n\t\t\t0, 0, 1, z,\r\n\t\t\t0, 0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakeRotationX: function ( theta ) {\r\n\r\n\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\t1, 0,  0, 0,\r\n\t\t\t0, c, - s, 0,\r\n\t\t\t0, s,  c, 0,\r\n\t\t\t0, 0,  0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakeRotationY: function ( theta ) {\r\n\r\n\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\t c, 0, s, 0,\r\n\t\t\t 0, 1, 0, 0,\r\n\t\t\t- s, 0, c, 0,\r\n\t\t\t 0, 0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakeRotationZ: function ( theta ) {\r\n\r\n\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\tc, - s, 0, 0,\r\n\t\t\ts,  c, 0, 0,\r\n\t\t\t0,  0, 1, 0,\r\n\t\t\t0,  0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakeRotationAxis: function ( axis, angle ) {\r\n\r\n\t\t// Based on http://www.gamedev.net/reference/articles/article1199.asp\r\n\r\n\t\tvar c = Math.cos( angle );\r\n\t\tvar s = Math.sin( angle );\r\n\t\tvar t = 1 - c;\r\n\t\tvar x = axis.x, y = axis.y, z = axis.z;\r\n\t\tvar tx = t * x, ty = t * y;\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\ttx * x + c, tx * y - s * z, tx * z + s * y, 0,\r\n\t\t\ttx * y + s * z, ty * y + c, ty * z - s * x, 0,\r\n\t\t\ttx * z - s * y, ty * z + s * x, t * z * z + c, 0,\r\n\t\t\t0, 0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\t return this;\r\n\r\n\t},\r\n\r\n\tmakeScale: function ( x, y, z ) {\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\tx, 0, 0, 0,\r\n\t\t\t0, y, 0, 0,\r\n\t\t\t0, 0, z, 0,\r\n\t\t\t0, 0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcompose: function ( position, quaternion, scale ) {\r\n\r\n\t\tthis.makeRotationFromQuaternion( quaternion );\r\n\t\tthis.scale( scale );\r\n\t\tthis.setPosition( position );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdecompose: function () {\r\n\r\n\t\tvar vector, matrix;\r\n\r\n\t\treturn function ( position, quaternion, scale ) {\r\n\r\n\t\t\tif ( vector === undefined ) vector = new THREE.Vector3();\r\n\t\t\tif ( matrix === undefined ) matrix = new THREE.Matrix4();\r\n\r\n\t\t\tvar te = this.elements;\r\n\r\n\t\t\tvar sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();\r\n\t\t\tvar sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();\r\n\t\t\tvar sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();\r\n\r\n\t\t\t// if determine is negative, we need to invert one scale\r\n\t\t\tvar det = this.determinant();\r\n\t\t\tif ( det < 0 ) {\r\n\r\n\t\t\t\tsx = - sx;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tposition.x = te[ 12 ];\r\n\t\t\tposition.y = te[ 13 ];\r\n\t\t\tposition.z = te[ 14 ];\r\n\r\n\t\t\t// scale the rotation part\r\n\r\n\t\t\tmatrix.elements.set( this.elements ); // at this point matrix is incomplete so we can't use .copy()\r\n\r\n\t\t\tvar invSX = 1 / sx;\r\n\t\t\tvar invSY = 1 / sy;\r\n\t\t\tvar invSZ = 1 / sz;\r\n\r\n\t\t\tmatrix.elements[ 0 ] *= invSX;\r\n\t\t\tmatrix.elements[ 1 ] *= invSX;\r\n\t\t\tmatrix.elements[ 2 ] *= invSX;\r\n\r\n\t\t\tmatrix.elements[ 4 ] *= invSY;\r\n\t\t\tmatrix.elements[ 5 ] *= invSY;\r\n\t\t\tmatrix.elements[ 6 ] *= invSY;\r\n\r\n\t\t\tmatrix.elements[ 8 ] *= invSZ;\r\n\t\t\tmatrix.elements[ 9 ] *= invSZ;\r\n\t\t\tmatrix.elements[ 10 ] *= invSZ;\r\n\r\n\t\t\tquaternion.setFromRotationMatrix( matrix );\r\n\r\n\t\t\tscale.x = sx;\r\n\t\t\tscale.y = sy;\r\n\t\t\tscale.z = sz;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tmakeFrustum: function ( left, right, bottom, top, near, far ) {\r\n\r\n\t\tvar te = this.elements;\r\n\t\tvar x = 2 * near / ( right - left );\r\n\t\tvar y = 2 * near / ( top - bottom );\r\n\r\n\t\tvar a = ( right + left ) / ( right - left );\r\n\t\tvar b = ( top + bottom ) / ( top - bottom );\r\n\t\tvar c = - ( far + near ) / ( far - near );\r\n\t\tvar d = - 2 * far * near / ( far - near );\r\n\r\n\t\tte[ 0 ] = x;\tte[ 4 ] = 0;\tte[ 8 ] = a;\tte[ 12 ] = 0;\r\n\t\tte[ 1 ] = 0;\tte[ 5 ] = y;\tte[ 9 ] = b;\tte[ 13 ] = 0;\r\n\t\tte[ 2 ] = 0;\tte[ 6 ] = 0;\tte[ 10 ] = c;\tte[ 14 ] = d;\r\n\t\tte[ 3 ] = 0;\tte[ 7 ] = 0;\tte[ 11 ] = - 1;\tte[ 15 ] = 0;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakePerspective: function ( fov, aspect, near, far ) {\r\n\r\n\t\tvar ymax = near * Math.tan( THREE.Math.DEG2RAD * fov * 0.5 );\r\n\t\tvar ymin = - ymax;\r\n\t\tvar xmin = ymin * aspect;\r\n\t\tvar xmax = ymax * aspect;\r\n\r\n\t\treturn this.makeFrustum( xmin, xmax, ymin, ymax, near, far );\r\n\r\n\t},\r\n\r\n\tmakeOrthographic: function ( left, right, top, bottom, near, far ) {\r\n\r\n\t\tvar te = this.elements;\r\n\t\tvar w = 1.0 / ( right - left );\r\n\t\tvar h = 1.0 / ( top - bottom );\r\n\t\tvar p = 1.0 / ( far - near );\r\n\r\n\t\tvar x = ( right + left ) * w;\r\n\t\tvar y = ( top + bottom ) * h;\r\n\t\tvar z = ( far + near ) * p;\r\n\r\n\t\tte[ 0 ] = 2 * w;\tte[ 4 ] = 0;\tte[ 8 ] = 0;\tte[ 12 ] = - x;\r\n\t\tte[ 1 ] = 0;\tte[ 5 ] = 2 * h;\tte[ 9 ] = 0;\tte[ 13 ] = - y;\r\n\t\tte[ 2 ] = 0;\tte[ 6 ] = 0;\tte[ 10 ] = - 2 * p;\tte[ 14 ] = - z;\r\n\t\tte[ 3 ] = 0;\tte[ 7 ] = 0;\tte[ 11 ] = 0;\tte[ 15 ] = 1;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( matrix ) {\r\n\r\n\t\tvar te = this.elements;\r\n\t\tvar me = matrix.elements;\r\n\r\n\t\tfor ( var i = 0; i < 16; i ++ ) {\r\n\r\n\t\t\tif ( te[ i ] !== me[ i ] ) return false;\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t},\r\n\r\n\tfromArray: function ( array ) {\r\n\r\n\t\tthis.elements.set( array );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoArray: function ( array, offset ) {\r\n\r\n\t\tif ( array === undefined ) array = [];\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tarray[ offset ] = te[ 0 ];\r\n\t\tarray[ offset + 1 ] = te[ 1 ];\r\n\t\tarray[ offset + 2 ] = te[ 2 ];\r\n\t\tarray[ offset + 3 ] = te[ 3 ];\r\n\r\n\t\tarray[ offset + 4 ] = te[ 4 ];\r\n\t\tarray[ offset + 5 ] = te[ 5 ];\r\n\t\tarray[ offset + 6 ] = te[ 6 ];\r\n\t\tarray[ offset + 7 ] = te[ 7 ];\r\n\r\n\t\tarray[ offset + 8 ]  = te[ 8 ];\r\n\t\tarray[ offset + 9 ]  = te[ 9 ];\r\n\t\tarray[ offset + 10 ] = te[ 10 ];\r\n\t\tarray[ offset + 11 ] = te[ 11 ];\r\n\r\n\t\tarray[ offset + 12 ] = te[ 12 ];\r\n\t\tarray[ offset + 13 ] = te[ 13 ];\r\n\t\tarray[ offset + 14 ] = te[ 14 ];\r\n\t\tarray[ offset + 15 ] = te[ 15 ];\r\n\r\n\t\treturn array;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/math/Ray.js\r\n\r\n/**\r\n * @author bhouston / http://clara.io\r\n */\r\n\r\nTHREE.Ray = function ( origin, direction ) {\r\n\r\n\tthis.origin = ( origin !== undefined ) ? origin : new THREE.Vector3();\r\n\tthis.direction = ( direction !== undefined ) ? direction : new THREE.Vector3();\r\n\r\n};\r\n\r\nTHREE.Ray.prototype = {\r\n\r\n\tconstructor: THREE.Ray,\r\n\r\n\tset: function ( origin, direction ) {\r\n\r\n\t\tthis.origin.copy( origin );\r\n\t\tthis.direction.copy( direction );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\r\n\t},\r\n\r\n\tcopy: function ( ray ) {\r\n\r\n\t\tthis.origin.copy( ray.origin );\r\n\t\tthis.direction.copy( ray.direction );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tat: function ( t, optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\r\n\t\treturn result.copy( this.direction ).multiplyScalar( t ).add( this.origin );\r\n\r\n\t},\r\n\r\n\tlookAt: function ( v ) {\r\n\r\n\t\tthis.direction.copy( v ).sub( this.origin ).normalize();\r\n\r\n\t},\r\n\r\n\trecast: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function ( t ) {\r\n\r\n\t\t\tthis.origin.copy( this.at( t, v1 ) );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tclosestPointToPoint: function ( point, optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\tresult.subVectors( point, this.origin );\r\n\t\tvar directionDistance = result.dot( this.direction );\r\n\r\n\t\tif ( directionDistance < 0 ) {\r\n\r\n\t\t\treturn result.copy( this.origin );\r\n\r\n\t\t}\r\n\r\n\t\treturn result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\r\n\r\n\t},\r\n\r\n\tdistanceToPoint: function ( point ) {\r\n\r\n\t\treturn Math.sqrt( this.distanceSqToPoint( point ) );\r\n\r\n\t},\r\n\r\n\tdistanceSqToPoint: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function ( point ) {\r\n\r\n\t\t\tvar directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );\r\n\r\n\t\t\t// point behind the ray\r\n\r\n\t\t\tif ( directionDistance < 0 ) {\r\n\r\n\t\t\t\treturn this.origin.distanceToSquared( point );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tv1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\r\n\r\n\t\t\treturn v1.distanceToSquared( point );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tdistanceSqToSegment: function () {\r\n\r\n\t\tvar segCenter = new THREE.Vector3();\r\n\t\tvar segDir = new THREE.Vector3();\r\n\t\tvar diff = new THREE.Vector3();\r\n\r\n\t\treturn function ( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {\r\n\r\n\t\t\t// from http://www.geometrictools.com/LibMathematics/Distance/Wm5DistRay3Segment3.cpp\r\n\t\t\t// It returns the min distance between the ray and the segment\r\n\t\t\t// defined by v0 and v1\r\n\t\t\t// It can also set two optional targets :\r\n\t\t\t// - The closest point on the ray\r\n\t\t\t// - The closest point on the segment\r\n\r\n\t\t\tsegCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );\r\n\t\t\tsegDir.copy( v1 ).sub( v0 ).normalize();\r\n\t\t\tdiff.copy( this.origin ).sub( segCenter );\r\n\r\n\t\t\tvar segExtent = v0.distanceTo( v1 ) * 0.5;\r\n\t\t\tvar a01 = - this.direction.dot( segDir );\r\n\t\t\tvar b0 = diff.dot( this.direction );\r\n\t\t\tvar b1 = - diff.dot( segDir );\r\n\t\t\tvar c = diff.lengthSq();\r\n\t\t\tvar det = Math.abs( 1 - a01 * a01 );\r\n\t\t\tvar s0, s1, sqrDist, extDet;\r\n\r\n\t\t\tif ( det > 0 ) {\r\n\r\n\t\t\t\t// The ray and segment are not parallel.\r\n\r\n\t\t\t\ts0 = a01 * b1 - b0;\r\n\t\t\t\ts1 = a01 * b0 - b1;\r\n\t\t\t\textDet = segExtent * det;\r\n\r\n\t\t\t\tif ( s0 >= 0 ) {\r\n\r\n\t\t\t\t\tif ( s1 >= - extDet ) {\r\n\r\n\t\t\t\t\t\tif ( s1 <= extDet ) {\r\n\r\n\t\t\t\t\t\t\t// region 0\r\n\t\t\t\t\t\t\t// Minimum at interior points of ray and segment.\r\n\r\n\t\t\t\t\t\t\tvar invDet = 1 / det;\r\n\t\t\t\t\t\t\ts0 *= invDet;\r\n\t\t\t\t\t\t\ts1 *= invDet;\r\n\t\t\t\t\t\t\tsqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t// region 1\r\n\r\n\t\t\t\t\t\t\ts1 = segExtent;\r\n\t\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\r\n\t\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t// region 5\r\n\r\n\t\t\t\t\t\ts1 = - segExtent;\r\n\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\r\n\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tif ( s1 <= - extDet ) {\r\n\r\n\t\t\t\t\t\t// region 4\r\n\r\n\t\t\t\t\t\ts0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );\r\n\t\t\t\t\t\ts1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\r\n\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\r\n\t\t\t\t\t} else if ( s1 <= extDet ) {\r\n\r\n\t\t\t\t\t\t// region 3\r\n\r\n\t\t\t\t\t\ts0 = 0;\r\n\t\t\t\t\t\ts1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );\r\n\t\t\t\t\t\tsqrDist = s1 * ( s1 + 2 * b1 ) + c;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t// region 2\r\n\r\n\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * segExtent + b0 ) );\r\n\t\t\t\t\t\ts1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\r\n\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// Ray and segment are parallel.\r\n\r\n\t\t\t\ts1 = ( a01 > 0 ) ? - segExtent : segExtent;\r\n\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\r\n\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( optionalPointOnRay ) {\r\n\r\n\t\t\t\toptionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( optionalPointOnSegment ) {\r\n\r\n\t\t\t\toptionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn sqrDist;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tintersectSphere: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function ( sphere, optionalTarget ) {\r\n\r\n\t\t\tv1.subVectors( sphere.center, this.origin );\r\n\t\t\tvar tca = v1.dot( this.direction );\r\n\t\t\tvar d2 = v1.dot( v1 ) - tca * tca;\r\n\t\t\tvar radius2 = sphere.radius * sphere.radius;\r\n\r\n\t\t\tif ( d2 > radius2 ) return null;\r\n\r\n\t\t\tvar thc = Math.sqrt( radius2 - d2 );\r\n\r\n\t\t\t// t0 = first intersect point - entrance on front of sphere\r\n\t\t\tvar t0 = tca - thc;\r\n\r\n\t\t\t// t1 = second intersect point - exit point on back of sphere\r\n\t\t\tvar t1 = tca + thc;\r\n\r\n\t\t\t// test to see if both t0 and t1 are behind the ray - if so, return null\r\n\t\t\tif ( t0 < 0 && t1 < 0 ) return null;\r\n\r\n\t\t\t// test to see if t0 is behind the ray:\r\n\t\t\t// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,\r\n\t\t\t// in order to always return an intersect point that is in front of the ray.\r\n\t\t\tif ( t0 < 0 ) return this.at( t1, optionalTarget );\r\n\r\n\t\t\t// else t0 is in front of the ray, so return the first collision point scaled by t0\r\n\t\t\treturn this.at( t0, optionalTarget );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tintersectsSphere: function ( sphere ) {\r\n\r\n\t\treturn this.distanceToPoint( sphere.center ) <= sphere.radius;\r\n\r\n\t},\r\n\r\n\tdistanceToPlane: function ( plane ) {\r\n\r\n\t\tvar denominator = plane.normal.dot( this.direction );\r\n\r\n\t\tif ( denominator === 0 ) {\r\n\r\n\t\t\t// line is coplanar, return origin\r\n\t\t\tif ( plane.distanceToPoint( this.origin ) === 0 ) {\r\n\r\n\t\t\t\treturn 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Null is preferable to undefined since undefined means.... it is undefined\r\n\r\n\t\t\treturn null;\r\n\r\n\t\t}\r\n\r\n\t\tvar t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;\r\n\r\n\t\t// Return if the ray never intersects the plane\r\n\r\n\t\treturn t >= 0 ? t :  null;\r\n\r\n\t},\r\n\r\n\tintersectPlane: function ( plane, optionalTarget ) {\r\n\r\n\t\tvar t = this.distanceToPlane( plane );\r\n\r\n\t\tif ( t === null ) {\r\n\r\n\t\t\treturn null;\r\n\r\n\t\t}\r\n\r\n\t\treturn this.at( t, optionalTarget );\r\n\r\n\t},\r\n\r\n\r\n\r\n\tintersectsPlane: function ( plane ) {\r\n\r\n\t\t// check if the ray lies on the plane first\r\n\r\n\t\tvar distToPoint = plane.distanceToPoint( this.origin );\r\n\r\n\t\tif ( distToPoint === 0 ) {\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\r\n\t\tvar denominator = plane.normal.dot( this.direction );\r\n\r\n\t\tif ( denominator * distToPoint < 0 ) {\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\r\n\t\t// ray origin is behind the plane (and is pointing behind it)\r\n\r\n\t\treturn false;\r\n\r\n\t},\r\n\r\n\tintersectBox: function ( box, optionalTarget ) {\r\n\r\n\t\tvar tmin, tmax, tymin, tymax, tzmin, tzmax;\r\n\r\n\t\tvar invdirx = 1 / this.direction.x,\r\n\t\t\tinvdiry = 1 / this.direction.y,\r\n\t\t\tinvdirz = 1 / this.direction.z;\r\n\r\n\t\tvar origin = this.origin;\r\n\r\n\t\tif ( invdirx >= 0 ) {\r\n\r\n\t\t\ttmin = ( box.min.x - origin.x ) * invdirx;\r\n\t\t\ttmax = ( box.max.x - origin.x ) * invdirx;\r\n\r\n\t\t} else {\r\n\r\n\t\t\ttmin = ( box.max.x - origin.x ) * invdirx;\r\n\t\t\ttmax = ( box.min.x - origin.x ) * invdirx;\r\n\r\n\t\t}\r\n\r\n\t\tif ( invdiry >= 0 ) {\r\n\r\n\t\t\ttymin = ( box.min.y - origin.y ) * invdiry;\r\n\t\t\ttymax = ( box.max.y - origin.y ) * invdiry;\r\n\r\n\t\t} else {\r\n\r\n\t\t\ttymin = ( box.max.y - origin.y ) * invdiry;\r\n\t\t\ttymax = ( box.min.y - origin.y ) * invdiry;\r\n\r\n\t\t}\r\n\r\n\t\tif ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;\r\n\r\n\t\t// These lines also handle the case where tmin or tmax is NaN\r\n\t\t// (result of 0 * Infinity). x !== x returns true if x is NaN\r\n\r\n\t\tif ( tymin > tmin || tmin !== tmin ) tmin = tymin;\r\n\r\n\t\tif ( tymax < tmax || tmax !== tmax ) tmax = tymax;\r\n\r\n\t\tif ( invdirz >= 0 ) {\r\n\r\n\t\t\ttzmin = ( box.min.z - origin.z ) * invdirz;\r\n\t\t\ttzmax = ( box.max.z - origin.z ) * invdirz;\r\n\r\n\t\t} else {\r\n\r\n\t\t\ttzmin = ( box.max.z - origin.z ) * invdirz;\r\n\t\t\ttzmax = ( box.min.z - origin.z ) * invdirz;\r\n\r\n\t\t}\r\n\r\n\t\tif ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;\r\n\r\n\t\tif ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;\r\n\r\n\t\tif ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;\r\n\r\n\t\t//return point closest to the ray (positive side)\r\n\r\n\t\tif ( tmax < 0 ) return null;\r\n\r\n\t\treturn this.at( tmin >= 0 ? tmin : tmax, optionalTarget );\r\n\r\n\t},\r\n\r\n\tintersectsBox: ( function () {\r\n\r\n\t\tvar v = new THREE.Vector3();\r\n\r\n\t\treturn function ( box ) {\r\n\r\n\t\t\treturn this.intersectBox( box, v ) !== null;\r\n\r\n\t\t};\r\n\r\n\t} )(),\r\n\r\n\tintersectTriangle: function () {\r\n\r\n\t\t// Compute the offset origin, edges, and normal.\r\n\t\tvar diff = new THREE.Vector3();\r\n\t\tvar edge1 = new THREE.Vector3();\r\n\t\tvar edge2 = new THREE.Vector3();\r\n\t\tvar normal = new THREE.Vector3();\r\n\r\n\t\treturn function ( a, b, c, backfaceCulling, optionalTarget ) {\r\n\r\n\t\t\t// from http://www.geometrictools.com/LibMathematics/Intersection/Wm5IntrRay3Triangle3.cpp\r\n\r\n\t\t\tedge1.subVectors( b, a );\r\n\t\t\tedge2.subVectors( c, a );\r\n\t\t\tnormal.crossVectors( edge1, edge2 );\r\n\r\n\t\t\t// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,\r\n\t\t\t// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by\r\n\t\t\t//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))\r\n\t\t\t//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))\r\n\t\t\t//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)\r\n\t\t\tvar DdN = this.direction.dot( normal );\r\n\t\t\tvar sign;\r\n\r\n\t\t\tif ( DdN > 0 ) {\r\n\r\n\t\t\t\tif ( backfaceCulling ) return null;\r\n\t\t\t\tsign = 1;\r\n\r\n\t\t\t} else if ( DdN < 0 ) {\r\n\r\n\t\t\t\tsign = - 1;\r\n\t\t\t\tDdN = - DdN;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tdiff.subVectors( this.origin, a );\r\n\t\t\tvar DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );\r\n\r\n\t\t\t// b1 < 0, no intersection\r\n\t\t\tif ( DdQxE2 < 0 ) {\r\n\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );\r\n\r\n\t\t\t// b2 < 0, no intersection\r\n\t\t\tif ( DdE1xQ < 0 ) {\r\n\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// b1+b2 > 1, no intersection\r\n\t\t\tif ( DdQxE2 + DdE1xQ > DdN ) {\r\n\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Line intersects triangle, check if ray does.\r\n\t\t\tvar QdN = - sign * diff.dot( normal );\r\n\r\n\t\t\t// t < 0, no intersection\r\n\t\t\tif ( QdN < 0 ) {\r\n\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Ray intersects triangle.\r\n\t\t\treturn this.at( QdN / DdN, optionalTarget );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tapplyMatrix4: function ( matrix4 ) {\r\n\r\n\t\tthis.direction.add( this.origin ).applyMatrix4( matrix4 );\r\n\t\tthis.origin.applyMatrix4( matrix4 );\r\n\t\tthis.direction.sub( this.origin );\r\n\t\tthis.direction.normalize();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( ray ) {\r\n\r\n\t\treturn ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/math/Sphere.js\r\n\r\n/**\r\n * @author bhouston / http://clara.io\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Sphere = function ( center, radius ) {\r\n\r\n\tthis.center = ( center !== undefined ) ? center : new THREE.Vector3();\r\n\tthis.radius = ( radius !== undefined ) ? radius : 0;\r\n\r\n};\r\n\r\nTHREE.Sphere.prototype = {\r\n\r\n\tconstructor: THREE.Sphere,\r\n\r\n\tset: function ( center, radius ) {\r\n\r\n\t\tthis.center.copy( center );\r\n\t\tthis.radius = radius;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromPoints: function () {\r\n\r\n\t\tvar box = new THREE.Box3();\r\n\r\n\t\treturn function ( points, optionalCenter ) {\r\n\r\n\t\t\tvar center = this.center;\r\n\r\n\t\t\tif ( optionalCenter !== undefined ) {\r\n\r\n\t\t\t\tcenter.copy( optionalCenter );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tbox.setFromPoints( points ).center( center );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar maxRadiusSq = 0;\r\n\r\n\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.radius = Math.sqrt( maxRadiusSq );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\r\n\t},\r\n\r\n\tcopy: function ( sphere ) {\r\n\r\n\t\tthis.center.copy( sphere.center );\r\n\t\tthis.radius = sphere.radius;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tempty: function () {\r\n\r\n\t\treturn ( this.radius <= 0 );\r\n\r\n\t},\r\n\r\n\tcontainsPoint: function ( point ) {\r\n\r\n\t\treturn ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );\r\n\r\n\t},\r\n\r\n\tdistanceToPoint: function ( point ) {\r\n\r\n\t\treturn ( point.distanceTo( this.center ) - this.radius );\r\n\r\n\t},\r\n\r\n\tintersectsSphere: function ( sphere ) {\r\n\r\n\t\tvar radiusSum = this.radius + sphere.radius;\r\n\r\n\t\treturn sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );\r\n\r\n\t},\r\n\r\n\tintersectsBox: function ( box ) {\r\n\r\n\t\treturn box.intersectsSphere( this );\r\n\r\n\t},\r\n\r\n\tintersectsPlane: function ( plane ) {\r\n\r\n\t\t// We use the following equation to compute the signed distance from\r\n\t\t// the center of the sphere to the plane.\r\n\t\t//\r\n\t\t// distance = q * n - d\r\n\t\t//\r\n\t\t// If this distance is greater than the radius of the sphere,\r\n\t\t// then there is no intersection.\r\n\r\n\t\treturn Math.abs( this.center.dot( plane.normal ) - plane.constant ) <= this.radius;\r\n\r\n\t},\r\n\r\n\tclampPoint: function ( point, optionalTarget ) {\r\n\r\n\t\tvar deltaLengthSq = this.center.distanceToSquared( point );\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\r\n\t\tresult.copy( point );\r\n\r\n\t\tif ( deltaLengthSq > ( this.radius * this.radius ) ) {\r\n\r\n\t\t\tresult.sub( this.center ).normalize();\r\n\t\t\tresult.multiplyScalar( this.radius ).add( this.center );\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t},\r\n\r\n\tgetBoundingBox: function ( optionalTarget ) {\r\n\r\n\t\tvar box = optionalTarget || new THREE.Box3();\r\n\r\n\t\tbox.set( this.center, this.center );\r\n\t\tbox.expandByScalar( this.radius );\r\n\r\n\t\treturn box;\r\n\r\n\t},\r\n\r\n\tapplyMatrix4: function ( matrix ) {\r\n\r\n\t\tthis.center.applyMatrix4( matrix );\r\n\t\tthis.radius = this.radius * matrix.getMaxScaleOnAxis();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttranslate: function ( offset ) {\r\n\r\n\t\tthis.center.add( offset );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( sphere ) {\r\n\r\n\t\treturn sphere.center.equals( this.center ) && ( sphere.radius === this.radius );\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/math/Frustum.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author bhouston / http://clara.io\r\n */\r\n\r\nTHREE.Frustum = function ( p0, p1, p2, p3, p4, p5 ) {\r\n\r\n\tthis.planes = [\r\n\r\n\t\t( p0 !== undefined ) ? p0 : new THREE.Plane(),\r\n\t\t( p1 !== undefined ) ? p1 : new THREE.Plane(),\r\n\t\t( p2 !== undefined ) ? p2 : new THREE.Plane(),\r\n\t\t( p3 !== undefined ) ? p3 : new THREE.Plane(),\r\n\t\t( p4 !== undefined ) ? p4 : new THREE.Plane(),\r\n\t\t( p5 !== undefined ) ? p5 : new THREE.Plane()\r\n\r\n\t];\r\n\r\n};\r\n\r\nTHREE.Frustum.prototype = {\r\n\r\n\tconstructor: THREE.Frustum,\r\n\r\n\tset: function ( p0, p1, p2, p3, p4, p5 ) {\r\n\r\n\t\tvar planes = this.planes;\r\n\r\n\t\tplanes[ 0 ].copy( p0 );\r\n\t\tplanes[ 1 ].copy( p1 );\r\n\t\tplanes[ 2 ].copy( p2 );\r\n\t\tplanes[ 3 ].copy( p3 );\r\n\t\tplanes[ 4 ].copy( p4 );\r\n\t\tplanes[ 5 ].copy( p5 );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\r\n\t},\r\n\r\n\tcopy: function ( frustum ) {\r\n\r\n\t\tvar planes = this.planes;\r\n\r\n\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\tplanes[ i ].copy( frustum.planes[ i ] );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromMatrix: function ( m ) {\r\n\r\n\t\tvar planes = this.planes;\r\n\t\tvar me = m.elements;\r\n\t\tvar me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];\r\n\t\tvar me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];\r\n\t\tvar me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];\r\n\t\tvar me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];\r\n\r\n\t\tplanes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();\r\n\t\tplanes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();\r\n\t\tplanes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();\r\n\t\tplanes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();\r\n\t\tplanes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();\r\n\t\tplanes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tintersectsObject: function () {\r\n\r\n\t\tvar sphere = new THREE.Sphere();\r\n\r\n\t\treturn function ( object ) {\r\n\r\n\t\t\tvar geometry = object.geometry;\r\n\r\n\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\r\n\r\n\t\t\tsphere.copy( geometry.boundingSphere );\r\n\t\t\tsphere.applyMatrix4( object.matrixWorld );\r\n\r\n\t\t\treturn this.intersectsSphere( sphere );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tintersectsSphere: function ( sphere ) {\r\n\r\n\t\tvar planes = this.planes;\r\n\t\tvar center = sphere.center;\r\n\t\tvar negRadius = - sphere.radius;\r\n\r\n\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\tvar distance = planes[ i ].distanceToPoint( center );\r\n\r\n\t\t\tif ( distance < negRadius ) {\r\n\r\n\t\t\t\treturn false;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t},\r\n\r\n\tintersectsBox: function () {\r\n\r\n\t\tvar p1 = new THREE.Vector3(),\r\n\t\t\tp2 = new THREE.Vector3();\r\n\r\n\t\treturn function ( box ) {\r\n\r\n\t\t\tvar planes = this.planes;\r\n\r\n\t\t\tfor ( var i = 0; i < 6 ; i ++ ) {\r\n\r\n\t\t\t\tvar plane = planes[ i ];\r\n\r\n\t\t\t\tp1.x = plane.normal.x > 0 ? box.min.x : box.max.x;\r\n\t\t\t\tp2.x = plane.normal.x > 0 ? box.max.x : box.min.x;\r\n\t\t\t\tp1.y = plane.normal.y > 0 ? box.min.y : box.max.y;\r\n\t\t\t\tp2.y = plane.normal.y > 0 ? box.max.y : box.min.y;\r\n\t\t\t\tp1.z = plane.normal.z > 0 ? box.min.z : box.max.z;\r\n\t\t\t\tp2.z = plane.normal.z > 0 ? box.max.z : box.min.z;\r\n\r\n\t\t\t\tvar d1 = plane.distanceToPoint( p1 );\r\n\t\t\t\tvar d2 = plane.distanceToPoint( p2 );\r\n\r\n\t\t\t\t// if both outside plane, no intersection\r\n\r\n\t\t\t\tif ( d1 < 0 && d2 < 0 ) {\r\n\r\n\t\t\t\t\treturn false;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\r\n\tcontainsPoint: function ( point ) {\r\n\r\n\t\tvar planes = this.planes;\r\n\r\n\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\tif ( planes[ i ].distanceToPoint( point ) < 0 ) {\r\n\r\n\t\t\t\treturn false;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/math/Plane.js\r\n\r\n/**\r\n * @author bhouston / http://clara.io\r\n */\r\n\r\nTHREE.Plane = function ( normal, constant ) {\r\n\r\n\tthis.normal = ( normal !== undefined ) ? normal : new THREE.Vector3( 1, 0, 0 );\r\n\tthis.constant = ( constant !== undefined ) ? constant : 0;\r\n\r\n};\r\n\r\nTHREE.Plane.prototype = {\r\n\r\n\tconstructor: THREE.Plane,\r\n\r\n\tset: function ( normal, constant ) {\r\n\r\n\t\tthis.normal.copy( normal );\r\n\t\tthis.constant = constant;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetComponents: function ( x, y, z, w ) {\r\n\r\n\t\tthis.normal.set( x, y, z );\r\n\t\tthis.constant = w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromNormalAndCoplanarPoint: function ( normal, point ) {\r\n\r\n\t\tthis.normal.copy( normal );\r\n\t\tthis.constant = - point.dot( this.normal );\t// must be this.normal, not normal, as this.normal is normalized\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromCoplanarPoints: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\t\tvar v2 = new THREE.Vector3();\r\n\r\n\t\treturn function ( a, b, c ) {\r\n\r\n\t\t\tvar normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();\r\n\r\n\t\t\t// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?\r\n\r\n\t\t\tthis.setFromNormalAndCoplanarPoint( normal, a );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\r\n\t},\r\n\r\n\tcopy: function ( plane ) {\r\n\r\n\t\tthis.normal.copy( plane.normal );\r\n\t\tthis.constant = plane.constant;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tnormalize: function () {\r\n\r\n\t\t// Note: will lead to a divide by zero if the plane is invalid.\r\n\r\n\t\tvar inverseNormalLength = 1.0 / this.normal.length();\r\n\t\tthis.normal.multiplyScalar( inverseNormalLength );\r\n\t\tthis.constant *= inverseNormalLength;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tnegate: function () {\r\n\r\n\t\tthis.constant *= - 1;\r\n\t\tthis.normal.negate();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdistanceToPoint: function ( point ) {\r\n\r\n\t\treturn this.normal.dot( point ) + this.constant;\r\n\r\n\t},\r\n\r\n\tdistanceToSphere: function ( sphere ) {\r\n\r\n\t\treturn this.distanceToPoint( sphere.center ) - sphere.radius;\r\n\r\n\t},\r\n\r\n\tprojectPoint: function ( point, optionalTarget ) {\r\n\r\n\t\treturn this.orthoPoint( point, optionalTarget ).sub( point ).negate();\r\n\r\n\t},\r\n\r\n\torthoPoint: function ( point, optionalTarget ) {\r\n\r\n\t\tvar perpendicularMagnitude = this.distanceToPoint( point );\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\treturn result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );\r\n\r\n\t},\r\n\r\n\tintersectLine: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function ( line, optionalTarget ) {\r\n\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\r\n\t\t\tvar direction = line.delta( v1 );\r\n\r\n\t\t\tvar denominator = this.normal.dot( direction );\r\n\r\n\t\t\tif ( denominator === 0 ) {\r\n\r\n\t\t\t\t// line is coplanar, return origin\r\n\t\t\t\tif ( this.distanceToPoint( line.start ) === 0 ) {\r\n\r\n\t\t\t\t\treturn result.copy( line.start );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Unsure if this is the correct method to handle this case.\r\n\t\t\t\treturn undefined;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;\r\n\r\n\t\t\tif ( t < 0 || t > 1 ) {\r\n\r\n\t\t\t\treturn undefined;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn result.copy( direction ).multiplyScalar( t ).add( line.start );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tintersectsLine: function ( line ) {\r\n\r\n\t\t// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.\r\n\r\n\t\tvar startSign = this.distanceToPoint( line.start );\r\n\t\tvar endSign = this.distanceToPoint( line.end );\r\n\r\n\t\treturn ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );\r\n\r\n\t},\r\n\r\n\tintersectsBox: function ( box ) {\r\n\r\n\t\treturn box.intersectsPlane( this );\r\n\r\n\t},\r\n\r\n\tintersectsSphere: function ( sphere ) {\r\n\r\n\t\treturn sphere.intersectsPlane( this );\r\n\r\n\t},\r\n\r\n\tcoplanarPoint: function ( optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\treturn result.copy( this.normal ).multiplyScalar( - this.constant );\r\n\r\n\t},\r\n\r\n\tapplyMatrix4: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\t\tvar m1 = new THREE.Matrix3();\r\n\r\n\t\treturn function ( matrix, optionalNormalMatrix ) {\r\n\r\n\t\t\tvar referencePoint = this.coplanarPoint( v1 ).applyMatrix4( matrix );\r\n\r\n\t\t\t// transform normal based on theory here:\r\n\t\t\t// http://www.songho.ca/opengl/gl_normaltransform.html\r\n\t\t\tvar normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );\r\n\t\t\tvar normal = this.normal.applyMatrix3( normalMatrix ).normalize();\r\n\r\n\t\t\t// recalculate constant (like in setFromNormalAndCoplanarPoint)\r\n\t\t\tthis.constant = - referencePoint.dot( normal );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\ttranslate: function ( offset ) {\r\n\r\n\t\tthis.constant = this.constant - offset.dot( this.normal );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( plane ) {\r\n\r\n\t\treturn plane.normal.equals( this.normal ) && ( plane.constant === this.constant );\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/math/Spherical.js\r\n\r\n/**\r\n * @author bhouston / http://clara.io\r\n * @author WestLangley / http://github.com/WestLangley\r\n *\r\n * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system\r\n *\r\n * The poles (phi) are at the positive and negative y axis.\r\n * The equator starts at positive z.\r\n */\r\n\r\nTHREE.Spherical = function ( radius, phi, theta ) {\r\n\r\n\tthis.radius = ( radius !== undefined ) ? radius : 1.0;\r\n\tthis.phi = ( phi !== undefined ) ? phi : 0; // up / down towards top and bottom pole\r\n\tthis.theta = ( theta !== undefined ) ? theta : 0; // around the equator of the sphere\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\nTHREE.Spherical.prototype = {\r\n\r\n\tconstructor: THREE.Spherical,\r\n\r\n\tset: function ( radius, phi, theta ) {\r\n\r\n\t\tthis.radius = radius;\r\n\t\tthis.phi = phi;\r\n\t\tthis.theta = theta;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\r\n\t},\r\n\r\n\tcopy: function ( other ) {\r\n\r\n\t\tthis.radius.copy( other.radius );\r\n\t\tthis.phi.copy( other.phi );\r\n\t\tthis.theta.copy( other.theta );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\t// restrict phi to be betwee EPS and PI-EPS\r\n\tmakeSafe: function() {\r\n\r\n\t\tvar EPS = 0.000001;\r\n\t\tthis.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );\r\n\r\n\t},\r\n\r\n\tsetFromVector3: function( vec3 ) {\r\n\r\n\t\tthis.radius = vec3.length();\r\n\r\n\t\tif ( this.radius === 0 ) {\r\n\r\n\t\t\tthis.theta = 0;\r\n\t\t\tthis.phi = 0;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.theta = Math.atan2( vec3.x, vec3.z ); // equator angle around y-up axis\r\n\t\t\tthis.phi = Math.acos( THREE.Math.clamp( vec3.y / this.radius, - 1, 1 ) ); // polar angle\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n};\r\n\r\n// File:src/math/Math.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Math = {\r\n\r\n\tDEG2RAD: Math.PI / 180,\r\n\tRAD2DEG: 180 / Math.PI,\r\n\r\n\tgenerateUUID: function () {\r\n\r\n\t\t// http://www.broofa.com/Tools/Math.uuid.htm\r\n\r\n\t\tvar chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split( '' );\r\n\t\tvar uuid = new Array( 36 );\r\n\t\tvar rnd = 0, r;\r\n\r\n\t\treturn function () {\r\n\r\n\t\t\tfor ( var i = 0; i < 36; i ++ ) {\r\n\r\n\t\t\t\tif ( i === 8 || i === 13 || i === 18 || i === 23 ) {\r\n\r\n\t\t\t\t\tuuid[ i ] = '-';\r\n\r\n\t\t\t\t} else if ( i === 14 ) {\r\n\r\n\t\t\t\t\tuuid[ i ] = '4';\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tif ( rnd <= 0x02 ) rnd = 0x2000000 + ( Math.random() * 0x1000000 ) | 0;\r\n\t\t\t\t\tr = rnd & 0xf;\r\n\t\t\t\t\trnd = rnd >> 4;\r\n\t\t\t\t\tuuid[ i ] = chars[ ( i === 19 ) ? ( r & 0x3 ) | 0x8 : r ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn uuid.join( '' );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tclamp: function ( value, min, max ) {\r\n\r\n\t\treturn Math.max( min, Math.min( max, value ) );\r\n\r\n\t},\r\n\r\n\t// compute euclidian modulo of m % n\r\n\t// https://en.wikipedia.org/wiki/Modulo_operation\r\n\r\n\teuclideanModulo: function ( n, m ) {\r\n\r\n\t\treturn ( ( n % m ) + m ) % m;\r\n\r\n\t},\r\n\r\n\t// Linear mapping from range <a1, a2> to range <b1, b2>\r\n\r\n\tmapLinear: function ( x, a1, a2, b1, b2 ) {\r\n\r\n\t\treturn b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );\r\n\r\n\t},\r\n\r\n\t// http://en.wikipedia.org/wiki/Smoothstep\r\n\r\n\tsmoothstep: function ( x, min, max ) {\r\n\r\n\t\tif ( x <= min ) return 0;\r\n\t\tif ( x >= max ) return 1;\r\n\r\n\t\tx = ( x - min ) / ( max - min );\r\n\r\n\t\treturn x * x * ( 3 - 2 * x );\r\n\r\n\t},\r\n\r\n\tsmootherstep: function ( x, min, max ) {\r\n\r\n\t\tif ( x <= min ) return 0;\r\n\t\tif ( x >= max ) return 1;\r\n\r\n\t\tx = ( x - min ) / ( max - min );\r\n\r\n\t\treturn x * x * x * ( x * ( x * 6 - 15 ) + 10 );\r\n\r\n\t},\r\n\r\n\trandom16: function () {\r\n\r\n\t\tconsole.warn( 'THREE.Math.random16() has been deprecated. Use Math.random() instead.' );\r\n\t\treturn Math.random();\r\n\r\n\t},\r\n\r\n\t// Random integer from <low, high> interval\r\n\r\n\trandInt: function ( low, high ) {\r\n\r\n\t\treturn low + Math.floor( Math.random() * ( high - low + 1 ) );\r\n\r\n\t},\r\n\r\n\t// Random float from <low, high> interval\r\n\r\n\trandFloat: function ( low, high ) {\r\n\r\n\t\treturn low + Math.random() * ( high - low );\r\n\r\n\t},\r\n\r\n\t// Random float from <-range/2, range/2> interval\r\n\r\n\trandFloatSpread: function ( range ) {\r\n\r\n\t\treturn range * ( 0.5 - Math.random() );\r\n\r\n\t},\r\n\r\n\tdegToRad: function ( degrees ) {\r\n\r\n\t\treturn degrees * THREE.Math.DEG2RAD;\r\n\r\n\t},\r\n\r\n\tradToDeg: function ( radians ) {\r\n\r\n\t\treturn radians * THREE.Math.RAD2DEG;\r\n\r\n\t},\r\n\r\n\tisPowerOfTwo: function ( value ) {\r\n\r\n\t\treturn ( value & ( value - 1 ) ) === 0 && value !== 0;\r\n\r\n\t},\r\n\r\n\tnearestPowerOfTwo: function ( value ) {\r\n\r\n\t\treturn Math.pow( 2, Math.round( Math.log( value ) / Math.LN2 ) );\r\n\r\n\t},\r\n\r\n\tnextPowerOfTwo: function ( value ) {\r\n\r\n\t\tvalue --;\r\n\t\tvalue |= value >> 1;\r\n\t\tvalue |= value >> 2;\r\n\t\tvalue |= value >> 4;\r\n\t\tvalue |= value >> 8;\r\n\t\tvalue |= value >> 16;\r\n\t\tvalue ++;\r\n\r\n\t\treturn value;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/math/Spline.js\r\n\r\n/**\r\n * Spline from Tween.js, slightly optimized (and trashed)\r\n * http://sole.github.com/tween.js/examples/05_spline.html\r\n *\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Spline = function ( points ) {\r\n\r\n\tthis.points = points;\r\n\r\n\tvar c = [], v3 = { x: 0, y: 0, z: 0 },\r\n\tpoint, intPoint, weight, w2, w3,\r\n\tpa, pb, pc, pd;\r\n\r\n\tthis.initFromArray = function ( a ) {\r\n\r\n\t\tthis.points = [];\r\n\r\n\t\tfor ( var i = 0; i < a.length; i ++ ) {\r\n\r\n\t\t\tthis.points[ i ] = { x: a[ i ][ 0 ], y: a[ i ][ 1 ], z: a[ i ][ 2 ] };\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.getPoint = function ( k ) {\r\n\r\n\t\tpoint = ( this.points.length - 1 ) * k;\r\n\t\tintPoint = Math.floor( point );\r\n\t\tweight = point - intPoint;\r\n\r\n\t\tc[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;\r\n\t\tc[ 1 ] = intPoint;\r\n\t\tc[ 2 ] = intPoint  > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;\r\n\t\tc[ 3 ] = intPoint  > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;\r\n\r\n\t\tpa = this.points[ c[ 0 ] ];\r\n\t\tpb = this.points[ c[ 1 ] ];\r\n\t\tpc = this.points[ c[ 2 ] ];\r\n\t\tpd = this.points[ c[ 3 ] ];\r\n\r\n\t\tw2 = weight * weight;\r\n\t\tw3 = weight * w2;\r\n\r\n\t\tv3.x = interpolate( pa.x, pb.x, pc.x, pd.x, weight, w2, w3 );\r\n\t\tv3.y = interpolate( pa.y, pb.y, pc.y, pd.y, weight, w2, w3 );\r\n\t\tv3.z = interpolate( pa.z, pb.z, pc.z, pd.z, weight, w2, w3 );\r\n\r\n\t\treturn v3;\r\n\r\n\t};\r\n\r\n\tthis.getControlPointsArray = function () {\r\n\r\n\t\tvar i, p, l = this.points.length,\r\n\t\t\tcoords = [];\r\n\r\n\t\tfor ( i = 0; i < l; i ++ ) {\r\n\r\n\t\t\tp = this.points[ i ];\r\n\t\t\tcoords[ i ] = [ p.x, p.y, p.z ];\r\n\r\n\t\t}\r\n\r\n\t\treturn coords;\r\n\r\n\t};\r\n\r\n\t// approximate length by summing linear segments\r\n\r\n\tthis.getLength = function ( nSubDivisions ) {\r\n\r\n\t\tvar i, index, nSamples, position,\r\n\t\t\tpoint = 0, intPoint = 0, oldIntPoint = 0,\r\n\t\t\toldPosition = new THREE.Vector3(),\r\n\t\t\ttmpVec = new THREE.Vector3(),\r\n\t\t\tchunkLengths = [],\r\n\t\t\ttotalLength = 0;\r\n\r\n\t\t// first point has 0 length\r\n\r\n\t\tchunkLengths[ 0 ] = 0;\r\n\r\n\t\tif ( ! nSubDivisions ) nSubDivisions = 100;\r\n\r\n\t\tnSamples = this.points.length * nSubDivisions;\r\n\r\n\t\toldPosition.copy( this.points[ 0 ] );\r\n\r\n\t\tfor ( i = 1; i < nSamples; i ++ ) {\r\n\r\n\t\t\tindex = i / nSamples;\r\n\r\n\t\t\tposition = this.getPoint( index );\r\n\t\t\ttmpVec.copy( position );\r\n\r\n\t\t\ttotalLength += tmpVec.distanceTo( oldPosition );\r\n\r\n\t\t\toldPosition.copy( position );\r\n\r\n\t\t\tpoint = ( this.points.length - 1 ) * index;\r\n\t\t\tintPoint = Math.floor( point );\r\n\r\n\t\t\tif ( intPoint !== oldIntPoint ) {\r\n\r\n\t\t\t\tchunkLengths[ intPoint ] = totalLength;\r\n\t\t\t\toldIntPoint = intPoint;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// last point ends with total length\r\n\r\n\t\tchunkLengths[ chunkLengths.length ] = totalLength;\r\n\r\n\t\treturn { chunks: chunkLengths, total: totalLength };\r\n\r\n\t};\r\n\r\n\tthis.reparametrizeByArcLength = function ( samplingCoef ) {\r\n\r\n\t\tvar i, j,\r\n\t\t\tindex, indexCurrent, indexNext,\r\n\t\t\trealDistance,\r\n\t\t\tsampling, position,\r\n\t\t\tnewpoints = [],\r\n\t\t\ttmpVec = new THREE.Vector3(),\r\n\t\t\tsl = this.getLength();\r\n\r\n\t\tnewpoints.push( tmpVec.copy( this.points[ 0 ] ).clone() );\r\n\r\n\t\tfor ( i = 1; i < this.points.length; i ++ ) {\r\n\r\n\t\t\t//tmpVec.copy( this.points[ i - 1 ] );\r\n\t\t\t//linearDistance = tmpVec.distanceTo( this.points[ i ] );\r\n\r\n\t\t\trealDistance = sl.chunks[ i ] - sl.chunks[ i - 1 ];\r\n\r\n\t\t\tsampling = Math.ceil( samplingCoef * realDistance / sl.total );\r\n\r\n\t\t\tindexCurrent = ( i - 1 ) / ( this.points.length - 1 );\r\n\t\t\tindexNext = i / ( this.points.length - 1 );\r\n\r\n\t\t\tfor ( j = 1; j < sampling - 1; j ++ ) {\r\n\r\n\t\t\t\tindex = indexCurrent + j * ( 1 / sampling ) * ( indexNext - indexCurrent );\r\n\r\n\t\t\t\tposition = this.getPoint( index );\r\n\t\t\t\tnewpoints.push( tmpVec.copy( position ).clone() );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tnewpoints.push( tmpVec.copy( this.points[ i ] ).clone() );\r\n\r\n\t\t}\r\n\r\n\t\tthis.points = newpoints;\r\n\r\n\t};\r\n\r\n\t// Catmull-Rom\r\n\r\n\tfunction interpolate( p0, p1, p2, p3, t, t2, t3 ) {\r\n\r\n\t\tvar v0 = ( p2 - p0 ) * 0.5,\r\n\t\t\tv1 = ( p3 - p1 ) * 0.5;\r\n\r\n\t\treturn ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/math/Triangle.js\r\n\r\n/**\r\n * @author bhouston / http://clara.io\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Triangle = function ( a, b, c ) {\r\n\r\n\tthis.a = ( a !== undefined ) ? a : new THREE.Vector3();\r\n\tthis.b = ( b !== undefined ) ? b : new THREE.Vector3();\r\n\tthis.c = ( c !== undefined ) ? c : new THREE.Vector3();\r\n\r\n};\r\n\r\nTHREE.Triangle.normal = function () {\r\n\r\n\tvar v0 = new THREE.Vector3();\r\n\r\n\treturn function ( a, b, c, optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\r\n\t\tresult.subVectors( c, b );\r\n\t\tv0.subVectors( a, b );\r\n\t\tresult.cross( v0 );\r\n\r\n\t\tvar resultLengthSq = result.lengthSq();\r\n\t\tif ( resultLengthSq > 0 ) {\r\n\r\n\t\t\treturn result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn result.set( 0, 0, 0 );\r\n\r\n\t};\r\n\r\n}();\r\n\r\n// static/instance method to calculate barycentric coordinates\r\n// based on: http://www.blackpawn.com/texts/pointinpoly/default.html\r\nTHREE.Triangle.barycoordFromPoint = function () {\r\n\r\n\tvar v0 = new THREE.Vector3();\r\n\tvar v1 = new THREE.Vector3();\r\n\tvar v2 = new THREE.Vector3();\r\n\r\n\treturn function ( point, a, b, c, optionalTarget ) {\r\n\r\n\t\tv0.subVectors( c, a );\r\n\t\tv1.subVectors( b, a );\r\n\t\tv2.subVectors( point, a );\r\n\r\n\t\tvar dot00 = v0.dot( v0 );\r\n\t\tvar dot01 = v0.dot( v1 );\r\n\t\tvar dot02 = v0.dot( v2 );\r\n\t\tvar dot11 = v1.dot( v1 );\r\n\t\tvar dot12 = v1.dot( v2 );\r\n\r\n\t\tvar denom = ( dot00 * dot11 - dot01 * dot01 );\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\r\n\t\t// collinear or singular triangle\r\n\t\tif ( denom === 0 ) {\r\n\r\n\t\t\t// arbitrary location outside of triangle?\r\n\t\t\t// not sure if this is the best idea, maybe should be returning undefined\r\n\t\t\treturn result.set( - 2, - 1, - 1 );\r\n\r\n\t\t}\r\n\r\n\t\tvar invDenom = 1 / denom;\r\n\t\tvar u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;\r\n\t\tvar v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;\r\n\r\n\t\t// barycentric coordinates must always sum to 1\r\n\t\treturn result.set( 1 - u - v, v, u );\r\n\r\n\t};\r\n\r\n}();\r\n\r\nTHREE.Triangle.containsPoint = function () {\r\n\r\n\tvar v1 = new THREE.Vector3();\r\n\r\n\treturn function ( point, a, b, c ) {\r\n\r\n\t\tvar result = THREE.Triangle.barycoordFromPoint( point, a, b, c, v1 );\r\n\r\n\t\treturn ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );\r\n\r\n\t};\r\n\r\n}();\r\n\r\nTHREE.Triangle.prototype = {\r\n\r\n\tconstructor: THREE.Triangle,\r\n\r\n\tset: function ( a, b, c ) {\r\n\r\n\t\tthis.a.copy( a );\r\n\t\tthis.b.copy( b );\r\n\t\tthis.c.copy( c );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromPointsAndIndices: function ( points, i0, i1, i2 ) {\r\n\r\n\t\tthis.a.copy( points[ i0 ] );\r\n\t\tthis.b.copy( points[ i1 ] );\r\n\t\tthis.c.copy( points[ i2 ] );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\r\n\t},\r\n\r\n\tcopy: function ( triangle ) {\r\n\r\n\t\tthis.a.copy( triangle.a );\r\n\t\tthis.b.copy( triangle.b );\r\n\t\tthis.c.copy( triangle.c );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tarea: function () {\r\n\r\n\t\tvar v0 = new THREE.Vector3();\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function () {\r\n\r\n\t\t\tv0.subVectors( this.c, this.b );\r\n\t\t\tv1.subVectors( this.a, this.b );\r\n\r\n\t\t\treturn v0.cross( v1 ).length() * 0.5;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tmidpoint: function ( optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\treturn result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );\r\n\r\n\t},\r\n\r\n\tnormal: function ( optionalTarget ) {\r\n\r\n\t\treturn THREE.Triangle.normal( this.a, this.b, this.c, optionalTarget );\r\n\r\n\t},\r\n\r\n\tplane: function ( optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Plane();\r\n\r\n\t\treturn result.setFromCoplanarPoints( this.a, this.b, this.c );\r\n\r\n\t},\r\n\r\n\tbarycoordFromPoint: function ( point, optionalTarget ) {\r\n\r\n\t\treturn THREE.Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );\r\n\r\n\t},\r\n\r\n\tcontainsPoint: function ( point ) {\r\n\r\n\t\treturn THREE.Triangle.containsPoint( point, this.a, this.b, this.c );\r\n\r\n\t},\r\n\r\n\tclosestPointToPoint: function () {\r\n\r\n\t\tvar plane, edgeList, projectedPoint, closestPoint;\r\n\r\n\t\treturn function closestPointToPoint( point, optionalTarget ) {\r\n\r\n\t\t\tif ( plane === undefined ) {\r\n\r\n\t\t\t\tplane = new THREE.Plane();\r\n\t\t\t\tedgeList = [ new THREE.Line3(), new THREE.Line3(), new THREE.Line3() ];\r\n\t\t\t\tprojectedPoint = new THREE.Vector3();\r\n\t\t\t\tclosestPoint = new THREE.Vector3();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\t\tvar minDistance = Infinity;\r\n\r\n\t\t\t// project the point onto the plane of the triangle\r\n\r\n\t\t\tplane.setFromCoplanarPoints( this.a, this.b, this.c );\r\n\t\t\tplane.projectPoint( point, projectedPoint );\r\n\r\n\t\t\t// check if the projection lies within the triangle\r\n\r\n\t\t\tif( this.containsPoint( projectedPoint ) === true ) {\r\n\r\n\t\t\t\t// if so, this is the closest point\r\n\r\n\t\t\t\tresult.copy( projectedPoint );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// if not, the point falls outside the triangle. the result is the closest point to the triangle's edges or vertices\r\n\r\n\t\t\t\tedgeList[ 0 ].set( this.a, this.b );\r\n\t\t\t\tedgeList[ 1 ].set( this.b, this.c );\r\n\t\t\t\tedgeList[ 2 ].set( this.c, this.a );\r\n\r\n\t\t\t\tfor( var i = 0; i < edgeList.length; i ++ ) {\r\n\r\n\t\t\t\t\tedgeList[ i ].closestPointToPoint( projectedPoint, true, closestPoint );\r\n\r\n\t\t\t\t\tvar distance = projectedPoint.distanceToSquared( closestPoint );\r\n\r\n\t\t\t\t\tif( distance < minDistance ) {\r\n\r\n\t\t\t\t\t\tminDistance = distance;\r\n\r\n\t\t\t\t\t\tresult.copy( closestPoint );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn result;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tequals: function ( triangle ) {\r\n\r\n\t\treturn triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/math/Interpolant.js\r\n\r\n/**\r\n * Abstract base class of interpolants over parametric samples.\r\n *\r\n * The parameter domain is one dimensional, typically the time or a path\r\n * along a curve defined by the data.\r\n *\r\n * The sample values can have any dimensionality and derived classes may\r\n * apply special interpretations to the data.\r\n *\r\n * This class provides the interval seek in a Template Method, deferring\r\n * the actual interpolation to derived classes.\r\n *\r\n * Time complexity is O(1) for linear access crossing at most two points\r\n * and O(log N) for random access, where N is the number of positions.\r\n *\r\n * References:\r\n *\r\n * \t\thttp://www.oodesign.com/template-method-pattern.html\r\n *\r\n * @author tschw\r\n */\r\n\r\nTHREE.Interpolant = function(\r\n\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\r\n\r\n\tthis.parameterPositions = parameterPositions;\r\n\tthis._cachedIndex = 0;\r\n\r\n\tthis.resultBuffer = resultBuffer !== undefined ?\r\n\t\t\tresultBuffer : new sampleValues.constructor( sampleSize );\r\n\tthis.sampleValues = sampleValues;\r\n\tthis.valueSize = sampleSize;\r\n\r\n};\r\n\r\nTHREE.Interpolant.prototype = {\r\n\r\n\tconstructor: THREE.Interpolant,\r\n\r\n\tevaluate: function( t ) {\r\n\r\n\t\tvar pp = this.parameterPositions,\r\n\t\t\ti1 = this._cachedIndex,\r\n\r\n\t\t\tt1 = pp[   i1   ],\r\n\t\t\tt0 = pp[ i1 - 1 ];\r\n\r\n\t\tvalidate_interval: {\r\n\r\n\t\t\tseek: {\r\n\r\n\t\t\t\tvar right;\r\n\r\n\t\t\t\tlinear_scan: {\r\n//- See http://jsperf.com/comparison-to-undefined/3\r\n//- slower code:\r\n//-\r\n//- \t\t\t\tif ( t >= t1 || t1 === undefined ) {\r\n\t\t\t\t\tforward_scan: if ( ! ( t < t1 ) ) {\r\n\r\n\t\t\t\t\t\tfor ( var giveUpAt = i1 + 2; ;) {\r\n\r\n\t\t\t\t\t\t\tif ( t1 === undefined ) {\r\n\r\n\t\t\t\t\t\t\t\tif ( t < t0 ) break forward_scan;\r\n\r\n\t\t\t\t\t\t\t\t// after end\r\n\r\n\t\t\t\t\t\t\t\ti1 = pp.length;\r\n\t\t\t\t\t\t\t\tthis._cachedIndex = i1;\r\n\t\t\t\t\t\t\t\treturn this.afterEnd_( i1 - 1, t, t0 );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif ( i1 === giveUpAt ) break; // this loop\r\n\r\n\t\t\t\t\t\t\tt0 = t1;\r\n\t\t\t\t\t\t\tt1 = pp[ ++ i1 ];\r\n\r\n\t\t\t\t\t\t\tif ( t < t1 ) {\r\n\r\n\t\t\t\t\t\t\t\t// we have arrived at the sought interval\r\n\t\t\t\t\t\t\t\tbreak seek;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// prepare binary search on the right side of the index\r\n\t\t\t\t\t\tright = pp.length;\r\n\t\t\t\t\t\tbreak linear_scan;\r\n\r\n\t\t\t\t\t}\r\n\r\n//- slower code:\r\n//-\t\t\t\t\tif ( t < t0 || t0 === undefined ) {\r\n\t\t\t\t\tif ( ! ( t >= t0 ) ) {\r\n\r\n\t\t\t\t\t\t// looping?\r\n\r\n\t\t\t\t\t\tvar t1global = pp[ 1 ];\r\n\r\n\t\t\t\t\t\tif ( t < t1global ) {\r\n\r\n\t\t\t\t\t\t\ti1 = 2; // + 1, using the scan for the details\r\n\t\t\t\t\t\t\tt0 = t1global;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// linear reverse scan\r\n\r\n\t\t\t\t\t\tfor ( var giveUpAt = i1 - 2; ;) {\r\n\r\n\t\t\t\t\t\t\tif ( t0 === undefined ) {\r\n\r\n\t\t\t\t\t\t\t\t// before start\r\n\r\n\t\t\t\t\t\t\t\tthis._cachedIndex = 0;\r\n\t\t\t\t\t\t\t\treturn this.beforeStart_( 0, t, t1 );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif ( i1 === giveUpAt ) break; // this loop\r\n\r\n\t\t\t\t\t\t\tt1 = t0;\r\n\t\t\t\t\t\t\tt0 = pp[ -- i1 - 1 ];\r\n\r\n\t\t\t\t\t\t\tif ( t >= t0 ) {\r\n\r\n\t\t\t\t\t\t\t\t// we have arrived at the sought interval\r\n\t\t\t\t\t\t\t\tbreak seek;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// prepare binary search on the left side of the index\r\n\t\t\t\t\t\tright = i1;\r\n\t\t\t\t\t\ti1 = 0;\r\n\t\t\t\t\t\tbreak linear_scan;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// the interval is valid\r\n\r\n\t\t\t\t\tbreak validate_interval;\r\n\r\n\t\t\t\t} // linear scan\r\n\r\n\t\t\t\t// binary search\r\n\r\n\t\t\t\twhile ( i1 < right ) {\r\n\r\n\t\t\t\t\tvar mid = ( i1 + right ) >>> 1;\r\n\r\n\t\t\t\t\tif ( t < pp[ mid ] ) {\r\n\r\n\t\t\t\t\t\tright = mid;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\ti1 = mid + 1;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tt1 = pp[   i1   ];\r\n\t\t\t\tt0 = pp[ i1 - 1 ];\r\n\r\n\t\t\t\t// check boundary cases, again\r\n\r\n\t\t\t\tif ( t0 === undefined ) {\r\n\r\n\t\t\t\t\tthis._cachedIndex = 0;\r\n\t\t\t\t\treturn this.beforeStart_( 0, t, t1 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( t1 === undefined ) {\r\n\r\n\t\t\t\t\ti1 = pp.length;\r\n\t\t\t\t\tthis._cachedIndex = i1;\r\n\t\t\t\t\treturn this.afterEnd_( i1 - 1, t0, t );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} // seek\r\n\r\n\t\t\tthis._cachedIndex = i1;\r\n\r\n\t\t\tthis.intervalChanged_( i1, t0, t1 );\r\n\r\n\t\t} // validate_interval\r\n\r\n\t\treturn this.interpolate_( i1, t0, t, t1 );\r\n\r\n\t},\r\n\r\n\tsettings: null, // optional, subclass-specific settings structure\r\n\t// Note: The indirection allows central control of many interpolants.\r\n\r\n\t// --- Protected interface\r\n\r\n\tDefaultSettings_: {},\r\n\r\n\tgetSettings_: function() {\r\n\r\n\t\treturn this.settings || this.DefaultSettings_;\r\n\r\n\t},\r\n\r\n\tcopySampleValue_: function( index ) {\r\n\r\n\t\t// copies a sample value to the result buffer\r\n\r\n\t\tvar result = this.resultBuffer,\r\n\t\t\tvalues = this.sampleValues,\r\n\t\t\tstride = this.valueSize,\r\n\t\t\toffset = index * stride;\r\n\r\n\t\tfor ( var i = 0; i !== stride; ++ i ) {\r\n\r\n\t\t\tresult[ i ] = values[ offset + i ];\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t},\r\n\r\n\t// Template methods for derived classes:\r\n\r\n\tinterpolate_: function( i1, t0, t, t1 ) {\r\n\r\n\t\tthrow new Error( \"call to abstract method\" );\r\n\t\t// implementations shall return this.resultBuffer\r\n\r\n\t},\r\n\r\n\tintervalChanged_: function( i1, t0, t1 ) {\r\n\r\n\t\t// empty\r\n\r\n\t}\r\n\r\n};\r\n\r\nObject.assign( THREE.Interpolant.prototype, {\r\n\r\n\tbeforeStart_: //( 0, t, t0 ), returns this.resultBuffer\r\n\t\tTHREE.Interpolant.prototype.copySampleValue_,\r\n\r\n\tafterEnd_: //( N-1, tN-1, t ), returns this.resultBuffer\r\n\t\tTHREE.Interpolant.prototype.copySampleValue_\r\n\r\n} );\r\n\r\n// File:src/math/interpolants/CubicInterpolant.js\r\n\r\n/**\r\n * Fast and simple cubic spline interpolant.\r\n *\r\n * It was derived from a Hermitian construction setting the first derivative\r\n * at each sample position to the linear slope between neighboring positions\r\n * over their parameter interval.\r\n *\r\n * @author tschw\r\n */\r\n\r\nTHREE.CubicInterpolant = function(\r\n\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\r\n\r\n\tTHREE.Interpolant.call(\r\n\t\t\tthis, parameterPositions, sampleValues, sampleSize, resultBuffer );\r\n\r\n\tthis._weightPrev = -0;\r\n\tthis._offsetPrev = -0;\r\n\tthis._weightNext = -0;\r\n\tthis._offsetNext = -0;\r\n\r\n};\r\n\r\nTHREE.CubicInterpolant.prototype =\r\n\t\tObject.assign( Object.create( THREE.Interpolant.prototype ), {\r\n\r\n\tconstructor: THREE.CubicInterpolant,\r\n\r\n\tDefaultSettings_: {\r\n\r\n\t\tendingStart: \tTHREE.ZeroCurvatureEnding,\r\n\t\tendingEnd:\t\tTHREE.ZeroCurvatureEnding\r\n\r\n\t},\r\n\r\n\tintervalChanged_: function( i1, t0, t1 ) {\r\n\r\n\t\tvar pp = this.parameterPositions,\r\n\t\t\tiPrev = i1 - 2,\r\n\t\t\tiNext = i1 + 1,\r\n\r\n\t\t\ttPrev = pp[ iPrev ],\r\n\t\t\ttNext = pp[ iNext ];\r\n\r\n\t\tif ( tPrev === undefined ) {\r\n\r\n\t\t\tswitch ( this.getSettings_().endingStart ) {\r\n\r\n\t\t\t\tcase THREE.ZeroSlopeEnding:\r\n\r\n\t\t\t\t\t// f'(t0) = 0\r\n\t\t\t\t\tiPrev = i1;\r\n\t\t\t\t\ttPrev = 2 * t0 - t1;\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase THREE.WrapAroundEnding:\r\n\r\n\t\t\t\t\t// use the other end of the curve\r\n\t\t\t\t\tiPrev = pp.length - 2;\r\n\t\t\t\t\ttPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tdefault: // ZeroCurvatureEnding\r\n\r\n\t\t\t\t\t// f''(t0) = 0 a.k.a. Natural Spline\r\n\t\t\t\t\tiPrev = i1;\r\n\t\t\t\t\ttPrev = t1;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( tNext === undefined ) {\r\n\r\n\t\t\tswitch ( this.getSettings_().endingEnd ) {\r\n\r\n\t\t\t\tcase THREE.ZeroSlopeEnding:\r\n\r\n\t\t\t\t\t// f'(tN) = 0\r\n\t\t\t\t\tiNext = i1;\r\n\t\t\t\t\ttNext = 2 * t1 - t0;\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase THREE.WrapAroundEnding:\r\n\r\n\t\t\t\t\t// use the other end of the curve\r\n\t\t\t\t\tiNext = 1;\r\n\t\t\t\t\ttNext = t1 + pp[ 1 ] - pp[ 0 ];\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tdefault: // ZeroCurvatureEnding\r\n\r\n\t\t\t\t\t// f''(tN) = 0, a.k.a. Natural Spline\r\n\t\t\t\t\tiNext = i1 - 1;\r\n\t\t\t\t\ttNext = t0;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar halfDt = ( t1 - t0 ) * 0.5,\r\n\t\t\tstride = this.valueSize;\r\n\r\n\t\tthis._weightPrev = halfDt / ( t0 - tPrev );\r\n\t\tthis._weightNext = halfDt / ( tNext - t1 );\r\n\t\tthis._offsetPrev = iPrev * stride;\r\n\t\tthis._offsetNext = iNext * stride;\r\n\r\n\t},\r\n\r\n\tinterpolate_: function( i1, t0, t, t1 ) {\r\n\r\n\t\tvar result = this.resultBuffer,\r\n\t\t\tvalues = this.sampleValues,\r\n\t\t\tstride = this.valueSize,\r\n\r\n\t\t\to1 = i1 * stride,\t\to0 = o1 - stride,\r\n\t\t\toP = this._offsetPrev, \toN = this._offsetNext,\r\n\t\t\twP = this._weightPrev,\twN = this._weightNext,\r\n\r\n\t\t\tp = ( t - t0 ) / ( t1 - t0 ),\r\n\t\t\tpp = p * p,\r\n\t\t\tppp = pp * p;\r\n\r\n\t\t// evaluate polynomials\r\n\r\n\t\tvar sP =     - wP   * ppp   +         2 * wP    * pp    -          wP   * p;\r\n\t\tvar s0 = ( 1 + wP ) * ppp   + (-1.5 - 2 * wP )  * pp    + ( -0.5 + wP ) * p     + 1;\r\n\t\tvar s1 = (-1 - wN ) * ppp   + ( 1.5 +   wN   )  * pp    +    0.5        * p;\r\n\t\tvar sN =       wN   * ppp   -           wN      * pp;\r\n\r\n\t\t// combine data linearly\r\n\r\n\t\tfor ( var i = 0; i !== stride; ++ i ) {\r\n\r\n\t\t\tresult[ i ] =\r\n\t\t\t\t\tsP * values[ oP + i ] +\r\n\t\t\t\t\ts0 * values[ o0 + i ] +\r\n\t\t\t\t\ts1 * values[ o1 + i ] +\r\n\t\t\t\t\tsN * values[ oN + i ];\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n} );\r\n\r\n// File:src/math/interpolants/DiscreteInterpolant.js\r\n\r\n/**\r\n *\r\n * Interpolant that evaluates to the sample value at the position preceeding\r\n * the parameter.\r\n *\r\n * @author tschw\r\n */\r\n\r\nTHREE.DiscreteInterpolant = function(\r\n\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\r\n\r\n\tTHREE.Interpolant.call(\r\n\t\t\tthis, parameterPositions, sampleValues, sampleSize, resultBuffer );\r\n\r\n};\r\n\r\nTHREE.DiscreteInterpolant.prototype =\r\n\t\tObject.assign( Object.create( THREE.Interpolant.prototype ), {\r\n\r\n\tconstructor: THREE.DiscreteInterpolant,\r\n\r\n\tinterpolate_: function( i1, t0, t, t1 ) {\r\n\r\n\t\treturn this.copySampleValue_( i1 - 1 );\r\n\r\n\t}\r\n\r\n} );\r\n\r\n// File:src/math/interpolants/LinearInterpolant.js\r\n\r\n/**\r\n * @author tschw\r\n */\r\n\r\nTHREE.LinearInterpolant = function(\r\n\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\r\n\r\n\tTHREE.Interpolant.call(\r\n\t\t\tthis, parameterPositions, sampleValues, sampleSize, resultBuffer );\r\n\r\n};\r\n\r\nTHREE.LinearInterpolant.prototype =\r\n\t\tObject.assign( Object.create( THREE.Interpolant.prototype ), {\r\n\r\n\tconstructor: THREE.LinearInterpolant,\r\n\r\n\tinterpolate_: function( i1, t0, t, t1 ) {\r\n\r\n\t\tvar result = this.resultBuffer,\r\n\t\t\tvalues = this.sampleValues,\r\n\t\t\tstride = this.valueSize,\r\n\r\n\t\t\toffset1 = i1 * stride,\r\n\t\t\toffset0 = offset1 - stride,\r\n\r\n\t\t\tweight1 = ( t - t0 ) / ( t1 - t0 ),\r\n\t\t\tweight0 = 1 - weight1;\r\n\r\n\t\tfor ( var i = 0; i !== stride; ++ i ) {\r\n\r\n\t\t\tresult[ i ] =\r\n\t\t\t\t\tvalues[ offset0 + i ] * weight0 +\r\n\t\t\t\t\tvalues[ offset1 + i ] * weight1;\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n} );\r\n\r\n// File:src/math/interpolants/QuaternionLinearInterpolant.js\r\n\r\n/**\r\n * Spherical linear unit quaternion interpolant.\r\n *\r\n * @author tschw\r\n */\r\n\r\nTHREE.QuaternionLinearInterpolant = function(\r\n\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\r\n\r\n\tTHREE.Interpolant.call(\r\n\t\t\tthis, parameterPositions, sampleValues, sampleSize, resultBuffer );\r\n\r\n};\r\n\r\nTHREE.QuaternionLinearInterpolant.prototype =\r\n\t\tObject.assign( Object.create( THREE.Interpolant.prototype ), {\r\n\r\n\tconstructor: THREE.QuaternionLinearInterpolant,\r\n\r\n\tinterpolate_: function( i1, t0, t, t1 ) {\r\n\r\n\t\tvar result = this.resultBuffer,\r\n\t\t\tvalues = this.sampleValues,\r\n\t\t\tstride = this.valueSize,\r\n\r\n\t\t\toffset = i1 * stride,\r\n\r\n\t\t\talpha = ( t - t0 ) / ( t1 - t0 );\r\n\r\n\t\tfor ( var end = offset + stride; offset !== end; offset += 4 ) {\r\n\r\n\t\t\tTHREE.Quaternion.slerpFlat( result, 0,\r\n\t\t\t\t\tvalues, offset - stride, values, offset, alpha );\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n} );\r\n\r\n// File:src/core/Clock.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Clock = function ( autoStart ) {\r\n\r\n\tthis.autoStart = ( autoStart !== undefined ) ? autoStart : true;\r\n\r\n\tthis.startTime = 0;\r\n\tthis.oldTime = 0;\r\n\tthis.elapsedTime = 0;\r\n\r\n\tthis.running = false;\r\n\r\n};\r\n\r\nTHREE.Clock.prototype = {\r\n\r\n\tconstructor: THREE.Clock,\r\n\r\n\tstart: function () {\r\n\r\n\t\tthis.startTime = ( performance || Date ).now();\r\n\r\n\t\tthis.oldTime = this.startTime;\r\n\t\tthis.running = true;\r\n\r\n\t},\r\n\r\n\tstop: function () {\r\n\r\n\t\tthis.getElapsedTime();\r\n\t\tthis.running = false;\r\n\r\n\t},\r\n\r\n\tgetElapsedTime: function () {\r\n\r\n\t\tthis.getDelta();\r\n\t\treturn this.elapsedTime;\r\n\r\n\t},\r\n\r\n\tgetDelta: function () {\r\n\r\n\t\tvar diff = 0;\r\n\r\n\t\tif ( this.autoStart && ! this.running ) {\r\n\r\n\t\t\tthis.start();\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.running ) {\r\n\r\n\t\t\tvar newTime = ( performance || Date ).now();\r\n\r\n\t\t\tdiff = ( newTime - this.oldTime ) / 1000;\r\n\t\t\tthis.oldTime = newTime;\r\n\r\n\t\t\tthis.elapsedTime += diff;\r\n\r\n\t\t}\r\n\r\n\t\treturn diff;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/core/EventDispatcher.js\r\n\r\n/**\r\n * https://github.com/mrdoob/eventdispatcher.js/\r\n */\r\n\r\nTHREE.EventDispatcher = function () {};\r\n\r\nTHREE.EventDispatcher.prototype = {\r\n\r\n\tconstructor: THREE.EventDispatcher,\r\n\r\n\tapply: function ( object ) {\r\n\r\n\t\tobject.addEventListener = THREE.EventDispatcher.prototype.addEventListener;\r\n\t\tobject.hasEventListener = THREE.EventDispatcher.prototype.hasEventListener;\r\n\t\tobject.removeEventListener = THREE.EventDispatcher.prototype.removeEventListener;\r\n\t\tobject.dispatchEvent = THREE.EventDispatcher.prototype.dispatchEvent;\r\n\r\n\t},\r\n\r\n\taddEventListener: function ( type, listener ) {\r\n\r\n\t\tif ( this._listeners === undefined ) this._listeners = {};\r\n\r\n\t\tvar listeners = this._listeners;\r\n\r\n\t\tif ( listeners[ type ] === undefined ) {\r\n\r\n\t\t\tlisteners[ type ] = [];\r\n\r\n\t\t}\r\n\r\n\t\tif ( listeners[ type ].indexOf( listener ) === - 1 ) {\r\n\r\n\t\t\tlisteners[ type ].push( listener );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\thasEventListener: function ( type, listener ) {\r\n\r\n\t\tif ( this._listeners === undefined ) return false;\r\n\r\n\t\tvar listeners = this._listeners;\r\n\r\n\t\tif ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\r\n\t},\r\n\r\n\tremoveEventListener: function ( type, listener ) {\r\n\r\n\t\tif ( this._listeners === undefined ) return;\r\n\r\n\t\tvar listeners = this._listeners;\r\n\t\tvar listenerArray = listeners[ type ];\r\n\r\n\t\tif ( listenerArray !== undefined ) {\r\n\r\n\t\t\tvar index = listenerArray.indexOf( listener );\r\n\r\n\t\t\tif ( index !== - 1 ) {\r\n\r\n\t\t\t\tlistenerArray.splice( index, 1 );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tdispatchEvent: function ( event ) {\r\n\r\n\t\tif ( this._listeners === undefined ) return;\r\n\r\n\t\tvar listeners = this._listeners;\r\n\t\tvar listenerArray = listeners[ event.type ];\r\n\r\n\t\tif ( listenerArray !== undefined ) {\r\n\r\n\t\t\tevent.target = this;\r\n\r\n\t\t\tvar array = [];\r\n\t\t\tvar length = listenerArray.length;\r\n\r\n\t\t\tfor ( var i = 0; i < length; i ++ ) {\r\n\r\n\t\t\t\tarray[ i ] = listenerArray[ i ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var i = 0; i < length; i ++ ) {\r\n\r\n\t\t\t\tarray[ i ].call( this, event );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/core/Layers.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Layers = function () {\r\n\r\n\tthis.mask = 1;\r\n\r\n};\r\n\r\nTHREE.Layers.prototype = {\r\n\r\n\tconstructor: THREE.Layers,\r\n\r\n\tset: function ( channel ) {\r\n\r\n\t\tthis.mask = 1 << channel;\r\n\r\n\t},\r\n\r\n\tenable: function ( channel ) {\r\n\r\n\t\tthis.mask |= 1 << channel;\r\n\r\n\t},\r\n\r\n\ttoggle: function ( channel ) {\r\n\r\n\t\tthis.mask ^= 1 << channel;\r\n\r\n\t},\r\n\r\n\tdisable: function ( channel ) {\r\n\r\n\t\tthis.mask &= ~ ( 1 << channel );\r\n\r\n\t},\r\n\r\n\ttest: function ( layers ) {\r\n\r\n\t\treturn ( this.mask & layers.mask ) !== 0;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/core/Raycaster.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author bhouston / http://clara.io/\r\n * @author stephomi / http://stephaneginier.com/\r\n */\r\n\r\n( function ( THREE ) {\r\n\r\n\tTHREE.Raycaster = function ( origin, direction, near, far ) {\r\n\r\n\t\tthis.ray = new THREE.Ray( origin, direction );\r\n\t\t// direction is assumed to be normalized (for accurate distance calculations)\r\n\r\n\t\tthis.near = near || 0;\r\n\t\tthis.far = far || Infinity;\r\n\r\n\t\tthis.params = {\r\n\t\t\tMesh: {},\r\n\t\t\tLine: {},\r\n\t\t\tLOD: {},\r\n\t\t\tPoints: { threshold: 1 },\r\n\t\t\tSprite: {}\r\n\t\t};\r\n\r\n\t\tObject.defineProperties( this.params, {\r\n\t\t\tPointCloud: {\r\n\t\t\t\tget: function () {\r\n\t\t\t\t\tconsole.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );\r\n\t\t\t\t\treturn this.Points;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} );\r\n\r\n\t};\r\n\r\n\tfunction ascSort( a, b ) {\r\n\r\n\t\treturn a.distance - b.distance;\r\n\r\n\t}\r\n\r\n\tfunction intersectObject( object, raycaster, intersects, recursive ) {\r\n\r\n\t\tif ( object.visible === false ) return;\r\n\r\n\t\tobject.raycast( raycaster, intersects );\r\n\r\n\t\tif ( recursive === true ) {\r\n\r\n\t\t\tvar children = object.children;\r\n\r\n\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tintersectObject( children[ i ], raycaster, intersects, true );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t//\r\n\r\n\tTHREE.Raycaster.prototype = {\r\n\r\n\t\tconstructor: THREE.Raycaster,\r\n\r\n\t\tlinePrecision: 1,\r\n\r\n\t\tset: function ( origin, direction ) {\r\n\r\n\t\t\t// direction is assumed to be normalized (for accurate distance calculations)\r\n\r\n\t\t\tthis.ray.set( origin, direction );\r\n\r\n\t\t},\r\n\r\n\t\tsetFromCamera: function ( coords, camera ) {\r\n\r\n\t\t\tif ( camera instanceof THREE.PerspectiveCamera ) {\r\n\r\n\t\t\t\tthis.ray.origin.setFromMatrixPosition( camera.matrixWorld );\r\n\t\t\t\tthis.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();\r\n\r\n\t\t\t} else if ( camera instanceof THREE.OrthographicCamera ) {\r\n\r\n\t\t\t\tthis.ray.origin.set( coords.x, coords.y, - 1 ).unproject( camera );\r\n\t\t\t\tthis.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tconsole.error( 'THREE.Raycaster: Unsupported camera type.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\tintersectObject: function ( object, recursive ) {\r\n\r\n\t\t\tvar intersects = [];\r\n\r\n\t\t\tintersectObject( object, this, intersects, recursive );\r\n\r\n\t\t\tintersects.sort( ascSort );\r\n\r\n\t\t\treturn intersects;\r\n\r\n\t\t},\r\n\r\n\t\tintersectObjects: function ( objects, recursive ) {\r\n\r\n\t\t\tvar intersects = [];\r\n\r\n\t\t\tif ( Array.isArray( objects ) === false ) {\r\n\r\n\t\t\t\tconsole.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );\r\n\t\t\t\treturn intersects;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var i = 0, l = objects.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tintersectObject( objects[ i ], this, intersects, recursive );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tintersects.sort( ascSort );\r\n\r\n\t\t\treturn intersects;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n}( THREE ) );\r\n\r\n// File:src/core/Object3D.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n * @author elephantatwork / www.elephantatwork.ch\r\n */\r\n\r\nTHREE.Object3D = function () {\r\n\r\n\tObject.defineProperty( this, 'id', { value: THREE.Object3DIdCount ++ } );\r\n\r\n\tthis.uuid = THREE.Math.generateUUID();\r\n\r\n\tthis.name = '';\r\n\tthis.type = 'Object3D';\r\n\r\n\tthis.parent = null;\r\n\tthis.children = [];\r\n\r\n\tthis.up = THREE.Object3D.DefaultUp.clone();\r\n\r\n\tvar position = new THREE.Vector3();\r\n\tvar rotation = new THREE.Euler();\r\n\tvar quaternion = new THREE.Quaternion();\r\n\tvar scale = new THREE.Vector3( 1, 1, 1 );\r\n\r\n\tfunction onRotationChange() {\r\n\r\n\t\tquaternion.setFromEuler( rotation, false );\r\n\r\n\t}\r\n\r\n\tfunction onQuaternionChange() {\r\n\r\n\t\trotation.setFromQuaternion( quaternion, undefined, false );\r\n\r\n\t}\r\n\r\n\trotation.onChange( onRotationChange );\r\n\tquaternion.onChange( onQuaternionChange );\r\n\r\n\tObject.defineProperties( this, {\r\n\t\tposition: {\r\n\t\t\tenumerable: true,\r\n\t\t\tvalue: position\r\n\t\t},\r\n\t\trotation: {\r\n\t\t\tenumerable: true,\r\n\t\t\tvalue: rotation\r\n\t\t},\r\n\t\tquaternion: {\r\n\t\t\tenumerable: true,\r\n\t\t\tvalue: quaternion\r\n\t\t},\r\n\t\tscale: {\r\n\t\t\tenumerable: true,\r\n\t\t\tvalue: scale\r\n\t\t},\r\n\t\tmodelViewMatrix: {\r\n\t\t\tvalue: new THREE.Matrix4()\r\n\t\t},\r\n\t\tnormalMatrix: {\r\n\t\t\tvalue: new THREE.Matrix3()\r\n\t\t}\r\n\t} );\r\n\r\n\tthis.rotationAutoUpdate = true;\r\n\r\n\tthis.matrix = new THREE.Matrix4();\r\n\tthis.matrixWorld = new THREE.Matrix4();\r\n\r\n\tthis.matrixAutoUpdate = THREE.Object3D.DefaultMatrixAutoUpdate;\r\n\tthis.matrixWorldNeedsUpdate = false;\r\n\r\n\tthis.layers = new THREE.Layers();\r\n\tthis.visible = true;\r\n\r\n\tthis.castShadow = false;\r\n\tthis.receiveShadow = false;\r\n\r\n\tthis.frustumCulled = true;\r\n\tthis.renderOrder = 0;\r\n\r\n\tthis.userData = {};\r\n\r\n};\r\n\r\nTHREE.Object3D.DefaultUp = new THREE.Vector3( 0, 1, 0 );\r\nTHREE.Object3D.DefaultMatrixAutoUpdate = true;\r\n\r\nTHREE.Object3D.prototype = {\r\n\r\n\tconstructor: THREE.Object3D,\r\n\r\n\tapplyMatrix: function ( matrix ) {\r\n\r\n\t\tthis.matrix.multiplyMatrices( matrix, this.matrix );\r\n\r\n\t\tthis.matrix.decompose( this.position, this.quaternion, this.scale );\r\n\r\n\t},\r\n\r\n\tsetRotationFromAxisAngle: function ( axis, angle ) {\r\n\r\n\t\t// assumes axis is normalized\r\n\r\n\t\tthis.quaternion.setFromAxisAngle( axis, angle );\r\n\r\n\t},\r\n\r\n\tsetRotationFromEuler: function ( euler ) {\r\n\r\n\t\tthis.quaternion.setFromEuler( euler, true );\r\n\r\n\t},\r\n\r\n\tsetRotationFromMatrix: function ( m ) {\r\n\r\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\r\n\r\n\t\tthis.quaternion.setFromRotationMatrix( m );\r\n\r\n\t},\r\n\r\n\tsetRotationFromQuaternion: function ( q ) {\r\n\r\n\t\t// assumes q is normalized\r\n\r\n\t\tthis.quaternion.copy( q );\r\n\r\n\t},\r\n\r\n\trotateOnAxis: function () {\r\n\r\n\t\t// rotate object on axis in object space\r\n\t\t// axis is assumed to be normalized\r\n\r\n\t\tvar q1 = new THREE.Quaternion();\r\n\r\n\t\treturn function ( axis, angle ) {\r\n\r\n\t\t\tq1.setFromAxisAngle( axis, angle );\r\n\r\n\t\t\tthis.quaternion.multiply( q1 );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\trotateX: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3( 1, 0, 0 );\r\n\r\n\t\treturn function ( angle ) {\r\n\r\n\t\t\treturn this.rotateOnAxis( v1, angle );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\trotateY: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3( 0, 1, 0 );\r\n\r\n\t\treturn function ( angle ) {\r\n\r\n\t\t\treturn this.rotateOnAxis( v1, angle );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\trotateZ: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3( 0, 0, 1 );\r\n\r\n\t\treturn function ( angle ) {\r\n\r\n\t\t\treturn this.rotateOnAxis( v1, angle );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\ttranslateOnAxis: function () {\r\n\r\n\t\t// translate object by distance along axis in object space\r\n\t\t// axis is assumed to be normalized\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function ( axis, distance ) {\r\n\r\n\t\t\tv1.copy( axis ).applyQuaternion( this.quaternion );\r\n\r\n\t\t\tthis.position.add( v1.multiplyScalar( distance ) );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\ttranslateX: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3( 1, 0, 0 );\r\n\r\n\t\treturn function ( distance ) {\r\n\r\n\t\t\treturn this.translateOnAxis( v1, distance );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\ttranslateY: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3( 0, 1, 0 );\r\n\r\n\t\treturn function ( distance ) {\r\n\r\n\t\t\treturn this.translateOnAxis( v1, distance );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\ttranslateZ: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3( 0, 0, 1 );\r\n\r\n\t\treturn function ( distance ) {\r\n\r\n\t\t\treturn this.translateOnAxis( v1, distance );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tlocalToWorld: function ( vector ) {\r\n\r\n\t\treturn vector.applyMatrix4( this.matrixWorld );\r\n\r\n\t},\r\n\r\n\tworldToLocal: function () {\r\n\r\n\t\tvar m1 = new THREE.Matrix4();\r\n\r\n\t\treturn function ( vector ) {\r\n\r\n\t\t\treturn vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tlookAt: function () {\r\n\r\n\t\t// This routine does not support objects with rotated and/or translated parent(s)\r\n\r\n\t\tvar m1 = new THREE.Matrix4();\r\n\r\n\t\treturn function ( vector ) {\r\n\r\n\t\t\tm1.lookAt( vector, this.position, this.up );\r\n\r\n\t\t\tthis.quaternion.setFromRotationMatrix( m1 );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tadd: function ( object ) {\r\n\r\n\t\tif ( arguments.length > 1 ) {\r\n\r\n\t\t\tfor ( var i = 0; i < arguments.length; i ++ ) {\r\n\r\n\t\t\t\tthis.add( arguments[ i ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\tif ( object === this ) {\r\n\r\n\t\t\tconsole.error( \"THREE.Object3D.add: object can't be added as a child of itself.\", object );\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\tif ( object instanceof THREE.Object3D ) {\r\n\r\n\t\t\tif ( object.parent !== null ) {\r\n\r\n\t\t\t\tobject.parent.remove( object );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tobject.parent = this;\r\n\t\t\tobject.dispatchEvent( { type: 'added' } );\r\n\r\n\t\t\tthis.children.push( object );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconsole.error( \"THREE.Object3D.add: object not an instance of THREE.Object3D.\", object );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tremove: function ( object ) {\r\n\r\n\t\tif ( arguments.length > 1 ) {\r\n\r\n\t\t\tfor ( var i = 0; i < arguments.length; i ++ ) {\r\n\r\n\t\t\t\tthis.remove( arguments[ i ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar index = this.children.indexOf( object );\r\n\r\n\t\tif ( index !== - 1 ) {\r\n\r\n\t\t\tobject.parent = null;\r\n\r\n\t\t\tobject.dispatchEvent( { type: 'removed' } );\r\n\r\n\t\t\tthis.children.splice( index, 1 );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tgetObjectById: function ( id ) {\r\n\r\n\t\treturn this.getObjectByProperty( 'id', id );\r\n\r\n\t},\r\n\r\n\tgetObjectByName: function ( name ) {\r\n\r\n\t\treturn this.getObjectByProperty( 'name', name );\r\n\r\n\t},\r\n\r\n\tgetObjectByProperty: function ( name, value ) {\r\n\r\n\t\tif ( this[ name ] === value ) return this;\r\n\r\n\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar child = this.children[ i ];\r\n\t\t\tvar object = child.getObjectByProperty( name, value );\r\n\r\n\t\t\tif ( object !== undefined ) {\r\n\r\n\t\t\t\treturn object;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn undefined;\r\n\r\n\t},\r\n\r\n\tgetWorldPosition: function ( optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\r\n\t\tthis.updateMatrixWorld( true );\r\n\r\n\t\treturn result.setFromMatrixPosition( this.matrixWorld );\r\n\r\n\t},\r\n\r\n\tgetWorldQuaternion: function () {\r\n\r\n\t\tvar position = new THREE.Vector3();\r\n\t\tvar scale = new THREE.Vector3();\r\n\r\n\t\treturn function ( optionalTarget ) {\r\n\r\n\t\t\tvar result = optionalTarget || new THREE.Quaternion();\r\n\r\n\t\t\tthis.updateMatrixWorld( true );\r\n\r\n\t\t\tthis.matrixWorld.decompose( position, result, scale );\r\n\r\n\t\t\treturn result;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tgetWorldRotation: function () {\r\n\r\n\t\tvar quaternion = new THREE.Quaternion();\r\n\r\n\t\treturn function ( optionalTarget ) {\r\n\r\n\t\t\tvar result = optionalTarget || new THREE.Euler();\r\n\r\n\t\t\tthis.getWorldQuaternion( quaternion );\r\n\r\n\t\t\treturn result.setFromQuaternion( quaternion, this.rotation.order, false );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tgetWorldScale: function () {\r\n\r\n\t\tvar position = new THREE.Vector3();\r\n\t\tvar quaternion = new THREE.Quaternion();\r\n\r\n\t\treturn function ( optionalTarget ) {\r\n\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\r\n\t\t\tthis.updateMatrixWorld( true );\r\n\r\n\t\t\tthis.matrixWorld.decompose( position, quaternion, result );\r\n\r\n\t\t\treturn result;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tgetWorldDirection: function () {\r\n\r\n\t\tvar quaternion = new THREE.Quaternion();\r\n\r\n\t\treturn function ( optionalTarget ) {\r\n\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\r\n\t\t\tthis.getWorldQuaternion( quaternion );\r\n\r\n\t\t\treturn result.set( 0, 0, 1 ).applyQuaternion( quaternion );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\traycast: function () {},\r\n\r\n\ttraverse: function ( callback ) {\r\n\r\n\t\tcallback( this );\r\n\r\n\t\tvar children = this.children;\r\n\r\n\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\r\n\r\n\t\t\tchildren[ i ].traverse( callback );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\ttraverseVisible: function ( callback ) {\r\n\r\n\t\tif ( this.visible === false ) return;\r\n\r\n\t\tcallback( this );\r\n\r\n\t\tvar children = this.children;\r\n\r\n\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\r\n\r\n\t\t\tchildren[ i ].traverseVisible( callback );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\ttraverseAncestors: function ( callback ) {\r\n\r\n\t\tvar parent = this.parent;\r\n\r\n\t\tif ( parent !== null ) {\r\n\r\n\t\t\tcallback( parent );\r\n\r\n\t\t\tparent.traverseAncestors( callback );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tupdateMatrix: function () {\r\n\r\n\t\tthis.matrix.compose( this.position, this.quaternion, this.scale );\r\n\r\n\t\tthis.matrixWorldNeedsUpdate = true;\r\n\r\n\t},\r\n\r\n\tupdateMatrixWorld: function ( force ) {\r\n\r\n\t\tif ( this.matrixAutoUpdate === true ) this.updateMatrix();\r\n\r\n\t\tif ( this.matrixWorldNeedsUpdate === true || force === true ) {\r\n\r\n\t\t\tif ( this.parent === null ) {\r\n\r\n\t\t\t\tthis.matrixWorld.copy( this.matrix );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.matrixWorldNeedsUpdate = false;\r\n\r\n\t\t\tforce = true;\r\n\r\n\t\t}\r\n\r\n\t\t// update children\r\n\r\n\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\r\n\r\n\t\t\tthis.children[ i ].updateMatrixWorld( force );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\ttoJSON: function ( meta ) {\r\n\r\n\t\t// meta is '' when called from JSON.stringify\r\n\t\tvar isRootObject = ( meta === undefined || meta === '' );\r\n\r\n\t\tvar output = {};\r\n\r\n\t\t// meta is a hash used to collect geometries, materials.\r\n\t\t// not providing it implies that this is the root object\r\n\t\t// being serialized.\r\n\t\tif ( isRootObject ) {\r\n\r\n\t\t\t// initialize meta obj\r\n\t\t\tmeta = {\r\n\t\t\t\tgeometries: {},\r\n\t\t\t\tmaterials: {},\r\n\t\t\t\ttextures: {},\r\n\t\t\t\timages: {}\r\n\t\t\t};\r\n\r\n\t\t\toutput.metadata = {\r\n\t\t\t\tversion: 4.4,\r\n\t\t\t\ttype: 'Object',\r\n\t\t\t\tgenerator: 'Object3D.toJSON'\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\t// standard Object3D serialization\r\n\r\n\t\tvar object = {};\r\n\r\n\t\tobject.uuid = this.uuid;\r\n\t\tobject.type = this.type;\r\n\r\n\t\tif ( this.name !== '' ) object.name = this.name;\r\n\t\tif ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;\r\n\t\tif ( this.castShadow === true ) object.castShadow = true;\r\n\t\tif ( this.receiveShadow === true ) object.receiveShadow = true;\r\n\t\tif ( this.visible === false ) object.visible = false;\r\n\r\n\t\tobject.matrix = this.matrix.toArray();\r\n\r\n\t\t//\r\n\r\n\t\tif ( this.geometry !== undefined ) {\r\n\r\n\t\t\tif ( meta.geometries[ this.geometry.uuid ] === undefined ) {\r\n\r\n\t\t\t\tmeta.geometries[ this.geometry.uuid ] = this.geometry.toJSON( meta );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tobject.geometry = this.geometry.uuid;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.material !== undefined ) {\r\n\r\n\t\t\tif ( meta.materials[ this.material.uuid ] === undefined ) {\r\n\r\n\t\t\t\tmeta.materials[ this.material.uuid ] = this.material.toJSON( meta );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tobject.material = this.material.uuid;\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tif ( this.children.length > 0 ) {\r\n\r\n\t\t\tobject.children = [];\r\n\r\n\t\t\tfor ( var i = 0; i < this.children.length; i ++ ) {\r\n\r\n\t\t\t\tobject.children.push( this.children[ i ].toJSON( meta ).object );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( isRootObject ) {\r\n\r\n\t\t\tvar geometries = extractFromCache( meta.geometries );\r\n\t\t\tvar materials = extractFromCache( meta.materials );\r\n\t\t\tvar textures = extractFromCache( meta.textures );\r\n\t\t\tvar images = extractFromCache( meta.images );\r\n\r\n\t\t\tif ( geometries.length > 0 ) output.geometries = geometries;\r\n\t\t\tif ( materials.length > 0 ) output.materials = materials;\r\n\t\t\tif ( textures.length > 0 ) output.textures = textures;\r\n\t\t\tif ( images.length > 0 ) output.images = images;\r\n\r\n\t\t}\r\n\r\n\t\toutput.object = object;\r\n\r\n\t\treturn output;\r\n\r\n\t\t// extract data from the cache hash\r\n\t\t// remove metadata on each item\r\n\t\t// and return as array\r\n\t\tfunction extractFromCache ( cache ) {\r\n\r\n\t\t\tvar values = [];\r\n\t\t\tfor ( var key in cache ) {\r\n\r\n\t\t\t\tvar data = cache[ key ];\r\n\t\t\t\tdelete data.metadata;\r\n\t\t\t\tvalues.push( data );\r\n\r\n\t\t\t}\r\n\t\t\treturn values;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tclone: function ( recursive ) {\r\n\r\n\t\treturn new this.constructor().copy( this, recursive );\r\n\r\n\t},\r\n\r\n\tcopy: function ( source, recursive ) {\r\n\r\n\t\tif ( recursive === undefined ) recursive = true;\r\n\r\n\t\tthis.name = source.name;\r\n\r\n\t\tthis.up.copy( source.up );\r\n\r\n\t\tthis.position.copy( source.position );\r\n\t\tthis.quaternion.copy( source.quaternion );\r\n\t\tthis.scale.copy( source.scale );\r\n\r\n\t\tthis.rotationAutoUpdate = source.rotationAutoUpdate;\r\n\r\n\t\tthis.matrix.copy( source.matrix );\r\n\t\tthis.matrixWorld.copy( source.matrixWorld );\r\n\r\n\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\r\n\t\tthis.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;\r\n\r\n\t\tthis.visible = source.visible;\r\n\r\n\t\tthis.castShadow = source.castShadow;\r\n\t\tthis.receiveShadow = source.receiveShadow;\r\n\r\n\t\tthis.frustumCulled = source.frustumCulled;\r\n\t\tthis.renderOrder = source.renderOrder;\r\n\r\n\t\tthis.userData = JSON.parse( JSON.stringify( source.userData ) );\r\n\r\n\t\tif ( recursive === true ) {\r\n\r\n\t\t\tfor ( var i = 0; i < source.children.length; i ++ ) {\r\n\r\n\t\t\t\tvar child = source.children[ i ];\r\n\t\t\t\tthis.add( child.clone() );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.EventDispatcher.prototype.apply( THREE.Object3D.prototype );\r\n\r\nTHREE.Object3DIdCount = 0;\r\n\r\n// File:src/core/Face3.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Face3 = function ( a, b, c, normal, color, materialIndex ) {\r\n\r\n\tthis.a = a;\r\n\tthis.b = b;\r\n\tthis.c = c;\r\n\r\n\tthis.normal = normal instanceof THREE.Vector3 ? normal : new THREE.Vector3();\r\n\tthis.vertexNormals = Array.isArray( normal ) ? normal : [];\r\n\r\n\tthis.color = color instanceof THREE.Color ? color : new THREE.Color();\r\n\tthis.vertexColors = Array.isArray( color ) ? color : [];\r\n\r\n\tthis.materialIndex = materialIndex !== undefined ? materialIndex : 0;\r\n\r\n};\r\n\r\nTHREE.Face3.prototype = {\r\n\r\n\tconstructor: THREE.Face3,\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\r\n\t},\r\n\r\n\tcopy: function ( source ) {\r\n\r\n\t\tthis.a = source.a;\r\n\t\tthis.b = source.b;\r\n\t\tthis.c = source.c;\r\n\r\n\t\tthis.normal.copy( source.normal );\r\n\t\tthis.color.copy( source.color );\r\n\r\n\t\tthis.materialIndex = source.materialIndex;\r\n\r\n\t\tfor ( var i = 0, il = source.vertexNormals.length; i < il; i ++ ) {\r\n\r\n\t\t\tthis.vertexNormals[ i ] = source.vertexNormals[ i ].clone();\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var i = 0, il = source.vertexColors.length; i < il; i ++ ) {\r\n\r\n\t\t\tthis.vertexColors[ i ] = source.vertexColors[ i ].clone();\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/core/BufferAttribute.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.BufferAttribute = function ( array, itemSize, normalized ) {\r\n\r\n\tthis.uuid = THREE.Math.generateUUID();\r\n\r\n\tthis.array = array;\r\n\tthis.itemSize = itemSize;\r\n\r\n\tthis.dynamic = false;\r\n\tthis.updateRange = { offset: 0, count: - 1 };\r\n\r\n\tthis.version = 0;\r\n\tthis.normalized = normalized === true;\r\n\r\n};\r\n\r\nTHREE.BufferAttribute.prototype = {\r\n\r\n\tconstructor: THREE.BufferAttribute,\r\n\r\n\tget count() {\r\n\r\n\t\treturn this.array.length / this.itemSize;\r\n\r\n\t},\r\n\r\n\tset needsUpdate( value ) {\r\n\r\n\t\tif ( value === true ) this.version ++;\r\n\r\n\t},\r\n\r\n\tsetDynamic: function ( value ) {\r\n\r\n\t\tthis.dynamic = value;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopy: function ( source ) {\r\n\r\n\t\tthis.array = new source.array.constructor( source.array );\r\n\t\tthis.itemSize = source.itemSize;\r\n\r\n\t\tthis.dynamic = source.dynamic;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopyAt: function ( index1, attribute, index2 ) {\r\n\r\n\t\tindex1 *= this.itemSize;\r\n\t\tindex2 *= attribute.itemSize;\r\n\r\n\t\tfor ( var i = 0, l = this.itemSize; i < l; i ++ ) {\r\n\r\n\t\t\tthis.array[ index1 + i ] = attribute.array[ index2 + i ];\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopyArray: function ( array ) {\r\n\r\n\t\tthis.array.set( array );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopyColorsArray: function ( colors ) {\r\n\r\n\t\tvar array = this.array, offset = 0;\r\n\r\n\t\tfor ( var i = 0, l = colors.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar color = colors[ i ];\r\n\r\n\t\t\tif ( color === undefined ) {\r\n\r\n\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );\r\n\t\t\t\tcolor = new THREE.Color();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tarray[ offset ++ ] = color.r;\r\n\t\t\tarray[ offset ++ ] = color.g;\r\n\t\t\tarray[ offset ++ ] = color.b;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopyIndicesArray: function ( indices ) {\r\n\r\n\t\tvar array = this.array, offset = 0;\r\n\r\n\t\tfor ( var i = 0, l = indices.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar index = indices[ i ];\r\n\r\n\t\t\tarray[ offset ++ ] = index.a;\r\n\t\t\tarray[ offset ++ ] = index.b;\r\n\t\t\tarray[ offset ++ ] = index.c;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopyVector2sArray: function ( vectors ) {\r\n\r\n\t\tvar array = this.array, offset = 0;\r\n\r\n\t\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar vector = vectors[ i ];\r\n\r\n\t\t\tif ( vector === undefined ) {\r\n\r\n\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );\r\n\t\t\t\tvector = new THREE.Vector2();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tarray[ offset ++ ] = vector.x;\r\n\t\t\tarray[ offset ++ ] = vector.y;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopyVector3sArray: function ( vectors ) {\r\n\r\n\t\tvar array = this.array, offset = 0;\r\n\r\n\t\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar vector = vectors[ i ];\r\n\r\n\t\t\tif ( vector === undefined ) {\r\n\r\n\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );\r\n\t\t\t\tvector = new THREE.Vector3();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tarray[ offset ++ ] = vector.x;\r\n\t\t\tarray[ offset ++ ] = vector.y;\r\n\t\t\tarray[ offset ++ ] = vector.z;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopyVector4sArray: function ( vectors ) {\r\n\r\n\t\tvar array = this.array, offset = 0;\r\n\r\n\t\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar vector = vectors[ i ];\r\n\r\n\t\t\tif ( vector === undefined ) {\r\n\r\n\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );\r\n\t\t\t\tvector = new THREE.Vector4();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tarray[ offset ++ ] = vector.x;\r\n\t\t\tarray[ offset ++ ] = vector.y;\r\n\t\t\tarray[ offset ++ ] = vector.z;\r\n\t\t\tarray[ offset ++ ] = vector.w;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tset: function ( value, offset ) {\r\n\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tthis.array.set( value, offset );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetX: function ( index ) {\r\n\r\n\t\treturn this.array[ index * this.itemSize ];\r\n\r\n\t},\r\n\r\n\tsetX: function ( index, x ) {\r\n\r\n\t\tthis.array[ index * this.itemSize ] = x;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetY: function ( index ) {\r\n\r\n\t\treturn this.array[ index * this.itemSize + 1 ];\r\n\r\n\t},\r\n\r\n\tsetY: function ( index, y ) {\r\n\r\n\t\tthis.array[ index * this.itemSize + 1 ] = y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetZ: function ( index ) {\r\n\r\n\t\treturn this.array[ index * this.itemSize + 2 ];\r\n\r\n\t},\r\n\r\n\tsetZ: function ( index, z ) {\r\n\r\n\t\tthis.array[ index * this.itemSize + 2 ] = z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetW: function ( index ) {\r\n\r\n\t\treturn this.array[ index * this.itemSize + 3 ];\r\n\r\n\t},\r\n\r\n\tsetW: function ( index, w ) {\r\n\r\n\t\tthis.array[ index * this.itemSize + 3 ] = w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetXY: function ( index, x, y ) {\r\n\r\n\t\tindex *= this.itemSize;\r\n\r\n\t\tthis.array[ index + 0 ] = x;\r\n\t\tthis.array[ index + 1 ] = y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetXYZ: function ( index, x, y, z ) {\r\n\r\n\t\tindex *= this.itemSize;\r\n\r\n\t\tthis.array[ index + 0 ] = x;\r\n\t\tthis.array[ index + 1 ] = y;\r\n\t\tthis.array[ index + 2 ] = z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetXYZW: function ( index, x, y, z, w ) {\r\n\r\n\t\tindex *= this.itemSize;\r\n\r\n\t\tthis.array[ index + 0 ] = x;\r\n\t\tthis.array[ index + 1 ] = y;\r\n\t\tthis.array[ index + 2 ] = z;\r\n\t\tthis.array[ index + 3 ] = w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\r\n\t}\r\n\r\n};\r\n\r\n//\r\n\r\nTHREE.Int8Attribute = function ( array, itemSize ) {\r\n\r\n\treturn new THREE.BufferAttribute( new Int8Array( array ), itemSize );\r\n\r\n};\r\n\r\nTHREE.Uint8Attribute = function ( array, itemSize ) {\r\n\r\n\treturn new THREE.BufferAttribute( new Uint8Array( array ), itemSize );\r\n\r\n};\r\n\r\nTHREE.Uint8ClampedAttribute = function ( array, itemSize ) {\r\n\r\n\treturn new THREE.BufferAttribute( new Uint8ClampedArray( array ), itemSize );\r\n\r\n};\r\n\r\nTHREE.Int16Attribute = function ( array, itemSize ) {\r\n\r\n\treturn new THREE.BufferAttribute( new Int16Array( array ), itemSize );\r\n\r\n};\r\n\r\nTHREE.Uint16Attribute = function ( array, itemSize ) {\r\n\r\n\treturn new THREE.BufferAttribute( new Uint16Array( array ), itemSize );\r\n\r\n};\r\n\r\nTHREE.Int32Attribute = function ( array, itemSize ) {\r\n\r\n\treturn new THREE.BufferAttribute( new Int32Array( array ), itemSize );\r\n\r\n};\r\n\r\nTHREE.Uint32Attribute = function ( array, itemSize ) {\r\n\r\n\treturn new THREE.BufferAttribute( new Uint32Array( array ), itemSize );\r\n\r\n};\r\n\r\nTHREE.Float32Attribute = function ( array, itemSize ) {\r\n\r\n\treturn new THREE.BufferAttribute( new Float32Array( array ), itemSize );\r\n\r\n};\r\n\r\nTHREE.Float64Attribute = function ( array, itemSize ) {\r\n\r\n\treturn new THREE.BufferAttribute( new Float64Array( array ), itemSize );\r\n\r\n};\r\n\r\n\r\n// Deprecated\r\n\r\nTHREE.DynamicBufferAttribute = function ( array, itemSize ) {\r\n\r\n\tconsole.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.' );\r\n\treturn new THREE.BufferAttribute( array, itemSize ).setDynamic( true );\r\n\r\n};\r\n\r\n// File:src/core/InstancedBufferAttribute.js\r\n\r\n/**\r\n * @author benaadams / https://twitter.com/ben_a_adams\r\n */\r\n\r\nTHREE.InstancedBufferAttribute = function ( array, itemSize, meshPerAttribute ) {\r\n\r\n\tTHREE.BufferAttribute.call( this, array, itemSize );\r\n\r\n\tthis.meshPerAttribute = meshPerAttribute || 1;\r\n\r\n};\r\n\r\nTHREE.InstancedBufferAttribute.prototype = Object.create( THREE.BufferAttribute.prototype );\r\nTHREE.InstancedBufferAttribute.prototype.constructor = THREE.InstancedBufferAttribute;\r\n\r\nTHREE.InstancedBufferAttribute.prototype.copy = function ( source ) {\r\n\r\n\tTHREE.BufferAttribute.prototype.copy.call( this, source );\r\n\r\n\tthis.meshPerAttribute = source.meshPerAttribute;\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\n// File:src/core/InterleavedBuffer.js\r\n\r\n/**\r\n * @author benaadams / https://twitter.com/ben_a_adams\r\n */\r\n\r\nTHREE.InterleavedBuffer = function ( array, stride ) {\r\n\r\n\tthis.uuid = THREE.Math.generateUUID();\r\n\r\n\tthis.array = array;\r\n\tthis.stride = stride;\r\n\r\n\tthis.dynamic = false;\r\n\tthis.updateRange = { offset: 0, count: - 1 };\r\n\r\n\tthis.version = 0;\r\n\r\n};\r\n\r\nTHREE.InterleavedBuffer.prototype = {\r\n\r\n\tconstructor: THREE.InterleavedBuffer,\r\n\r\n\tget length () {\r\n\r\n\t\treturn this.array.length;\r\n\r\n\t},\r\n\r\n\tget count () {\r\n\r\n\t\treturn this.array.length / this.stride;\r\n\r\n\t},\r\n\r\n\tset needsUpdate( value ) {\r\n\r\n\t\tif ( value === true ) this.version ++;\r\n\r\n\t},\r\n\r\n\tsetDynamic: function ( value ) {\r\n\r\n\t\tthis.dynamic = value;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopy: function ( source ) {\r\n\r\n\t\tthis.array = new source.array.constructor( source.array );\r\n\t\tthis.stride = source.stride;\r\n\t\tthis.dynamic = source.dynamic;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopyAt: function ( index1, attribute, index2 ) {\r\n\r\n\t\tindex1 *= this.stride;\r\n\t\tindex2 *= attribute.stride;\r\n\r\n\t\tfor ( var i = 0, l = this.stride; i < l; i ++ ) {\r\n\r\n\t\t\tthis.array[ index1 + i ] = attribute.array[ index2 + i ];\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tset: function ( value, offset ) {\r\n\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tthis.array.set( value, offset );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/core/InstancedInterleavedBuffer.js\r\n\r\n/**\r\n * @author benaadams / https://twitter.com/ben_a_adams\r\n */\r\n\r\nTHREE.InstancedInterleavedBuffer = function ( array, stride, meshPerAttribute ) {\r\n\r\n\tTHREE.InterleavedBuffer.call( this, array, stride );\r\n\r\n\tthis.meshPerAttribute = meshPerAttribute || 1;\r\n\r\n};\r\n\r\nTHREE.InstancedInterleavedBuffer.prototype = Object.create( THREE.InterleavedBuffer.prototype );\r\nTHREE.InstancedInterleavedBuffer.prototype.constructor = THREE.InstancedInterleavedBuffer;\r\n\r\nTHREE.InstancedInterleavedBuffer.prototype.copy = function ( source ) {\r\n\r\n\tTHREE.InterleavedBuffer.prototype.copy.call( this, source );\r\n\r\n\tthis.meshPerAttribute = source.meshPerAttribute;\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\n// File:src/core/InterleavedBufferAttribute.js\r\n\r\n/**\r\n * @author benaadams / https://twitter.com/ben_a_adams\r\n */\r\n\r\nTHREE.InterleavedBufferAttribute = function ( interleavedBuffer, itemSize, offset ) {\r\n\r\n\tthis.uuid = THREE.Math.generateUUID();\r\n\r\n\tthis.data = interleavedBuffer;\r\n\tthis.itemSize = itemSize;\r\n\tthis.offset = offset;\r\n\r\n};\r\n\r\n\r\nTHREE.InterleavedBufferAttribute.prototype = {\r\n\r\n\tconstructor: THREE.InterleavedBufferAttribute,\r\n\r\n\tget length() {\r\n\r\n\t\tconsole.warn( 'THREE.BufferAttribute: .length has been deprecated. Please use .count.' );\r\n\t\treturn this.array.length;\r\n\r\n\t},\r\n\r\n\tget count() {\r\n\r\n\t\treturn this.data.count;\r\n\r\n\t},\r\n\r\n\tsetX: function ( index, x ) {\r\n\r\n\t\tthis.data.array[ index * this.data.stride + this.offset ] = x;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetY: function ( index, y ) {\r\n\r\n\t\tthis.data.array[ index * this.data.stride + this.offset + 1 ] = y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetZ: function ( index, z ) {\r\n\r\n\t\tthis.data.array[ index * this.data.stride + this.offset + 2 ] = z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetW: function ( index, w ) {\r\n\r\n\t\tthis.data.array[ index * this.data.stride + this.offset + 3 ] = w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetX: function ( index ) {\r\n\r\n\t\treturn this.data.array[ index * this.data.stride + this.offset ];\r\n\r\n\t},\r\n\r\n\tgetY: function ( index ) {\r\n\r\n\t\treturn this.data.array[ index * this.data.stride + this.offset + 1 ];\r\n\r\n\t},\r\n\r\n\tgetZ: function ( index ) {\r\n\r\n\t\treturn this.data.array[ index * this.data.stride + this.offset + 2 ];\r\n\r\n\t},\r\n\r\n\tgetW: function ( index ) {\r\n\r\n\t\treturn this.data.array[ index * this.data.stride + this.offset + 3 ];\r\n\r\n\t},\r\n\r\n\tsetXY: function ( index, x, y ) {\r\n\r\n\t\tindex = index * this.data.stride + this.offset;\r\n\r\n\t\tthis.data.array[ index + 0 ] = x;\r\n\t\tthis.data.array[ index + 1 ] = y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetXYZ: function ( index, x, y, z ) {\r\n\r\n\t\tindex = index * this.data.stride + this.offset;\r\n\r\n\t\tthis.data.array[ index + 0 ] = x;\r\n\t\tthis.data.array[ index + 1 ] = y;\r\n\t\tthis.data.array[ index + 2 ] = z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetXYZW: function ( index, x, y, z, w ) {\r\n\r\n\t\tindex = index * this.data.stride + this.offset;\r\n\r\n\t\tthis.data.array[ index + 0 ] = x;\r\n\t\tthis.data.array[ index + 1 ] = y;\r\n\t\tthis.data.array[ index + 2 ] = z;\r\n\t\tthis.data.array[ index + 3 ] = w;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/core/Geometry.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author kile / http://kile.stravaganza.org/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * @author bhouston / http://clara.io\r\n */\r\n\r\nTHREE.Geometry = function () {\r\n\r\n\tObject.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );\r\n\r\n\tthis.uuid = THREE.Math.generateUUID();\r\n\r\n\tthis.name = '';\r\n\tthis.type = 'Geometry';\r\n\r\n\tthis.vertices = [];\r\n\tthis.colors = [];\r\n\tthis.faces = [];\r\n\tthis.faceVertexUvs = [ [] ];\r\n\r\n\tthis.morphTargets = [];\r\n\tthis.morphNormals = [];\r\n\r\n\tthis.skinWeights = [];\r\n\tthis.skinIndices = [];\r\n\r\n\tthis.lineDistances = [];\r\n\r\n\tthis.boundingBox = null;\r\n\tthis.boundingSphere = null;\r\n\r\n\t// update flags\r\n\r\n\tthis.verticesNeedUpdate = false;\r\n\tthis.elementsNeedUpdate = false;\r\n\tthis.uvsNeedUpdate = false;\r\n\tthis.normalsNeedUpdate = false;\r\n\tthis.colorsNeedUpdate = false;\r\n\tthis.lineDistancesNeedUpdate = false;\r\n\tthis.groupsNeedUpdate = false;\r\n\r\n};\r\n\r\nTHREE.Geometry.prototype = {\r\n\r\n\tconstructor: THREE.Geometry,\r\n\r\n\tapplyMatrix: function ( matrix ) {\r\n\r\n\t\tvar normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );\r\n\r\n\t\tfor ( var i = 0, il = this.vertices.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar vertex = this.vertices[ i ];\r\n\t\t\tvertex.applyMatrix4( matrix );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var i = 0, il = this.faces.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar face = this.faces[ i ];\r\n\t\t\tface.normal.applyMatrix3( normalMatrix ).normalize();\r\n\r\n\t\t\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\tface.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.boundingBox !== null ) {\r\n\r\n\t\t\tthis.computeBoundingBox();\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.boundingSphere !== null ) {\r\n\r\n\t\t\tthis.computeBoundingSphere();\r\n\r\n\t\t}\r\n\r\n\t\tthis.verticesNeedUpdate = true;\r\n\t\tthis.normalsNeedUpdate = true;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\trotateX: function () {\r\n\r\n\t\t// rotate geometry around world x-axis\r\n\r\n\t\tvar m1;\r\n\r\n\t\treturn function rotateX( angle ) {\r\n\r\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\r\n\r\n\t\t\tm1.makeRotationX( angle );\r\n\r\n\t\t\tthis.applyMatrix( m1 );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\trotateY: function () {\r\n\r\n\t\t// rotate geometry around world y-axis\r\n\r\n\t\tvar m1;\r\n\r\n\t\treturn function rotateY( angle ) {\r\n\r\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\r\n\r\n\t\t\tm1.makeRotationY( angle );\r\n\r\n\t\t\tthis.applyMatrix( m1 );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\trotateZ: function () {\r\n\r\n\t\t// rotate geometry around world z-axis\r\n\r\n\t\tvar m1;\r\n\r\n\t\treturn function rotateZ( angle ) {\r\n\r\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\r\n\r\n\t\t\tm1.makeRotationZ( angle );\r\n\r\n\t\t\tthis.applyMatrix( m1 );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\ttranslate: function () {\r\n\r\n\t\t// translate geometry\r\n\r\n\t\tvar m1;\r\n\r\n\t\treturn function translate( x, y, z ) {\r\n\r\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\r\n\r\n\t\t\tm1.makeTranslation( x, y, z );\r\n\r\n\t\t\tthis.applyMatrix( m1 );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tscale: function () {\r\n\r\n\t\t// scale geometry\r\n\r\n\t\tvar m1;\r\n\r\n\t\treturn function scale( x, y, z ) {\r\n\r\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\r\n\r\n\t\t\tm1.makeScale( x, y, z );\r\n\r\n\t\t\tthis.applyMatrix( m1 );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tlookAt: function () {\r\n\r\n\t\tvar obj;\r\n\r\n\t\treturn function lookAt( vector ) {\r\n\r\n\t\t\tif ( obj === undefined ) obj = new THREE.Object3D();\r\n\r\n\t\t\tobj.lookAt( vector );\r\n\r\n\t\t\tobj.updateMatrix();\r\n\r\n\t\t\tthis.applyMatrix( obj.matrix );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tfromBufferGeometry: function ( geometry ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar indices = geometry.index !== null ? geometry.index.array : undefined;\r\n\t\tvar attributes = geometry.attributes;\r\n\r\n\t\tvar positions = attributes.position.array;\r\n\t\tvar normals = attributes.normal !== undefined ? attributes.normal.array : undefined;\r\n\t\tvar colors = attributes.color !== undefined ? attributes.color.array : undefined;\r\n\t\tvar uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;\r\n\t\tvar uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;\r\n\r\n\t\tif ( uvs2 !== undefined ) this.faceVertexUvs[ 1 ] = [];\r\n\r\n\t\tvar tempNormals = [];\r\n\t\tvar tempUVs = [];\r\n\t\tvar tempUVs2 = [];\r\n\r\n\t\tfor ( var i = 0, j = 0; i < positions.length; i += 3, j += 2 ) {\r\n\r\n\t\t\tscope.vertices.push( new THREE.Vector3( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] ) );\r\n\r\n\t\t\tif ( normals !== undefined ) {\r\n\r\n\t\t\t\ttempNormals.push( new THREE.Vector3( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( colors !== undefined ) {\r\n\r\n\t\t\t\tscope.colors.push( new THREE.Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( uvs !== undefined ) {\r\n\r\n\t\t\t\ttempUVs.push( new THREE.Vector2( uvs[ j ], uvs[ j + 1 ] ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( uvs2 !== undefined ) {\r\n\r\n\t\t\t\ttempUVs2.push( new THREE.Vector2( uvs2[ j ], uvs2[ j + 1 ] ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction addFace( a, b, c, materialIndex ) {\r\n\r\n\t\t\tvar vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];\r\n\t\t\tvar vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];\r\n\r\n\t\t\tvar face = new THREE.Face3( a, b, c, vertexNormals, vertexColors, materialIndex );\r\n\r\n\t\t\tscope.faces.push( face );\r\n\r\n\t\t\tif ( uvs !== undefined ) {\r\n\r\n\t\t\t\tscope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ].clone(), tempUVs[ b ].clone(), tempUVs[ c ].clone() ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( uvs2 !== undefined ) {\r\n\r\n\t\t\t\tscope.faceVertexUvs[ 1 ].push( [ tempUVs2[ a ].clone(), tempUVs2[ b ].clone(), tempUVs2[ c ].clone() ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( indices !== undefined ) {\r\n\r\n\t\t\tvar groups = geometry.groups;\r\n\r\n\t\t\tif ( groups.length > 0 ) {\r\n\r\n\t\t\t\tfor ( var i = 0; i < groups.length; i ++ ) {\r\n\r\n\t\t\t\t\tvar group = groups[ i ];\r\n\r\n\t\t\t\t\tvar start = group.start;\r\n\t\t\t\t\tvar count = group.count;\r\n\r\n\t\t\t\t\tfor ( var j = start, jl = start + count; j < jl; j += 3 ) {\r\n\r\n\t\t\t\t\t\taddFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ], group.materialIndex  );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tfor ( var i = 0; i < indices.length; i += 3 ) {\r\n\r\n\t\t\t\t\taddFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tfor ( var i = 0; i < positions.length / 3; i += 3 ) {\r\n\r\n\t\t\t\taddFace( i, i + 1, i + 2 );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.computeFaceNormals();\r\n\r\n\t\tif ( geometry.boundingBox !== null ) {\r\n\r\n\t\t\tthis.boundingBox = geometry.boundingBox.clone();\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.boundingSphere !== null ) {\r\n\r\n\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcenter: function () {\r\n\r\n\t\tthis.computeBoundingBox();\r\n\r\n\t\tvar offset = this.boundingBox.center().negate();\r\n\r\n\t\tthis.translate( offset.x, offset.y, offset.z );\r\n\r\n\t\treturn offset;\r\n\r\n\t},\r\n\r\n\tnormalize: function () {\r\n\r\n\t\tthis.computeBoundingSphere();\r\n\r\n\t\tvar center = this.boundingSphere.center;\r\n\t\tvar radius = this.boundingSphere.radius;\r\n\r\n\t\tvar s = radius === 0 ? 1 : 1.0 / radius;\r\n\r\n\t\tvar matrix = new THREE.Matrix4();\r\n\t\tmatrix.set(\r\n\t\t\ts, 0, 0, - s * center.x,\r\n\t\t\t0, s, 0, - s * center.y,\r\n\t\t\t0, 0, s, - s * center.z,\r\n\t\t\t0, 0, 0, 1\r\n\t\t);\r\n\r\n\t\tthis.applyMatrix( matrix );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcomputeFaceNormals: function () {\r\n\r\n\t\tvar cb = new THREE.Vector3(), ab = new THREE.Vector3();\r\n\r\n\t\tfor ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\tvar face = this.faces[ f ];\r\n\r\n\t\t\tvar vA = this.vertices[ face.a ];\r\n\t\t\tvar vB = this.vertices[ face.b ];\r\n\t\t\tvar vC = this.vertices[ face.c ];\r\n\r\n\t\t\tcb.subVectors( vC, vB );\r\n\t\t\tab.subVectors( vA, vB );\r\n\t\t\tcb.cross( ab );\r\n\r\n\t\t\tcb.normalize();\r\n\r\n\t\t\tface.normal.copy( cb );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tcomputeVertexNormals: function ( areaWeighted ) {\r\n\r\n\t\tif ( areaWeighted === undefined ) areaWeighted = true;\r\n\r\n\t\tvar v, vl, f, fl, face, vertices;\r\n\r\n\t\tvertices = new Array( this.vertices.length );\r\n\r\n\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\r\n\r\n\t\t\tvertices[ v ] = new THREE.Vector3();\r\n\r\n\t\t}\r\n\r\n\t\tif ( areaWeighted ) {\r\n\r\n\t\t\t// vertex normals weighted by triangle areas\r\n\t\t\t// http://www.iquilezles.org/www/articles/normals/normals.htm\r\n\r\n\t\t\tvar vA, vB, vC;\r\n\t\t\tvar cb = new THREE.Vector3(), ab = new THREE.Vector3();\r\n\r\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tface = this.faces[ f ];\r\n\r\n\t\t\t\tvA = this.vertices[ face.a ];\r\n\t\t\t\tvB = this.vertices[ face.b ];\r\n\t\t\t\tvC = this.vertices[ face.c ];\r\n\r\n\t\t\t\tcb.subVectors( vC, vB );\r\n\t\t\t\tab.subVectors( vA, vB );\r\n\t\t\t\tcb.cross( ab );\r\n\r\n\t\t\t\tvertices[ face.a ].add( cb );\r\n\t\t\t\tvertices[ face.b ].add( cb );\r\n\t\t\t\tvertices[ face.c ].add( cb );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tface = this.faces[ f ];\r\n\r\n\t\t\t\tvertices[ face.a ].add( face.normal );\r\n\t\t\t\tvertices[ face.b ].add( face.normal );\r\n\t\t\t\tvertices[ face.c ].add( face.normal );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\r\n\r\n\t\t\tvertices[ v ].normalize();\r\n\r\n\t\t}\r\n\r\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\tface = this.faces[ f ];\r\n\r\n\t\t\tvar vertexNormals = face.vertexNormals;\r\n\r\n\t\t\tif ( vertexNormals.length === 3 ) {\r\n\r\n\t\t\t\tvertexNormals[ 0 ].copy( vertices[ face.a ] );\r\n\t\t\t\tvertexNormals[ 1 ].copy( vertices[ face.b ] );\r\n\t\t\t\tvertexNormals[ 2 ].copy( vertices[ face.c ] );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tvertexNormals[ 0 ] = vertices[ face.a ].clone();\r\n\t\t\t\tvertexNormals[ 1 ] = vertices[ face.b ].clone();\r\n\t\t\t\tvertexNormals[ 2 ] = vertices[ face.c ].clone();\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.faces.length > 0 ) {\r\n\r\n\t\t\tthis.normalsNeedUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tcomputeMorphNormals: function () {\r\n\r\n\t\tvar i, il, f, fl, face;\r\n\r\n\t\t// save original normals\r\n\t\t// - create temp variables on first access\r\n\t\t//   otherwise just copy (for faster repeated calls)\r\n\r\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\tface = this.faces[ f ];\r\n\r\n\t\t\tif ( ! face.__originalFaceNormal ) {\r\n\r\n\t\t\t\tface.__originalFaceNormal = face.normal.clone();\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tface.__originalFaceNormal.copy( face.normal );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];\r\n\r\n\t\t\tfor ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tif ( ! face.__originalVertexNormals[ i ] ) {\r\n\r\n\t\t\t\t\tface.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tface.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// use temp geometry to compute face and vertex normals for each morph\r\n\r\n\t\tvar tmpGeo = new THREE.Geometry();\r\n\t\ttmpGeo.faces = this.faces;\r\n\r\n\t\tfor ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {\r\n\r\n\t\t\t// create on first access\r\n\r\n\t\t\tif ( ! this.morphNormals[ i ] ) {\r\n\r\n\t\t\t\tthis.morphNormals[ i ] = {};\r\n\t\t\t\tthis.morphNormals[ i ].faceNormals = [];\r\n\t\t\t\tthis.morphNormals[ i ].vertexNormals = [];\r\n\r\n\t\t\t\tvar dstNormalsFace = this.morphNormals[ i ].faceNormals;\r\n\t\t\t\tvar dstNormalsVertex = this.morphNormals[ i ].vertexNormals;\r\n\r\n\t\t\t\tvar faceNormal, vertexNormals;\r\n\r\n\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\tfaceNormal = new THREE.Vector3();\r\n\t\t\t\t\tvertexNormals = { a: new THREE.Vector3(), b: new THREE.Vector3(), c: new THREE.Vector3() };\r\n\r\n\t\t\t\t\tdstNormalsFace.push( faceNormal );\r\n\t\t\t\t\tdstNormalsVertex.push( vertexNormals );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar morphNormals = this.morphNormals[ i ];\r\n\r\n\t\t\t// set vertices to morph target\r\n\r\n\t\t\ttmpGeo.vertices = this.morphTargets[ i ].vertices;\r\n\r\n\t\t\t// compute morph normals\r\n\r\n\t\t\ttmpGeo.computeFaceNormals();\r\n\t\t\ttmpGeo.computeVertexNormals();\r\n\r\n\t\t\t// store morph normals\r\n\r\n\t\t\tvar faceNormal, vertexNormals;\r\n\r\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tface = this.faces[ f ];\r\n\r\n\t\t\t\tfaceNormal = morphNormals.faceNormals[ f ];\r\n\t\t\t\tvertexNormals = morphNormals.vertexNormals[ f ];\r\n\r\n\t\t\t\tfaceNormal.copy( face.normal );\r\n\r\n\t\t\t\tvertexNormals.a.copy( face.vertexNormals[ 0 ] );\r\n\t\t\t\tvertexNormals.b.copy( face.vertexNormals[ 1 ] );\r\n\t\t\t\tvertexNormals.c.copy( face.vertexNormals[ 2 ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// restore original normals\r\n\r\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\tface = this.faces[ f ];\r\n\r\n\t\t\tface.normal = face.__originalFaceNormal;\r\n\t\t\tface.vertexNormals = face.__originalVertexNormals;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tcomputeTangents: function () {\r\n\r\n\t\tconsole.warn( 'THREE.Geometry: .computeTangents() has been removed.' );\r\n\r\n\t},\r\n\r\n\tcomputeLineDistances: function () {\r\n\r\n\t\tvar d = 0;\r\n\t\tvar vertices = this.vertices;\r\n\r\n\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\r\n\r\n\t\t\tif ( i > 0 ) {\r\n\r\n\t\t\t\td += vertices[ i ].distanceTo( vertices[ i - 1 ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.lineDistances[ i ] = d;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tcomputeBoundingBox: function () {\r\n\r\n\t\tif ( this.boundingBox === null ) {\r\n\r\n\t\t\tthis.boundingBox = new THREE.Box3();\r\n\r\n\t\t}\r\n\r\n\t\tthis.boundingBox.setFromPoints( this.vertices );\r\n\r\n\t},\r\n\r\n\tcomputeBoundingSphere: function () {\r\n\r\n\t\tif ( this.boundingSphere === null ) {\r\n\r\n\t\t\tthis.boundingSphere = new THREE.Sphere();\r\n\r\n\t\t}\r\n\r\n\t\tthis.boundingSphere.setFromPoints( this.vertices );\r\n\r\n\t},\r\n\r\n\tmerge: function ( geometry, matrix, materialIndexOffset ) {\r\n\r\n\t\tif ( geometry instanceof THREE.Geometry === false ) {\r\n\r\n\t\t\tconsole.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tvar normalMatrix,\r\n\t\tvertexOffset = this.vertices.length,\r\n\t\tvertices1 = this.vertices,\r\n\t\tvertices2 = geometry.vertices,\r\n\t\tfaces1 = this.faces,\r\n\t\tfaces2 = geometry.faces,\r\n\t\tuvs1 = this.faceVertexUvs[ 0 ],\r\n\t\tuvs2 = geometry.faceVertexUvs[ 0 ];\r\n\r\n\t\tif ( materialIndexOffset === undefined ) materialIndexOffset = 0;\r\n\r\n\t\tif ( matrix !== undefined ) {\r\n\r\n\t\t\tnormalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );\r\n\r\n\t\t}\r\n\r\n\t\t// vertices\r\n\r\n\t\tfor ( var i = 0, il = vertices2.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar vertex = vertices2[ i ];\r\n\r\n\t\t\tvar vertexCopy = vertex.clone();\r\n\r\n\t\t\tif ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );\r\n\r\n\t\t\tvertices1.push( vertexCopy );\r\n\r\n\t\t}\r\n\r\n\t\t// faces\r\n\r\n\t\tfor ( i = 0, il = faces2.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar face = faces2[ i ], faceCopy, normal, color,\r\n\t\t\tfaceVertexNormals = face.vertexNormals,\r\n\t\t\tfaceVertexColors = face.vertexColors;\r\n\r\n\t\t\tfaceCopy = new THREE.Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );\r\n\t\t\tfaceCopy.normal.copy( face.normal );\r\n\r\n\t\t\tif ( normalMatrix !== undefined ) {\r\n\r\n\t\t\t\tfaceCopy.normal.applyMatrix3( normalMatrix ).normalize();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\tnormal = faceVertexNormals[ j ].clone();\r\n\r\n\t\t\t\tif ( normalMatrix !== undefined ) {\r\n\r\n\t\t\t\t\tnormal.applyMatrix3( normalMatrix ).normalize();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfaceCopy.vertexNormals.push( normal );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfaceCopy.color.copy( face.color );\r\n\r\n\t\t\tfor ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\tcolor = faceVertexColors[ j ];\r\n\t\t\t\tfaceCopy.vertexColors.push( color.clone() );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfaceCopy.materialIndex = face.materialIndex + materialIndexOffset;\r\n\r\n\t\t\tfaces1.push( faceCopy );\r\n\r\n\t\t}\r\n\r\n\t\t// uvs\r\n\r\n\t\tfor ( i = 0, il = uvs2.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar uv = uvs2[ i ], uvCopy = [];\r\n\r\n\t\t\tif ( uv === undefined ) {\r\n\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var j = 0, jl = uv.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\tuvCopy.push( uv[ j ].clone() );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tuvs1.push( uvCopy );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tmergeMesh: function ( mesh ) {\r\n\r\n\t\tif ( mesh instanceof THREE.Mesh === false ) {\r\n\r\n\t\t\tconsole.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tmesh.matrixAutoUpdate && mesh.updateMatrix();\r\n\r\n\t\tthis.merge( mesh.geometry, mesh.matrix );\r\n\r\n\t},\r\n\r\n\t/*\r\n\t * Checks for duplicate vertices with hashmap.\r\n\t * Duplicated vertices are removed\r\n\t * and faces' vertices are updated.\r\n\t */\r\n\r\n\tmergeVertices: function () {\r\n\r\n\t\tvar verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)\r\n\t\tvar unique = [], changes = [];\r\n\r\n\t\tvar v, key;\r\n\t\tvar precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001\r\n\t\tvar precision = Math.pow( 10, precisionPoints );\r\n\t\tvar i, il, face;\r\n\t\tvar indices, j, jl;\r\n\r\n\t\tfor ( i = 0, il = this.vertices.length; i < il; i ++ ) {\r\n\r\n\t\t\tv = this.vertices[ i ];\r\n\t\t\tkey = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );\r\n\r\n\t\t\tif ( verticesMap[ key ] === undefined ) {\r\n\r\n\t\t\t\tverticesMap[ key ] = i;\r\n\t\t\t\tunique.push( this.vertices[ i ] );\r\n\t\t\t\tchanges[ i ] = unique.length - 1;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);\r\n\t\t\t\tchanges[ i ] = changes[ verticesMap[ key ] ];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\r\n\t\t// if faces are completely degenerate after merging vertices, we\r\n\t\t// have to remove them from the geometry.\r\n\t\tvar faceIndicesToRemove = [];\r\n\r\n\t\tfor ( i = 0, il = this.faces.length; i < il; i ++ ) {\r\n\r\n\t\t\tface = this.faces[ i ];\r\n\r\n\t\t\tface.a = changes[ face.a ];\r\n\t\t\tface.b = changes[ face.b ];\r\n\t\t\tface.c = changes[ face.c ];\r\n\r\n\t\t\tindices = [ face.a, face.b, face.c ];\r\n\r\n\t\t\tvar dupIndex = - 1;\r\n\r\n\t\t\t// if any duplicate vertices are found in a Face3\r\n\t\t\t// we have to remove the face as nothing can be saved\r\n\t\t\tfor ( var n = 0; n < 3; n ++ ) {\r\n\r\n\t\t\t\tif ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {\r\n\r\n\t\t\t\t\tdupIndex = n;\r\n\t\t\t\t\tfaceIndicesToRemove.push( i );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfor ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {\r\n\r\n\t\t\tvar idx = faceIndicesToRemove[ i ];\r\n\r\n\t\t\tthis.faces.splice( idx, 1 );\r\n\r\n\t\t\tfor ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\tthis.faceVertexUvs[ j ].splice( idx, 1 );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// Use unique set of vertices\r\n\r\n\t\tvar diff = this.vertices.length - unique.length;\r\n\t\tthis.vertices = unique;\r\n\t\treturn diff;\r\n\r\n\t},\r\n\r\n\tsortFacesByMaterialIndex: function () {\r\n\r\n\t\tvar faces = this.faces;\r\n\t\tvar length = faces.length;\r\n\r\n\t\t// tag faces\r\n\r\n\t\tfor ( var i = 0; i < length; i ++ ) {\r\n\r\n\t\t\tfaces[ i ]._id = i;\r\n\r\n\t\t}\r\n\r\n\t\t// sort faces\r\n\r\n\t\tfunction materialIndexSort( a, b ) {\r\n\r\n\t\t\treturn a.materialIndex - b.materialIndex;\r\n\r\n\t\t}\r\n\r\n\t\tfaces.sort( materialIndexSort );\r\n\r\n\t\t// sort uvs\r\n\r\n\t\tvar uvs1 = this.faceVertexUvs[ 0 ];\r\n\t\tvar uvs2 = this.faceVertexUvs[ 1 ];\r\n\r\n\t\tvar newUvs1, newUvs2;\r\n\r\n\t\tif ( uvs1 && uvs1.length === length ) newUvs1 = [];\r\n\t\tif ( uvs2 && uvs2.length === length ) newUvs2 = [];\r\n\r\n\t\tfor ( var i = 0; i < length; i ++ ) {\r\n\r\n\t\t\tvar id = faces[ i ]._id;\r\n\r\n\t\t\tif ( newUvs1 ) newUvs1.push( uvs1[ id ] );\r\n\t\t\tif ( newUvs2 ) newUvs2.push( uvs2[ id ] );\r\n\r\n\t\t}\r\n\r\n\t\tif ( newUvs1 ) this.faceVertexUvs[ 0 ] = newUvs1;\r\n\t\tif ( newUvs2 ) this.faceVertexUvs[ 1 ] = newUvs2;\r\n\r\n\t},\r\n\r\n\ttoJSON: function () {\r\n\r\n\t\tvar data = {\r\n\t\t\tmetadata: {\r\n\t\t\t\tversion: 4.4,\r\n\t\t\t\ttype: 'Geometry',\r\n\t\t\t\tgenerator: 'Geometry.toJSON'\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t// standard Geometry serialization\r\n\r\n\t\tdata.uuid = this.uuid;\r\n\t\tdata.type = this.type;\r\n\t\tif ( this.name !== '' ) data.name = this.name;\r\n\r\n\t\tif ( this.parameters !== undefined ) {\r\n\r\n\t\t\tvar parameters = this.parameters;\r\n\r\n\t\t\tfor ( var key in parameters ) {\r\n\r\n\t\t\t\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn data;\r\n\r\n\t\t}\r\n\r\n\t\tvar vertices = [];\r\n\r\n\t\tfor ( var i = 0; i < this.vertices.length; i ++ ) {\r\n\r\n\t\t\tvar vertex = this.vertices[ i ];\r\n\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\r\n\r\n\t\t}\r\n\r\n\t\tvar faces = [];\r\n\t\tvar normals = [];\r\n\t\tvar normalsHash = {};\r\n\t\tvar colors = [];\r\n\t\tvar colorsHash = {};\r\n\t\tvar uvs = [];\r\n\t\tvar uvsHash = {};\r\n\r\n\t\tfor ( var i = 0; i < this.faces.length; i ++ ) {\r\n\r\n\t\t\tvar face = this.faces[ i ];\r\n\r\n\t\t\tvar hasMaterial = true;\r\n\t\t\tvar hasFaceUv = false; // deprecated\r\n\t\t\tvar hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;\r\n\t\t\tvar hasFaceNormal = face.normal.length() > 0;\r\n\t\t\tvar hasFaceVertexNormal = face.vertexNormals.length > 0;\r\n\t\t\tvar hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;\r\n\t\t\tvar hasFaceVertexColor = face.vertexColors.length > 0;\r\n\r\n\t\t\tvar faceType = 0;\r\n\r\n\t\t\tfaceType = setBit( faceType, 0, 0 ); // isQuad\r\n\t\t\tfaceType = setBit( faceType, 1, hasMaterial );\r\n\t\t\tfaceType = setBit( faceType, 2, hasFaceUv );\r\n\t\t\tfaceType = setBit( faceType, 3, hasFaceVertexUv );\r\n\t\t\tfaceType = setBit( faceType, 4, hasFaceNormal );\r\n\t\t\tfaceType = setBit( faceType, 5, hasFaceVertexNormal );\r\n\t\t\tfaceType = setBit( faceType, 6, hasFaceColor );\r\n\t\t\tfaceType = setBit( faceType, 7, hasFaceVertexColor );\r\n\r\n\t\t\tfaces.push( faceType );\r\n\t\t\tfaces.push( face.a, face.b, face.c );\r\n\t\t\tfaces.push( face.materialIndex );\r\n\r\n\t\t\tif ( hasFaceVertexUv ) {\r\n\r\n\t\t\t\tvar faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];\r\n\r\n\t\t\t\tfaces.push(\r\n\t\t\t\t\tgetUvIndex( faceVertexUvs[ 0 ] ),\r\n\t\t\t\t\tgetUvIndex( faceVertexUvs[ 1 ] ),\r\n\t\t\t\t\tgetUvIndex( faceVertexUvs[ 2 ] )\r\n\t\t\t\t);\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( hasFaceNormal ) {\r\n\r\n\t\t\t\tfaces.push( getNormalIndex( face.normal ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( hasFaceVertexNormal ) {\r\n\r\n\t\t\t\tvar vertexNormals = face.vertexNormals;\r\n\r\n\t\t\t\tfaces.push(\r\n\t\t\t\t\tgetNormalIndex( vertexNormals[ 0 ] ),\r\n\t\t\t\t\tgetNormalIndex( vertexNormals[ 1 ] ),\r\n\t\t\t\t\tgetNormalIndex( vertexNormals[ 2 ] )\r\n\t\t\t\t);\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( hasFaceColor ) {\r\n\r\n\t\t\t\tfaces.push( getColorIndex( face.color ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( hasFaceVertexColor ) {\r\n\r\n\t\t\t\tvar vertexColors = face.vertexColors;\r\n\r\n\t\t\t\tfaces.push(\r\n\t\t\t\t\tgetColorIndex( vertexColors[ 0 ] ),\r\n\t\t\t\t\tgetColorIndex( vertexColors[ 1 ] ),\r\n\t\t\t\t\tgetColorIndex( vertexColors[ 2 ] )\r\n\t\t\t\t);\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction setBit( value, position, enabled ) {\r\n\r\n\t\t\treturn enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );\r\n\r\n\t\t}\r\n\r\n\t\tfunction getNormalIndex( normal ) {\r\n\r\n\t\t\tvar hash = normal.x.toString() + normal.y.toString() + normal.z.toString();\r\n\r\n\t\t\tif ( normalsHash[ hash ] !== undefined ) {\r\n\r\n\t\t\t\treturn normalsHash[ hash ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tnormalsHash[ hash ] = normals.length / 3;\r\n\t\t\tnormals.push( normal.x, normal.y, normal.z );\r\n\r\n\t\t\treturn normalsHash[ hash ];\r\n\r\n\t\t}\r\n\r\n\t\tfunction getColorIndex( color ) {\r\n\r\n\t\t\tvar hash = color.r.toString() + color.g.toString() + color.b.toString();\r\n\r\n\t\t\tif ( colorsHash[ hash ] !== undefined ) {\r\n\r\n\t\t\t\treturn colorsHash[ hash ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tcolorsHash[ hash ] = colors.length;\r\n\t\t\tcolors.push( color.getHex() );\r\n\r\n\t\t\treturn colorsHash[ hash ];\r\n\r\n\t\t}\r\n\r\n\t\tfunction getUvIndex( uv ) {\r\n\r\n\t\t\tvar hash = uv.x.toString() + uv.y.toString();\r\n\r\n\t\t\tif ( uvsHash[ hash ] !== undefined ) {\r\n\r\n\t\t\t\treturn uvsHash[ hash ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tuvsHash[ hash ] = uvs.length / 2;\r\n\t\t\tuvs.push( uv.x, uv.y );\r\n\r\n\t\t\treturn uvsHash[ hash ];\r\n\r\n\t\t}\r\n\r\n\t\tdata.data = {};\r\n\r\n\t\tdata.data.vertices = vertices;\r\n\t\tdata.data.normals = normals;\r\n\t\tif ( colors.length > 0 ) data.data.colors = colors;\r\n\t\tif ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility\r\n\t\tdata.data.faces = faces;\r\n\r\n\t\treturn data;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\t/*\r\n\t\t// Handle primitives\r\n\r\n\t\tvar parameters = this.parameters;\r\n\r\n\t\tif ( parameters !== undefined ) {\r\n\r\n\t\t\tvar values = [];\r\n\r\n\t\t\tfor ( var key in parameters ) {\r\n\r\n\t\t\t\tvalues.push( parameters[ key ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar geometry = Object.create( this.constructor.prototype );\r\n\t\t\tthis.constructor.apply( geometry, values );\r\n\t\t\treturn geometry;\r\n\r\n\t\t}\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\t\t*/\r\n\r\n\t\treturn new THREE.Geometry().copy( this );\r\n\r\n\t},\r\n\r\n\tcopy: function ( source ) {\r\n\r\n\t\tthis.vertices = [];\r\n\t\tthis.faces = [];\r\n\t\tthis.faceVertexUvs = [ [] ];\r\n\r\n\t\tvar vertices = source.vertices;\r\n\r\n\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\r\n\r\n\t\t\tthis.vertices.push( vertices[ i ].clone() );\r\n\r\n\t\t}\r\n\r\n\t\tvar faces = source.faces;\r\n\r\n\t\tfor ( var i = 0, il = faces.length; i < il; i ++ ) {\r\n\r\n\t\t\tthis.faces.push( faces[ i ].clone() );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar faceVertexUvs = source.faceVertexUvs[ i ];\r\n\r\n\t\t\tif ( this.faceVertexUvs[ i ] === undefined ) {\r\n\r\n\t\t\t\tthis.faceVertexUvs[ i ] = [];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\tvar uvs = faceVertexUvs[ j ], uvsCopy = [];\r\n\r\n\t\t\t\tfor ( var k = 0, kl = uvs.length; k < kl; k ++ ) {\r\n\r\n\t\t\t\t\tvar uv = uvs[ k ];\r\n\r\n\t\t\t\t\tuvsCopy.push( uv.clone() );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.faceVertexUvs[ i ].push( uvsCopy );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdispose: function () {\r\n\r\n\t\tthis.dispatchEvent( { type: 'dispose' } );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.EventDispatcher.prototype.apply( THREE.Geometry.prototype );\r\n\r\nTHREE.GeometryIdCount = 0;\r\n\r\n// File:src/core/DirectGeometry.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.DirectGeometry = function () {\r\n\r\n\tObject.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );\r\n\r\n\tthis.uuid = THREE.Math.generateUUID();\r\n\r\n\tthis.name = '';\r\n\tthis.type = 'DirectGeometry';\r\n\r\n\tthis.indices = [];\r\n\tthis.vertices = [];\r\n\tthis.normals = [];\r\n\tthis.colors = [];\r\n\tthis.uvs = [];\r\n\tthis.uvs2 = [];\r\n\r\n\tthis.groups = [];\r\n\r\n\tthis.morphTargets = {};\r\n\r\n\tthis.skinWeights = [];\r\n\tthis.skinIndices = [];\r\n\r\n\t// this.lineDistances = [];\r\n\r\n\tthis.boundingBox = null;\r\n\tthis.boundingSphere = null;\r\n\r\n\t// update flags\r\n\r\n\tthis.verticesNeedUpdate = false;\r\n\tthis.normalsNeedUpdate = false;\r\n\tthis.colorsNeedUpdate = false;\r\n\tthis.uvsNeedUpdate = false;\r\n\tthis.groupsNeedUpdate = false;\r\n\r\n};\r\n\r\nTHREE.DirectGeometry.prototype = {\r\n\r\n\tconstructor: THREE.DirectGeometry,\r\n\r\n\tcomputeBoundingBox: THREE.Geometry.prototype.computeBoundingBox,\r\n\tcomputeBoundingSphere: THREE.Geometry.prototype.computeBoundingSphere,\r\n\r\n\tcomputeFaceNormals: function () {\r\n\r\n\t\tconsole.warn( 'THREE.DirectGeometry: computeFaceNormals() is not a method of this type of geometry.' );\r\n\r\n\t},\r\n\r\n\tcomputeVertexNormals: function () {\r\n\r\n\t\tconsole.warn( 'THREE.DirectGeometry: computeVertexNormals() is not a method of this type of geometry.' );\r\n\r\n\t},\r\n\r\n\tcomputeGroups: function ( geometry ) {\r\n\r\n\t\tvar group;\r\n\t\tvar groups = [];\r\n\t\tvar materialIndex;\r\n\r\n\t\tvar faces = geometry.faces;\r\n\r\n\t\tfor ( var i = 0; i < faces.length; i ++ ) {\r\n\r\n\t\t\tvar face = faces[ i ];\r\n\r\n\t\t\t// materials\r\n\r\n\t\t\tif ( face.materialIndex !== materialIndex ) {\r\n\r\n\t\t\t\tmaterialIndex = face.materialIndex;\r\n\r\n\t\t\t\tif ( group !== undefined ) {\r\n\r\n\t\t\t\t\tgroup.count = ( i * 3 ) - group.start;\r\n\t\t\t\t\tgroups.push( group );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tgroup = {\r\n\t\t\t\t\tstart: i * 3,\r\n\t\t\t\t\tmaterialIndex: materialIndex\r\n\t\t\t\t};\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( group !== undefined ) {\r\n\r\n\t\t\tgroup.count = ( i * 3 ) - group.start;\r\n\t\t\tgroups.push( group );\r\n\r\n\t\t}\r\n\r\n\t\tthis.groups = groups;\r\n\r\n\t},\r\n\r\n\tfromGeometry: function ( geometry ) {\r\n\r\n\t\tvar faces = geometry.faces;\r\n\t\tvar vertices = geometry.vertices;\r\n\t\tvar faceVertexUvs = geometry.faceVertexUvs;\r\n\r\n\t\tvar hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;\r\n\t\tvar hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;\r\n\r\n\t\t// morphs\r\n\r\n\t\tvar morphTargets = geometry.morphTargets;\r\n\t\tvar morphTargetsLength = morphTargets.length;\r\n\r\n\t\tvar morphTargetsPosition;\r\n\r\n\t\tif ( morphTargetsLength > 0 ) {\r\n\r\n\t\t\tmorphTargetsPosition = [];\r\n\r\n\t\t\tfor ( var i = 0; i < morphTargetsLength; i ++ ) {\r\n\r\n\t\t\t\tmorphTargetsPosition[ i ] = [];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.morphTargets.position = morphTargetsPosition;\r\n\r\n\t\t}\r\n\r\n\t\tvar morphNormals = geometry.morphNormals;\r\n\t\tvar morphNormalsLength = morphNormals.length;\r\n\r\n\t\tvar morphTargetsNormal;\r\n\r\n\t\tif ( morphNormalsLength > 0 ) {\r\n\r\n\t\t\tmorphTargetsNormal = [];\r\n\r\n\t\t\tfor ( var i = 0; i < morphNormalsLength; i ++ ) {\r\n\r\n\t\t\t\tmorphTargetsNormal[ i ] = [];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.morphTargets.normal = morphTargetsNormal;\r\n\r\n\t\t}\r\n\r\n\t\t// skins\r\n\r\n\t\tvar skinIndices = geometry.skinIndices;\r\n\t\tvar skinWeights = geometry.skinWeights;\r\n\r\n\t\tvar hasSkinIndices = skinIndices.length === vertices.length;\r\n\t\tvar hasSkinWeights = skinWeights.length === vertices.length;\r\n\r\n\t\t//\r\n\r\n\t\tfor ( var i = 0; i < faces.length; i ++ ) {\r\n\r\n\t\t\tvar face = faces[ i ];\r\n\r\n\t\t\tthis.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );\r\n\r\n\t\t\tvar vertexNormals = face.vertexNormals;\r\n\r\n\t\t\tif ( vertexNormals.length === 3 ) {\r\n\r\n\t\t\t\tthis.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tvar normal = face.normal;\r\n\r\n\t\t\t\tthis.normals.push( normal, normal, normal );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar vertexColors = face.vertexColors;\r\n\r\n\t\t\tif ( vertexColors.length === 3 ) {\r\n\r\n\t\t\t\tthis.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tvar color = face.color;\r\n\r\n\t\t\t\tthis.colors.push( color, color, color );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( hasFaceVertexUv === true ) {\r\n\r\n\t\t\t\tvar vertexUvs = faceVertexUvs[ 0 ][ i ];\r\n\r\n\t\t\t\tif ( vertexUvs !== undefined ) {\r\n\r\n\t\t\t\t\tthis.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tconsole.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );\r\n\r\n\t\t\t\t\tthis.uvs.push( new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2() );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( hasFaceVertexUv2 === true ) {\r\n\r\n\t\t\t\tvar vertexUvs = faceVertexUvs[ 1 ][ i ];\r\n\r\n\t\t\t\tif ( vertexUvs !== undefined ) {\r\n\r\n\t\t\t\t\tthis.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tconsole.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );\r\n\r\n\t\t\t\t\tthis.uvs2.push( new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2() );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// morphs\r\n\r\n\t\t\tfor ( var j = 0; j < morphTargetsLength; j ++ ) {\r\n\r\n\t\t\t\tvar morphTarget = morphTargets[ j ].vertices;\r\n\r\n\t\t\t\tmorphTargetsPosition[ j ].push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var j = 0; j < morphNormalsLength; j ++ ) {\r\n\r\n\t\t\t\tvar morphNormal = morphNormals[ j ].vertexNormals[ i ];\r\n\r\n\t\t\t\tmorphTargetsNormal[ j ].push( morphNormal.a, morphNormal.b, morphNormal.c );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// skins\r\n\r\n\t\t\tif ( hasSkinIndices ) {\r\n\r\n\t\t\t\tthis.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( hasSkinWeights ) {\r\n\r\n\t\t\t\tthis.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.computeGroups( geometry );\r\n\r\n\t\tthis.verticesNeedUpdate = geometry.verticesNeedUpdate;\r\n\t\tthis.normalsNeedUpdate = geometry.normalsNeedUpdate;\r\n\t\tthis.colorsNeedUpdate = geometry.colorsNeedUpdate;\r\n\t\tthis.uvsNeedUpdate = geometry.uvsNeedUpdate;\r\n\t\tthis.groupsNeedUpdate = geometry.groupsNeedUpdate;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdispose: function () {\r\n\r\n\t\tthis.dispatchEvent( { type: 'dispose' } );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.EventDispatcher.prototype.apply( THREE.DirectGeometry.prototype );\r\n\r\n// File:src/core/BufferGeometry.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.BufferGeometry = function () {\r\n\r\n\tObject.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );\r\n\r\n\tthis.uuid = THREE.Math.generateUUID();\r\n\r\n\tthis.name = '';\r\n\tthis.type = 'BufferGeometry';\r\n\r\n\tthis.index = null;\r\n\tthis.attributes = {};\r\n\r\n\tthis.morphAttributes = {};\r\n\r\n\tthis.groups = [];\r\n\r\n\tthis.boundingBox = null;\r\n\tthis.boundingSphere = null;\r\n\r\n\tthis.drawRange = { start: 0, count: Infinity };\r\n\r\n};\r\n\r\nTHREE.BufferGeometry.prototype = {\r\n\r\n\tconstructor: THREE.BufferGeometry,\r\n\r\n\tgetIndex: function () {\r\n\r\n\t\treturn this.index;\r\n\r\n\t},\r\n\r\n\tsetIndex: function ( index ) {\r\n\r\n\t\tthis.index = index;\r\n\r\n\t},\r\n\r\n\taddAttribute: function ( name, attribute ) {\r\n\r\n\t\tif ( attribute instanceof THREE.BufferAttribute === false && attribute instanceof THREE.InterleavedBufferAttribute === false ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );\r\n\r\n\t\t\tthis.addAttribute( name, new THREE.BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );\r\n\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tif ( name === 'index' ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );\r\n\t\t\tthis.setIndex( attribute );\r\n\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tthis.attributes[ name ] = attribute;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetAttribute: function ( name ) {\r\n\r\n\t\treturn this.attributes[ name ];\r\n\r\n\t},\r\n\r\n\tremoveAttribute: function ( name ) {\r\n\r\n\t\tdelete this.attributes[ name ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddGroup: function ( start, count, materialIndex ) {\r\n\r\n\t\tthis.groups.push( {\r\n\r\n\t\t\tstart: start,\r\n\t\t\tcount: count,\r\n\t\t\tmaterialIndex: materialIndex !== undefined ? materialIndex : 0\r\n\r\n\t\t} );\r\n\r\n\t},\r\n\r\n\tclearGroups: function () {\r\n\r\n\t\tthis.groups = [];\r\n\r\n\t},\r\n\r\n\tsetDrawRange: function ( start, count ) {\r\n\r\n\t\tthis.drawRange.start = start;\r\n\t\tthis.drawRange.count = count;\r\n\r\n\t},\r\n\r\n\tapplyMatrix: function ( matrix ) {\r\n\r\n\t\tvar position = this.attributes.position;\r\n\r\n\t\tif ( position !== undefined ) {\r\n\r\n\t\t\tmatrix.applyToVector3Array( position.array );\r\n\t\t\tposition.needsUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t\tvar normal = this.attributes.normal;\r\n\r\n\t\tif ( normal !== undefined ) {\r\n\r\n\t\t\tvar normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );\r\n\r\n\t\t\tnormalMatrix.applyToVector3Array( normal.array );\r\n\t\t\tnormal.needsUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.boundingBox !== null ) {\r\n\r\n\t\t\tthis.computeBoundingBox();\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.boundingSphere !== null ) {\r\n\r\n\t\t\tthis.computeBoundingSphere();\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\trotateX: function () {\r\n\r\n\t\t// rotate geometry around world x-axis\r\n\r\n\t\tvar m1;\r\n\r\n\t\treturn function rotateX( angle ) {\r\n\r\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\r\n\r\n\t\t\tm1.makeRotationX( angle );\r\n\r\n\t\t\tthis.applyMatrix( m1 );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\trotateY: function () {\r\n\r\n\t\t// rotate geometry around world y-axis\r\n\r\n\t\tvar m1;\r\n\r\n\t\treturn function rotateY( angle ) {\r\n\r\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\r\n\r\n\t\t\tm1.makeRotationY( angle );\r\n\r\n\t\t\tthis.applyMatrix( m1 );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\trotateZ: function () {\r\n\r\n\t\t// rotate geometry around world z-axis\r\n\r\n\t\tvar m1;\r\n\r\n\t\treturn function rotateZ( angle ) {\r\n\r\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\r\n\r\n\t\t\tm1.makeRotationZ( angle );\r\n\r\n\t\t\tthis.applyMatrix( m1 );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\ttranslate: function () {\r\n\r\n\t\t// translate geometry\r\n\r\n\t\tvar m1;\r\n\r\n\t\treturn function translate( x, y, z ) {\r\n\r\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\r\n\r\n\t\t\tm1.makeTranslation( x, y, z );\r\n\r\n\t\t\tthis.applyMatrix( m1 );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tscale: function () {\r\n\r\n\t\t// scale geometry\r\n\r\n\t\tvar m1;\r\n\r\n\t\treturn function scale( x, y, z ) {\r\n\r\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\r\n\r\n\t\t\tm1.makeScale( x, y, z );\r\n\r\n\t\t\tthis.applyMatrix( m1 );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tlookAt: function () {\r\n\r\n\t\tvar obj;\r\n\r\n\t\treturn function lookAt( vector ) {\r\n\r\n\t\t\tif ( obj === undefined ) obj = new THREE.Object3D();\r\n\r\n\t\t\tobj.lookAt( vector );\r\n\r\n\t\t\tobj.updateMatrix();\r\n\r\n\t\t\tthis.applyMatrix( obj.matrix );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tcenter: function () {\r\n\r\n\t\tthis.computeBoundingBox();\r\n\r\n\t\tvar offset = this.boundingBox.center().negate();\r\n\r\n\t\tthis.translate( offset.x, offset.y, offset.z );\r\n\r\n\t\treturn offset;\r\n\r\n\t},\r\n\r\n\tsetFromObject: function ( object ) {\r\n\r\n\t\t// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );\r\n\r\n\t\tvar geometry = object.geometry;\r\n\r\n\t\tif ( object instanceof THREE.Points || object instanceof THREE.Line ) {\r\n\r\n\t\t\tvar positions = new THREE.Float32Attribute( geometry.vertices.length * 3, 3 );\r\n\t\t\tvar colors = new THREE.Float32Attribute( geometry.colors.length * 3, 3 );\r\n\r\n\t\t\tthis.addAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );\r\n\t\t\tthis.addAttribute( 'color', colors.copyColorsArray( geometry.colors ) );\r\n\r\n\t\t\tif ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {\r\n\r\n\t\t\t\tvar lineDistances = new THREE.Float32Attribute( geometry.lineDistances.length, 1 );\r\n\r\n\t\t\t\tthis.addAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( geometry.boundingSphere !== null ) {\r\n\r\n\t\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( geometry.boundingBox !== null ) {\r\n\r\n\t\t\t\tthis.boundingBox = geometry.boundingBox.clone();\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( object instanceof THREE.Mesh ) {\r\n\r\n\t\t\tif ( geometry instanceof THREE.Geometry ) {\r\n\r\n\t\t\t\tthis.fromGeometry( geometry );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tupdateFromObject: function ( object ) {\r\n\r\n\t\tvar geometry = object.geometry;\r\n\r\n\t\tif ( object instanceof THREE.Mesh ) {\r\n\r\n\t\t\tvar direct = geometry.__directGeometry;\r\n\r\n\t\t\tif ( direct === undefined ) {\r\n\r\n\t\t\t\treturn this.fromGeometry( geometry );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tdirect.verticesNeedUpdate = geometry.verticesNeedUpdate;\r\n\t\t\tdirect.normalsNeedUpdate = geometry.normalsNeedUpdate;\r\n\t\t\tdirect.colorsNeedUpdate = geometry.colorsNeedUpdate;\r\n\t\t\tdirect.uvsNeedUpdate = geometry.uvsNeedUpdate;\r\n\t\t\tdirect.groupsNeedUpdate = geometry.groupsNeedUpdate;\r\n\r\n\t\t\tgeometry.verticesNeedUpdate = false;\r\n\t\t\tgeometry.normalsNeedUpdate = false;\r\n\t\t\tgeometry.colorsNeedUpdate = false;\r\n\t\t\tgeometry.uvsNeedUpdate = false;\r\n\t\t\tgeometry.groupsNeedUpdate = false;\r\n\r\n\t\t\tgeometry = direct;\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.verticesNeedUpdate === true ) {\r\n\r\n\t\t\tvar attribute = this.attributes.position;\r\n\r\n\t\t\tif ( attribute !== undefined ) {\r\n\r\n\t\t\t\tattribute.copyVector3sArray( geometry.vertices );\r\n\t\t\t\tattribute.needsUpdate = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry.verticesNeedUpdate = false;\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.normalsNeedUpdate === true ) {\r\n\r\n\t\t\tvar attribute = this.attributes.normal;\r\n\r\n\t\t\tif ( attribute !== undefined ) {\r\n\r\n\t\t\t\tattribute.copyVector3sArray( geometry.normals );\r\n\t\t\t\tattribute.needsUpdate = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry.normalsNeedUpdate = false;\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.colorsNeedUpdate === true ) {\r\n\r\n\t\t\tvar attribute = this.attributes.color;\r\n\r\n\t\t\tif ( attribute !== undefined ) {\r\n\r\n\t\t\t\tattribute.copyColorsArray( geometry.colors );\r\n\t\t\t\tattribute.needsUpdate = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry.colorsNeedUpdate = false;\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.uvsNeedUpdate ) {\r\n\r\n\t\t\tvar attribute = this.attributes.uv;\r\n\r\n\t\t\tif ( attribute !== undefined ) {\r\n\r\n\t\t\t\tattribute.copyVector2sArray( geometry.uvs );\r\n\t\t\t\tattribute.needsUpdate = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry.uvsNeedUpdate = false;\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.lineDistancesNeedUpdate ) {\r\n\r\n\t\t\tvar attribute = this.attributes.lineDistance;\r\n\r\n\t\t\tif ( attribute !== undefined ) {\r\n\r\n\t\t\t\tattribute.copyArray( geometry.lineDistances );\r\n\t\t\t\tattribute.needsUpdate = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry.lineDistancesNeedUpdate = false;\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.groupsNeedUpdate ) {\r\n\r\n\t\t\tgeometry.computeGroups( object.geometry );\r\n\t\t\tthis.groups = geometry.groups;\r\n\r\n\t\t\tgeometry.groupsNeedUpdate = false;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tfromGeometry: function ( geometry ) {\r\n\r\n\t\tgeometry.__directGeometry = new THREE.DirectGeometry().fromGeometry( geometry );\r\n\r\n\t\treturn this.fromDirectGeometry( geometry.__directGeometry );\r\n\r\n\t},\r\n\r\n\tfromDirectGeometry: function ( geometry ) {\r\n\r\n\t\tvar positions = new Float32Array( geometry.vertices.length * 3 );\r\n\t\tthis.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );\r\n\r\n\t\tif ( geometry.normals.length > 0 ) {\r\n\r\n\t\t\tvar normals = new Float32Array( geometry.normals.length * 3 );\r\n\t\t\tthis.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.colors.length > 0 ) {\r\n\r\n\t\t\tvar colors = new Float32Array( geometry.colors.length * 3 );\r\n\t\t\tthis.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.uvs.length > 0 ) {\r\n\r\n\t\t\tvar uvs = new Float32Array( geometry.uvs.length * 2 );\r\n\t\t\tthis.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.uvs2.length > 0 ) {\r\n\r\n\t\t\tvar uvs2 = new Float32Array( geometry.uvs2.length * 2 );\r\n\t\t\tthis.addAttribute( 'uv2', new THREE.BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.indices.length > 0 ) {\r\n\r\n\t\t\tvar TypeArray = geometry.vertices.length > 65535 ? Uint32Array : Uint16Array;\r\n\t\t\tvar indices = new TypeArray( geometry.indices.length * 3 );\r\n\t\t\tthis.setIndex( new THREE.BufferAttribute( indices, 1 ).copyIndicesArray( geometry.indices ) );\r\n\r\n\t\t}\r\n\r\n\t\t// groups\r\n\r\n\t\tthis.groups = geometry.groups;\r\n\r\n\t\t// morphs\r\n\r\n\t\tfor ( var name in geometry.morphTargets ) {\r\n\r\n\t\t\tvar array = [];\r\n\t\t\tvar morphTargets = geometry.morphTargets[ name ];\r\n\r\n\t\t\tfor ( var i = 0, l = morphTargets.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar morphTarget = morphTargets[ i ];\r\n\r\n\t\t\t\tvar attribute = new THREE.Float32Attribute( morphTarget.length * 3, 3 );\r\n\r\n\t\t\t\tarray.push( attribute.copyVector3sArray( morphTarget ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.morphAttributes[ name ] = array;\r\n\r\n\t\t}\r\n\r\n\t\t// skinning\r\n\r\n\t\tif ( geometry.skinIndices.length > 0 ) {\r\n\r\n\t\t\tvar skinIndices = new THREE.Float32Attribute( geometry.skinIndices.length * 4, 4 );\r\n\t\t\tthis.addAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.skinWeights.length > 0 ) {\r\n\r\n\t\t\tvar skinWeights = new THREE.Float32Attribute( geometry.skinWeights.length * 4, 4 );\r\n\t\t\tthis.addAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tif ( geometry.boundingSphere !== null ) {\r\n\r\n\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.boundingBox !== null ) {\r\n\r\n\t\t\tthis.boundingBox = geometry.boundingBox.clone();\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcomputeBoundingBox: function () {\r\n\r\n\t\tif ( this.boundingBox === null ) {\r\n\r\n\t\t\tthis.boundingBox = new THREE.Box3();\r\n\r\n\t\t}\r\n\r\n\t\tvar positions = this.attributes.position.array;\r\n\r\n\t\tif ( positions !== undefined ) {\r\n\r\n\t\t\tthis.boundingBox.setFromArray( positions );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.boundingBox.makeEmpty();\r\n\r\n\t\t}\r\n\r\n\t\tif ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {\r\n\r\n\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.', this );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tcomputeBoundingSphere: function () {\r\n\r\n\t\tvar box = new THREE.Box3();\r\n\t\tvar vector = new THREE.Vector3();\r\n\r\n\t\treturn function () {\r\n\r\n\t\t\tif ( this.boundingSphere === null ) {\r\n\r\n\t\t\t\tthis.boundingSphere = new THREE.Sphere();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar positions = this.attributes.position.array;\r\n\r\n\t\t\tif ( positions ) {\r\n\r\n\t\t\t\tvar center = this.boundingSphere.center;\r\n\r\n\t\t\t\tbox.setFromArray( positions );\r\n\t\t\t\tbox.center( center );\r\n\r\n\t\t\t\t// hoping to find a boundingSphere with a radius smaller than the\r\n\t\t\t\t// boundingSphere of the boundingBox: sqrt(3) smaller in the best case\r\n\r\n\t\t\t\tvar maxRadiusSq = 0;\r\n\r\n\t\t\t\tfor ( var i = 0, il = positions.length; i < il; i += 3 ) {\r\n\r\n\t\t\t\t\tvector.fromArray( positions, i );\r\n\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.boundingSphere.radius = Math.sqrt( maxRadiusSq );\r\n\r\n\t\t\t\tif ( isNaN( this.boundingSphere.radius ) ) {\r\n\r\n\t\t\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.', this );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tcomputeFaceNormals: function () {\r\n\r\n\t\t// backwards compatibility\r\n\r\n\t},\r\n\r\n\tcomputeVertexNormals: function () {\r\n\r\n\t\tvar index = this.index;\r\n\t\tvar attributes = this.attributes;\r\n\t\tvar groups = this.groups;\r\n\r\n\t\tif ( attributes.position ) {\r\n\r\n\t\t\tvar positions = attributes.position.array;\r\n\r\n\t\t\tif ( attributes.normal === undefined ) {\r\n\r\n\t\t\t\tthis.addAttribute( 'normal', new THREE.BufferAttribute( new Float32Array( positions.length ), 3 ) );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// reset existing normals to zero\r\n\r\n\t\t\t\tvar array = attributes.normal.array;\r\n\r\n\t\t\t\tfor ( var i = 0, il = array.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tarray[ i ] = 0;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar normals = attributes.normal.array;\r\n\r\n\t\t\tvar vA, vB, vC,\r\n\r\n\t\t\tpA = new THREE.Vector3(),\r\n\t\t\tpB = new THREE.Vector3(),\r\n\t\t\tpC = new THREE.Vector3(),\r\n\r\n\t\t\tcb = new THREE.Vector3(),\r\n\t\t\tab = new THREE.Vector3();\r\n\r\n\t\t\t// indexed elements\r\n\r\n\t\t\tif ( index ) {\r\n\r\n\t\t\t\tvar indices = index.array;\r\n\r\n\t\t\t\tif ( groups.length === 0 ) {\r\n\r\n\t\t\t\t\tthis.addGroup( 0, indices.length );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor ( var j = 0, jl = groups.length; j < jl; ++ j ) {\r\n\r\n\t\t\t\t\tvar group = groups[ j ];\r\n\r\n\t\t\t\t\tvar start = group.start;\r\n\t\t\t\t\tvar count = group.count;\r\n\r\n\t\t\t\t\tfor ( var i = start, il = start + count; i < il; i += 3 ) {\r\n\r\n\t\t\t\t\t\tvA = indices[ i + 0 ] * 3;\r\n\t\t\t\t\t\tvB = indices[ i + 1 ] * 3;\r\n\t\t\t\t\t\tvC = indices[ i + 2 ] * 3;\r\n\r\n\t\t\t\t\t\tpA.fromArray( positions, vA );\r\n\t\t\t\t\t\tpB.fromArray( positions, vB );\r\n\t\t\t\t\t\tpC.fromArray( positions, vC );\r\n\r\n\t\t\t\t\t\tcb.subVectors( pC, pB );\r\n\t\t\t\t\t\tab.subVectors( pA, pB );\r\n\t\t\t\t\t\tcb.cross( ab );\r\n\r\n\t\t\t\t\t\tnormals[ vA ] += cb.x;\r\n\t\t\t\t\t\tnormals[ vA + 1 ] += cb.y;\r\n\t\t\t\t\t\tnormals[ vA + 2 ] += cb.z;\r\n\r\n\t\t\t\t\t\tnormals[ vB ] += cb.x;\r\n\t\t\t\t\t\tnormals[ vB + 1 ] += cb.y;\r\n\t\t\t\t\t\tnormals[ vB + 2 ] += cb.z;\r\n\r\n\t\t\t\t\t\tnormals[ vC ] += cb.x;\r\n\t\t\t\t\t\tnormals[ vC + 1 ] += cb.y;\r\n\t\t\t\t\t\tnormals[ vC + 2 ] += cb.z;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// non-indexed elements (unconnected triangle soup)\r\n\r\n\t\t\t\tfor ( var i = 0, il = positions.length; i < il; i += 9 ) {\r\n\r\n\t\t\t\t\tpA.fromArray( positions, i );\r\n\t\t\t\t\tpB.fromArray( positions, i + 3 );\r\n\t\t\t\t\tpC.fromArray( positions, i + 6 );\r\n\r\n\t\t\t\t\tcb.subVectors( pC, pB );\r\n\t\t\t\t\tab.subVectors( pA, pB );\r\n\t\t\t\t\tcb.cross( ab );\r\n\r\n\t\t\t\t\tnormals[ i ] = cb.x;\r\n\t\t\t\t\tnormals[ i + 1 ] = cb.y;\r\n\t\t\t\t\tnormals[ i + 2 ] = cb.z;\r\n\r\n\t\t\t\t\tnormals[ i + 3 ] = cb.x;\r\n\t\t\t\t\tnormals[ i + 4 ] = cb.y;\r\n\t\t\t\t\tnormals[ i + 5 ] = cb.z;\r\n\r\n\t\t\t\t\tnormals[ i + 6 ] = cb.x;\r\n\t\t\t\t\tnormals[ i + 7 ] = cb.y;\r\n\t\t\t\t\tnormals[ i + 8 ] = cb.z;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.normalizeNormals();\r\n\r\n\t\t\tattributes.normal.needsUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tmerge: function ( geometry, offset ) {\r\n\r\n\t\tif ( geometry instanceof THREE.BufferGeometry === false ) {\r\n\r\n\t\t\tconsole.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tvar attributes = this.attributes;\r\n\r\n\t\tfor ( var key in attributes ) {\r\n\r\n\t\t\tif ( geometry.attributes[ key ] === undefined ) continue;\r\n\r\n\t\t\tvar attribute1 = attributes[ key ];\r\n\t\t\tvar attributeArray1 = attribute1.array;\r\n\r\n\t\t\tvar attribute2 = geometry.attributes[ key ];\r\n\t\t\tvar attributeArray2 = attribute2.array;\r\n\r\n\t\t\tvar attributeSize = attribute2.itemSize;\r\n\r\n\t\t\tfor ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {\r\n\r\n\t\t\t\tattributeArray1[ j ] = attributeArray2[ i ];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tnormalizeNormals: function () {\r\n\r\n\t\tvar normals = this.attributes.normal.array;\r\n\r\n\t\tvar x, y, z, n;\r\n\r\n\t\tfor ( var i = 0, il = normals.length; i < il; i += 3 ) {\r\n\r\n\t\t\tx = normals[ i ];\r\n\t\t\ty = normals[ i + 1 ];\r\n\t\t\tz = normals[ i + 2 ];\r\n\r\n\t\t\tn = 1.0 / Math.sqrt( x * x + y * y + z * z );\r\n\r\n\t\t\tnormals[ i ] *= n;\r\n\t\t\tnormals[ i + 1 ] *= n;\r\n\t\t\tnormals[ i + 2 ] *= n;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\ttoNonIndexed: function () {\r\n\r\n\t\tif ( this.index === null ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.' );\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\tvar geometry2 = new THREE.BufferGeometry();\r\n\r\n\t\tvar indices = this.index.array;\r\n\t\tvar attributes = this.attributes;\r\n\r\n\t\tfor ( var name in attributes ) {\r\n\r\n\t\t\tvar attribute = attributes[ name ];\r\n\r\n\t\t\tvar array = attribute.array;\r\n\t\t\tvar itemSize = attribute.itemSize;\r\n\r\n\t\t\tvar array2 = new array.constructor( indices.length * itemSize );\r\n\r\n\t\t\tvar index = 0, index2 = 0;\r\n\r\n\t\t\tfor ( var i = 0, l = indices.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tindex = indices[ i ] * itemSize;\r\n\r\n\t\t\t\tfor ( var j = 0; j < itemSize; j ++ ) {\r\n\r\n\t\t\t\t\tarray2[ index2 ++ ] = array[ index ++ ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry2.addAttribute( name, new THREE.BufferAttribute( array2, itemSize ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn geometry2;\r\n\r\n\t},\r\n\r\n\ttoJSON: function () {\r\n\r\n\t\tvar data = {\r\n\t\t\tmetadata: {\r\n\t\t\t\tversion: 4.4,\r\n\t\t\t\ttype: 'BufferGeometry',\r\n\t\t\t\tgenerator: 'BufferGeometry.toJSON'\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t// standard BufferGeometry serialization\r\n\r\n\t\tdata.uuid = this.uuid;\r\n\t\tdata.type = this.type;\r\n\t\tif ( this.name !== '' ) data.name = this.name;\r\n\r\n\t\tif ( this.parameters !== undefined ) {\r\n\r\n\t\t\tvar parameters = this.parameters;\r\n\r\n\t\t\tfor ( var key in parameters ) {\r\n\r\n\t\t\t\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn data;\r\n\r\n\t\t}\r\n\r\n\t\tdata.data = { attributes: {} };\r\n\r\n\t\tvar index = this.index;\r\n\r\n\t\tif ( index !== null ) {\r\n\r\n\t\t\tvar array = Array.prototype.slice.call( index.array );\r\n\r\n\t\t\tdata.data.index = {\r\n\t\t\t\ttype: index.array.constructor.name,\r\n\t\t\t\tarray: array\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\tvar attributes = this.attributes;\r\n\r\n\t\tfor ( var key in attributes ) {\r\n\r\n\t\t\tvar attribute = attributes[ key ];\r\n\r\n\t\t\tvar array = Array.prototype.slice.call( attribute.array );\r\n\r\n\t\t\tdata.data.attributes[ key ] = {\r\n\t\t\t\titemSize: attribute.itemSize,\r\n\t\t\t\ttype: attribute.array.constructor.name,\r\n\t\t\t\tarray: array,\r\n\t\t\t\tnormalized: attribute.normalized\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\tvar groups = this.groups;\r\n\r\n\t\tif ( groups.length > 0 ) {\r\n\r\n\t\t\tdata.data.groups = JSON.parse( JSON.stringify( groups ) );\r\n\r\n\t\t}\r\n\r\n\t\tvar boundingSphere = this.boundingSphere;\r\n\r\n\t\tif ( boundingSphere !== null ) {\r\n\r\n\t\t\tdata.data.boundingSphere = {\r\n\t\t\t\tcenter: boundingSphere.center.toArray(),\r\n\t\t\t\tradius: boundingSphere.radius\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\treturn data;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\t/*\r\n\t\t// Handle primitives\r\n\r\n\t\tvar parameters = this.parameters;\r\n\r\n\t\tif ( parameters !== undefined ) {\r\n\r\n\t\t\tvar values = [];\r\n\r\n\t\t\tfor ( var key in parameters ) {\r\n\r\n\t\t\t\tvalues.push( parameters[ key ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar geometry = Object.create( this.constructor.prototype );\r\n\t\t\tthis.constructor.apply( geometry, values );\r\n\t\t\treturn geometry;\r\n\r\n\t\t}\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\t\t*/\r\n\r\n\t\treturn new THREE.BufferGeometry().copy( this );\r\n\r\n\t},\r\n\r\n\tcopy: function ( source ) {\r\n\r\n\t\tvar index = source.index;\r\n\r\n\t\tif ( index !== null ) {\r\n\r\n\t\t\tthis.setIndex( index.clone() );\r\n\r\n\t\t}\r\n\r\n\t\tvar attributes = source.attributes;\r\n\r\n\t\tfor ( var name in attributes ) {\r\n\r\n\t\t\tvar attribute = attributes[ name ];\r\n\t\t\tthis.addAttribute( name, attribute.clone() );\r\n\r\n\t\t}\r\n\r\n\t\tvar groups = source.groups;\r\n\r\n\t\tfor ( var i = 0, l = groups.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar group = groups[ i ];\r\n\t\t\tthis.addGroup( group.start, group.count, group.materialIndex );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdispose: function () {\r\n\r\n\t\tthis.dispatchEvent( { type: 'dispose' } );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.EventDispatcher.prototype.apply( THREE.BufferGeometry.prototype );\r\n\r\nTHREE.BufferGeometry.MaxIndex = 65535;\r\n\r\n// File:src/core/InstancedBufferGeometry.js\r\n\r\n/**\r\n * @author benaadams / https://twitter.com/ben_a_adams\r\n */\r\n\r\nTHREE.InstancedBufferGeometry = function () {\r\n\r\n\tTHREE.BufferGeometry.call( this );\r\n\r\n\tthis.type = 'InstancedBufferGeometry';\r\n\tthis.maxInstancedCount = undefined;\r\n\r\n};\r\n\r\nTHREE.InstancedBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\nTHREE.InstancedBufferGeometry.prototype.constructor = THREE.InstancedBufferGeometry;\r\n\r\nTHREE.InstancedBufferGeometry.prototype.addGroup = function ( start, count, instances ) {\r\n\r\n\tthis.groups.push( {\r\n\r\n\t\tstart: start,\r\n\t\tcount: count,\r\n\t\tinstances: instances\r\n\r\n\t} );\r\n\r\n};\r\n\r\nTHREE.InstancedBufferGeometry.prototype.copy = function ( source ) {\r\n\r\n\tvar index = source.index;\r\n\r\n\tif ( index !== null ) {\r\n\r\n\t\tthis.setIndex( index.clone() );\r\n\r\n\t}\r\n\r\n\tvar attributes = source.attributes;\r\n\r\n\tfor ( var name in attributes ) {\r\n\r\n\t\tvar attribute = attributes[ name ];\r\n\t\tthis.addAttribute( name, attribute.clone() );\r\n\r\n\t}\r\n\r\n\tvar groups = source.groups;\r\n\r\n\tfor ( var i = 0, l = groups.length; i < l; i ++ ) {\r\n\r\n\t\tvar group = groups[ i ];\r\n\t\tthis.addGroup( group.start, group.count, group.instances );\r\n\r\n\t}\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\nTHREE.EventDispatcher.prototype.apply( THREE.InstancedBufferGeometry.prototype );\r\n\r\n// File:src/core/Uniform.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Uniform = function ( value ) {\r\n\r\n\tif ( typeof value === 'string' ) {\r\n\r\n\t\tconsole.warn( 'THREE.Uniform: Type parameter is no longer needed.' );\r\n\t\tvalue = arguments[ 1 ];\r\n\r\n\t}\r\n\r\n\tthis.value = value;\r\n\r\n\tthis.dynamic = false;\r\n\r\n};\r\n\r\nTHREE.Uniform.prototype = {\r\n\r\n\tconstructor: THREE.Uniform,\r\n\r\n\tonUpdate: function ( callback ) {\r\n\r\n\t\tthis.dynamic = true;\r\n\t\tthis.onUpdateCallback = callback;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/animation/AnimationClip.js\r\n\r\n/**\r\n *\r\n * Reusable set of Tracks that represent an animation.\r\n *\r\n * @author Ben Houston / http://clara.io/\r\n * @author David Sarno / http://lighthaus.us/\r\n */\r\n\r\nTHREE.AnimationClip = function ( name, duration, tracks ) {\r\n\r\n\tthis.name = name || THREE.Math.generateUUID();\r\n\tthis.tracks = tracks;\r\n\tthis.duration = ( duration !== undefined ) ? duration : -1;\r\n\r\n\t// this means it should figure out its duration by scanning the tracks\r\n\tif ( this.duration < 0 ) {\r\n\r\n\t\tthis.resetDuration();\r\n\r\n\t}\r\n\r\n\t// maybe only do these on demand, as doing them here could potentially slow down loading\r\n\t// but leaving these here during development as this ensures a lot of testing of these functions\r\n\tthis.trim();\r\n\tthis.optimize();\r\n\r\n};\r\n\r\nTHREE.AnimationClip.prototype = {\r\n\r\n\tconstructor: THREE.AnimationClip,\r\n\r\n\tresetDuration: function() {\r\n\r\n\t\tvar tracks = this.tracks,\r\n\t\t\tduration = 0;\r\n\r\n\t\tfor ( var i = 0, n = tracks.length; i !== n; ++ i ) {\r\n\r\n\t\t\tvar track = this.tracks[ i ];\r\n\r\n\t\t\tduration = Math.max(\r\n\t\t\t\t\tduration, track.times[ track.times.length - 1 ] );\r\n\r\n\t\t}\r\n\r\n\t\tthis.duration = duration;\r\n\r\n\t},\r\n\r\n\ttrim: function() {\r\n\r\n\t\tfor ( var i = 0; i < this.tracks.length; i ++ ) {\r\n\r\n\t\t\tthis.tracks[ i ].trim( 0, this.duration );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\toptimize: function() {\r\n\r\n\t\tfor ( var i = 0; i < this.tracks.length; i ++ ) {\r\n\r\n\t\t\tthis.tracks[ i ].optimize();\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// Static methods:\r\n\r\nObject.assign( THREE.AnimationClip, {\r\n\r\n\tparse: function( json ) {\r\n\r\n\t\tvar tracks = [],\r\n\t\t\tjsonTracks = json.tracks,\r\n\t\t\tframeTime = 1.0 / ( json.fps || 1.0 );\r\n\r\n\t\tfor ( var i = 0, n = jsonTracks.length; i !== n; ++ i ) {\r\n\r\n\t\t\ttracks.push( THREE.KeyframeTrack.parse( jsonTracks[ i ] ).scale( frameTime ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn new THREE.AnimationClip( json.name, json.duration, tracks );\r\n\r\n\t},\r\n\r\n\r\n\ttoJSON: function( clip ) {\r\n\r\n\t\tvar tracks = [],\r\n\t\t\tclipTracks = clip.tracks;\r\n\r\n\t\tvar json = {\r\n\r\n\t\t\t'name': clip.name,\r\n\t\t\t'duration': clip.duration,\r\n\t\t\t'tracks': tracks\r\n\r\n\t\t};\r\n\r\n\t\tfor ( var i = 0, n = clipTracks.length; i !== n; ++ i ) {\r\n\r\n\t\t\ttracks.push( THREE.KeyframeTrack.toJSON( clipTracks[ i ] ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn json;\r\n\r\n\t},\r\n\r\n\r\n\tCreateFromMorphTargetSequence: function( name, morphTargetSequence, fps, noLoop ) {\r\n\r\n\t\tvar numMorphTargets = morphTargetSequence.length;\r\n\t\tvar tracks = [];\r\n\r\n\t\tfor ( var i = 0; i < numMorphTargets; i ++ ) {\r\n\r\n\t\t\tvar times = [];\r\n\t\t\tvar values = [];\r\n\r\n\t\t\ttimes.push(\r\n\t\t\t\t\t( i + numMorphTargets - 1 ) % numMorphTargets,\r\n\t\t\t\t\ti,\r\n\t\t\t\t\t( i + 1 ) % numMorphTargets );\r\n\r\n\t\t\tvalues.push( 0, 1, 0 );\r\n\r\n\t\t\tvar order = THREE.AnimationUtils.getKeyframeOrder( times );\r\n\t\t\ttimes = THREE.AnimationUtils.sortedArray( times, 1, order );\r\n\t\t\tvalues = THREE.AnimationUtils.sortedArray( values, 1, order );\r\n\r\n\t\t\t// if there is a key at the first frame, duplicate it as the\r\n\t\t\t// last frame as well for perfect loop.\r\n\t\t\tif ( ! noLoop && times[ 0 ] === 0 ) {\r\n\r\n\t\t\t\ttimes.push( numMorphTargets );\r\n\t\t\t\tvalues.push( values[ 0 ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttracks.push(\r\n\t\t\t\t\tnew THREE.NumberKeyframeTrack(\r\n\t\t\t\t\t\t'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',\r\n\t\t\t\t\t\ttimes, values\r\n\t\t\t\t\t).scale( 1.0 / fps ) );\r\n\t\t}\r\n\r\n\t\treturn new THREE.AnimationClip( name, -1, tracks );\r\n\r\n\t},\r\n\r\n\tfindByName: function( clipArray, name ) {\r\n\r\n\t\tfor ( var i = 0; i < clipArray.length; i ++ ) {\r\n\r\n\t\t\tif ( clipArray[ i ].name === name ) {\r\n\r\n\t\t\t\treturn clipArray[ i ];\r\n\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn null;\r\n\r\n\t},\r\n\r\n\tCreateClipsFromMorphTargetSequences: function( morphTargets, fps, noLoop ) {\r\n\r\n\t\tvar animationToMorphTargets = {};\r\n\r\n\t\t// tested with https://regex101.com/ on trick sequences\r\n\t\t// such flamingo_flyA_003, flamingo_run1_003, crdeath0059\r\n\t\tvar pattern = /^([\\w-]*?)([\\d]+)$/;\r\n\r\n\t\t// sort morph target names into animation groups based\r\n\t\t// patterns like Walk_001, Walk_002, Run_001, Run_002\r\n\t\tfor ( var i = 0, il = morphTargets.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar morphTarget = morphTargets[ i ];\r\n\t\t\tvar parts = morphTarget.name.match( pattern );\r\n\r\n\t\t\tif ( parts && parts.length > 1 ) {\r\n\r\n\t\t\t\tvar name = parts[ 1 ];\r\n\r\n\t\t\t\tvar animationMorphTargets = animationToMorphTargets[ name ];\r\n\t\t\t\tif ( ! animationMorphTargets ) {\r\n\r\n\t\t\t\t\tanimationToMorphTargets[ name ] = animationMorphTargets = [];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tanimationMorphTargets.push( morphTarget );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar clips = [];\r\n\r\n\t\tfor ( var name in animationToMorphTargets ) {\r\n\r\n\t\t\tclips.push( THREE.AnimationClip.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn clips;\r\n\r\n\t},\r\n\r\n\t// parse the animation.hierarchy format\r\n\tparseAnimation: function( animation, bones, nodeName ) {\r\n\r\n\t\tif ( ! animation ) {\r\n\r\n\t\t\tconsole.error( \"  no animation in JSONLoader data\" );\r\n\t\t\treturn null;\r\n\r\n\t\t}\r\n\r\n\t\tvar addNonemptyTrack = function(\r\n\t\t\t\ttrackType, trackName, animationKeys, propertyName, destTracks ) {\r\n\r\n\t\t\t// only return track if there are actually keys.\r\n\t\t\tif ( animationKeys.length !== 0 ) {\r\n\r\n\t\t\t\tvar times = [];\r\n\t\t\t\tvar values = [];\r\n\r\n\t\t\t\tTHREE.AnimationUtils.flattenJSON(\r\n\t\t\t\t\t\tanimationKeys, times, values, propertyName );\r\n\r\n\t\t\t\t// empty keys are filtered out, so check again\r\n\t\t\t\tif ( times.length !== 0 ) {\r\n\r\n\t\t\t\t\tdestTracks.push( new trackType( trackName, times, values ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t\tvar tracks = [];\r\n\r\n\t\tvar clipName = animation.name || 'default';\r\n\t\t// automatic length determination in AnimationClip.\r\n\t\tvar duration = animation.length || -1;\r\n\t\tvar fps = animation.fps || 30;\r\n\r\n\t\tvar hierarchyTracks = animation.hierarchy || [];\r\n\r\n\t\tfor ( var h = 0; h < hierarchyTracks.length; h ++ ) {\r\n\r\n\t\t\tvar animationKeys = hierarchyTracks[ h ].keys;\r\n\r\n\t\t\t// skip empty tracks\r\n\t\t\tif ( ! animationKeys || animationKeys.length == 0 ) continue;\r\n\r\n\t\t\t// process morph targets in a way exactly compatible\r\n\t\t\t// with AnimationHandler.init( animation )\r\n\t\t\tif ( animationKeys[0].morphTargets ) {\r\n\r\n\t\t\t\t// figure out all morph targets used in this track\r\n\t\t\t\tvar morphTargetNames = {};\r\n\t\t\t\tfor ( var k = 0; k < animationKeys.length; k ++ ) {\r\n\r\n\t\t\t\t\tif ( animationKeys[k].morphTargets ) {\r\n\r\n\t\t\t\t\t\tfor ( var m = 0; m < animationKeys[k].morphTargets.length; m ++ ) {\r\n\r\n\t\t\t\t\t\t\tmorphTargetNames[ animationKeys[k].morphTargets[m] ] = -1;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// create a track for each morph target with all zero\r\n\t\t\t\t// morphTargetInfluences except for the keys in which\r\n\t\t\t\t// the morphTarget is named.\r\n\t\t\t\tfor ( var morphTargetName in morphTargetNames ) {\r\n\r\n\t\t\t\t\tvar times = [];\r\n\t\t\t\t\tvar values = [];\r\n\r\n\t\t\t\t\tfor ( var m = 0;\r\n\t\t\t\t\t\t\tm !== animationKeys[k].morphTargets.length; ++ m ) {\r\n\r\n\t\t\t\t\t\tvar animationKey = animationKeys[k];\r\n\r\n\t\t\t\t\t\ttimes.push( animationKey.time );\r\n\t\t\t\t\t\tvalues.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 )\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\ttracks.push( new THREE.NumberKeyframeTrack(\r\n\t\t\t\t\t\t\t'.morphTargetInfluence[' + morphTargetName + ']', times, values ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tduration = morphTargetNames.length * ( fps || 1.0 );\r\n\r\n\t\t\t} else {\r\n\t\t\t\t// ...assume skeletal animation\r\n\r\n\t\t\t\tvar boneName = '.bones[' + bones[ h ].name + ']';\r\n\r\n\t\t\t\taddNonemptyTrack(\r\n\t\t\t\t\t\tTHREE.VectorKeyframeTrack, boneName + '.position',\r\n\t\t\t\t\t\tanimationKeys, 'pos', tracks );\r\n\r\n\t\t\t\taddNonemptyTrack(\r\n\t\t\t\t\t\tTHREE.QuaternionKeyframeTrack, boneName + '.quaternion',\r\n\t\t\t\t\t\tanimationKeys, 'rot', tracks );\r\n\r\n\t\t\t\taddNonemptyTrack(\r\n\t\t\t\t\t\tTHREE.VectorKeyframeTrack, boneName + '.scale',\r\n\t\t\t\t\t\tanimationKeys, 'scl', tracks );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( tracks.length === 0 ) {\r\n\r\n\t\t\treturn null;\r\n\r\n\t\t}\r\n\r\n\t\tvar clip = new THREE.AnimationClip( clipName, duration, tracks );\r\n\r\n\t\treturn clip;\r\n\r\n\t}\r\n\r\n} );\r\n\r\n\r\n// File:src/animation/AnimationMixer.js\r\n\r\n/**\r\n *\r\n * Player for AnimationClips.\r\n *\r\n *\r\n * @author Ben Houston / http://clara.io/\r\n * @author David Sarno / http://lighthaus.us/\r\n * @author tschw\r\n */\r\n\r\nTHREE.AnimationMixer = function( root ) {\r\n\r\n\tthis._root = root;\r\n\tthis._initMemoryManager();\r\n\tthis._accuIndex = 0;\r\n\r\n\tthis.time = 0;\r\n\r\n\tthis.timeScale = 1.0;\r\n\r\n};\r\n\r\nTHREE.AnimationMixer.prototype = {\r\n\r\n\tconstructor: THREE.AnimationMixer,\r\n\r\n\t// return an action for a clip optionally using a custom root target\r\n\t// object (this method allocates a lot of dynamic memory in case a\r\n\t// previously unknown clip/root combination is specified)\r\n\tclipAction: function( clip, optionalRoot ) {\r\n\r\n\t\tvar root = optionalRoot || this._root,\r\n\t\t\trootUuid = root.uuid,\r\n\t\t\tclipName = ( typeof clip === 'string' ) ? clip : clip.name,\r\n\t\t\tclipObject = ( clip !== clipName ) ? clip : null,\r\n\r\n\t\t\tactionsForClip = this._actionsByClip[ clipName ],\r\n\t\t\tprototypeAction;\r\n\r\n\t\tif ( actionsForClip !== undefined ) {\r\n\r\n\t\t\tvar existingAction =\r\n\t\t\t\t\tactionsForClip.actionByRoot[ rootUuid ];\r\n\r\n\t\t\tif ( existingAction !== undefined ) {\r\n\r\n\t\t\t\treturn existingAction;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// we know the clip, so we don't have to parse all\r\n\t\t\t// the bindings again but can just copy\r\n\t\t\tprototypeAction = actionsForClip.knownActions[ 0 ];\r\n\r\n\t\t\t// also, take the clip from the prototype action\r\n\t\t\tclipObject = prototypeAction._clip;\r\n\r\n\t\t\tif ( clip !== clipName && clip !== clipObject ) {\r\n\r\n\t\t\t\tthrow new Error(\r\n\t\t\t\t\t\t\"Different clips with the same name detected!\" );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// clip must be known when specified via string\r\n\t\tif ( clipObject === null ) return null;\r\n\r\n\t\t// allocate all resources required to run it\r\n\t\tvar newAction = new THREE.\r\n\t\t\t\tAnimationMixer._Action( this, clipObject, optionalRoot );\r\n\r\n\t\tthis._bindAction( newAction, prototypeAction );\r\n\r\n\t\t// and make the action known to the memory manager\r\n\t\tthis._addInactiveAction( newAction, clipName, rootUuid );\r\n\r\n\t\treturn newAction;\r\n\r\n\t},\r\n\r\n\t// get an existing action\r\n\texistingAction: function( clip, optionalRoot ) {\r\n\r\n\t\tvar root = optionalRoot || this._root,\r\n\t\t\trootUuid = root.uuid,\r\n\t\t\tclipName = ( typeof clip === 'string' ) ? clip : clip.name,\r\n\t\t\tactionsForClip = this._actionsByClip[ clipName ];\r\n\r\n\t\tif ( actionsForClip !== undefined ) {\r\n\r\n\t\t\treturn actionsForClip.actionByRoot[ rootUuid ] || null;\r\n\r\n\t\t}\r\n\r\n\t\treturn null;\r\n\r\n\t},\r\n\r\n\t// deactivates all previously scheduled actions\r\n\tstopAllAction: function() {\r\n\r\n\t\tvar actions = this._actions,\r\n\t\t\tnActions = this._nActiveActions,\r\n\t\t\tbindings = this._bindings,\r\n\t\t\tnBindings = this._nActiveBindings;\r\n\r\n\t\tthis._nActiveActions = 0;\r\n\t\tthis._nActiveBindings = 0;\r\n\r\n\t\tfor ( var i = 0; i !== nActions; ++ i ) {\r\n\r\n\t\t\tactions[ i ].reset();\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var i = 0; i !== nBindings; ++ i ) {\r\n\r\n\t\t\tbindings[ i ].useCount = 0;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\t// advance the time and update apply the animation\r\n\tupdate: function( deltaTime ) {\r\n\r\n\t\tdeltaTime *= this.timeScale;\r\n\r\n\t\tvar actions = this._actions,\r\n\t\t\tnActions = this._nActiveActions,\r\n\r\n\t\t\ttime = this.time += deltaTime,\r\n\t\t\ttimeDirection = Math.sign( deltaTime ),\r\n\r\n\t\t\taccuIndex = this._accuIndex ^= 1;\r\n\r\n\t\t// run active actions\r\n\r\n\t\tfor ( var i = 0; i !== nActions; ++ i ) {\r\n\r\n\t\t\tvar action = actions[ i ];\r\n\r\n\t\t\tif ( action.enabled ) {\r\n\r\n\t\t\t\taction._update( time, deltaTime, timeDirection, accuIndex );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// update scene graph\r\n\r\n\t\tvar bindings = this._bindings,\r\n\t\t\tnBindings = this._nActiveBindings;\r\n\r\n\t\tfor ( var i = 0; i !== nBindings; ++ i ) {\r\n\r\n\t\t\tbindings[ i ].apply( accuIndex );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\t// return this mixer's root target object\r\n\tgetRoot: function() {\r\n\r\n\t\treturn this._root;\r\n\r\n\t},\r\n\r\n\t// free all resources specific to a particular clip\r\n\tuncacheClip: function( clip ) {\r\n\r\n\t\tvar actions = this._actions,\r\n\t\t\tclipName = clip.name,\r\n\t\t\tactionsByClip = this._actionsByClip,\r\n\t\t\tactionsForClip = actionsByClip[ clipName ];\r\n\r\n\t\tif ( actionsForClip !== undefined ) {\r\n\r\n\t\t\t// note: just calling _removeInactiveAction would mess up the\r\n\t\t\t// iteration state and also require updating the state we can\r\n\t\t\t// just throw away\r\n\r\n\t\t\tvar actionsToRemove = actionsForClip.knownActions;\r\n\r\n\t\t\tfor ( var i = 0, n = actionsToRemove.length; i !== n; ++ i ) {\r\n\r\n\t\t\t\tvar action = actionsToRemove[ i ];\r\n\r\n\t\t\t\tthis._deactivateAction( action );\r\n\r\n\t\t\t\tvar cacheIndex = action._cacheIndex,\r\n\t\t\t\t\tlastInactiveAction = actions[ actions.length - 1 ];\r\n\r\n\t\t\t\taction._cacheIndex = null;\r\n\t\t\t\taction._byClipCacheIndex = null;\r\n\r\n\t\t\t\tlastInactiveAction._cacheIndex = cacheIndex;\r\n\t\t\t\tactions[ cacheIndex ] = lastInactiveAction;\r\n\t\t\t\tactions.pop();\r\n\r\n\t\t\t\tthis._removeInactiveBindingsForAction( action );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tdelete actionsByClip[ clipName ];\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\t// free all resources specific to a particular root target object\r\n\tuncacheRoot: function( root ) {\r\n\r\n\t\tvar rootUuid = root.uuid,\r\n\t\t\tactionsByClip = this._actionsByClip;\r\n\r\n\t\tfor ( var clipName in actionsByClip ) {\r\n\r\n\t\t\tvar actionByRoot = actionsByClip[ clipName ].actionByRoot,\r\n\t\t\t\taction = actionByRoot[ rootUuid ];\r\n\r\n\t\t\tif ( action !== undefined ) {\r\n\r\n\t\t\t\tthis._deactivateAction( action );\r\n\t\t\t\tthis._removeInactiveAction( action );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar bindingsByRoot = this._bindingsByRootAndName,\r\n\t\t\tbindingByName = bindingsByRoot[ rootUuid ];\r\n\r\n\t\tif ( bindingByName !== undefined ) {\r\n\r\n\t\t\tfor ( var trackName in bindingByName ) {\r\n\r\n\t\t\t\tvar binding = bindingByName[ trackName ];\r\n\t\t\t\tbinding.restoreOriginalState();\r\n\t\t\t\tthis._removeInactiveBinding( binding );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\t// remove a targeted clip from the cache\r\n\tuncacheAction: function( clip, optionalRoot ) {\r\n\r\n\t\tvar action = this.existingAction( clip, optionalRoot );\r\n\r\n\t\tif ( action !== null ) {\r\n\r\n\t\t\tthis._deactivateAction( action );\r\n\t\t\tthis._removeInactiveAction( action );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.EventDispatcher.prototype.apply( THREE.AnimationMixer.prototype );\r\n\r\nTHREE.AnimationMixer._Action =\r\n\t\tfunction( mixer, clip, localRoot ) {\r\n\r\n\tthis._mixer = mixer;\r\n\tthis._clip = clip;\r\n\tthis._localRoot = localRoot || null;\r\n\r\n\tvar tracks = clip.tracks,\r\n\t\tnTracks = tracks.length,\r\n\t\tinterpolants = new Array( nTracks );\r\n\r\n\tvar interpolantSettings = {\r\n\t\t\tendingStart: \tTHREE.ZeroCurvatureEnding,\r\n\t\t\tendingEnd:\t\tTHREE.ZeroCurvatureEnding\r\n\t};\r\n\r\n\tfor ( var i = 0; i !== nTracks; ++ i ) {\r\n\r\n\t\tvar interpolant = tracks[ i ].createInterpolant( null );\r\n\t\tinterpolants[ i ] = interpolant;\r\n\t\tinterpolant.settings = interpolantSettings\r\n\r\n\t}\r\n\r\n\tthis._interpolantSettings = interpolantSettings;\r\n\r\n\tthis._interpolants = interpolants;\t// bound by the mixer\r\n\r\n\t// inside: PropertyMixer (managed by the mixer)\r\n\tthis._propertyBindings = new Array( nTracks );\r\n\r\n\tthis._cacheIndex = null;\t\t\t// for the memory manager\r\n\tthis._byClipCacheIndex = null;\t\t// for the memory manager\r\n\r\n\tthis._timeScaleInterpolant = null;\r\n\tthis._weightInterpolant = null;\r\n\r\n\tthis.loop = THREE.LoopRepeat;\r\n\tthis._loopCount = -1;\r\n\r\n\t// global mixer time when the action is to be started\r\n\t// it's set back to 'null' upon start of the action\r\n\tthis._startTime = null;\r\n\r\n\t// scaled local time of the action\r\n\t// gets clamped or wrapped to 0..clip.duration according to loop\r\n\tthis.time = 0;\r\n\r\n\tthis.timeScale = 1;\r\n\tthis._effectiveTimeScale = 1;\r\n\r\n\tthis.weight = 1;\r\n\tthis._effectiveWeight = 1;\r\n\r\n\tthis.repetitions = Infinity; \t\t// no. of repetitions when looping\r\n\r\n\tthis.paused = false;\t\t\t\t// false -> zero effective time scale\r\n\tthis.enabled = true;\t\t\t\t// true -> zero effective weight\r\n\r\n\tthis.clampWhenFinished \t= false;\t// keep feeding the last frame?\r\n\r\n\tthis.zeroSlopeAtStart \t= true;\t\t// for smooth interpolation w/o separate\r\n\tthis.zeroSlopeAtEnd\t\t= true;\t\t// clips for start, loop and end\r\n\r\n};\r\n\r\nTHREE.AnimationMixer._Action.prototype = {\r\n\r\n\tconstructor: THREE.AnimationMixer._Action,\r\n\r\n\t// State & Scheduling\r\n\r\n\tplay: function() {\r\n\r\n\t\tthis._mixer._activateAction( this );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tstop: function() {\r\n\r\n\t\tthis._mixer._deactivateAction( this );\r\n\r\n\t\treturn this.reset();\r\n\r\n\t},\r\n\r\n\treset: function() {\r\n\r\n\t\tthis.paused = false;\r\n\t\tthis.enabled = true;\r\n\r\n\t\tthis.time = 0;\t\t\t// restart clip\r\n\t\tthis._loopCount = -1;\t// forget previous loops\r\n\t\tthis._startTime = null;\t// forget scheduling\r\n\r\n\t\treturn this.stopFading().stopWarping();\r\n\r\n\t},\r\n\r\n\tisRunning: function() {\r\n\r\n\t\tvar start = this._startTime;\r\n\r\n\t\treturn this.enabled && ! this.paused && this.timeScale !== 0 &&\r\n\t\t\t\tthis._startTime === null && this._mixer._isActiveAction( this )\r\n\r\n\t},\r\n\r\n\t// return true when play has been called\r\n\tisScheduled: function() {\r\n\r\n\t\treturn this._mixer._isActiveAction( this );\r\n\r\n\t},\r\n\r\n\tstartAt: function( time ) {\r\n\r\n\t\tthis._startTime = time;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetLoop: function( mode, repetitions ) {\r\n\r\n\t\tthis.loop = mode;\r\n\t\tthis.repetitions = repetitions;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\t// Weight\r\n\r\n\t// set the weight stopping any scheduled fading\r\n\t// although .enabled = false yields an effective weight of zero, this\r\n\t// method does *not* change .enabled, because it would be confusing\r\n\tsetEffectiveWeight: function( weight ) {\r\n\r\n\t\tthis.weight = weight;\r\n\r\n\t\t// note: same logic as when updated at runtime\r\n\t\tthis._effectiveWeight = this.enabled ? weight : 0;\r\n\r\n\t\treturn this.stopFading();\r\n\r\n\t},\r\n\r\n\t// return the weight considering fading and .enabled\r\n\tgetEffectiveWeight: function() {\r\n\r\n\t\treturn this._effectiveWeight;\r\n\r\n\t},\r\n\r\n\tfadeIn: function( duration ) {\r\n\r\n\t\treturn this._scheduleFading( duration, 0, 1 );\r\n\r\n\t},\r\n\r\n\tfadeOut: function( duration ) {\r\n\r\n\t\treturn this._scheduleFading( duration, 1, 0 );\r\n\r\n\t},\r\n\r\n\tcrossFadeFrom: function( fadeOutAction, duration, warp ) {\r\n\r\n\t\tvar mixer = this._mixer;\r\n\r\n\t\tfadeOutAction.fadeOut( duration );\r\n\t\tthis.fadeIn( duration );\r\n\r\n\t\tif( warp ) {\r\n\r\n\t\t\tvar fadeInDuration = this._clip.duration,\r\n\t\t\t\tfadeOutDuration = fadeOutAction._clip.duration,\r\n\r\n\t\t\t\tstartEndRatio = fadeOutDuration / fadeInDuration,\r\n\t\t\t\tendStartRatio = fadeInDuration / fadeOutDuration;\r\n\r\n\t\t\tfadeOutAction.warp( 1.0, startEndRatio, duration );\r\n\t\t\tthis.warp( endStartRatio, 1.0, duration );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcrossFadeTo: function( fadeInAction, duration, warp ) {\r\n\r\n\t\treturn fadeInAction.crossFadeFrom( this, duration, warp );\r\n\r\n\t},\r\n\r\n\tstopFading: function() {\r\n\r\n\t\tvar weightInterpolant = this._weightInterpolant;\r\n\r\n\t\tif ( weightInterpolant !== null ) {\r\n\r\n\t\t\tthis._weightInterpolant = null;\r\n\t\t\tthis._mixer._takeBackControlInterpolant( weightInterpolant );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\t// Time Scale Control\r\n\r\n\t// set the weight stopping any scheduled warping\r\n\t// although .paused = true yields an effective time scale of zero, this\r\n\t// method does *not* change .paused, because it would be confusing\r\n\tsetEffectiveTimeScale: function( timeScale ) {\r\n\r\n\t\tthis.timeScale = timeScale;\r\n\t\tthis._effectiveTimeScale = this.paused ? 0 :timeScale;\r\n\r\n\t\treturn this.stopWarping();\r\n\r\n\t},\r\n\r\n\t// return the time scale considering warping and .paused\r\n\tgetEffectiveTimeScale: function() {\r\n\r\n\t\treturn this._effectiveTimeScale;\r\n\r\n\t},\r\n\r\n\tsetDuration: function( duration ) {\r\n\r\n\t\tthis.timeScale = this._clip.duration / duration;\r\n\r\n\t\treturn this.stopWarping();\r\n\r\n\t},\r\n\r\n\tsyncWith: function( action ) {\r\n\r\n\t\tthis.time = action.time;\r\n\t\tthis.timeScale = action.timeScale;\r\n\r\n\t\treturn this.stopWarping();\r\n\r\n\t},\r\n\r\n\thalt: function( duration ) {\r\n\r\n\t\treturn this.warp( this._currentTimeScale, 0, duration );\r\n\r\n\t},\r\n\r\n\twarp: function( startTimeScale, endTimeScale, duration ) {\r\n\r\n\t\tvar mixer = this._mixer, now = mixer.time,\r\n\t\t\tinterpolant = this._timeScaleInterpolant,\r\n\r\n\t\t\ttimeScale = this.timeScale;\r\n\r\n\t\tif ( interpolant === null ) {\r\n\r\n\t\t\tinterpolant = mixer._lendControlInterpolant(),\r\n\t\t\tthis._timeScaleInterpolant = interpolant;\r\n\r\n\t\t}\r\n\r\n\t\tvar times = interpolant.parameterPositions,\r\n\t\t\tvalues = interpolant.sampleValues;\r\n\r\n\t\ttimes[ 0 ] = now;\r\n\t\ttimes[ 1 ] = now + duration;\r\n\r\n\t\tvalues[ 0 ] = startTimeScale / timeScale;\r\n\t\tvalues[ 1 ] = endTimeScale / timeScale;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tstopWarping: function() {\r\n\r\n\t\tvar timeScaleInterpolant = this._timeScaleInterpolant;\r\n\r\n\t\tif ( timeScaleInterpolant !== null ) {\r\n\r\n\t\t\tthis._timeScaleInterpolant = null;\r\n\t\t\tthis._mixer._takeBackControlInterpolant( timeScaleInterpolant );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\t// Object Accessors\r\n\r\n\tgetMixer: function() {\r\n\r\n\t\treturn this._mixer;\r\n\r\n\t},\r\n\r\n\tgetClip: function() {\r\n\r\n\t\treturn this._clip;\r\n\r\n\t},\r\n\r\n\tgetRoot: function() {\r\n\r\n\t\treturn this._localRoot || this._mixer._root;\r\n\r\n\t},\r\n\r\n\t// Interna\r\n\r\n\t_update: function( time, deltaTime, timeDirection, accuIndex ) {\r\n\t\t// called by the mixer\r\n\r\n\t\tvar startTime = this._startTime;\r\n\r\n\t\tif ( startTime !== null ) {\r\n\r\n\t\t\t// check for scheduled start of action\r\n\r\n\t\t\tvar timeRunning = ( time - startTime ) * timeDirection;\r\n\t\t\tif ( timeRunning < 0 || timeDirection === 0 ) {\r\n\r\n\t\t\t\treturn; // yet to come / don't decide when delta = 0\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// start\r\n\r\n\t\t\tthis._startTime = null; // unschedule\r\n\t\t\tdeltaTime = timeDirection * timeRunning;\r\n\r\n\t\t}\r\n\r\n\t\t// apply time scale and advance time\r\n\r\n\t\tdeltaTime *= this._updateTimeScale( time );\r\n\t\tvar clipTime = this._updateTime( deltaTime );\r\n\r\n\t\t// note: _updateTime may disable the action resulting in\r\n\t\t// an effective weight of 0\r\n\r\n\t\tvar weight = this._updateWeight( time );\r\n\r\n\t\tif ( weight > 0 ) {\r\n\r\n\t\t\tvar interpolants = this._interpolants;\r\n\t\t\tvar propertyMixers = this._propertyBindings;\r\n\r\n\t\t\tfor ( var j = 0, m = interpolants.length; j !== m; ++ j ) {\r\n\r\n\t\t\t\tinterpolants[ j ].evaluate( clipTime );\r\n\t\t\t\tpropertyMixers[ j ].accumulate( accuIndex, weight );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\t_updateWeight: function( time ) {\r\n\r\n\t\tvar weight = 0;\r\n\r\n\t\tif ( this.enabled ) {\r\n\r\n\t\t\tweight = this.weight;\r\n\t\t\tvar interpolant = this._weightInterpolant;\r\n\r\n\t\t\tif ( interpolant !== null ) {\r\n\r\n\t\t\t\tvar interpolantValue = interpolant.evaluate( time )[ 0 ];\r\n\r\n\t\t\t\tweight *= interpolantValue;\r\n\r\n\t\t\t\tif ( time > interpolant.parameterPositions[ 1 ] ) {\r\n\r\n\t\t\t\t\tthis.stopFading();\r\n\r\n\t\t\t\t\tif ( interpolantValue === 0 ) {\r\n\r\n\t\t\t\t\t\t// faded out, disable\r\n\t\t\t\t\t\tthis.enabled = false;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis._effectiveWeight = weight;\r\n\t\treturn weight;\r\n\r\n\t},\r\n\r\n\t_updateTimeScale: function( time ) {\r\n\r\n\t\tvar timeScale = 0;\r\n\r\n\t\tif ( ! this.paused ) {\r\n\r\n\t\t\ttimeScale = this.timeScale;\r\n\r\n\t\t\tvar interpolant = this._timeScaleInterpolant;\r\n\r\n\t\t\tif ( interpolant !== null ) {\r\n\r\n\t\t\t\tvar interpolantValue = interpolant.evaluate( time )[ 0 ];\r\n\r\n\t\t\t\ttimeScale *= interpolantValue;\r\n\r\n\t\t\t\tif ( time > interpolant.parameterPositions[ 1 ] ) {\r\n\r\n\t\t\t\t\tthis.stopWarping();\r\n\r\n\t\t\t\t\tif ( timeScale === 0 ) {\r\n\r\n\t\t\t\t\t\t// motion has halted, pause\r\n\t\t\t\t\t\tthis.pause = true;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t// warp done - apply final time scale\r\n\t\t\t\t\t\tthis.timeScale = timeScale;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis._effectiveTimeScale = timeScale;\r\n\t\treturn timeScale;\r\n\r\n\t},\r\n\r\n\t_updateTime: function( deltaTime ) {\r\n\r\n\t\tvar time = this.time + deltaTime;\r\n\r\n\t\tif ( deltaTime === 0 ) return time;\r\n\r\n\t\tvar duration = this._clip.duration,\r\n\r\n\t\t\tloop = this.loop,\r\n\t\t\tloopCount = this._loopCount,\r\n\r\n\t\t\tpingPong = false;\r\n\r\n\t\tswitch ( loop ) {\r\n\r\n\t\t\tcase THREE.LoopOnce:\r\n\r\n\t\t\t\tif ( loopCount === -1 ) {\r\n\r\n\t\t\t\t\t// just started\r\n\r\n\t\t\t\t\tthis.loopCount = 0;\r\n\t\t\t\t\tthis._setEndings( true, true, false );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( time >= duration ) {\r\n\r\n\t\t\t\t\ttime = duration;\r\n\r\n\t\t\t\t} else if ( time < 0 ) {\r\n\r\n\t\t\t\t\ttime = 0;\r\n\r\n\t\t\t\t} else break;\r\n\r\n\t\t\t\t// reached the end\r\n\r\n\t\t\t\tif ( this.clampWhenFinished ) this.pause = true;\r\n\t\t\t\telse this.enabled = false;\r\n\r\n\t\t\t\tthis._mixer.dispatchEvent( {\r\n\t\t\t\t\ttype: 'finished', action: this,\r\n\t\t\t\t\tdirection: deltaTime < 0 ? -1 : 1\r\n\t\t\t\t} );\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase THREE.LoopPingPong:\r\n\r\n\t\t\t\tpingPong = true;\r\n\r\n\t\t\tcase THREE.LoopRepeat:\r\n\r\n\t\t\t\tif ( loopCount === -1 ) {\r\n\r\n\t\t\t\t\t// just started\r\n\r\n\t\t\t\t\tif ( deltaTime > 0 ) {\r\n\r\n\t\t\t\t\t\tloopCount = 0;\r\n\r\n\t\t\t\t\t\tthis._setEndings(\r\n\t\t\t\t\t\t\t\ttrue, this.repetitions === 0, pingPong );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t// when looping in reverse direction, the initial\r\n\t\t\t\t\t\t// transition through zero counts as a repetition,\r\n\t\t\t\t\t\t// so leave loopCount at -1\r\n\r\n\t\t\t\t\t\tthis._setEndings(\r\n\t\t\t\t\t\t\t\tthis.repetitions === 0, true, pingPong );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( time >= duration || time < 0 ) {\r\n\r\n\t\t\t\t\t// wrap around\r\n\r\n\t\t\t\t\tvar loopDelta = Math.floor( time / duration ); // signed\r\n\t\t\t\t\ttime -= duration * loopDelta;\r\n\r\n\t\t\t\t\tloopCount += Math.abs( loopDelta );\r\n\r\n\t\t\t\t\tvar pending = this.repetitions - loopCount;\r\n\r\n\t\t\t\t\tif ( pending < 0 ) {\r\n\r\n\t\t\t\t\t\t// stop (switch state, clamp time, fire event)\r\n\r\n\t\t\t\t\t\tif ( this.clampWhenFinished ) this.paused = true;\r\n\t\t\t\t\t\telse this.enabled = false;\r\n\r\n\t\t\t\t\t\ttime = deltaTime > 0 ? duration : 0;\r\n\r\n\t\t\t\t\t\tthis._mixer.dispatchEvent( {\r\n\t\t\t\t\t\t\ttype: 'finished', action: this,\r\n\t\t\t\t\t\t\tdirection: deltaTime > 0 ? 1 : -1\r\n\t\t\t\t\t\t} );\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t} else if ( pending === 0 ) {\r\n\r\n\t\t\t\t\t\t// transition to last round\r\n\r\n\t\t\t\t\t\tvar atStart = deltaTime < 0;\r\n\t\t\t\t\t\tthis._setEndings( atStart, ! atStart, pingPong );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tthis._setEndings( false, false, pingPong );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tthis._loopCount = loopCount;\r\n\r\n\t\t\t\t\tthis._mixer.dispatchEvent( {\r\n\t\t\t\t\t\ttype: 'loop', action: this, loopDelta: loopDelta\r\n\t\t\t\t\t} );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( loop === THREE.LoopPingPong && ( loopCount & 1 ) === 1 ) {\r\n\r\n\t\t\t\t\t// invert time for the \"pong round\"\r\n\r\n\t\t\t\t\tthis.time = time;\r\n\r\n\t\t\t\t\treturn duration - time;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t}\r\n\r\n\t\tthis.time = time;\r\n\r\n\t\treturn time;\r\n\r\n\t},\r\n\r\n\t_setEndings: function( atStart, atEnd, pingPong ) {\r\n\r\n\t\tvar settings = this._interpolantSettings;\r\n\r\n\t\tif ( pingPong ) {\r\n\r\n\t\t\tsettings.endingStart \t= THREE.ZeroSlopeEnding;\r\n\t\t\tsettings.endingEnd\t\t= THREE.ZeroSlopeEnding;\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// assuming for LoopOnce atStart == atEnd == true\r\n\r\n\t\t\tif ( atStart ) {\r\n\r\n\t\t\t\tsettings.endingStart = this.zeroSlopeAtStart ?\r\n\t\t\t\t\t\tTHREE.ZeroSlopeEnding : THREE.ZeroCurvatureEnding;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tsettings.endingStart = THREE.WrapAroundEnding;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( atEnd ) {\r\n\r\n\t\t\t\tsettings.endingEnd = this.zeroSlopeAtEnd ?\r\n\t\t\t\t\t\tTHREE.ZeroSlopeEnding : THREE.ZeroCurvatureEnding;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tsettings.endingEnd \t = THREE.WrapAroundEnding;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\t_scheduleFading: function( duration, weightNow, weightThen ) {\r\n\r\n\t\tvar mixer = this._mixer, now = mixer.time,\r\n\t\t\tinterpolant = this._weightInterpolant;\r\n\r\n\t\tif ( interpolant === null ) {\r\n\r\n\t\t\tinterpolant = mixer._lendControlInterpolant(),\r\n\t\t\tthis._weightInterpolant = interpolant;\r\n\r\n\t\t}\r\n\r\n\t\tvar times = interpolant.parameterPositions,\r\n\t\t\tvalues = interpolant.sampleValues;\r\n\r\n\t\ttimes[ 0 ] = now; \t\t\t\tvalues[ 0 ] = weightNow;\r\n\t\ttimes[ 1 ] = now + duration;\tvalues[ 1 ] = weightThen;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// Implementation details:\r\n\r\nObject.assign( THREE.AnimationMixer.prototype, {\r\n\r\n\t_bindAction: function( action, prototypeAction ) {\r\n\r\n\t\tvar root = action._localRoot || this._root,\r\n\t\t\ttracks = action._clip.tracks,\r\n\t\t\tnTracks = tracks.length,\r\n\t\t\tbindings = action._propertyBindings,\r\n\t\t\tinterpolants = action._interpolants,\r\n\t\t\trootUuid = root.uuid,\r\n\t\t\tbindingsByRoot = this._bindingsByRootAndName,\r\n\t\t\tbindingsByName = bindingsByRoot[ rootUuid ];\r\n\r\n\t\tif ( bindingsByName === undefined ) {\r\n\r\n\t\t\tbindingsByName = {};\r\n\t\t\tbindingsByRoot[ rootUuid ] = bindingsByName;\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var i = 0; i !== nTracks; ++ i ) {\r\n\r\n\t\t\tvar track = tracks[ i ],\r\n\t\t\t\ttrackName = track.name,\r\n\t\t\t\tbinding = bindingsByName[ trackName ];\r\n\r\n\t\t\tif ( binding !== undefined ) {\r\n\r\n\t\t\t\tbindings[ i ] = binding;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tbinding = bindings[ i ];\r\n\r\n\t\t\t\tif ( binding !== undefined ) {\r\n\r\n\t\t\t\t\t// existing binding, make sure the cache knows\r\n\r\n\t\t\t\t\tif ( binding._cacheIndex === null ) {\r\n\r\n\t\t\t\t\t\t++ binding.referenceCount;\r\n\t\t\t\t\t\tthis._addInactiveBinding( binding, rootUuid, trackName );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar path = prototypeAction && prototypeAction.\r\n\t\t\t\t\t\t_propertyBindings[ i ].binding.parsedPath;\r\n\r\n\t\t\t\tbinding = new THREE.PropertyMixer(\r\n\t\t\t\t\t\tTHREE.PropertyBinding.create( root, trackName, path ),\r\n\t\t\t\t\t\ttrack.ValueTypeName, track.getValueSize() );\r\n\r\n\t\t\t\t++ binding.referenceCount;\r\n\t\t\t\tthis._addInactiveBinding( binding, rootUuid, trackName );\r\n\r\n\t\t\t\tbindings[ i ] = binding;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tinterpolants[ i ].resultBuffer = binding.buffer;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\t_activateAction: function( action ) {\r\n\r\n\t\tif ( ! this._isActiveAction( action ) ) {\r\n\r\n\t\t\tif ( action._cacheIndex === null ) {\r\n\r\n\t\t\t\t// this action has been forgotten by the cache, but the user\r\n\t\t\t\t// appears to be still using it -> rebind\r\n\r\n\t\t\t\tvar rootUuid = ( action._localRoot || this._root ).uuid,\r\n\t\t\t\t\tclipName = action._clip.name,\r\n\t\t\t\t\tactionsForClip = this._actionsByClip[ clipName ];\r\n\r\n\t\t\t\tthis._bindAction( action,\r\n\t\t\t\t\t\tactionsForClip && actionsForClip.knownActions[ 0 ] );\r\n\r\n\t\t\t\tthis._addInactiveAction( action, clipName, rootUuid );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar bindings = action._propertyBindings;\r\n\r\n\t\t\t// increment reference counts / sort out state\r\n\t\t\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\r\n\r\n\t\t\t\tvar binding = bindings[ i ];\r\n\r\n\t\t\t\tif ( binding.useCount ++ === 0 ) {\r\n\r\n\t\t\t\t\tthis._lendBinding( binding );\r\n\t\t\t\t\tbinding.saveOriginalState();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis._lendAction( action );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\t_deactivateAction: function( action ) {\r\n\r\n\t\tif ( this._isActiveAction( action ) ) {\r\n\r\n\t\t\tvar bindings = action._propertyBindings;\r\n\r\n\t\t\t// decrement reference counts / sort out state\r\n\t\t\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\r\n\r\n\t\t\t\tvar binding = bindings[ i ];\r\n\r\n\t\t\t\tif ( -- binding.useCount === 0 ) {\r\n\r\n\t\t\t\t\tbinding.restoreOriginalState();\r\n\t\t\t\t\tthis._takeBackBinding( binding );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis._takeBackAction( action );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\t// Memory manager\r\n\r\n\t_initMemoryManager: function() {\r\n\r\n\t\tthis._actions = []; // 'nActiveActions' followed by inactive ones\r\n\t\tthis._nActiveActions = 0;\r\n\r\n\t\tthis._actionsByClip = {};\r\n\t\t// inside:\r\n\t\t// {\r\n\t\t// \t\tknownActions: Array< _Action >\t- used as prototypes\r\n\t\t// \t\tactionByRoot: _Action\t\t\t- lookup\r\n\t\t// }\r\n\r\n\r\n\t\tthis._bindings = []; // 'nActiveBindings' followed by inactive ones\r\n\t\tthis._nActiveBindings = 0;\r\n\r\n\t\tthis._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >\r\n\r\n\r\n\t\tthis._controlInterpolants = []; // same game as above\r\n\t\tthis._nActiveControlInterpolants = 0;\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tthis.stats = {\r\n\r\n\t\t\tactions: {\r\n\t\t\t\tget total() { return scope._actions.length; },\r\n\t\t\t\tget inUse() { return scope._nActiveActions; }\r\n\t\t\t},\r\n\t\t\tbindings: {\r\n\t\t\t\tget total() { return scope._bindings.length; },\r\n\t\t\t\tget inUse() { return scope._nActiveBindings; }\r\n\t\t\t},\r\n\t\t\tcontrolInterpolants: {\r\n\t\t\t\tget total() { return scope._controlInterpolants.length; },\r\n\t\t\t\tget inUse() { return scope._nActiveControlInterpolants; }\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t},\r\n\r\n\t// Memory management for _Action objects\r\n\r\n\t_isActiveAction: function( action ) {\r\n\r\n\t\tvar index = action._cacheIndex;\r\n\t\treturn index !== null && index < this._nActiveActions;\r\n\r\n\t},\r\n\r\n\t_addInactiveAction: function( action, clipName, rootUuid ) {\r\n\r\n\t\tvar actions = this._actions,\r\n\t\t\tactionsByClip = this._actionsByClip,\r\n\t\t\tactionsForClip = actionsByClip[ clipName ];\r\n\r\n\t\tif ( actionsForClip === undefined ) {\r\n\r\n\t\t\tactionsForClip = {\r\n\r\n\t\t\t\tknownActions: [ action ],\r\n\t\t\t\tactionByRoot: {}\r\n\r\n\t\t\t};\r\n\r\n\t\t\taction._byClipCacheIndex = 0;\r\n\r\n\t\t\tactionsByClip[ clipName ] = actionsForClip;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tvar knownActions = actionsForClip.knownActions;\r\n\r\n\t\t\taction._byClipCacheIndex = knownActions.length;\r\n\t\t\tknownActions.push( action );\r\n\r\n\t\t}\r\n\r\n\t\taction._cacheIndex = actions.length;\r\n\t\tactions.push( action );\r\n\r\n\t\tactionsForClip.actionByRoot[ rootUuid ] = action;\r\n\r\n\t},\r\n\r\n\t_removeInactiveAction: function( action ) {\r\n\r\n\t\tvar actions = this._actions,\r\n\t\t\tlastInactiveAction = actions[ actions.length - 1 ],\r\n\t\t\tcacheIndex = action._cacheIndex;\r\n\r\n\t\tlastInactiveAction._cacheIndex = cacheIndex;\r\n\t\tactions[ cacheIndex ] = lastInactiveAction;\r\n\t\tactions.pop();\r\n\r\n\t\taction._cacheIndex = null;\r\n\r\n\r\n\t\tvar clipName = action._clip.name,\r\n\t\t\tactionsByClip = this._actionsByClip,\r\n\t\t\tactionsForClip = actionsByClip[ clipName ],\r\n\t\t\tknownActionsForClip = actionsForClip.knownActions,\r\n\r\n\t\t\tlastKnownAction =\r\n\t\t\t\tknownActionsForClip[ knownActionsForClip.length - 1 ],\r\n\r\n\t\t\tbyClipCacheIndex = action._byClipCacheIndex;\r\n\r\n\t\tlastKnownAction._byClipCacheIndex = byClipCacheIndex;\r\n\t\tknownActionsForClip[ byClipCacheIndex ] = lastKnownAction;\r\n\t\tknownActionsForClip.pop();\r\n\r\n\t\taction._byClipCacheIndex = null;\r\n\r\n\r\n\t\tvar actionByRoot = actionsForClip.actionByRoot,\r\n\t\t\trootUuid = ( actions._localRoot || this._root ).uuid;\r\n\r\n\t\tdelete actionByRoot[ rootUuid ];\r\n\r\n\t\tif ( knownActionsForClip.length === 0 ) {\r\n\r\n\t\t\tdelete actionsByClip[ clipName ];\r\n\r\n\t\t}\r\n\r\n\t\tthis._removeInactiveBindingsForAction( action );\r\n\r\n\t},\r\n\r\n\t_removeInactiveBindingsForAction: function( action ) {\r\n\r\n\t\tvar bindings = action._propertyBindings;\r\n\t\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\r\n\r\n\t\t\tvar binding = bindings[ i ];\r\n\r\n\t\t\tif ( -- binding.referenceCount === 0 ) {\r\n\r\n\t\t\t\tthis._removeInactiveBinding( binding );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\t_lendAction: function( action ) {\r\n\r\n\t\t// [ active actions |  inactive actions  ]\r\n\t\t// [  active actions >| inactive actions ]\r\n\t\t//                 s        a\r\n\t\t//                  <-swap->\r\n\t\t//                 a        s\r\n\r\n\t\tvar actions = this._actions,\r\n\t\t\tprevIndex = action._cacheIndex,\r\n\r\n\t\t\tlastActiveIndex = this._nActiveActions ++,\r\n\r\n\t\t\tfirstInactiveAction = actions[ lastActiveIndex ];\r\n\r\n\t\taction._cacheIndex = lastActiveIndex;\r\n\t\tactions[ lastActiveIndex ] = action;\r\n\r\n\t\tfirstInactiveAction._cacheIndex = prevIndex;\r\n\t\tactions[ prevIndex ] = firstInactiveAction;\r\n\r\n\t},\r\n\r\n\t_takeBackAction: function( action ) {\r\n\r\n\t\t// [  active actions  | inactive actions ]\r\n\t\t// [ active actions |< inactive actions  ]\r\n\t\t//        a        s\r\n\t\t//         <-swap->\r\n\t\t//        s        a\r\n\r\n\t\tvar actions = this._actions,\r\n\t\t\tprevIndex = action._cacheIndex,\r\n\r\n\t\t\tfirstInactiveIndex = -- this._nActiveActions,\r\n\r\n\t\t\tlastActiveAction = actions[ firstInactiveIndex ];\r\n\r\n\t\taction._cacheIndex = firstInactiveIndex;\r\n\t\tactions[ firstInactiveIndex ] = action;\r\n\r\n\t\tlastActiveAction._cacheIndex = prevIndex;\r\n\t\tactions[ prevIndex ] = lastActiveAction;\r\n\r\n\t},\r\n\r\n\t// Memory management for PropertyMixer objects\r\n\r\n\t_addInactiveBinding: function( binding, rootUuid, trackName ) {\r\n\r\n\t\tvar bindingsByRoot = this._bindingsByRootAndName,\r\n\t\t\tbindingByName = bindingsByRoot[ rootUuid ],\r\n\r\n\t\t\tbindings = this._bindings;\r\n\r\n\t\tif ( bindingByName === undefined ) {\r\n\r\n\t\t\tbindingByName = {};\r\n\t\t\tbindingsByRoot[ rootUuid ] = bindingByName;\r\n\r\n\t\t}\r\n\r\n\t\tbindingByName[ trackName ] = binding;\r\n\r\n\t\tbinding._cacheIndex = bindings.length;\r\n\t\tbindings.push( binding );\r\n\r\n\t},\r\n\r\n\t_removeInactiveBinding: function( binding ) {\r\n\r\n\t\tvar bindings = this._bindings,\r\n\t\t\tpropBinding = binding.binding,\r\n\t\t\trootUuid = propBinding.rootNode.uuid,\r\n\t\t\ttrackName = propBinding.path,\r\n\t\t\tbindingsByRoot = this._bindingsByRootAndName,\r\n\t\t\tbindingByName = bindingsByRoot[ rootUuid ],\r\n\r\n\t\t\tlastInactiveBinding = bindings[ bindings.length - 1 ],\r\n\t\t\tcacheIndex = binding._cacheIndex;\r\n\r\n\t\tlastInactiveBinding._cacheIndex = cacheIndex;\r\n\t\tbindings[ cacheIndex ] = lastInactiveBinding;\r\n\t\tbindings.pop();\r\n\r\n\t\tdelete bindingByName[ trackName ];\r\n\r\n\t\tremove_empty_map: {\r\n\r\n\t\t\tfor ( var _ in bindingByName ) break remove_empty_map;\r\n\r\n\t\t\tdelete bindingsByRoot[ rootUuid ];\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\t_lendBinding: function( binding ) {\r\n\r\n\t\tvar bindings = this._bindings,\r\n\t\t\tprevIndex = binding._cacheIndex,\r\n\r\n\t\t\tlastActiveIndex = this._nActiveBindings ++,\r\n\r\n\t\t\tfirstInactiveBinding = bindings[ lastActiveIndex ];\r\n\r\n\t\tbinding._cacheIndex = lastActiveIndex;\r\n\t\tbindings[ lastActiveIndex ] = binding;\r\n\r\n\t\tfirstInactiveBinding._cacheIndex = prevIndex;\r\n\t\tbindings[ prevIndex ] = firstInactiveBinding;\r\n\r\n\t},\r\n\r\n\t_takeBackBinding: function( binding ) {\r\n\r\n\t\tvar bindings = this._bindings,\r\n\t\t\tprevIndex = binding._cacheIndex,\r\n\r\n\t\t\tfirstInactiveIndex = -- this._nActiveBindings,\r\n\r\n\t\t\tlastActiveBinding = bindings[ firstInactiveIndex ];\r\n\r\n\t\tbinding._cacheIndex = firstInactiveIndex;\r\n\t\tbindings[ firstInactiveIndex ] = binding;\r\n\r\n\t\tlastActiveBinding._cacheIndex = prevIndex;\r\n\t\tbindings[ prevIndex ] = lastActiveBinding;\r\n\r\n\t},\r\n\r\n\r\n\t// Memory management of Interpolants for weight and time scale\r\n\r\n\t_lendControlInterpolant: function() {\r\n\r\n\t\tvar interpolants = this._controlInterpolants,\r\n\t\t\tlastActiveIndex = this._nActiveControlInterpolants ++,\r\n\t\t\tinterpolant = interpolants[ lastActiveIndex ];\r\n\r\n\t\tif ( interpolant === undefined ) {\r\n\r\n\t\t\tinterpolant = new THREE.LinearInterpolant(\r\n\t\t\t\t\tnew Float32Array( 2 ), new Float32Array( 2 ),\r\n\t\t\t\t\t\t1, this._controlInterpolantsResultBuffer );\r\n\r\n\t\t\tinterpolant.__cacheIndex = lastActiveIndex;\r\n\t\t\tinterpolants[ lastActiveIndex ] = interpolant;\r\n\r\n\t\t}\r\n\r\n\t\treturn interpolant;\r\n\r\n\t},\r\n\r\n\t_takeBackControlInterpolant: function( interpolant ) {\r\n\r\n\t\tvar interpolants = this._controlInterpolants,\r\n\t\t\tprevIndex = interpolant.__cacheIndex,\r\n\r\n\t\t\tfirstInactiveIndex = -- this._nActiveControlInterpolants,\r\n\r\n\t\t\tlastActiveInterpolant = interpolants[ firstInactiveIndex ];\r\n\r\n\t\tinterpolant.__cacheIndex = firstInactiveIndex;\r\n\t\tinterpolants[ firstInactiveIndex ] = interpolant;\r\n\r\n\t\tlastActiveInterpolant.__cacheIndex = prevIndex;\r\n\t\tinterpolants[ prevIndex ] = lastActiveInterpolant;\r\n\r\n\t},\r\n\r\n\t_controlInterpolantsResultBuffer: new Float32Array( 1 )\r\n\r\n} );\r\n\r\n\r\n// File:src/animation/AnimationObjectGroup.js\r\n\r\n/**\r\n *\r\n * A group of objects that receives a shared animation state.\r\n *\r\n * Usage:\r\n *\r\n * \t-\tAdd objects you would otherwise pass as 'root' to the\r\n * \t\tconstructor or the .clipAction method of AnimationMixer.\r\n *\r\n * \t-\tInstead pass this object as 'root'.\r\n *\r\n * \t-\tYou can also add and remove objects later when the mixer\r\n * \t\tis running.\r\n *\r\n * Note:\r\n *\r\n *  \tObjects of this class appear as one object to the mixer,\r\n *  \tso cache control of the individual objects must be done\r\n *  \ton the group.\r\n *\r\n * Limitation:\r\n *\r\n * \t- \tThe animated properties must be compatible among the\r\n * \t\tall objects in the group.\r\n *\r\n *  -\tA single property can either be controlled through a\r\n *  \ttarget group or directly, but not both.\r\n *\r\n * @author tschw\r\n */\r\n\r\nTHREE.AnimationObjectGroup = function( var_args ) {\r\n\r\n\tthis.uuid = THREE.Math.generateUUID();\r\n\r\n\t// cached objects followed by the active ones\r\n\tthis._objects = Array.prototype.slice.call( arguments );\r\n\r\n\tthis.nCachedObjects_ = 0;\t\t\t// threshold\r\n\t// note: read by PropertyBinding.Composite\r\n\r\n\tvar indices = {};\r\n\tthis._indicesByUUID = indices;\t\t// for bookkeeping\r\n\r\n\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\r\n\r\n\t\tindices[ arguments[ i ].uuid ] = i;\r\n\r\n\t}\r\n\r\n\tthis._paths = [];\t\t\t\t\t// inside: string\r\n\tthis._parsedPaths = [];\t\t\t\t// inside: { we don't care, here }\r\n\tthis._bindings = []; \t\t\t\t// inside: Array< PropertyBinding >\r\n\tthis._bindingsIndicesByPath = {}; \t// inside: indices in these arrays\r\n\r\n\tvar scope = this;\r\n\r\n\tthis.stats = {\r\n\r\n\t\tobjects: {\r\n\t\t\tget total() { return scope._objects.length; },\r\n\t\t\tget inUse() { return this.total - scope.nCachedObjects_;  }\r\n\t\t},\r\n\r\n\t\tget bindingsPerObject() { return scope._bindings.length; }\r\n\r\n\t};\r\n\r\n};\r\n\r\nTHREE.AnimationObjectGroup.prototype = {\r\n\r\n\tconstructor: THREE.AnimationObjectGroup,\r\n\r\n\tadd: function( var_args ) {\r\n\r\n\t\tvar objects = this._objects,\r\n\t\t\tnObjects = objects.length,\r\n\t\t\tnCachedObjects = this.nCachedObjects_,\r\n\t\t\tindicesByUUID = this._indicesByUUID,\r\n\t\t\tpaths = this._paths,\r\n\t\t\tparsedPaths = this._parsedPaths,\r\n\t\t\tbindings = this._bindings,\r\n\t\t\tnBindings = bindings.length;\r\n\r\n\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\r\n\r\n\t\t\tvar object = arguments[ i ],\r\n\t\t\t\tuuid = object.uuid,\r\n\t\t\t\tindex = indicesByUUID[ uuid ];\r\n\r\n\t\t\tif ( index === undefined ) {\r\n\r\n\t\t\t\t// unknown object -> add it to the ACTIVE region\r\n\r\n\t\t\t\tindex = nObjects ++;\r\n\t\t\t\tindicesByUUID[ uuid ] = index;\r\n\t\t\t\tobjects.push( object );\r\n\r\n\t\t\t\t// accounting is done, now do the same for all bindings\r\n\r\n\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\r\n\r\n\t\t\t\t\tbindings[ j ].push(\r\n\t\t\t\t\t\t\tnew THREE.PropertyBinding(\r\n\t\t\t\t\t\t\t\tobject, paths[ j ], parsedPaths[ j ] ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( index < nCachedObjects ) {\r\n\r\n\t\t\t\tvar knownObject = objects[ index ];\r\n\r\n\t\t\t\t// move existing object to the ACTIVE region\r\n\r\n\t\t\t\tvar firstActiveIndex = -- nCachedObjects,\r\n\t\t\t\t\tlastCachedObject = objects[ firstActiveIndex ];\r\n\r\n\t\t\t\tindicesByUUID[ lastCachedObject.uuid ] = index;\r\n\t\t\t\tobjects[ index ] = lastCachedObject;\r\n\r\n\t\t\t\tindicesByUUID[ uuid ] = firstActiveIndex;\r\n\t\t\t\tobjects[ firstActiveIndex ] = object;\r\n\r\n\t\t\t\t// accounting is done, now do the same for all bindings\r\n\r\n\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\r\n\r\n\t\t\t\t\tvar bindingsForPath = bindings[ j ],\r\n\t\t\t\t\t\tlastCached = bindingsForPath[ firstActiveIndex ],\r\n\t\t\t\t\t\tbinding = bindingsForPath[ index ];\r\n\r\n\t\t\t\t\tbindingsForPath[ index ] = lastCached;\r\n\r\n\t\t\t\t\tif ( binding === undefined ) {\r\n\r\n\t\t\t\t\t\t// since we do not bother to create new bindings\r\n\t\t\t\t\t\t// for objects that are cached, the binding may\r\n\t\t\t\t\t\t// or may not exist\r\n\r\n\t\t\t\t\t\tbinding = new THREE.PropertyBinding(\r\n\t\t\t\t\t\t\t\tobject, paths[ j ], parsedPaths[ j ] );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbindingsForPath[ firstActiveIndex ] = binding;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( objects[ index ] !== knownObject) {\r\n\r\n\t\t\t\tconsole.error( \"Different objects with the same UUID \" +\r\n\t\t\t\t\t\t\"detected. Clean the caches or recreate your \" +\r\n\t\t\t\t\t\t\"infrastructure when reloading scenes...\" );\r\n\r\n\t\t\t} // else the object is already where we want it to be\r\n\r\n\t\t} // for arguments\r\n\r\n\t\tthis.nCachedObjects_ = nCachedObjects;\r\n\r\n\t},\r\n\r\n\tremove: function( var_args ) {\r\n\r\n\t\tvar objects = this._objects,\r\n\t\t\tnObjects = objects.length,\r\n\t\t\tnCachedObjects = this.nCachedObjects_,\r\n\t\t\tindicesByUUID = this._indicesByUUID,\r\n\t\t\tbindings = this._bindings,\r\n\t\t\tnBindings = bindings.length;\r\n\r\n\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\r\n\r\n\t\t\tvar object = arguments[ i ],\r\n\t\t\t\tuuid = object.uuid,\r\n\t\t\t\tindex = indicesByUUID[ uuid ];\r\n\r\n\t\t\tif ( index !== undefined && index >= nCachedObjects ) {\r\n\r\n\t\t\t\t// move existing object into the CACHED region\r\n\r\n\t\t\t\tvar lastCachedIndex = nCachedObjects ++,\r\n\t\t\t\t\tfirstActiveObject = objects[ lastCachedIndex ];\r\n\r\n\t\t\t\tindicesByUUID[ firstActiveObject.uuid ] = index;\r\n\t\t\t\tobjects[ index ] = firstActiveObject;\r\n\r\n\t\t\t\tindicesByUUID[ uuid ] = lastCachedIndex;\r\n\t\t\t\tobjects[ lastCachedIndex ] = object;\r\n\r\n\t\t\t\t// accounting is done, now do the same for all bindings\r\n\r\n\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\r\n\r\n\t\t\t\t\tvar bindingsForPath = bindings[ j ],\r\n\t\t\t\t\t\tfirstActive = bindingsForPath[ lastCachedIndex ],\r\n\t\t\t\t\t\tbinding = bindingsForPath[ index ];\r\n\r\n\t\t\t\t\tbindingsForPath[ index ] = firstActive;\r\n\t\t\t\t\tbindingsForPath[ lastCachedIndex ] = binding;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} // for arguments\r\n\r\n\t\tthis.nCachedObjects_ = nCachedObjects;\r\n\r\n\t},\r\n\r\n\t// remove & forget\r\n\tuncache: function( var_args ) {\r\n\r\n\t\tvar objects = this._objects,\r\n\t\t\tnObjects = objects.length,\r\n\t\t\tnCachedObjects = this.nCachedObjects_,\r\n\t\t\tindicesByUUID = this._indicesByUUID,\r\n\t\t\tbindings = this._bindings,\r\n\t\t\tnBindings = bindings.length;\r\n\r\n\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\r\n\r\n\t\t\tvar object = arguments[ i ],\r\n\t\t\t\tuuid = object.uuid,\r\n\t\t\t\tindex = indicesByUUID[ uuid ];\r\n\r\n\t\t\tif ( index !== undefined ) {\r\n\r\n\t\t\t\tdelete indicesByUUID[ uuid ];\r\n\r\n\t\t\t\tif ( index < nCachedObjects ) {\r\n\r\n\t\t\t\t\t// object is cached, shrink the CACHED region\r\n\r\n\t\t\t\t\tvar firstActiveIndex = -- nCachedObjects,\r\n\t\t\t\t\t\tlastCachedObject = objects[ firstActiveIndex ],\r\n\t\t\t\t\t\tlastIndex = -- nObjects,\r\n\t\t\t\t\t\tlastObject = objects[ lastIndex ];\r\n\r\n\t\t\t\t\t// last cached object takes this object's place\r\n\t\t\t\t\tindicesByUUID[ lastCachedObject.uuid ] = index;\r\n\t\t\t\t\tobjects[ index ] = lastCachedObject;\r\n\r\n\t\t\t\t\t// last object goes to the activated slot and pop\r\n\t\t\t\t\tindicesByUUID[ lastObject.uuid ] = firstActiveIndex;\r\n\t\t\t\t\tobjects[ firstActiveIndex ] = lastObject;\r\n\t\t\t\t\tobjects.pop();\r\n\r\n\t\t\t\t\t// accounting is done, now do the same for all bindings\r\n\r\n\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\r\n\r\n\t\t\t\t\t\tvar bindingsForPath = bindings[ j ],\r\n\t\t\t\t\t\t\tlastCached = bindingsForPath[ firstActiveIndex ],\r\n\t\t\t\t\t\t\tlast = bindingsForPath[ lastIndex ];\r\n\r\n\t\t\t\t\t\tbindingsForPath[ index ] = lastCached;\r\n\t\t\t\t\t\tbindingsForPath[ firstActiveIndex ] = last;\r\n\t\t\t\t\t\tbindingsForPath.pop();\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// object is active, just swap with the last and pop\r\n\r\n\t\t\t\t\tvar lastIndex = -- nObjects,\r\n\t\t\t\t\t\tlastObject = objects[ lastIndex ];\r\n\r\n\t\t\t\t\tindicesByUUID[ lastObject.uuid ] = index;\r\n\t\t\t\t\tobjects[ index ] = lastObject;\r\n\t\t\t\t\tobjects.pop();\r\n\r\n\t\t\t\t\t// accounting is done, now do the same for all bindings\r\n\r\n\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\r\n\r\n\t\t\t\t\t\tvar bindingsForPath = bindings[ j ];\r\n\r\n\t\t\t\t\t\tbindingsForPath[ index ] = bindingsForPath[ lastIndex ];\r\n\t\t\t\t\t\tbindingsForPath.pop();\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} // cached or active\r\n\r\n\t\t\t} // if object is known\r\n\r\n\t\t} // for arguments\r\n\r\n\t\tthis.nCachedObjects_ = nCachedObjects;\r\n\r\n\t},\r\n\r\n\t// Internal interface used by befriended PropertyBinding.Composite:\r\n\r\n\tsubscribe_: function( path, parsedPath ) {\r\n\t\t// returns an array of bindings for the given path that is changed\r\n\t\t// according to the contained objects in the group\r\n\r\n\t\tvar indicesByPath = this._bindingsIndicesByPath,\r\n\t\t\tindex = indicesByPath[ path ],\r\n\t\t\tbindings = this._bindings;\r\n\r\n\t\tif ( index !== undefined ) return bindings[ index ];\r\n\r\n\t\tvar paths = this._paths,\r\n\t\t\tparsedPaths = this._parsedPaths,\r\n\t\t\tobjects = this._objects,\r\n\t\t\tnObjects = objects.length,\r\n\t\t\tnCachedObjects = this.nCachedObjects_,\r\n\t\t\tbindingsForPath = new Array( nObjects );\r\n\r\n\t\tindex = bindings.length;\r\n\r\n\t\tindicesByPath[ path ] = index;\r\n\r\n\t\tpaths.push( path );\r\n\t\tparsedPaths.push( parsedPath );\r\n\t\tbindings.push( bindingsForPath );\r\n\r\n\t\tfor ( var i = nCachedObjects,\r\n\t\t\t\tn = objects.length; i !== n; ++ i ) {\r\n\r\n\t\t\tvar object = objects[ i ];\r\n\r\n\t\t\tbindingsForPath[ i ] =\r\n\t\t\t\t\tnew THREE.PropertyBinding( object, path, parsedPath );\r\n\r\n\t\t}\r\n\r\n\t\treturn bindingsForPath;\r\n\r\n\t},\r\n\r\n\tunsubscribe_: function( path ) {\r\n\t\t// tells the group to forget about a property path and no longer\r\n\t\t// update the array previously obtained with 'subscribe_'\r\n\r\n\t\tvar indicesByPath = this._bindingsIndicesByPath,\r\n\t\t\tindex = indicesByPath[ path ];\r\n\r\n\t\tif ( index !== undefined ) {\r\n\r\n\t\t\tvar paths = this._paths,\r\n\t\t\t\tparsedPaths = this._parsedPaths,\r\n\t\t\t\tbindings = this._bindings,\r\n\t\t\t\tlastBindingsIndex = bindings.length - 1,\r\n\t\t\t\tlastBindings = bindings[ lastBindingsIndex ],\r\n\t\t\t\tlastBindingsPath = path[ lastBindingsIndex ];\r\n\r\n\t\t\tindicesByPath[ lastBindingsPath ] = index;\r\n\r\n\t\t\tbindings[ index ] = lastBindings;\r\n\t\t\tbindings.pop();\r\n\r\n\t\t\tparsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];\r\n\t\t\tparsedPaths.pop();\r\n\r\n\t\t\tpaths[ index ] = paths[ lastBindingsIndex ];\r\n\t\t\tpaths.pop();\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\n\r\n// File:src/animation/AnimationUtils.js\r\n\r\n/**\r\n * @author tschw\r\n * @author Ben Houston / http://clara.io/\r\n * @author David Sarno / http://lighthaus.us/\r\n */\r\n\r\nTHREE.AnimationUtils = {\r\n\r\n\t// same as Array.prototype.slice, but also works on typed arrays\r\n\tarraySlice: function( array, from, to ) {\r\n\r\n\t\tif ( THREE.AnimationUtils.isTypedArray( array ) ) {\r\n\r\n\t\t\treturn new array.constructor( array.subarray( from, to ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn array.slice( from, to );\r\n\r\n\t},\r\n\r\n\t// converts an array to a specific type\r\n\tconvertArray: function( array, type, forceClone ) {\r\n\r\n\t\tif ( ! array || // let 'undefined' and 'null' pass\r\n\t\t\t\t! forceClone && array.constructor === type ) return array;\r\n\r\n\t\tif ( typeof type.BYTES_PER_ELEMENT === 'number' ) {\r\n\r\n\t\t\treturn new type( array ); // create typed array\r\n\r\n\t\t}\r\n\r\n\t\treturn Array.prototype.slice.call( array ); // create Array\r\n\r\n\t},\r\n\r\n\tisTypedArray: function( object ) {\r\n\r\n\t\treturn ArrayBuffer.isView( object ) &&\r\n\t\t\t\t! ( object instanceof DataView );\r\n\r\n\t},\r\n\r\n\t// returns an array by which times and values can be sorted\r\n\tgetKeyframeOrder: function( times ) {\r\n\r\n\t\tfunction compareTime( i, j ) {\r\n\r\n\t\t\treturn times[ i ] - times[ j ];\r\n\r\n\t\t}\r\n\r\n\t\tvar n = times.length;\r\n\t\tvar result = new Array( n );\r\n\t\tfor ( var i = 0; i !== n; ++ i ) result[ i ] = i;\r\n\r\n\t\tresult.sort( compareTime );\r\n\r\n\t\treturn result;\r\n\r\n\t},\r\n\r\n\t// uses the array previously returned by 'getKeyframeOrder' to sort data\r\n\tsortedArray: function( values, stride, order ) {\r\n\r\n\t\tvar nValues = values.length;\r\n\t\tvar result = new values.constructor( nValues );\r\n\r\n\t\tfor ( var i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {\r\n\r\n\t\t\tvar srcOffset = order[ i ] * stride;\r\n\r\n\t\t\tfor ( var j = 0; j !== stride; ++ j ) {\r\n\r\n\t\t\t\tresult[ dstOffset ++ ] = values[ srcOffset + j ];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t},\r\n\r\n\t// function for parsing AOS keyframe formats\r\n\tflattenJSON: function( jsonKeys, times, values, valuePropertyName ) {\r\n\r\n\t\tvar i = 1, key = jsonKeys[ 0 ];\r\n\r\n\t\twhile ( key !== undefined && key[ valuePropertyName ] === undefined ) {\r\n\r\n\t\t\tkey = jsonKeys[ i ++ ];\r\n\r\n\t\t}\r\n\r\n\t\tif ( key === undefined ) return; // no data\r\n\r\n\t\tvar value = key[ valuePropertyName ];\r\n\t\tif ( value === undefined ) return; // no data\r\n\r\n\t\tif ( Array.isArray( value ) ) {\r\n\r\n\t\t\tdo {\r\n\r\n\t\t\t\tvalue = key[ valuePropertyName ];\r\n\r\n\t\t\t\tif ( value !== undefined ) {\r\n\r\n\t\t\t\t\ttimes.push( key.time );\r\n\t\t\t\t\tvalues.push.apply( values, value ); // push all elements\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tkey = jsonKeys[ i ++ ];\r\n\r\n\t\t\t} while ( key !== undefined );\r\n\r\n\t\t} else if ( value.toArray !== undefined ) {\r\n\t\t\t// ...assume THREE.Math-ish\r\n\r\n\t\t\tdo {\r\n\r\n\t\t\t\tvalue = key[ valuePropertyName ];\r\n\r\n\t\t\t\tif ( value !== undefined ) {\r\n\r\n\t\t\t\t\ttimes.push( key.time );\r\n\t\t\t\t\tvalue.toArray( values, values.length );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tkey = jsonKeys[ i ++ ];\r\n\r\n\t\t\t} while ( key !== undefined );\r\n\r\n\t\t} else {\r\n\t\t\t// otherwise push as-is\r\n\r\n\t\t\tdo {\r\n\r\n\t\t\t\tvalue = key[ valuePropertyName ];\r\n\r\n\t\t\t\tif ( value !== undefined ) {\r\n\r\n\t\t\t\t\ttimes.push( key.time );\r\n\t\t\t\t\tvalues.push( value );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tkey = jsonKeys[ i ++ ];\r\n\r\n\t\t\t} while ( key !== undefined );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/animation/KeyframeTrack.js\r\n\r\n/**\r\n *\r\n * A timed sequence of keyframes for a specific property.\r\n *\r\n *\r\n * @author Ben Houston / http://clara.io/\r\n * @author David Sarno / http://lighthaus.us/\r\n * @author tschw\r\n */\r\n\r\nTHREE.KeyframeTrack = function ( name, times, values, interpolation ) {\r\n\r\n\tif( name === undefined ) throw new Error( \"track name is undefined\" );\r\n\r\n\tif( times === undefined || times.length === 0 ) {\r\n\r\n\t\tthrow new Error( \"no keyframes in track named \" + name );\r\n\r\n\t}\r\n\r\n\tthis.name = name;\r\n\r\n\tthis.times = THREE.AnimationUtils.convertArray( times, this.TimeBufferType );\r\n\tthis.values = THREE.AnimationUtils.convertArray( values, this.ValueBufferType );\r\n\r\n\tthis.setInterpolation( interpolation || this.DefaultInterpolation );\r\n\r\n\tthis.validate();\r\n\tthis.optimize();\r\n\r\n};\r\n\r\nTHREE.KeyframeTrack.prototype = {\r\n\r\n\tconstructor: THREE.KeyframeTrack,\r\n\r\n\tTimeBufferType: Float32Array,\r\n\tValueBufferType: Float32Array,\r\n\r\n\tDefaultInterpolation: THREE.InterpolateLinear,\r\n\r\n\tInterpolantFactoryMethodDiscrete: function( result ) {\r\n\r\n\t\treturn new THREE.DiscreteInterpolant(\r\n\t\t\t\tthis.times, this.values, this.getValueSize(), result );\r\n\r\n\t},\r\n\r\n\tInterpolantFactoryMethodLinear: function( result ) {\r\n\r\n\t\treturn new THREE.LinearInterpolant(\r\n\t\t\t\tthis.times, this.values, this.getValueSize(), result );\r\n\r\n\t},\r\n\r\n\tInterpolantFactoryMethodSmooth: function( result ) {\r\n\r\n\t\treturn new THREE.CubicInterpolant(\r\n\t\t\t\tthis.times, this.values, this.getValueSize(), result );\r\n\r\n\t},\r\n\r\n\tsetInterpolation: function( interpolation ) {\r\n\r\n\t\tvar factoryMethod = undefined;\r\n\r\n\t\tswitch ( interpolation ) {\r\n\r\n\t\t\tcase THREE.InterpolateDiscrete:\r\n\r\n\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodDiscrete;\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase THREE.InterpolateLinear:\r\n\r\n\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodLinear;\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase THREE.InterpolateSmooth:\r\n\r\n\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodSmooth;\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t}\r\n\r\n\t\tif ( factoryMethod === undefined ) {\r\n\r\n\t\t\tvar message = \"unsupported interpolation for \" +\r\n\t\t\t\t\tthis.ValueTypeName + \" keyframe track named \" + this.name;\r\n\r\n\t\t\tif ( this.createInterpolant === undefined ) {\r\n\r\n\t\t\t\t// fall back to default, unless the default itself is messed up\r\n\t\t\t\tif ( interpolation !== this.DefaultInterpolation ) {\r\n\r\n\t\t\t\t\tthis.setInterpolation( this.DefaultInterpolation );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tthrow new Error( message ); // fatal, in this case\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconsole.warn( message );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tthis.createInterpolant = factoryMethod;\r\n\r\n\t},\r\n\r\n\tgetInterpolation: function() {\r\n\r\n\t\tswitch ( this.createInterpolant ) {\r\n\r\n\t\t\tcase this.InterpolantFactoryMethodDiscrete:\r\n\r\n\t\t\t\treturn THREE.InterpolateDiscrete;\r\n\r\n\t\t\tcase this.InterpolantFactoryMethodLinear:\r\n\r\n\t\t\t\treturn THREE.InterpolateLinear;\r\n\r\n\t\t\tcase this.InterpolantFactoryMethodSmooth:\r\n\r\n\t\t\t\treturn THREE.InterpolateSmooth;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tgetValueSize: function() {\r\n\r\n\t\treturn this.values.length / this.times.length;\r\n\r\n\t},\r\n\r\n\t// move all keyframes either forwards or backwards in time\r\n\tshift: function( timeOffset ) {\r\n\r\n\t\tif( timeOffset !== 0.0 ) {\r\n\r\n\t\t\tvar times = this.times;\r\n\r\n\t\t\tfor( var i = 0, n = times.length; i !== n; ++ i ) {\r\n\r\n\t\t\t\ttimes[ i ] += timeOffset;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\t// scale all keyframe times by a factor (useful for frame <-> seconds conversions)\r\n\tscale: function( timeScale ) {\r\n\r\n\t\tif( timeScale !== 1.0 ) {\r\n\r\n\t\t\tvar times = this.times;\r\n\r\n\t\t\tfor( var i = 0, n = times.length; i !== n; ++ i ) {\r\n\r\n\t\t\t\ttimes[ i ] *= timeScale;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\t// removes keyframes before and after animation without changing any values within the range [startTime, endTime].\r\n\t// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values\r\n\ttrim: function( startTime, endTime ) {\r\n\r\n\t\tvar times = this.times,\r\n\t\t\tnKeys = times.length,\r\n\t\t\tfrom = 0,\r\n\t\t\tto = nKeys - 1;\r\n\r\n\t\twhile ( from !== nKeys && times[ from ] < startTime ) ++ from;\r\n\t\twhile ( to !== -1 && times[ to ] > endTime ) -- to;\r\n\r\n\t\t++ to; // inclusive -> exclusive bound\r\n\r\n\t\tif( from !== 0 || to !== nKeys ) {\r\n\r\n\t\t\t// empty tracks are forbidden, so keep at least one keyframe\r\n\t\t\tif ( from >= to ) to = Math.max( to , 1 ), from = to - 1;\r\n\r\n\t\t\tvar stride = this.getValueSize();\r\n\t\t\tthis.times = THREE.AnimationUtils.arraySlice( times, from, to );\r\n\t\t\tthis.values = THREE.AnimationUtils.\r\n\t\t\t\t\tarraySlice( this.values, from * stride, to * stride );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\t// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable\r\n\tvalidate: function() {\r\n\r\n\t\tvar valid = true;\r\n\r\n\t\tvar valueSize = this.getValueSize();\r\n\t\tif ( valueSize - Math.floor( valueSize ) !== 0 ) {\r\n\r\n\t\t\tconsole.error( \"invalid value size in track\", this );\r\n\t\t\tvalid = false;\r\n\r\n\t\t}\r\n\r\n\t\tvar times = this.times,\r\n\t\t\tvalues = this.values,\r\n\r\n\t\t\tnKeys = times.length;\r\n\r\n\t\tif( nKeys === 0 ) {\r\n\r\n\t\t\tconsole.error( \"track is empty\", this );\r\n\t\t\tvalid = false;\r\n\r\n\t\t}\r\n\r\n\t\tvar prevTime = null;\r\n\r\n\t\tfor( var i = 0; i !== nKeys; i ++ ) {\r\n\r\n\t\t\tvar currTime = times[ i ];\r\n\r\n\t\t\tif ( typeof currTime === 'number' && isNaN( currTime ) ) {\r\n\r\n\t\t\t\tconsole.error( \"time is not a valid number\", this, i, currTime );\r\n\t\t\t\tvalid = false;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif( prevTime !== null && prevTime > currTime ) {\r\n\r\n\t\t\t\tconsole.error( \"out of order keys\", this, i, currTime, prevTime );\r\n\t\t\t\tvalid = false;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tprevTime = currTime;\r\n\r\n\t\t}\r\n\r\n\t\tif ( values !== undefined ) {\r\n\r\n\t\t\tif ( THREE.AnimationUtils.isTypedArray( values ) ) {\r\n\r\n\t\t\t\tfor ( var i = 0, n = values.length; i !== n; ++ i ) {\r\n\r\n\t\t\t\t\tvar value = values[ i ];\r\n\r\n\t\t\t\t\tif ( isNaN( value ) ) {\r\n\r\n\t\t\t\t\t\tconsole.error( \"value is not a valid number\", this, i, value );\r\n\t\t\t\t\t\tvalid = false;\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn valid;\r\n\r\n\t},\r\n\r\n\t// removes equivalent sequential keys as common in morph target sequences\r\n\t// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)\r\n\toptimize: function() {\r\n\r\n\t\tvar times = this.times,\r\n\t\t\tvalues = this.values,\r\n\t\t\tstride = this.getValueSize(),\r\n\r\n\t\t\twriteIndex = 1;\r\n\r\n\t\tfor( var i = 1, n = times.length - 1; i <= n; ++ i ) {\r\n\r\n\t\t\tvar keep = false;\r\n\r\n\t\t\tvar time = times[ i ];\r\n\t\t\tvar timeNext = times[ i + 1 ];\r\n\r\n\t\t\t// remove adjacent keyframes scheduled at the same time\r\n\r\n\t\t\tif ( time !== timeNext && ( i !== 1 || time !== time[ 0 ] ) ) {\r\n\r\n\t\t\t\t// remove unnecessary keyframes same as their neighbors\r\n\t\t\t\tvar offset = i * stride,\r\n\t\t\t\t\toffsetP = offset - stride,\r\n\t\t\t\t\toffsetN = offset + stride;\r\n\r\n\t\t\t\tfor ( var j = 0; j !== stride; ++ j ) {\r\n\r\n\t\t\t\t\tvar value = values[ offset + j ];\r\n\r\n\t\t\t\t\tif ( value !== values[ offsetP + j ] ||\r\n\t\t\t\t\t\t\tvalue !== values[ offsetN + j ] ) {\r\n\r\n\t\t\t\t\t\tkeep = true;\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// in-place compaction\r\n\r\n\t\t\tif ( keep ) {\r\n\r\n\t\t\t\tif ( i !== writeIndex ) {\r\n\r\n\t\t\t\t\ttimes[ writeIndex ] = times[ i ];\r\n\r\n\t\t\t\t\tvar readOffset = i * stride,\r\n\t\t\t\t\t\twriteOffset = writeIndex * stride;\r\n\r\n\t\t\t\t\tfor ( var j = 0; j !== stride; ++ j ) {\r\n\r\n\t\t\t\t\t\tvalues[ writeOffset + j ] = values[ readOffset + j ];\r\n\r\n\t\t\t\t\t}\r\n\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t++ writeIndex;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( writeIndex !== times.length ) {\r\n\r\n\t\t\tthis.times = THREE.AnimationUtils.arraySlice( times, 0, writeIndex );\r\n\t\t\tthis.values = THREE.AnimationUtils.arraySlice( values, 0, writeIndex * stride );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// Static methods:\r\n\r\nObject.assign( THREE.KeyframeTrack, {\r\n\r\n\t// Serialization (in static context, because of constructor invocation\r\n\t// and automatic invocation of .toJSON):\r\n\r\n\tparse: function( json ) {\r\n\r\n\t\tif( json.type === undefined ) {\r\n\r\n\t\t\tthrow new Error( \"track type undefined, can not parse\" );\r\n\r\n\t\t}\r\n\r\n\t\tvar trackType = THREE.KeyframeTrack._getTrackTypeForValueTypeName( json.type );\r\n\r\n\t\tif ( json.times === undefined ) {\r\n\r\n\t\t\tconsole.warn( \"legacy JSON format detected, converting\" );\r\n\r\n\t\t\tvar times = [], values = [];\r\n\r\n\t\t\tTHREE.AnimationUtils.flattenJSON( json.keys, times, values, 'value' );\r\n\r\n\t\t\tjson.times = times;\r\n\t\t\tjson.values = values;\r\n\r\n\t\t}\r\n\r\n\t\t// derived classes can define a static parse method\r\n\t\tif ( trackType.parse !== undefined ) {\r\n\r\n\t\t\treturn trackType.parse( json );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// by default, we asssume a constructor compatible with the base\r\n\t\t\treturn new trackType(\r\n\t\t\t\t\tjson.name, json.times, json.values, json.interpolation );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\ttoJSON: function( track ) {\r\n\r\n\t\tvar trackType = track.constructor;\r\n\r\n\t\tvar json;\r\n\r\n\t\t// derived classes can define a static toJSON method\r\n\t\tif ( trackType.toJSON !== undefined ) {\r\n\r\n\t\t\tjson = trackType.toJSON( track );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// by default, we assume the data can be serialized as-is\r\n\t\t\tjson = {\r\n\r\n\t\t\t\t'name': track.name,\r\n\t\t\t\t'times': THREE.AnimationUtils.convertArray( track.times, Array ),\r\n\t\t\t\t'values': THREE.AnimationUtils.convertArray( track.values, Array )\r\n\r\n\t\t\t};\r\n\r\n\t\t\tvar interpolation = track.getInterpolation();\r\n\r\n\t\t\tif ( interpolation !== track.DefaultInterpolation ) {\r\n\r\n\t\t\t\tjson.interpolation = interpolation;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tjson.type = track.ValueTypeName; // mandatory\r\n\r\n\t\treturn json;\r\n\r\n\t},\r\n\r\n\t_getTrackTypeForValueTypeName: function( typeName ) {\r\n\r\n\t\tswitch( typeName.toLowerCase() ) {\r\n\r\n\t\t\tcase \"scalar\":\r\n\t\t\tcase \"double\":\r\n\t\t\tcase \"float\":\r\n\t\t\tcase \"number\":\r\n\t\t\tcase \"integer\":\r\n\r\n\t\t\t\treturn THREE.NumberKeyframeTrack;\r\n\r\n\t\t\tcase \"vector\":\r\n\t\t\tcase \"vector2\":\r\n\t\t\tcase \"vector3\":\r\n\t\t\tcase \"vector4\":\r\n\r\n\t\t\t\treturn THREE.VectorKeyframeTrack;\r\n\r\n\t\t\tcase \"color\":\r\n\r\n\t\t\t\treturn THREE.ColorKeyframeTrack;\r\n\r\n\t\t\tcase \"quaternion\":\r\n\r\n\t\t\t\treturn THREE.QuaternionKeyframeTrack;\r\n\r\n\t\t\tcase \"bool\":\r\n\t\t\tcase \"boolean\":\r\n\r\n\t\t\t\treturn THREE.BooleanKeyframeTrack;\r\n\r\n\t\t\tcase \"string\":\r\n\r\n\t\t\t\treturn THREE.StringKeyframeTrack;\r\n\r\n\t\t};\r\n\r\n\t\tthrow new Error( \"Unsupported typeName: \" + typeName );\r\n\r\n\t}\r\n\r\n} );\r\n\r\n// File:src/animation/PropertyBinding.js\r\n\r\n/**\r\n *\r\n * A reference to a real property in the scene graph.\r\n *\r\n *\r\n * @author Ben Houston / http://clara.io/\r\n * @author David Sarno / http://lighthaus.us/\r\n * @author tschw\r\n */\r\n\r\nTHREE.PropertyBinding = function ( rootNode, path, parsedPath ) {\r\n\r\n\tthis.path = path;\r\n\tthis.parsedPath = parsedPath ||\r\n\t\t\tTHREE.PropertyBinding.parseTrackName( path );\r\n\r\n\tthis.node = THREE.PropertyBinding.findNode(\r\n\t\t\trootNode, this.parsedPath.nodeName ) || rootNode;\r\n\r\n\tthis.rootNode = rootNode;\r\n\r\n};\r\n\r\nTHREE.PropertyBinding.prototype = {\r\n\r\n\tconstructor: THREE.PropertyBinding,\r\n\r\n\tgetValue: function getValue_unbound( targetArray, offset ) {\r\n\r\n\t\tthis.bind();\r\n\t\tthis.getValue( targetArray, offset );\r\n\r\n\t\t// Note: This class uses a State pattern on a per-method basis:\r\n\t\t// 'bind' sets 'this.getValue' / 'setValue' and shadows the\r\n\t\t// prototype version of these methods with one that represents\r\n\t\t// the bound state. When the property is not found, the methods\r\n\t\t// become no-ops.\r\n\r\n\t},\r\n\r\n\tsetValue: function getValue_unbound( sourceArray, offset ) {\r\n\r\n\t\tthis.bind();\r\n\t\tthis.setValue( sourceArray, offset );\r\n\r\n\t},\r\n\r\n\t// create getter / setter pair for a property in the scene graph\r\n\tbind: function() {\r\n\r\n\t\tvar targetObject = this.node,\r\n\t\t\tparsedPath = this.parsedPath,\r\n\r\n\t\t\tobjectName = parsedPath.objectName,\r\n\t\t\tpropertyName = parsedPath.propertyName,\r\n\t\t\tpropertyIndex = parsedPath.propertyIndex;\r\n\r\n\t\tif ( ! targetObject ) {\r\n\r\n\t\t\ttargetObject = THREE.PropertyBinding.findNode(\r\n\t\t\t\t\tthis.rootNode, parsedPath.nodeName ) || this.rootNode;\r\n\r\n\t\t\tthis.node = targetObject;\r\n\r\n\t\t}\r\n\r\n\t\t// set fail state so we can just 'return' on error\r\n\t\tthis.getValue = this._getValue_unavailable;\r\n\t\tthis.setValue = this._setValue_unavailable;\r\n\r\n \t\t// ensure there is a value node\r\n\t\tif ( ! targetObject ) {\r\n\r\n\t\t\tconsole.error( \"  trying to update node for track: \" + this.path + \" but it wasn't found.\" );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tif( objectName ) {\r\n\r\n\t\t\tvar objectIndex = parsedPath.objectIndex;\r\n\r\n\t\t\t// special cases were we need to reach deeper into the hierarchy to get the face materials....\r\n\t\t\tswitch ( objectName ) {\r\n\r\n\t\t\t\tcase 'materials':\r\n\r\n\t\t\t\t\tif( ! targetObject.material ) {\r\n\r\n\t\t\t\t\t\tconsole.error( '  can not bind to material as node does not have a material', this );\r\n\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif( ! targetObject.material.materials ) {\r\n\r\n\t\t\t\t\t\tconsole.error( '  can not bind to material.materials as node.material does not have a materials array', this );\r\n\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\ttargetObject = targetObject.material.materials;\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'bones':\r\n\r\n\t\t\t\t\tif( ! targetObject.skeleton ) {\r\n\r\n\t\t\t\t\t\tconsole.error( '  can not bind to bones as node does not have a skeleton', this );\r\n\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// potential future optimization: skip this if propertyIndex is already an integer\r\n\t\t\t\t\t// and convert the integer string to a true integer.\r\n\r\n\t\t\t\t\ttargetObject = targetObject.skeleton.bones;\r\n\r\n\t\t\t\t\t// support resolving morphTarget names into indices.\r\n\t\t\t\t\tfor ( var i = 0; i < targetObject.length; i ++ ) {\r\n\r\n\t\t\t\t\t\tif ( targetObject[i].name === objectIndex ) {\r\n\r\n\t\t\t\t\t\t\tobjectIndex = i;\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tdefault:\r\n\r\n\t\t\t\t\tif ( targetObject[ objectName ] === undefined ) {\r\n\r\n\t\t\t\t\t\tconsole.error( '  can not bind to objectName of node, undefined', this );\r\n\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\ttargetObject = targetObject[ objectName ];\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t\tif ( objectIndex !== undefined ) {\r\n\r\n\t\t\t\tif( targetObject[ objectIndex ] === undefined ) {\r\n\r\n\t\t\t\t\tconsole.error( \"  trying to bind to objectIndex of objectName, but is undefined:\", this, targetObject );\r\n\t\t\t\t\treturn;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttargetObject = targetObject[ objectIndex ];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// resolve property\r\n\t\tvar nodeProperty = targetObject[ propertyName ];\r\n\r\n\t\tif ( ! nodeProperty ) {\r\n\r\n\t\t\tvar nodeName = parsedPath.nodeName;\r\n\r\n\t\t\tconsole.error( \"  trying to update property for track: \" + nodeName +\r\n\t\t\t\t\t'.' + propertyName + \" but it wasn't found.\", targetObject );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\t// determine versioning scheme\r\n\t\tvar versioning = this.Versioning.None;\r\n\r\n\t\tif ( targetObject.needsUpdate !== undefined ) { // material\r\n\r\n\t\t\tversioning = this.Versioning.NeedsUpdate;\r\n\t\t\tthis.targetObject = targetObject;\r\n\r\n\t\t} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform\r\n\r\n\t\t\tversioning = this.Versioning.MatrixWorldNeedsUpdate;\r\n\t\t\tthis.targetObject = targetObject;\r\n\r\n\t\t}\r\n\r\n\t\t// determine how the property gets bound\r\n\t\tvar bindingType = this.BindingType.Direct;\r\n\r\n\t\tif ( propertyIndex !== undefined ) {\r\n\t\t\t// access a sub element of the property array (only primitives are supported right now)\r\n\r\n\t\t\tif ( propertyName === \"morphTargetInfluences\" ) {\r\n\t\t\t\t// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.\r\n\r\n\t\t\t\t// support resolving morphTarget names into indices.\r\n\t\t\t\tif ( ! targetObject.geometry ) {\r\n\r\n\t\t\t\t\tconsole.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry', this );\r\n\t\t\t\t\treturn;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( ! targetObject.geometry.morphTargets ) {\r\n\r\n\t\t\t\t\tconsole.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets', this );\r\n\t\t\t\t\treturn;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor ( var i = 0; i < this.node.geometry.morphTargets.length; i ++ ) {\r\n\r\n\t\t\t\t\tif ( targetObject.geometry.morphTargets[i].name === propertyIndex ) {\r\n\r\n\t\t\t\t\t\tpropertyIndex = i;\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tbindingType = this.BindingType.ArrayElement;\r\n\r\n\t\t\tthis.resolvedProperty = nodeProperty;\r\n\t\t\tthis.propertyIndex = propertyIndex;\r\n\r\n\t\t} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {\r\n\t\t\t// must use copy for Object3D.Euler/Quaternion\r\n\r\n\t\t\tbindingType = this.BindingType.HasFromToArray;\r\n\r\n\t\t\tthis.resolvedProperty = nodeProperty;\r\n\r\n\t\t} else if ( nodeProperty.length !== undefined ) {\r\n\r\n\t\t\tbindingType = this.BindingType.EntireArray;\r\n\r\n\t\t\tthis.resolvedProperty = nodeProperty;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.propertyName = propertyName;\r\n\r\n\t\t}\r\n\r\n\t\t// select getter / setter\r\n\t\tthis.getValue = this.GetterByBindingType[ bindingType ];\r\n\t\tthis.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];\r\n\r\n\t},\r\n\r\n\tunbind: function() {\r\n\r\n\t\tthis.node = null;\r\n\r\n\t\t// back to the prototype version of getValue / setValue\r\n\t\t// note: avoiding to mutate the shape of 'this' via 'delete'\r\n\t\tthis.getValue = this._getValue_unbound;\r\n\t\tthis.setValue = this._setValue_unbound;\r\n\r\n\t}\r\n\r\n};\r\n\r\nObject.assign( THREE.PropertyBinding.prototype, { // prototype, continued\r\n\r\n\t// these are used to \"bind\" a nonexistent property\r\n\t_getValue_unavailable: function() {},\r\n\t_setValue_unavailable: function() {},\r\n\r\n\t// initial state of these methods that calls 'bind'\r\n\t_getValue_unbound: THREE.PropertyBinding.prototype.getValue,\r\n\t_setValue_unbound: THREE.PropertyBinding.prototype.setValue,\r\n\r\n\tBindingType: {\r\n\t\tDirect: 0,\r\n\t\tEntireArray: 1,\r\n\t\tArrayElement: 2,\r\n\t\tHasFromToArray: 3\r\n\t},\r\n\r\n\tVersioning: {\r\n\t\tNone: 0,\r\n\t\tNeedsUpdate: 1,\r\n\t\tMatrixWorldNeedsUpdate: 2\r\n\t},\r\n\r\n\tGetterByBindingType: [\r\n\r\n\t\tfunction getValue_direct( buffer, offset ) {\r\n\r\n\t\t\tbuffer[ offset ] = this.node[ this.propertyName ];\r\n\r\n\t\t},\r\n\r\n\t\tfunction getValue_array( buffer, offset ) {\r\n\r\n\t\t\tvar source = this.resolvedProperty;\r\n\r\n\t\t\tfor ( var i = 0, n = source.length; i !== n; ++ i ) {\r\n\r\n\t\t\t\tbuffer[ offset ++ ] = source[ i ];\r\n\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\tfunction getValue_arrayElement( buffer, offset ) {\r\n\r\n\t\t\tbuffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];\r\n\r\n\t\t},\r\n\r\n\t\tfunction getValue_toArray( buffer, offset ) {\r\n\r\n\t\t\tthis.resolvedProperty.toArray( buffer, offset );\r\n\r\n\t\t}\r\n\r\n\t],\r\n\r\n\tSetterByBindingTypeAndVersioning: [\r\n\r\n\t\t[\r\n\t\t\t// Direct\r\n\r\n\t\t\tfunction setValue_direct( buffer, offset ) {\r\n\r\n\t\t\t\tthis.node[ this.propertyName ] = buffer[ offset ];\r\n\r\n\t\t\t},\r\n\r\n\t\t\tfunction setValue_direct_setNeedsUpdate( buffer, offset ) {\r\n\r\n\t\t\t\tthis.node[ this.propertyName ] = buffer[ offset ];\r\n\t\t\t\tthis.targetObject.needsUpdate = true;\r\n\r\n\t\t\t},\r\n\r\n\t\t\tfunction setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {\r\n\r\n\t\t\t\tthis.node[ this.propertyName ] = buffer[ offset ];\r\n\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t], [\r\n\r\n\t\t\t// EntireArray\r\n\r\n\t\t\tfunction setValue_array( buffer, offset ) {\r\n\r\n\t\t\t\tvar dest = this.resolvedProperty;\r\n\r\n\t\t\t\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\r\n\r\n\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t},\r\n\r\n\t\t\tfunction setValue_array_setNeedsUpdate( buffer, offset ) {\r\n\r\n\t\t\t\tvar dest = this.resolvedProperty;\r\n\r\n\t\t\t\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\r\n\r\n\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.targetObject.needsUpdate = true;\r\n\r\n\t\t\t},\r\n\r\n\t\t\tfunction setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {\r\n\r\n\t\t\t\tvar dest = this.resolvedProperty;\r\n\r\n\t\t\t\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\r\n\r\n\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t], [\r\n\r\n\t\t\t// ArrayElement\r\n\r\n\t\t\tfunction setValue_arrayElement( buffer, offset ) {\r\n\r\n\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\r\n\r\n\t\t\t},\r\n\r\n\t\t\tfunction setValue_arrayElement_setNeedsUpdate( buffer, offset ) {\r\n\r\n\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\r\n\t\t\t\tthis.targetObject.needsUpdate = true;\r\n\r\n\t\t\t},\r\n\r\n\t\t\tfunction setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {\r\n\r\n\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\r\n\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t], [\r\n\r\n\t\t\t// HasToFromArray\r\n\r\n\t\t\tfunction setValue_fromArray( buffer, offset ) {\r\n\r\n\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\r\n\r\n\t\t\t},\r\n\r\n\t\t\tfunction setValue_fromArray_setNeedsUpdate( buffer, offset ) {\r\n\r\n\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\r\n\t\t\t\tthis.targetObject.needsUpdate = true;\r\n\r\n\t\t\t},\r\n\r\n\t\t\tfunction setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {\r\n\r\n\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\r\n\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t]\r\n\r\n\t]\r\n\r\n} );\r\n\r\nTHREE.PropertyBinding.Composite =\r\n\t\tfunction( targetGroup, path, optionalParsedPath ) {\r\n\r\n\tvar parsedPath = optionalParsedPath ||\r\n\t\t\tTHREE.PropertyBinding.parseTrackName( path );\r\n\r\n\tthis._targetGroup = targetGroup;\r\n\tthis._bindings = targetGroup.subscribe_( path, parsedPath );\r\n\r\n};\r\n\r\nTHREE.PropertyBinding.Composite.prototype = {\r\n\r\n\tconstructor: THREE.PropertyBinding.Composite,\r\n\r\n\tgetValue: function( array, offset ) {\r\n\r\n\t\tthis.bind(); // bind all binding\r\n\r\n\t\tvar firstValidIndex = this._targetGroup.nCachedObjects_,\r\n\t\t\tbinding = this._bindings[ firstValidIndex ];\r\n\r\n\t\t// and only call .getValue on the first\r\n\t\tif ( binding !== undefined ) binding.getValue( array, offset );\r\n\r\n\t},\r\n\r\n\tsetValue: function( array, offset ) {\r\n\r\n\t\tvar bindings = this._bindings;\r\n\r\n\t\tfor ( var i = this._targetGroup.nCachedObjects_,\r\n\t\t\t\tn = bindings.length; i !== n; ++ i ) {\r\n\r\n\t\t\tbindings[ i ].setValue( array, offset );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tbind: function() {\r\n\r\n\t\tvar bindings = this._bindings;\r\n\r\n\t\tfor ( var i = this._targetGroup.nCachedObjects_,\r\n\t\t\t\tn = bindings.length; i !== n; ++ i ) {\r\n\r\n\t\t\tbindings[ i ].bind();\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tunbind: function() {\r\n\r\n\t\tvar bindings = this._bindings;\r\n\r\n\t\tfor ( var i = this._targetGroup.nCachedObjects_,\r\n\t\t\t\tn = bindings.length; i !== n; ++ i ) {\r\n\r\n\t\t\tbindings[ i ].unbind();\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.PropertyBinding.create = function( root, path, parsedPath ) {\r\n\r\n\tif ( ! ( root instanceof THREE.AnimationObjectGroup ) ) {\r\n\r\n\t\treturn new THREE.PropertyBinding( root, path, parsedPath );\r\n\r\n\t} else {\r\n\r\n\t\treturn new THREE.PropertyBinding.Composite( root, path, parsedPath );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.PropertyBinding.parseTrackName = function( trackName ) {\r\n\r\n\t// matches strings in the form of:\r\n\t//    nodeName.property\r\n\t//    nodeName.property[accessor]\r\n\t//    nodeName.material.property[accessor]\r\n\t//    uuid.property[accessor]\r\n\t//    uuid.objectName[objectIndex].propertyName[propertyIndex]\r\n\t//    parentName/nodeName.property\r\n\t//    parentName/parentName/nodeName.property[index]\r\n\t//\t  .bone[Armature.DEF_cog].position\r\n\t// created and tested via https://regex101.com/#javascript\r\n\r\n\tvar re = /^(([\\w]+\\/)*)([\\w-\\d]+)?(\\.([\\w]+)(\\[([\\w\\d\\[\\]\\_.:\\- ]+)\\])?)?(\\.([\\w.]+)(\\[([\\w\\d\\[\\]\\_. ]+)\\])?)$/;\r\n\tvar matches = re.exec(trackName);\r\n\r\n\tif( ! matches ) {\r\n\t\tthrow new Error( \"cannot parse trackName at all: \" + trackName );\r\n\t}\r\n\r\n    if (matches.index === re.lastIndex) {\r\n        re.lastIndex++;\r\n    }\r\n\r\n\tvar results = {\r\n\t\t// directoryName: matches[1], // (tschw) currently unused\r\n\t\tnodeName: matches[3], \t// allowed to be null, specified root node.\r\n\t\tobjectName: matches[5],\r\n\t\tobjectIndex: matches[7],\r\n\t\tpropertyName: matches[9],\r\n\t\tpropertyIndex: matches[11]\t// allowed to be null, specifies that the whole property is set.\r\n\t};\r\n\r\n\tif( results.propertyName === null || results.propertyName.length === 0 ) {\r\n\t\tthrow new Error( \"can not parse propertyName from trackName: \" + trackName );\r\n\t}\r\n\r\n\treturn results;\r\n\r\n};\r\n\r\nTHREE.PropertyBinding.findNode = function( root, nodeName ) {\r\n\r\n\tif( ! nodeName || nodeName === \"\" || nodeName === \"root\" || nodeName === \".\" || nodeName === -1 || nodeName === root.name || nodeName === root.uuid ) {\r\n\r\n\t\treturn root;\r\n\r\n\t}\r\n\r\n\t// search into skeleton bones.\r\n\tif( root.skeleton ) {\r\n\r\n\t\tvar searchSkeleton = function( skeleton ) {\r\n\r\n\t\t\tfor( var i = 0; i < skeleton.bones.length; i ++ ) {\r\n\r\n\t\t\t\tvar bone = skeleton.bones[i];\r\n\r\n\t\t\t\tif( bone.name === nodeName ) {\r\n\r\n\t\t\t\t\treturn bone;\r\n\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn null;\r\n\r\n\t\t};\r\n\r\n\t\tvar bone = searchSkeleton( root.skeleton );\r\n\r\n\t\tif( bone ) {\r\n\r\n\t\t\treturn bone;\r\n\r\n\t\t}\r\n\t}\r\n\r\n\t// search into node subtree.\r\n\tif( root.children ) {\r\n\r\n\t\tvar searchNodeSubtree = function( children ) {\r\n\r\n\t\t\tfor( var i = 0; i < children.length; i ++ ) {\r\n\r\n\t\t\t\tvar childNode = children[i];\r\n\r\n\t\t\t\tif( childNode.name === nodeName || childNode.uuid === nodeName ) {\r\n\r\n\t\t\t\t\treturn childNode;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar result = searchNodeSubtree( childNode.children );\r\n\r\n\t\t\t\tif( result ) return result;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn null;\r\n\r\n\t\t};\r\n\r\n\t\tvar subTreeNode = searchNodeSubtree( root.children );\r\n\r\n\t\tif( subTreeNode ) {\r\n\r\n\t\t\treturn subTreeNode;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn null;\r\n\r\n}\r\n\r\n// File:src/animation/PropertyMixer.js\r\n\r\n/**\r\n *\r\n * Buffered scene graph property that allows weighted accumulation.\r\n *\r\n *\r\n * @author Ben Houston / http://clara.io/\r\n * @author David Sarno / http://lighthaus.us/\r\n * @author tschw\r\n */\r\n\r\nTHREE.PropertyMixer = function ( binding, typeName, valueSize ) {\r\n\r\n\tthis.binding = binding;\r\n\tthis.valueSize = valueSize;\r\n\r\n\tvar bufferType = Float64Array,\r\n\t\tmixFunction;\r\n\r\n\tswitch ( typeName ) {\r\n\r\n\t\tcase 'quaternion':\t\t\tmixFunction = this._slerp;\t\tbreak;\r\n\r\n\t\tcase 'string':\r\n\t\tcase 'bool':\r\n\r\n\t\t\tbufferType = Array,\t\tmixFunction = this._select;\t\tbreak;\r\n\r\n\t\tdefault:\t\t\t\t\tmixFunction = this._lerp;\r\n\r\n\t}\r\n\r\n\tthis.buffer = new bufferType( valueSize * 4 );\r\n\t// layout: [ incoming | accu0 | accu1 | orig ]\r\n\t//\r\n\t// interpolators can use .buffer as their .result\r\n\t// the data then goes to 'incoming'\r\n\t//\r\n\t// 'accu0' and 'accu1' are used frame-interleaved for\r\n\t// the cumulative result and are compared to detect\r\n\t// changes\r\n\t//\r\n\t// 'orig' stores the original state of the property\r\n\r\n\tthis._mixBufferRegion = mixFunction;\r\n\r\n\tthis.cumulativeWeight = 0;\r\n\r\n\tthis.useCount = 0;\r\n\tthis.referenceCount = 0;\r\n\r\n};\r\n\r\nTHREE.PropertyMixer.prototype = {\r\n\r\n\tconstructor: THREE.PropertyMixer,\r\n\r\n\t// accumulate data in the 'incoming' region into 'accu<i>'\r\n\taccumulate: function( accuIndex, weight ) {\r\n\r\n\t\t// note: happily accumulating nothing when weight = 0, the caller knows\r\n\t\t// the weight and shouldn't have made the call in the first place\r\n\r\n\t\tvar buffer = this.buffer,\r\n\t\t\tstride = this.valueSize,\r\n\t\t\toffset = accuIndex * stride + stride,\r\n\r\n\t\t\tcurrentWeight = this.cumulativeWeight;\r\n\r\n\t\tif ( currentWeight === 0 ) {\r\n\r\n\t\t\t// accuN := incoming * weight\r\n\r\n\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\r\n\r\n\t\t\t\tbuffer[ offset + i ] = buffer[ i ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tcurrentWeight = weight;\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// accuN := accuN + incoming * weight\r\n\r\n\t\t\tcurrentWeight += weight;\r\n\t\t\tvar mix = weight / currentWeight;\r\n\t\t\tthis._mixBufferRegion( buffer, offset, 0, mix, stride );\r\n\r\n\t\t}\r\n\r\n\t\tthis.cumulativeWeight = currentWeight;\r\n\r\n\t},\r\n\r\n\t// apply the state of 'accu<i>' to the binding when accus differ\r\n\tapply: function( accuIndex ) {\r\n\r\n\t\tvar stride = this.valueSize,\r\n\t\t\tbuffer = this.buffer,\r\n\t\t\toffset = accuIndex * stride + stride,\r\n\r\n\t\t\tweight = this.cumulativeWeight,\r\n\r\n\t\t\tbinding = this.binding;\r\n\r\n\t\tthis.cumulativeWeight = 0;\r\n\r\n\t\tif ( weight < 1 ) {\r\n\r\n\t\t\t// accuN := accuN + original * ( 1 - cumulativeWeight )\r\n\r\n\t\t\tvar originalValueOffset = stride * 3;\r\n\r\n\t\t\tthis._mixBufferRegion(\r\n\t\t\t\t\tbuffer, offset, originalValueOffset, 1 - weight, stride );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var i = stride, e = stride + stride; i !== e; ++ i ) {\r\n\r\n\t\t\tif ( buffer[ i ] !== buffer[ i + stride ] ) {\r\n\r\n\t\t\t\t// value has changed -> update scene graph\r\n\r\n\t\t\t\tbinding.setValue( buffer, offset );\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\t// remember the state of the bound property and copy it to both accus\r\n\tsaveOriginalState: function() {\r\n\r\n\t\tvar binding = this.binding;\r\n\r\n\t\tvar buffer = this.buffer,\r\n\t\t\tstride = this.valueSize,\r\n\r\n\t\t\toriginalValueOffset = stride * 3;\r\n\r\n\t\tbinding.getValue( buffer, originalValueOffset );\r\n\r\n\t\t// accu[0..1] := orig -- initially detect changes against the original\r\n\t\tfor ( var i = stride, e = originalValueOffset; i !== e; ++ i ) {\r\n\r\n\t\t\tbuffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];\r\n\r\n\t\t}\r\n\r\n\t\tthis.cumulativeWeight = 0;\r\n\r\n\t},\r\n\r\n\t// apply the state previously taken via 'saveOriginalState' to the binding\r\n\trestoreOriginalState: function() {\r\n\r\n\t\tvar originalValueOffset = this.valueSize * 3;\r\n\t\tthis.binding.setValue( this.buffer, originalValueOffset );\r\n\r\n\t},\r\n\r\n\r\n\t// mix functions\r\n\r\n\t_select: function( buffer, dstOffset, srcOffset, t, stride ) {\r\n\r\n\t\tif ( t >= 0.5 ) {\r\n\r\n\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\r\n\r\n\t\t\t\tbuffer[ dstOffset + i ] = buffer[ srcOffset + i ];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\t_slerp: function( buffer, dstOffset, srcOffset, t, stride ) {\r\n\r\n\t\tTHREE.Quaternion.slerpFlat( buffer, dstOffset,\r\n\t\t\t\tbuffer, dstOffset, buffer, srcOffset, t );\r\n\r\n\t},\r\n\r\n\t_lerp: function( buffer, dstOffset, srcOffset, t, stride ) {\r\n\r\n\t\tvar s = 1 - t;\r\n\r\n\t\tfor ( var i = 0; i !== stride; ++ i ) {\r\n\r\n\t\t\tvar j = dstOffset + i;\r\n\r\n\t\t\tbuffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/animation/tracks/BooleanKeyframeTrack.js\r\n\r\n/**\r\n *\r\n * A Track of Boolean keyframe values.\r\n *\r\n *\r\n * @author Ben Houston / http://clara.io/\r\n * @author David Sarno / http://lighthaus.us/\r\n * @author tschw\r\n */\r\n\r\nTHREE.BooleanKeyframeTrack = function ( name, times, values ) {\r\n\r\n\tTHREE.KeyframeTrack.call( this, name, times, values );\r\n\r\n};\r\n\r\nTHREE.BooleanKeyframeTrack.prototype =\r\n\t\tObject.assign( Object.create( THREE.KeyframeTrack.prototype ), {\r\n\r\n\tconstructor: THREE.BooleanKeyframeTrack,\r\n\r\n\tValueTypeName: 'bool',\r\n\tValueBufferType: Array,\r\n\r\n\tDefaultInterpolation: THREE.InterpolateDiscrete,\r\n\r\n\tInterpolantFactoryMethodLinear: undefined,\r\n\tInterpolantFactoryMethodSmooth: undefined\r\n\r\n\t// Note: Actually this track could have a optimized / compressed\r\n\t// representation of a single value and a custom interpolant that\r\n\t// computes \"firstValue ^ isOdd( index )\".\r\n\r\n} );\r\n\r\n// File:src/animation/tracks/ColorKeyframeTrack.js\r\n\r\n/**\r\n *\r\n * A Track of keyframe values that represent color.\r\n *\r\n *\r\n * @author Ben Houston / http://clara.io/\r\n * @author David Sarno / http://lighthaus.us/\r\n * @author tschw\r\n */\r\n\r\nTHREE.ColorKeyframeTrack = function ( name, times, values, interpolation ) {\r\n\r\n\tTHREE.KeyframeTrack.call( this, name, times, values, interpolation );\r\n\r\n};\r\n\r\nTHREE.ColorKeyframeTrack.prototype =\r\n\t\tObject.assign( Object.create( THREE.KeyframeTrack.prototype ), {\r\n\r\n\tconstructor: THREE.ColorKeyframeTrack,\r\n\r\n\tValueTypeName: 'color'\r\n\r\n\t// ValueBufferType is inherited\r\n\r\n\t// DefaultInterpolation is inherited\r\n\r\n\r\n\t// Note: Very basic implementation and nothing special yet.\r\n\t// However, this is the place for color space parameterization.\r\n\r\n} );\r\n\r\n// File:src/animation/tracks/NumberKeyframeTrack.js\r\n\r\n/**\r\n *\r\n * A Track of numeric keyframe values.\r\n *\r\n * @author Ben Houston / http://clara.io/\r\n * @author David Sarno / http://lighthaus.us/\r\n * @author tschw\r\n */\r\n\r\nTHREE.NumberKeyframeTrack = function ( name, times, values, interpolation ) {\r\n\r\n\tTHREE.KeyframeTrack.call( this, name, times, values, interpolation );\r\n\r\n};\r\n\r\nTHREE.NumberKeyframeTrack.prototype =\r\n\t\tObject.assign( Object.create( THREE.KeyframeTrack.prototype ), {\r\n\r\n\tconstructor: THREE.NumberKeyframeTrack,\r\n\r\n\tValueTypeName: 'number',\r\n\r\n\t// ValueBufferType is inherited\r\n\r\n\t// DefaultInterpolation is inherited\r\n\r\n} );\r\n\r\n// File:src/animation/tracks/QuaternionKeyframeTrack.js\r\n\r\n/**\r\n *\r\n * A Track of quaternion keyframe values.\r\n *\r\n * @author Ben Houston / http://clara.io/\r\n * @author David Sarno / http://lighthaus.us/\r\n * @author tschw\r\n */\r\n\r\nTHREE.QuaternionKeyframeTrack = function ( name, times, values, interpolation ) {\r\n\r\n\tTHREE.KeyframeTrack.call( this, name, times, values, interpolation );\r\n\r\n};\r\n\r\nTHREE.QuaternionKeyframeTrack.prototype =\r\n\t\tObject.assign( Object.create( THREE.KeyframeTrack.prototype ), {\r\n\r\n\tconstructor: THREE.QuaternionKeyframeTrack,\r\n\r\n\tValueTypeName: 'quaternion',\r\n\r\n\t// ValueBufferType is inherited\r\n\r\n\tDefaultInterpolation: THREE.InterpolateLinear,\r\n\r\n\tInterpolantFactoryMethodLinear: function( result ) {\r\n\r\n\t\treturn new THREE.QuaternionLinearInterpolant(\r\n\t\t\t\tthis.times, this.values, this.getValueSize(), result );\r\n\r\n\t},\r\n\r\n\tInterpolantFactoryMethodSmooth: undefined // not yet implemented\r\n\r\n} );\r\n\r\n// File:src/animation/tracks/StringKeyframeTrack.js\r\n\r\n/**\r\n *\r\n * A Track that interpolates Strings\r\n *\r\n *\r\n * @author Ben Houston / http://clara.io/\r\n * @author David Sarno / http://lighthaus.us/\r\n * @author tschw\r\n */\r\n\r\nTHREE.StringKeyframeTrack = function ( name, times, values, interpolation ) {\r\n\r\n\tTHREE.KeyframeTrack.call( this, name, times, values, interpolation );\r\n\r\n};\r\n\r\nTHREE.StringKeyframeTrack.prototype =\r\n\t\tObject.assign( Object.create( THREE.KeyframeTrack.prototype ), {\r\n\r\n\tconstructor: THREE.StringKeyframeTrack,\r\n\r\n\tValueTypeName: 'string',\r\n\tValueBufferType: Array,\r\n\r\n\tDefaultInterpolation: THREE.InterpolateDiscrete,\r\n\r\n\tInterpolantFactoryMethodLinear: undefined,\r\n\r\n\tInterpolantFactoryMethodSmooth: undefined\r\n\r\n} );\r\n\r\n// File:src/animation/tracks/VectorKeyframeTrack.js\r\n\r\n/**\r\n *\r\n * A Track of vectored keyframe values.\r\n *\r\n *\r\n * @author Ben Houston / http://clara.io/\r\n * @author David Sarno / http://lighthaus.us/\r\n * @author tschw\r\n */\r\n\r\nTHREE.VectorKeyframeTrack = function ( name, times, values, interpolation ) {\r\n\r\n\tTHREE.KeyframeTrack.call( this, name, times, values, interpolation );\r\n\r\n};\r\n\r\nTHREE.VectorKeyframeTrack.prototype =\r\n\t\tObject.assign( Object.create( THREE.KeyframeTrack.prototype ), {\r\n\r\n\tconstructor: THREE.VectorKeyframeTrack,\r\n\r\n\tValueTypeName: 'vector'\r\n\r\n\t// ValueBufferType is inherited\r\n\r\n\t// DefaultInterpolation is inherited\r\n\r\n} );\r\n\r\n// File:src/audio/Audio.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author Reece Aaron Lecrivain / http://reecenotes.com/\r\n */\r\n\r\nTHREE.Audio = function ( listener ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.type = 'Audio';\r\n\r\n\tthis.context = listener.context;\r\n\tthis.source = this.context.createBufferSource();\r\n\tthis.source.onended = this.onEnded.bind( this );\r\n\r\n\tthis.gain = this.context.createGain();\r\n\tthis.gain.connect( listener.getInput() );\r\n\r\n\tthis.autoplay = false;\r\n\r\n\tthis.startTime = 0;\r\n\tthis.playbackRate = 1;\r\n\tthis.isPlaying = false;\r\n\tthis.hasPlaybackControl = true;\r\n\tthis.sourceType = 'empty';\r\n\r\n\tthis.filter = null;\r\n\r\n};\r\n\r\nTHREE.Audio.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.Audio.prototype.constructor = THREE.Audio;\r\n\r\nTHREE.Audio.prototype.getOutput = function () {\r\n\r\n\treturn this.gain;\r\n\r\n};\r\n\r\nTHREE.Audio.prototype.setNodeSource = function ( audioNode ) {\r\n\r\n\tthis.hasPlaybackControl = false;\r\n\tthis.sourceType = 'audioNode';\r\n\tthis.source = audioNode;\r\n\tthis.connect();\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\nTHREE.Audio.prototype.setBuffer = function ( audioBuffer ) {\r\n\r\n\tvar scope = this;\r\n\r\n\tscope.source.buffer = audioBuffer;\r\n\tscope.sourceType = 'buffer';\r\n\tif ( scope.autoplay ) scope.play();\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\nTHREE.Audio.prototype.play = function () {\r\n\r\n\tif ( this.isPlaying === true ) {\r\n\r\n\t\tconsole.warn( 'THREE.Audio: Audio is already playing.' );\r\n\t\treturn;\r\n\r\n\t}\r\n\r\n\tif ( this.hasPlaybackControl === false ) {\r\n\r\n\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\r\n\t\treturn;\r\n\r\n\t}\r\n\r\n\tvar source = this.context.createBufferSource();\r\n\r\n\tsource.buffer = this.source.buffer;\r\n\tsource.loop = this.source.loop;\r\n\tsource.onended = this.source.onended;\r\n\tsource.start( 0, this.startTime );\r\n\tsource.playbackRate.value = this.playbackRate;\r\n\r\n\tthis.isPlaying = true;\r\n\r\n\tthis.source = source;\r\n\r\n\tthis.connect();\r\n\r\n};\r\n\r\nTHREE.Audio.prototype.pause = function () {\r\n\r\n\tif ( this.hasPlaybackControl === false ) {\r\n\r\n\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\r\n\t\treturn;\r\n\r\n\t}\r\n\r\n\tthis.source.stop();\r\n\tthis.startTime = this.context.currentTime;\r\n\r\n};\r\n\r\nTHREE.Audio.prototype.stop = function () {\r\n\r\n\tif ( this.hasPlaybackControl === false ) {\r\n\r\n\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\r\n\t\treturn;\r\n\r\n\t}\r\n\r\n\tthis.source.stop();\r\n\tthis.startTime = 0;\r\n\r\n};\r\n\r\nTHREE.Audio.prototype.connect = function () {\r\n\r\n\tif ( this.filter !== null ) {\r\n\r\n\t\tthis.source.connect( this.filter );\r\n\t\tthis.filter.connect( this.getOutput() );\r\n\r\n\t} else {\r\n\r\n\t\tthis.source.connect( this.getOutput() );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.Audio.prototype.disconnect = function () {\r\n\r\n\tif ( this.filter !== null ) {\r\n\r\n\t\tthis.source.disconnect( this.filter );\r\n\t\tthis.filter.disconnect( this.getOutput() );\r\n\r\n\t} else {\r\n\r\n\t\tthis.source.disconnect( this.getOutput() );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.Audio.prototype.getFilter = function () {\r\n\r\n\treturn this.filter;\r\n\r\n};\r\n\r\nTHREE.Audio.prototype.setFilter = function ( value ) {\r\n\r\n\tif ( value === undefined ) value = null;\r\n\r\n\tif ( this.isPlaying === true ) {\r\n\r\n\t\tthis.disconnect();\r\n\t\tthis.filter = value;\r\n\t\tthis.connect();\r\n\r\n\t} else {\r\n\r\n\t\tthis.filter = value;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.Audio.prototype.setPlaybackRate = function ( value ) {\r\n\r\n\tif ( this.hasPlaybackControl === false ) {\r\n\r\n\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\r\n\t\treturn;\r\n\r\n\t}\r\n\r\n\tthis.playbackRate = value;\r\n\r\n\tif ( this.isPlaying === true ) {\r\n\r\n\t\tthis.source.playbackRate.value = this.playbackRate;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.Audio.prototype.getPlaybackRate = function () {\r\n\r\n\treturn this.playbackRate;\r\n\r\n};\r\n\r\nTHREE.Audio.prototype.onEnded = function () {\r\n\r\n\tthis.isPlaying = false;\r\n\r\n};\r\n\r\nTHREE.Audio.prototype.setLoop = function ( value ) {\r\n\r\n\tif ( this.hasPlaybackControl === false ) {\r\n\r\n\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\r\n\t\treturn;\r\n\r\n\t}\r\n\r\n\tthis.source.loop = value;\r\n\r\n};\r\n\r\nTHREE.Audio.prototype.getLoop = function () {\r\n\r\n\tif ( this.hasPlaybackControl === false ) {\r\n\r\n\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\r\n\t\treturn false;\r\n\r\n\t}\r\n\r\n\treturn this.source.loop;\r\n\r\n};\r\n\r\n\r\nTHREE.Audio.prototype.setVolume = function ( value ) {\r\n\r\n\tthis.gain.gain.value = value;\r\n\r\n};\r\n\r\nTHREE.Audio.prototype.getVolume = function () {\r\n\r\n\treturn this.gain.gain.value;\r\n\r\n};\r\n\r\n// File:src/audio/AudioAnalyser.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.AudioAnalyser = function ( audio, fftSize ) {\r\n\r\n\tthis.analyser = audio.context.createAnalyser();\r\n\tthis.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;\r\n\r\n\tthis.data = new Uint8Array( this.analyser.frequencyBinCount );\r\n\r\n\taudio.getOutput().connect( this.analyser );\r\n\r\n};\r\n\r\nTHREE.AudioAnalyser.prototype = {\r\n\r\n\tconstructor: THREE.AudioAnalyser,\r\n\r\n\tgetData: function () {\r\n\r\n\t\tthis.analyser.getByteFrequencyData( this.data );\r\n\t\treturn this.data;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/audio/AudioContext.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nObject.defineProperty( THREE, 'AudioContext', {\r\n\r\n\tget: ( function () {\r\n\r\n\t\tvar context;\r\n\r\n\t\treturn function () {\r\n\r\n\t\t\tif ( context === undefined ) {\r\n\r\n\t\t\t\tcontext = new ( window.AudioContext || window.webkitAudioContext )();\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn context;\r\n\r\n\t\t};\r\n\r\n\t} )()\r\n\r\n} );\r\n\r\n// File:src/audio/PositionalAudio.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.PositionalAudio = function ( listener ) {\r\n\r\n\tTHREE.Audio.call( this, listener );\r\n\r\n\tthis.panner = this.context.createPanner();\r\n\tthis.panner.connect( this.gain );\r\n\r\n};\r\n\r\nTHREE.PositionalAudio.prototype = Object.create( THREE.Audio.prototype );\r\nTHREE.PositionalAudio.prototype.constructor = THREE.PositionalAudio;\r\n\r\nTHREE.PositionalAudio.prototype.getOutput = function () {\r\n\r\n\treturn this.panner;\r\n\r\n};\r\n\r\nTHREE.PositionalAudio.prototype.setRefDistance = function ( value ) {\r\n\r\n\tthis.panner.refDistance = value;\r\n\r\n};\r\n\r\nTHREE.PositionalAudio.prototype.getRefDistance = function () {\r\n\r\n\treturn this.panner.refDistance;\r\n\r\n};\r\n\r\nTHREE.PositionalAudio.prototype.setRolloffFactor = function ( value ) {\r\n\r\n\tthis.panner.rolloffFactor = value;\r\n\r\n};\r\n\r\nTHREE.PositionalAudio.prototype.getRolloffFactor = function () {\r\n\r\n\treturn this.panner.rolloffFactor;\r\n\r\n};\r\n\r\nTHREE.PositionalAudio.prototype.setDistanceModel = function ( value ) {\r\n\r\n\tthis.panner.distanceModel = value;\r\n\r\n};\r\n\r\nTHREE.PositionalAudio.prototype.getDistanceModel = function () {\r\n\r\n\treturn this.panner.distanceModel;\r\n\r\n};\r\n\r\nTHREE.PositionalAudio.prototype.setMaxDistance = function ( value ) {\r\n\r\n\tthis.panner.maxDistance = value;\r\n\r\n};\r\n\r\nTHREE.PositionalAudio.prototype.getMaxDistance = function () {\r\n\r\n\treturn this.panner.maxDistance;\r\n\r\n};\r\n\r\nTHREE.PositionalAudio.prototype.updateMatrixWorld = ( function () {\r\n\r\n\tvar position = new THREE.Vector3();\r\n\r\n\treturn function updateMatrixWorld( force ) {\r\n\r\n\t\tTHREE.Object3D.prototype.updateMatrixWorld.call( this, force );\r\n\r\n\t\tposition.setFromMatrixPosition( this.matrixWorld );\r\n\r\n\t\tthis.panner.setPosition( position.x, position.y, position.z );\r\n\r\n\t};\r\n\r\n} )();\r\n\r\n// File:src/audio/AudioListener.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.AudioListener = function () {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.type = 'AudioListener';\r\n\r\n\tthis.context = THREE.AudioContext;\r\n\r\n\tthis.gain = this.context.createGain();\r\n\tthis.gain.connect( this.context.destination );\r\n\r\n\tthis.filter = null;\r\n\r\n};\r\n\r\nTHREE.AudioListener.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.AudioListener.prototype.constructor = THREE.AudioListener;\r\n\r\nTHREE.AudioListener.prototype.getInput = function () {\r\n\r\n\treturn this.gain;\r\n\r\n};\r\n\r\nTHREE.AudioListener.prototype.removeFilter = function ( ) {\r\n\r\n\tif ( this.filter !== null ) {\r\n\r\n\t\tthis.gain.disconnect( this.filter );\r\n\t\tthis.filter.disconnect( this.context.destination );\r\n\t\tthis.gain.connect( this.context.destination );\r\n\t\tthis.filter = null;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.AudioListener.prototype.setFilter = function ( value ) {\r\n\r\n\tif ( this.filter !== null ) {\r\n\r\n\t\tthis.gain.disconnect( this.filter );\r\n\t\tthis.filter.disconnect( this.context.destination );\r\n\r\n\t} else {\r\n\r\n\t\tthis.gain.disconnect( this.context.destination );\r\n\r\n\t}\r\n\r\n\tthis.filter = value;\r\n\tthis.gain.connect( this.filter );\r\n\tthis.filter.connect( this.context.destination );\r\n\r\n};\r\n\r\nTHREE.AudioListener.prototype.getFilter = function () {\r\n\r\n\treturn this.filter;\r\n\r\n};\r\n\r\nTHREE.AudioListener.prototype.setMasterVolume = function ( value ) {\r\n\r\n\tthis.gain.gain.value = value;\r\n\r\n};\r\n\r\nTHREE.AudioListener.prototype.getMasterVolume = function () {\r\n\r\n\treturn this.gain.gain.value;\r\n\r\n};\r\n\r\n\r\nTHREE.AudioListener.prototype.updateMatrixWorld = ( function () {\r\n\r\n\tvar position = new THREE.Vector3();\r\n\tvar quaternion = new THREE.Quaternion();\r\n\tvar scale = new THREE.Vector3();\r\n\r\n\tvar orientation = new THREE.Vector3();\r\n\r\n\treturn function updateMatrixWorld( force ) {\r\n\r\n\t\tTHREE.Object3D.prototype.updateMatrixWorld.call( this, force );\r\n\r\n\t\tvar listener = this.context.listener;\r\n\t\tvar up = this.up;\r\n\r\n\t\tthis.matrixWorld.decompose( position, quaternion, scale );\r\n\r\n\t\torientation.set( 0, 0, - 1 ).applyQuaternion( quaternion );\r\n\r\n\t\tlistener.setPosition( position.x, position.y, position.z );\r\n\t\tlistener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );\r\n\r\n\t};\r\n\r\n} )();\r\n\r\n// File:src/cameras/Camera.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author WestLangley / http://github.com/WestLangley\r\n*/\r\n\r\nTHREE.Camera = function () {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.type = 'Camera';\r\n\r\n\tthis.matrixWorldInverse = new THREE.Matrix4();\r\n\tthis.projectionMatrix = new THREE.Matrix4();\r\n\r\n};\r\n\r\nTHREE.Camera.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.Camera.prototype.constructor = THREE.Camera;\r\n\r\nTHREE.Camera.prototype.getWorldDirection = function () {\r\n\r\n\tvar quaternion = new THREE.Quaternion();\r\n\r\n\treturn function ( optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\r\n\t\tthis.getWorldQuaternion( quaternion );\r\n\r\n\t\treturn result.set( 0, 0, - 1 ).applyQuaternion( quaternion );\r\n\r\n\t};\r\n\r\n}();\r\n\r\nTHREE.Camera.prototype.lookAt = function () {\r\n\r\n\t// This routine does not support cameras with rotated and/or translated parent(s)\r\n\r\n\tvar m1 = new THREE.Matrix4();\r\n\r\n\treturn function ( vector ) {\r\n\r\n\t\tm1.lookAt( this.position, vector, this.up );\r\n\r\n\t\tthis.quaternion.setFromRotationMatrix( m1 );\r\n\r\n\t};\r\n\r\n}();\r\n\r\nTHREE.Camera.prototype.clone = function () {\r\n\r\n\treturn new this.constructor().copy( this );\r\n\r\n};\r\n\r\nTHREE.Camera.prototype.copy = function ( source ) {\r\n\r\n\tTHREE.Object3D.prototype.copy.call( this, source );\r\n\r\n\tthis.matrixWorldInverse.copy( source.matrixWorldInverse );\r\n\tthis.projectionMatrix.copy( source.projectionMatrix );\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\n// File:src/cameras/CubeCamera.js\r\n\r\n/**\r\n * Camera for rendering cube maps\r\n *\t- renders scene into axis-aligned cube\r\n *\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.CubeCamera = function ( near, far, cubeResolution ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.type = 'CubeCamera';\r\n\r\n\tvar fov = 90, aspect = 1;\r\n\r\n\tvar cameraPX = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n\tcameraPX.up.set( 0, - 1, 0 );\r\n\tcameraPX.lookAt( new THREE.Vector3( 1, 0, 0 ) );\r\n\tthis.add( cameraPX );\r\n\r\n\tvar cameraNX = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n\tcameraNX.up.set( 0, - 1, 0 );\r\n\tcameraNX.lookAt( new THREE.Vector3( - 1, 0, 0 ) );\r\n\tthis.add( cameraNX );\r\n\r\n\tvar cameraPY = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n\tcameraPY.up.set( 0, 0, 1 );\r\n\tcameraPY.lookAt( new THREE.Vector3( 0, 1, 0 ) );\r\n\tthis.add( cameraPY );\r\n\r\n\tvar cameraNY = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n\tcameraNY.up.set( 0, 0, - 1 );\r\n\tcameraNY.lookAt( new THREE.Vector3( 0, - 1, 0 ) );\r\n\tthis.add( cameraNY );\r\n\r\n\tvar cameraPZ = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n\tcameraPZ.up.set( 0, - 1, 0 );\r\n\tcameraPZ.lookAt( new THREE.Vector3( 0, 0, 1 ) );\r\n\tthis.add( cameraPZ );\r\n\r\n\tvar cameraNZ = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n\tcameraNZ.up.set( 0, - 1, 0 );\r\n\tcameraNZ.lookAt( new THREE.Vector3( 0, 0, - 1 ) );\r\n\tthis.add( cameraNZ );\r\n\r\n\tvar options = { format: THREE.RGBFormat, magFilter: THREE.LinearFilter, minFilter: THREE.LinearFilter };\r\n\r\n\tthis.renderTarget = new THREE.WebGLRenderTargetCube( cubeResolution, cubeResolution, options );\r\n\r\n\tthis.updateCubeMap = function ( renderer, scene ) {\r\n\r\n\t\tif ( this.parent === null ) this.updateMatrixWorld();\r\n\r\n\t\tvar renderTarget = this.renderTarget;\r\n\t\tvar generateMipmaps = renderTarget.texture.generateMipmaps;\r\n\r\n\t\trenderTarget.texture.generateMipmaps = false;\r\n\r\n\t\trenderTarget.activeCubeFace = 0;\r\n\t\trenderer.render( scene, cameraPX, renderTarget );\r\n\r\n\t\trenderTarget.activeCubeFace = 1;\r\n\t\trenderer.render( scene, cameraNX, renderTarget );\r\n\r\n\t\trenderTarget.activeCubeFace = 2;\r\n\t\trenderer.render( scene, cameraPY, renderTarget );\r\n\r\n\t\trenderTarget.activeCubeFace = 3;\r\n\t\trenderer.render( scene, cameraNY, renderTarget );\r\n\r\n\t\trenderTarget.activeCubeFace = 4;\r\n\t\trenderer.render( scene, cameraPZ, renderTarget );\r\n\r\n\t\trenderTarget.texture.generateMipmaps = generateMipmaps;\r\n\r\n\t\trenderTarget.activeCubeFace = 5;\r\n\t\trenderer.render( scene, cameraNZ, renderTarget );\r\n\r\n\t\trenderer.setRenderTarget( null );\r\n\r\n\t};\r\n\r\n};\r\n\r\nTHREE.CubeCamera.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.CubeCamera.prototype.constructor = THREE.CubeCamera;\r\n\r\n// File:src/cameras/OrthographicCamera.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.OrthographicCamera = function ( left, right, top, bottom, near, far ) {\r\n\r\n\tTHREE.Camera.call( this );\r\n\r\n\tthis.type = 'OrthographicCamera';\r\n\r\n\tthis.zoom = 1;\r\n\r\n\tthis.left = left;\r\n\tthis.right = right;\r\n\tthis.top = top;\r\n\tthis.bottom = bottom;\r\n\r\n\tthis.near = ( near !== undefined ) ? near : 0.1;\r\n\tthis.far = ( far !== undefined ) ? far : 2000;\r\n\r\n\tthis.updateProjectionMatrix();\r\n\r\n};\r\n\r\nTHREE.OrthographicCamera.prototype = Object.create( THREE.Camera.prototype );\r\nTHREE.OrthographicCamera.prototype.constructor = THREE.OrthographicCamera;\r\n\r\nTHREE.OrthographicCamera.prototype.updateProjectionMatrix = function () {\r\n\r\n\tvar dx = ( this.right - this.left ) / ( 2 * this.zoom );\r\n\tvar dy = ( this.top - this.bottom ) / ( 2 * this.zoom );\r\n\tvar cx = ( this.right + this.left ) / 2;\r\n\tvar cy = ( this.top + this.bottom ) / 2;\r\n\r\n\tthis.projectionMatrix.makeOrthographic( cx - dx, cx + dx, cy + dy, cy - dy, this.near, this.far );\r\n\r\n};\r\n\r\nTHREE.OrthographicCamera.prototype.copy = function ( source ) {\r\n\r\n\tTHREE.Camera.prototype.copy.call( this, source );\r\n\r\n\tthis.left = source.left;\r\n\tthis.right = source.right;\r\n\tthis.top = source.top;\r\n\tthis.bottom = source.bottom;\r\n\tthis.near = source.near;\r\n\tthis.far = source.far;\r\n\r\n\tthis.zoom = source.zoom;\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\nTHREE.OrthographicCamera.prototype.toJSON = function ( meta ) {\r\n\r\n\tvar data = THREE.Object3D.prototype.toJSON.call( this, meta );\r\n\r\n\tdata.object.zoom = this.zoom;\r\n\tdata.object.left = this.left;\r\n\tdata.object.right = this.right;\r\n\tdata.object.top = this.top;\r\n\tdata.object.bottom = this.bottom;\r\n\tdata.object.near = this.near;\r\n\tdata.object.far = this.far;\r\n\r\n\treturn data;\r\n\r\n};\r\n\r\n// File:src/cameras/PerspectiveCamera.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author greggman / http://games.greggman.com/\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * @author tschw\r\n */\r\n\r\nTHREE.PerspectiveCamera = function( fov, aspect, near, far ) {\r\n\r\n\tTHREE.Camera.call( this );\r\n\r\n\tthis.type = 'PerspectiveCamera';\r\n\r\n\tthis.fov = fov !== undefined ? fov : 50;\r\n\tthis.zoom = 1;\r\n\r\n\tthis.near = near !== undefined ? near : 0.1;\r\n\tthis.far = far !== undefined ? far : 2000;\r\n\tthis.focus = 10;\r\n\r\n\tthis.aspect = aspect !== undefined ? aspect : 1;\r\n\tthis.view = null;\r\n\r\n\tthis.filmGauge = 35;\t// width of the film (default in millimeters)\r\n\tthis.filmOffset = 0;\t// horizontal film offset (same unit as gauge)\r\n\r\n\tthis.updateProjectionMatrix();\r\n\r\n};\r\n\r\nTHREE.PerspectiveCamera.prototype = Object.create( THREE.Camera.prototype );\r\nTHREE.PerspectiveCamera.prototype.constructor = THREE.PerspectiveCamera;\r\n\r\n\r\n/**\r\n * Sets the FOV by focal length (DEPRECATED).\r\n *\r\n * Optionally also sets .filmGauge, otherwise uses it. See .setFocalLength.\r\n */\r\nTHREE.PerspectiveCamera.prototype.setLens = function( focalLength, filmGauge ) {\r\n\r\n\tconsole.warn( \"THREE.PerspectiveCamera.setLens is deprecated. \" +\r\n\t\t\t\"Use .setFocalLength and .filmGauge for a photographic setup.\" );\r\n\r\n\tif ( filmGauge !== undefined ) this.filmGauge = filmGauge;\r\n\tthis.setFocalLength( focalLength );\r\n\r\n};\r\n\r\n/**\r\n * Sets the FOV by focal length in respect to the current .filmGauge.\r\n *\r\n * The default film gauge is 35, so that the focal length can be specified for\r\n * a 35mm (full frame) camera.\r\n *\r\n * Values for focal length and film gauge must have the same unit.\r\n */\r\nTHREE.PerspectiveCamera.prototype.setFocalLength = function( focalLength ) {\r\n\r\n\t// see http://www.bobatkins.com/photography/technical/field_of_view.html\r\n\tvar vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;\r\n\r\n\tthis.fov = THREE.Math.RAD2DEG * 2 * Math.atan( vExtentSlope );\r\n\tthis.updateProjectionMatrix();\r\n\r\n};\r\n\r\n\r\n/**\r\n * Calculates the focal length from the current .fov and .filmGauge.\r\n */\r\nTHREE.PerspectiveCamera.prototype.getFocalLength = function() {\r\n\r\n\tvar vExtentSlope = Math.tan( THREE.Math.DEG2RAD * 0.5 * this.fov );\r\n\r\n\treturn 0.5 * this.getFilmHeight() / vExtentSlope;\r\n\r\n};\r\n\r\nTHREE.PerspectiveCamera.prototype.getEffectiveFOV = function() {\r\n\r\n\treturn THREE.Math.RAD2DEG * 2 * Math.atan(\r\n\t\t\tMath.tan( THREE.Math.DEG2RAD * 0.5 * this.fov ) / this.zoom );\r\n\r\n};\r\n\r\nTHREE.PerspectiveCamera.prototype.getFilmWidth = function() {\r\n\r\n\t// film not completely covered in portrait format (aspect < 1)\r\n\treturn this.filmGauge * Math.min( this.aspect, 1 );\r\n\r\n};\r\n\r\nTHREE.PerspectiveCamera.prototype.getFilmHeight = function() {\r\n\r\n\t// film not completely covered in landscape format (aspect > 1)\r\n\treturn this.filmGauge / Math.max( this.aspect, 1 );\r\n\r\n};\r\n\r\n\r\n\r\n/**\r\n * Sets an offset in a larger frustum. This is useful for multi-window or\r\n * multi-monitor/multi-machine setups.\r\n *\r\n * For example, if you have 3x2 monitors and each monitor is 1920x1080 and\r\n * the monitors are in grid like this\r\n *\r\n *   +---+---+---+\r\n *   | A | B | C |\r\n *   +---+---+---+\r\n *   | D | E | F |\r\n *   +---+---+---+\r\n *\r\n * then for each monitor you would call it like this\r\n *\r\n *   var w = 1920;\r\n *   var h = 1080;\r\n *   var fullWidth = w * 3;\r\n *   var fullHeight = h * 2;\r\n *\r\n *   --A--\r\n *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );\r\n *   --B--\r\n *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );\r\n *   --C--\r\n *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );\r\n *   --D--\r\n *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );\r\n *   --E--\r\n *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );\r\n *   --F--\r\n *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );\r\n *\r\n *   Note there is no reason monitors have to be the same size or in a grid.\r\n */\r\nTHREE.PerspectiveCamera.prototype.setViewOffset = function( fullWidth, fullHeight, x, y, width, height ) {\r\n\r\n\tthis.aspect = fullWidth / fullHeight;\r\n\r\n\tthis.view = {\r\n\t\tfullWidth: fullWidth,\r\n\t\tfullHeight: fullHeight,\r\n\t\toffsetX: x,\r\n\t\toffsetY: y,\r\n\t\twidth: width,\r\n\t\theight: height\r\n\t};\r\n\r\n\tthis.updateProjectionMatrix();\r\n\r\n};\r\n\r\nTHREE.PerspectiveCamera.prototype.updateProjectionMatrix = function() {\r\n\r\n\tvar near = this.near,\r\n\t\ttop = near * Math.tan(\r\n\t\t\t\tTHREE.Math.DEG2RAD * 0.5 * this.fov ) / this.zoom,\r\n\t\theight = 2 * top,\r\n\t\twidth = this.aspect * height,\r\n\t\tleft = - 0.5 * width,\r\n\t\tview = this.view;\r\n\r\n\tif ( view !== null ) {\r\n\r\n\t\tvar fullWidth = view.fullWidth,\r\n\t\t\tfullHeight = view.fullHeight;\r\n\r\n\t\tleft += view.offsetX * width / fullWidth;\r\n\t\ttop -= view.offsetY * height / fullHeight;\r\n\t\twidth *= view.width / fullWidth;\r\n\t\theight *= view.height / fullHeight;\r\n\r\n\t}\r\n\r\n\tvar skew = this.filmOffset;\r\n\tif ( skew !== 0 ) left += near * skew / this.getFilmWidth();\r\n\r\n\tthis.projectionMatrix.makeFrustum(\r\n\t\t\tleft, left + width, top - height, top, near, this.far );\r\n\r\n};\r\n\r\nTHREE.PerspectiveCamera.prototype.copy = function( source ) {\r\n\r\n\tTHREE.Camera.prototype.copy.call( this, source );\r\n\r\n\tthis.fov = source.fov;\r\n\tthis.zoom = source.zoom;\r\n\r\n\tthis.near = source.near;\r\n\tthis.far = source.far;\r\n\tthis.focus = source.focus;\r\n\r\n\tthis.aspect = source.aspect;\r\n\tthis.view = source.view === null ? null : Object.assign( {}, source.view );\r\n\r\n\tthis.filmGauge = source.filmGauge;\r\n\tthis.filmOffset = source.filmOffset;\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\nTHREE.PerspectiveCamera.prototype.toJSON = function( meta ) {\r\n\r\n\tvar data = THREE.Object3D.prototype.toJSON.call( this, meta );\r\n\r\n\tdata.object.fov = this.fov;\r\n\tdata.object.zoom = this.zoom;\r\n\r\n\tdata.object.near = this.near;\r\n\tdata.object.far = this.far;\r\n\tdata.object.focus = this.focus;\r\n\r\n\tdata.object.aspect = this.aspect;\r\n\r\n\tif ( this.view !== null ) data.object.view = Object.assign( {}, this.view );\r\n\r\n\tdata.object.filmGauge = this.filmGauge;\r\n\tdata.object.filmOffset = this.filmOffset;\r\n\r\n\treturn data;\r\n\r\n};\r\n\r\n// File:src/cameras/StereoCamera.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.StereoCamera = function () {\r\n\r\n\tthis.type = 'StereoCamera';\r\n\r\n\tthis.aspect = 1;\r\n\r\n\tthis.cameraL = new THREE.PerspectiveCamera();\r\n\tthis.cameraL.layers.enable( 1 );\r\n\tthis.cameraL.matrixAutoUpdate = false;\r\n\r\n\tthis.cameraR = new THREE.PerspectiveCamera();\r\n\tthis.cameraR.layers.enable( 2 );\r\n\tthis.cameraR.matrixAutoUpdate = false;\r\n\r\n};\r\n\r\nTHREE.StereoCamera.prototype = {\r\n\r\n\tconstructor: THREE.StereoCamera,\r\n\r\n\tupdate: ( function () {\r\n\r\n\t\tvar focus, fov, aspect, near, far;\r\n\r\n\t\tvar eyeRight = new THREE.Matrix4();\r\n\t\tvar eyeLeft = new THREE.Matrix4();\r\n\r\n\t\treturn function update ( camera ) {\r\n\r\n\t\t\tvar needsUpdate = focus !== camera.focus || fov !== camera.fov ||\r\n\t\t\t\t\t\t\t\t\t\t\t\taspect !== camera.aspect * this.aspect || near !== camera.near ||\r\n\t\t\t\t\t\t\t\t\t\t\t\tfar !== camera.far;\r\n\r\n\t\t\tif ( needsUpdate ) {\r\n\r\n\t\t\t\tfocus = camera.focus;\r\n\t\t\t\tfov = camera.fov;\r\n\t\t\t\taspect = camera.aspect * this.aspect;\r\n\t\t\t\tnear = camera.near;\r\n\t\t\t\tfar = camera.far;\r\n\r\n\t\t\t\t// Off-axis stereoscopic effect based on\r\n\t\t\t\t// http://paulbourke.net/stereographics/stereorender/\r\n\r\n\t\t\t\tvar projectionMatrix = camera.projectionMatrix.clone();\r\n\t\t\t\tvar eyeSep = 0.064 / 2;\r\n\t\t\t\tvar eyeSepOnProjection = eyeSep * near / focus;\r\n\t\t\t\tvar ymax = near * Math.tan( THREE.Math.DEG2RAD * fov * 0.5 );\r\n\t\t\t\tvar xmin, xmax;\r\n\r\n\t\t\t\t// translate xOffset\r\n\r\n\t\t\t\teyeLeft.elements[ 12 ] = - eyeSep;\r\n\t\t\t\teyeRight.elements[ 12 ] = eyeSep;\r\n\r\n\t\t\t\t// for left eye\r\n\r\n\t\t\t\txmin = - ymax * aspect + eyeSepOnProjection;\r\n\t\t\t\txmax = ymax * aspect + eyeSepOnProjection;\r\n\r\n\t\t\t\tprojectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );\r\n\t\t\t\tprojectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );\r\n\r\n\t\t\t\tthis.cameraL.projectionMatrix.copy( projectionMatrix );\r\n\r\n\t\t\t\t// for right eye\r\n\r\n\t\t\t\txmin = - ymax * aspect - eyeSepOnProjection;\r\n\t\t\t\txmax = ymax * aspect - eyeSepOnProjection;\r\n\r\n\t\t\t\tprojectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );\r\n\t\t\t\tprojectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );\r\n\r\n\t\t\t\tthis.cameraR.projectionMatrix.copy( projectionMatrix );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( eyeLeft );\r\n\t\t\tthis.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( eyeRight );\r\n\r\n\t\t};\r\n\r\n\t} )()\r\n\r\n};\r\n\r\n// File:src/lights/Light.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Light = function ( color, intensity ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.type = 'Light';\r\n\r\n\tthis.color = new THREE.Color( color );\r\n\tthis.intensity = intensity !== undefined ? intensity : 1;\r\n\r\n\tthis.receiveShadow = undefined;\r\n\r\n};\r\n\r\nTHREE.Light.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.Light.prototype.constructor = THREE.Light;\r\n\r\nTHREE.Light.prototype.copy = function ( source ) {\r\n\r\n\tTHREE.Object3D.prototype.copy.call( this, source );\r\n\r\n\tthis.color.copy( source.color );\r\n\tthis.intensity = source.intensity;\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\nTHREE.Light.prototype.toJSON = function ( meta ) {\r\n\r\n\tvar data = THREE.Object3D.prototype.toJSON.call( this, meta );\r\n\r\n\tdata.object.color = this.color.getHex();\r\n\tdata.object.intensity = this.intensity;\r\n\r\n\tif ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();\r\n\r\n\tif ( this.distance !== undefined ) data.object.distance = this.distance;\r\n\tif ( this.angle !== undefined ) data.object.angle = this.angle;\r\n\tif ( this.decay !== undefined ) data.object.decay = this.decay;\r\n\tif ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;\r\n\r\n\treturn data;\r\n\r\n};\r\n\r\n// File:src/lights/LightShadow.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.LightShadow = function ( camera ) {\r\n\r\n\tthis.camera = camera;\r\n\r\n\tthis.bias = 0;\r\n\tthis.radius = 1;\r\n\r\n\tthis.mapSize = new THREE.Vector2( 512, 512 );\r\n\r\n\tthis.map = null;\r\n\tthis.matrix = new THREE.Matrix4();\r\n\r\n};\r\n\r\nTHREE.LightShadow.prototype = {\r\n\r\n\tconstructor: THREE.LightShadow,\r\n\r\n\tcopy: function ( source ) {\r\n\r\n\t\tthis.camera = source.camera.clone();\r\n\r\n\t\tthis.bias = source.bias;\r\n\t\tthis.radius = source.radius;\r\n\r\n\t\tthis.mapSize.copy( source.mapSize );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/lights/AmbientLight.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.AmbientLight = function ( color, intensity ) {\r\n\r\n\tTHREE.Light.call( this, color, intensity );\r\n\r\n\tthis.type = 'AmbientLight';\r\n\r\n\tthis.castShadow = undefined;\r\n\r\n};\r\n\r\nTHREE.AmbientLight.prototype = Object.create( THREE.Light.prototype );\r\nTHREE.AmbientLight.prototype.constructor = THREE.AmbientLight;\r\n\r\n// File:src/lights/DirectionalLight.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.DirectionalLight = function ( color, intensity ) {\r\n\r\n\tTHREE.Light.call( this, color, intensity );\r\n\r\n\tthis.type = 'DirectionalLight';\r\n\r\n\tthis.position.set( 0, 1, 0 );\r\n\tthis.updateMatrix();\r\n\r\n\tthis.target = new THREE.Object3D();\r\n\r\n\tthis.shadow = new THREE.DirectionalLightShadow();\r\n\r\n};\r\n\r\nTHREE.DirectionalLight.prototype = Object.create( THREE.Light.prototype );\r\nTHREE.DirectionalLight.prototype.constructor = THREE.DirectionalLight;\r\n\r\nTHREE.DirectionalLight.prototype.copy = function ( source ) {\r\n\r\n\tTHREE.Light.prototype.copy.call( this, source );\r\n\r\n\tthis.target = source.target.clone();\r\n\r\n\tthis.shadow = source.shadow.clone();\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\n// File:src/lights/DirectionalLightShadow.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.DirectionalLightShadow = function ( light ) {\r\n\r\n\tTHREE.LightShadow.call( this, new THREE.OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );\r\n\r\n};\r\n\r\nTHREE.DirectionalLightShadow.prototype = Object.create( THREE.LightShadow.prototype );\r\nTHREE.DirectionalLightShadow.prototype.constructor = THREE.DirectionalLightShadow;\r\n\r\n// File:src/lights/HemisphereLight.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.HemisphereLight = function ( skyColor, groundColor, intensity ) {\r\n\r\n\tTHREE.Light.call( this, skyColor, intensity );\r\n\r\n\tthis.type = 'HemisphereLight';\r\n\r\n\tthis.castShadow = undefined;\r\n\r\n\tthis.position.set( 0, 1, 0 );\r\n\tthis.updateMatrix();\r\n\r\n\tthis.groundColor = new THREE.Color( groundColor );\r\n\r\n};\r\n\r\nTHREE.HemisphereLight.prototype = Object.create( THREE.Light.prototype );\r\nTHREE.HemisphereLight.prototype.constructor = THREE.HemisphereLight;\r\n\r\nTHREE.HemisphereLight.prototype.copy = function ( source ) {\r\n\r\n\tTHREE.Light.prototype.copy.call( this, source );\r\n\r\n\tthis.groundColor.copy( source.groundColor );\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\n// File:src/lights/PointLight.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\n\r\nTHREE.PointLight = function ( color, intensity, distance, decay ) {\r\n\r\n\tTHREE.Light.call( this, color, intensity );\r\n\r\n\tthis.type = 'PointLight';\r\n\r\n\tthis.distance = ( distance !== undefined ) ? distance : 0;\r\n\tthis.decay = ( decay !== undefined ) ? decay : 1;\t// for physically correct lights, should be 2.\r\n\r\n\tthis.shadow = new THREE.LightShadow( new THREE.PerspectiveCamera( 90, 1, 0.5, 500 ) );\r\n\r\n};\r\n\r\nTHREE.PointLight.prototype = Object.create( THREE.Light.prototype );\r\nTHREE.PointLight.prototype.constructor = THREE.PointLight;\r\n\r\nObject.defineProperty( THREE.PointLight.prototype, \"power\", {\r\n\r\n\tget: function () {\r\n\r\n\t\t// intensity = power per solid angle.\r\n\t\t// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\r\n\t\treturn this.intensity * 4 * Math.PI;\r\n\r\n\t},\r\n\r\n\tset: function ( power ) {\r\n\r\n\t\t// intensity = power per solid angle.\r\n\t\t// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\r\n\t\tthis.intensity = power / ( 4 * Math.PI );\r\n\r\n\t}\r\n\r\n} );\r\n\r\nTHREE.PointLight.prototype.copy = function ( source ) {\r\n\r\n\tTHREE.Light.prototype.copy.call( this, source );\r\n\r\n\tthis.distance = source.distance;\r\n\tthis.decay = source.decay;\r\n\r\n\tthis.shadow = source.shadow.clone();\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\n// File:src/lights/SpotLight.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.SpotLight = function ( color, intensity, distance, angle, penumbra, decay ) {\r\n\r\n\tTHREE.Light.call( this, color, intensity );\r\n\r\n\tthis.type = 'SpotLight';\r\n\r\n\tthis.position.set( 0, 1, 0 );\r\n\tthis.updateMatrix();\r\n\r\n\tthis.target = new THREE.Object3D();\r\n\r\n\tthis.distance = ( distance !== undefined ) ? distance : 0;\r\n\tthis.angle = ( angle !== undefined ) ? angle : Math.PI / 3;\r\n\tthis.penumbra = ( penumbra !== undefined ) ? penumbra : 0;\r\n\tthis.decay = ( decay !== undefined ) ? decay : 1;\t// for physically correct lights, should be 2.\r\n\r\n\tthis.shadow = new THREE.SpotLightShadow();\r\n\r\n};\r\n\r\nTHREE.SpotLight.prototype = Object.create( THREE.Light.prototype );\r\nTHREE.SpotLight.prototype.constructor = THREE.SpotLight;\r\n\r\nObject.defineProperty( THREE.SpotLight.prototype, \"power\", {\r\n\r\n\tget: function () {\r\n\r\n\t\t// intensity = power per solid angle.\r\n\t\t// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\r\n\t\treturn this.intensity * Math.PI;\r\n\r\n\t},\r\n\r\n\tset: function ( power ) {\r\n\r\n\t\t// intensity = power per solid angle.\r\n\t\t// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\r\n\t\tthis.intensity = power / Math.PI;\r\n\r\n\t}\r\n\r\n} );\r\n\r\nTHREE.SpotLight.prototype.copy = function ( source ) {\r\n\r\n\tTHREE.Light.prototype.copy.call( this, source );\r\n\r\n\tthis.distance = source.distance;\r\n\tthis.angle = source.angle;\r\n\tthis.penumbra = source.penumbra;\r\n\tthis.decay = source.decay;\r\n\r\n\tthis.target = source.target.clone();\r\n\r\n\tthis.shadow = source.shadow.clone();\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\n// File:src/lights/SpotLightShadow.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.SpotLightShadow = function () {\r\n\r\n\tTHREE.LightShadow.call( this, new THREE.PerspectiveCamera( 50, 1, 0.5, 500 ) );\r\n\r\n};\r\n\r\nTHREE.SpotLightShadow.prototype = Object.create( THREE.LightShadow.prototype );\r\nTHREE.SpotLightShadow.prototype.constructor = THREE.SpotLightShadow;\r\n\r\nTHREE.SpotLightShadow.prototype.update = function ( light ) {\r\n\r\n\tvar fov = THREE.Math.RAD2DEG * 2 * light.angle;\r\n\tvar aspect = this.mapSize.width / this.mapSize.height;\r\n\tvar far = light.distance || 500;\r\n\r\n\tvar camera = this.camera;\r\n\r\n\tif ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {\r\n\r\n\t\tcamera.fov = fov;\r\n\t\tcamera.aspect = aspect;\r\n\t\tcamera.far = far;\r\n\t\tcamera.updateProjectionMatrix();\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/loaders/AudioLoader.js\r\n\r\n/**\r\n * @author Reece Aaron Lecrivain / http://reecenotes.com/\r\n */\r\n\r\nTHREE.AudioLoader = function ( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\r\n};\r\n\r\nTHREE.AudioLoader.prototype = {\r\n\r\n\tconstructor: THREE.AudioLoader,\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar loader = new THREE.XHRLoader( this.manager );\r\n\t\tloader.setResponseType( 'arraybuffer' );\r\n\t\tloader.load( url, function ( buffer ) {\r\n\r\n\t\t\tvar context = THREE.AudioContext;\r\n\r\n\t\t\tcontext.decodeAudioData( buffer, function ( audioBuffer ) {\r\n\r\n\t\t\t\tonLoad( audioBuffer );\r\n\r\n\t\t\t} );\r\n\r\n\t\t}, onProgress, onError );\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/loaders/Cache.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Cache = {\r\n\r\n\tenabled: false,\r\n\r\n\tfiles: {},\r\n\r\n\tadd: function ( key, file ) {\r\n\r\n\t\tif ( this.enabled === false ) return;\r\n\r\n\t\t// console.log( 'THREE.Cache', 'Adding key:', key );\r\n\r\n\t\tthis.files[ key ] = file;\r\n\r\n\t},\r\n\r\n\tget: function ( key ) {\r\n\r\n\t\tif ( this.enabled === false ) return;\r\n\r\n\t\t// console.log( 'THREE.Cache', 'Checking key:', key );\r\n\r\n\t\treturn this.files[ key ];\r\n\r\n\t},\r\n\r\n\tremove: function ( key ) {\r\n\r\n\t\tdelete this.files[ key ];\r\n\r\n\t},\r\n\r\n\tclear: function () {\r\n\r\n\t\tthis.files = {};\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/loaders/Loader.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Loader = function () {\r\n\r\n\tthis.onLoadStart = function () {};\r\n\tthis.onLoadProgress = function () {};\r\n\tthis.onLoadComplete = function () {};\r\n\r\n};\r\n\r\nTHREE.Loader.prototype = {\r\n\r\n\tconstructor: THREE.Loader,\r\n\r\n\tcrossOrigin: undefined,\r\n\r\n\textractUrlBase: function ( url ) {\r\n\r\n\t\tvar parts = url.split( '/' );\r\n\r\n\t\tif ( parts.length === 1 ) return './';\r\n\r\n\t\tparts.pop();\r\n\r\n\t\treturn parts.join( '/' ) + '/';\r\n\r\n\t},\r\n\r\n\tinitMaterials: function ( materials, texturePath, crossOrigin ) {\r\n\r\n\t\tvar array = [];\r\n\r\n\t\tfor ( var i = 0; i < materials.length; ++ i ) {\r\n\r\n\t\t\tarray[ i ] = this.createMaterial( materials[ i ], texturePath, crossOrigin );\r\n\r\n\t\t}\r\n\r\n\t\treturn array;\r\n\r\n\t},\r\n\r\n\tcreateMaterial: ( function () {\r\n\r\n\t\tvar color, textureLoader, materialLoader;\r\n\r\n\t\treturn function ( m, texturePath, crossOrigin ) {\r\n\r\n\t\t\tif ( color === undefined ) color = new THREE.Color();\r\n\t\t\tif ( textureLoader === undefined ) textureLoader = new THREE.TextureLoader();\r\n\t\t\tif ( materialLoader === undefined ) materialLoader = new THREE.MaterialLoader();\r\n\r\n\t\t\t// convert from old material format\r\n\r\n\t\t\tvar textures = {};\r\n\r\n\t\t\tfunction loadTexture( path, repeat, offset, wrap, anisotropy ) {\r\n\r\n\t\t\t\tvar fullPath = texturePath + path;\r\n\t\t\t\tvar loader = THREE.Loader.Handlers.get( fullPath );\r\n\r\n\t\t\t\tvar texture;\r\n\r\n\t\t\t\tif ( loader !== null ) {\r\n\r\n\t\t\t\t\ttexture = loader.load( fullPath );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\ttextureLoader.setCrossOrigin( crossOrigin );\r\n\t\t\t\t\ttexture = textureLoader.load( fullPath );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( repeat !== undefined ) {\r\n\r\n\t\t\t\t\ttexture.repeat.fromArray( repeat );\r\n\r\n\t\t\t\t\tif ( repeat[ 0 ] !== 1 ) texture.wrapS = THREE.RepeatWrapping;\r\n\t\t\t\t\tif ( repeat[ 1 ] !== 1 ) texture.wrapT = THREE.RepeatWrapping;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( offset !== undefined ) {\r\n\r\n\t\t\t\t\ttexture.offset.fromArray( offset );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( wrap !== undefined ) {\r\n\r\n\t\t\t\t\tif ( wrap[ 0 ] === 'repeat' ) texture.wrapS = THREE.RepeatWrapping;\r\n\t\t\t\t\tif ( wrap[ 0 ] === 'mirror' ) texture.wrapS = THREE.MirroredRepeatWrapping;\r\n\r\n\t\t\t\t\tif ( wrap[ 1 ] === 'repeat' ) texture.wrapT = THREE.RepeatWrapping;\r\n\t\t\t\t\tif ( wrap[ 1 ] === 'mirror' ) texture.wrapT = THREE.MirroredRepeatWrapping;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( anisotropy !== undefined ) {\r\n\r\n\t\t\t\t\ttexture.anisotropy = anisotropy;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar uuid = THREE.Math.generateUUID();\r\n\r\n\t\t\t\ttextures[ uuid ] = texture;\r\n\r\n\t\t\t\treturn uuid;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t//\r\n\r\n\t\t\tvar json = {\r\n\t\t\t\tuuid: THREE.Math.generateUUID(),\r\n\t\t\t\ttype: 'MeshLambertMaterial'\r\n\t\t\t};\r\n\r\n\t\t\tfor ( var name in m ) {\r\n\r\n\t\t\t\tvar value = m[ name ];\r\n\r\n\t\t\t\tswitch ( name ) {\r\n\t\t\t\t\tcase 'DbgColor':\r\n\t\t\t\t\tcase 'DbgIndex':\r\n\t\t\t\t\tcase 'opticalDensity':\r\n\t\t\t\t\tcase 'illumination':\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'DbgName':\r\n\t\t\t\t\t\tjson.name = value;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'blending':\r\n\t\t\t\t\t\tjson.blending = THREE[ value ];\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'colorAmbient':\r\n\t\t\t\t\tcase 'mapAmbient':\r\n\t\t\t\t\t\tconsole.warn( 'THREE.Loader.createMaterial:', name, 'is no longer supported.' );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'colorDiffuse':\r\n\t\t\t\t\t\tjson.color = color.fromArray( value ).getHex();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'colorSpecular':\r\n\t\t\t\t\t\tjson.specular = color.fromArray( value ).getHex();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'colorEmissive':\r\n\t\t\t\t\t\tjson.emissive = color.fromArray( value ).getHex();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'specularCoef':\r\n\t\t\t\t\t\tjson.shininess = value;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'shading':\r\n\t\t\t\t\t\tif ( value.toLowerCase() === 'basic' ) json.type = 'MeshBasicMaterial';\r\n\t\t\t\t\t\tif ( value.toLowerCase() === 'phong' ) json.type = 'MeshPhongMaterial';\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'mapDiffuse':\r\n\t\t\t\t\t\tjson.map = loadTexture( value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'mapDiffuseRepeat':\r\n\t\t\t\t\tcase 'mapDiffuseOffset':\r\n\t\t\t\t\tcase 'mapDiffuseWrap':\r\n\t\t\t\t\tcase 'mapDiffuseAnisotropy':\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'mapLight':\r\n\t\t\t\t\t\tjson.lightMap = loadTexture( value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'mapLightRepeat':\r\n\t\t\t\t\tcase 'mapLightOffset':\r\n\t\t\t\t\tcase 'mapLightWrap':\r\n\t\t\t\t\tcase 'mapLightAnisotropy':\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'mapAO':\r\n\t\t\t\t\t\tjson.aoMap = loadTexture( value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'mapAORepeat':\r\n\t\t\t\t\tcase 'mapAOOffset':\r\n\t\t\t\t\tcase 'mapAOWrap':\r\n\t\t\t\t\tcase 'mapAOAnisotropy':\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'mapBump':\r\n\t\t\t\t\t\tjson.bumpMap = loadTexture( value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'mapBumpScale':\r\n\t\t\t\t\t\tjson.bumpScale = value;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'mapBumpRepeat':\r\n\t\t\t\t\tcase 'mapBumpOffset':\r\n\t\t\t\t\tcase 'mapBumpWrap':\r\n\t\t\t\t\tcase 'mapBumpAnisotropy':\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'mapNormal':\r\n\t\t\t\t\t\tjson.normalMap = loadTexture( value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'mapNormalFactor':\r\n\t\t\t\t\t\tjson.normalScale = [ value, value ];\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'mapNormalRepeat':\r\n\t\t\t\t\tcase 'mapNormalOffset':\r\n\t\t\t\t\tcase 'mapNormalWrap':\r\n\t\t\t\t\tcase 'mapNormalAnisotropy':\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'mapSpecular':\r\n\t\t\t\t\t\tjson.specularMap = loadTexture( value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'mapSpecularRepeat':\r\n\t\t\t\t\tcase 'mapSpecularOffset':\r\n\t\t\t\t\tcase 'mapSpecularWrap':\r\n\t\t\t\t\tcase 'mapSpecularAnisotropy':\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'mapAlpha':\r\n\t\t\t\t\t\tjson.alphaMap = loadTexture( value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'mapAlphaRepeat':\r\n\t\t\t\t\tcase 'mapAlphaOffset':\r\n\t\t\t\t\tcase 'mapAlphaWrap':\r\n\t\t\t\t\tcase 'mapAlphaAnisotropy':\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'flipSided':\r\n\t\t\t\t\t\tjson.side = THREE.BackSide;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'doubleSided':\r\n\t\t\t\t\t\tjson.side = THREE.DoubleSide;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'transparency':\r\n\t\t\t\t\t\tconsole.warn( 'THREE.Loader.createMaterial: transparency has been renamed to opacity' );\r\n\t\t\t\t\t\tjson.opacity = value;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'depthTest':\r\n\t\t\t\t\tcase 'depthWrite':\r\n\t\t\t\t\tcase 'colorWrite':\r\n\t\t\t\t\tcase 'opacity':\r\n\t\t\t\t\tcase 'reflectivity':\r\n\t\t\t\t\tcase 'transparent':\r\n\t\t\t\t\tcase 'visible':\r\n\t\t\t\t\tcase 'wireframe':\r\n\t\t\t\t\t\tjson[ name ] = value;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'vertexColors':\r\n\t\t\t\t\t\tif ( value === true ) json.vertexColors = THREE.VertexColors;\r\n\t\t\t\t\t\tif ( value === 'face' ) json.vertexColors = THREE.FaceColors;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tconsole.error( 'THREE.Loader.createMaterial: Unsupported', name, value );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( json.type === 'MeshBasicMaterial' ) delete json.emissive;\r\n\t\t\tif ( json.type !== 'MeshPhongMaterial' ) delete json.specular;\r\n\r\n\t\t\tif ( json.opacity < 1 ) json.transparent = true;\r\n\r\n\t\t\tmaterialLoader.setTextures( textures );\r\n\r\n\t\t\treturn materialLoader.parse( json );\r\n\r\n\t\t};\r\n\r\n\t} )()\r\n\r\n};\r\n\r\nTHREE.Loader.Handlers = {\r\n\r\n\thandlers: [],\r\n\r\n\tadd: function ( regex, loader ) {\r\n\r\n\t\tthis.handlers.push( regex, loader );\r\n\r\n\t},\r\n\r\n\tget: function ( file ) {\r\n\r\n\t\tvar handlers = this.handlers;\r\n\r\n\t\tfor ( var i = 0, l = handlers.length; i < l; i += 2 ) {\r\n\r\n\t\t\tvar regex = handlers[ i ];\r\n\t\t\tvar loader  = handlers[ i + 1 ];\r\n\r\n\t\t\tif ( regex.test( file ) ) {\r\n\r\n\t\t\t\treturn loader;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn null;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/loaders/XHRLoader.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.XHRLoader = function ( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\r\n};\r\n\r\nTHREE.XHRLoader.prototype = {\r\n\r\n\tconstructor: THREE.XHRLoader,\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tif ( this.path !== undefined ) url = this.path + url;\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar cached = THREE.Cache.get( url );\r\n\r\n\t\tif ( cached !== undefined ) {\r\n\r\n\t\t\tif ( onLoad ) {\r\n\r\n\t\t\t\tsetTimeout( function () {\r\n\r\n\t\t\t\t\tonLoad( cached );\r\n\r\n\t\t\t\t}, 0 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn cached;\r\n\r\n\t\t}\r\n\r\n\t\tvar request = new XMLHttpRequest();\r\n\t\trequest.overrideMimeType( 'text/plain' );\r\n\t\trequest.open( 'GET', url, true );\r\n\r\n\t\trequest.addEventListener( 'load', function ( event ) {\r\n\r\n\t\t\tvar response = event.target.response;\r\n\r\n\t\t\tTHREE.Cache.add( url, response );\r\n\r\n\t\t\tif ( this.status === 200 ) {\r\n\r\n\t\t\t\tif ( onLoad ) onLoad( response );\r\n\r\n\t\t\t\tscope.manager.itemEnd( url );\r\n\r\n\t\t\t} else if ( this.status === 0 ) {\r\n\r\n\t\t\t\t// Some browsers return HTTP Status 0 when using non-http protocol\r\n\t\t\t\t// e.g. 'file://' or 'data://'. Handle as success.\r\n\r\n\t\t\t\tconsole.warn( 'THREE.XHRLoader: HTTP Status 0 received.' );\r\n\r\n\t\t\t\tif ( onLoad ) onLoad( response );\r\n\r\n\t\t\t\tscope.manager.itemEnd( url );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tif ( onError ) onError( event );\r\n\r\n\t\t\t\tscope.manager.itemError( url );\r\n\r\n\t\t\t}\r\n\r\n\t\t}, false );\r\n\r\n\t\tif ( onProgress !== undefined ) {\r\n\r\n\t\t\trequest.addEventListener( 'progress', function ( event ) {\r\n\r\n\t\t\t\tonProgress( event );\r\n\r\n\t\t\t}, false );\r\n\r\n\t\t}\r\n\r\n\t\trequest.addEventListener( 'error', function ( event ) {\r\n\r\n\t\t\tif ( onError ) onError( event );\r\n\r\n\t\t\tscope.manager.itemError( url );\r\n\r\n\t\t}, false );\r\n\r\n\t\tif ( this.responseType !== undefined ) request.responseType = this.responseType;\r\n\t\tif ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;\r\n\r\n\t\trequest.send( null );\r\n\r\n\t\tscope.manager.itemStart( url );\r\n\r\n\t\treturn request;\r\n\r\n\t},\r\n\r\n\tsetPath: function ( value ) {\r\n\r\n\t\tthis.path = value;\r\n\r\n\t},\r\n\r\n\tsetResponseType: function ( value ) {\r\n\r\n\t\tthis.responseType = value;\r\n\r\n\t},\r\n\r\n\tsetWithCredentials: function ( value ) {\r\n\r\n\t\tthis.withCredentials = value;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/loaders/FontLoader.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.FontLoader = function ( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\r\n};\r\n\r\nTHREE.FontLoader.prototype = {\r\n\r\n\tconstructor: THREE.FontLoader,\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar loader = new THREE.XHRLoader( this.manager );\r\n\t\tloader.load( url, function ( text ) {\r\n\r\n\t\t\tonLoad( new THREE.Font( JSON.parse( text.substring( 65, text.length - 2 ) ) ) );\r\n\r\n\t\t}, onProgress, onError );\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/loaders/ImageLoader.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.ImageLoader = function ( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\r\n};\r\n\r\nTHREE.ImageLoader.prototype = {\r\n\r\n\tconstructor: THREE.ImageLoader,\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tif ( this.path !== undefined ) url = this.path + url;\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar cached = THREE.Cache.get( url );\r\n\r\n\t\tif ( cached !== undefined ) {\r\n\r\n\t\t\tscope.manager.itemStart( url );\r\n\r\n\t\t\tif ( onLoad ) {\r\n\r\n\t\t\t\tsetTimeout( function () {\r\n\r\n\t\t\t\t\tonLoad( cached );\r\n\r\n\t\t\t\t\tscope.manager.itemEnd( url );\r\n\r\n\t\t\t\t}, 0 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tscope.manager.itemEnd( url );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn cached;\r\n\r\n\t\t}\r\n\r\n\t\tvar image = document.createElement( 'img' );\r\n\r\n\t\timage.addEventListener( 'load', function ( event ) {\r\n\r\n\t\t\tTHREE.Cache.add( url, this );\r\n\r\n\t\t\tif ( onLoad ) onLoad( this );\r\n\r\n\t\t\tscope.manager.itemEnd( url );\r\n\r\n\t\t}, false );\r\n\r\n\t\tif ( onProgress !== undefined ) {\r\n\r\n\t\t\timage.addEventListener( 'progress', function ( event ) {\r\n\r\n\t\t\t\tonProgress( event );\r\n\r\n\t\t\t}, false );\r\n\r\n\t\t}\r\n\r\n\t\timage.addEventListener( 'error', function ( event ) {\r\n\r\n\t\t\tif ( onError ) onError( event );\r\n\r\n\t\t\tscope.manager.itemError( url );\r\n\r\n\t\t}, false );\r\n\r\n\t\tif ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;\r\n\r\n\t\tscope.manager.itemStart( url );\r\n\r\n\t\timage.src = url;\r\n\r\n\t\treturn image;\r\n\r\n\t},\r\n\r\n\tsetCrossOrigin: function ( value ) {\r\n\r\n\t\tthis.crossOrigin = value;\r\n\r\n\t},\r\n\r\n\tsetPath: function ( value ) {\r\n\r\n\t\tthis.path = value;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/loaders/JSONLoader.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.JSONLoader = function ( manager ) {\r\n\r\n\tif ( typeof manager === 'boolean' ) {\r\n\r\n\t\tconsole.warn( 'THREE.JSONLoader: showStatus parameter has been removed from constructor.' );\r\n\t\tmanager = undefined;\r\n\r\n\t}\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\r\n\tthis.withCredentials = false;\r\n\r\n};\r\n\r\nTHREE.JSONLoader.prototype = {\r\n\r\n\tconstructor: THREE.JSONLoader,\r\n\r\n\t// Deprecated\r\n\r\n\tget statusDomElement () {\r\n\r\n\t\tif ( this._statusDomElement === undefined ) {\r\n\r\n\t\t\tthis._statusDomElement = document.createElement( 'div' );\r\n\r\n\t\t}\r\n\r\n\t\tconsole.warn( 'THREE.JSONLoader: .statusDomElement has been removed.' );\r\n\t\treturn this._statusDomElement;\r\n\r\n\t},\r\n\r\n\tload: function( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar texturePath = this.texturePath && ( typeof this.texturePath === \"string\" ) ? this.texturePath : THREE.Loader.prototype.extractUrlBase( url );\r\n\r\n\t\tvar loader = new THREE.XHRLoader( this.manager );\r\n\t\tloader.setWithCredentials( this.withCredentials );\r\n\t\tloader.load( url, function ( text ) {\r\n\r\n\t\t\tvar json = JSON.parse( text );\r\n\t\t\tvar metadata = json.metadata;\r\n\r\n\t\t\tif ( metadata !== undefined ) {\r\n\r\n\t\t\t\tvar type = metadata.type;\r\n\r\n\t\t\t\tif ( type !== undefined ) {\r\n\r\n\t\t\t\t\tif ( type.toLowerCase() === 'object' ) {\r\n\r\n\t\t\t\t\t\tconsole.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.' );\r\n\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( type.toLowerCase() === 'scene' ) {\r\n\r\n\t\t\t\t\t\tconsole.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.SceneLoader instead.' );\r\n\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar object = scope.parse( json, texturePath );\r\n\t\t\tonLoad( object.geometry, object.materials );\r\n\r\n\t\t}, onProgress, onError );\r\n\r\n\t},\r\n\r\n\tsetTexturePath: function ( value ) {\r\n\r\n\t\tthis.texturePath = value;\r\n\r\n\t},\r\n\r\n\tparse: function ( json, texturePath ) {\r\n\r\n\t\tvar geometry = new THREE.Geometry(),\r\n\t\tscale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;\r\n\r\n\t\tparseModel( scale );\r\n\r\n\t\tparseSkin();\r\n\t\tparseMorphing( scale );\r\n\t\tparseAnimations();\r\n\r\n\t\tgeometry.computeFaceNormals();\r\n\t\tgeometry.computeBoundingSphere();\r\n\r\n\t\tfunction parseModel( scale ) {\r\n\r\n\t\t\tfunction isBitSet( value, position ) {\r\n\r\n\t\t\t\treturn value & ( 1 << position );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar i, j, fi,\r\n\r\n\t\t\toffset, zLength,\r\n\r\n\t\tcolorIndex, normalIndex, uvIndex, materialIndex,\r\n\r\n\t\t\ttype,\r\n\t\t\tisQuad,\r\n\t\t\thasMaterial,\r\n\t\t\thasFaceVertexUv,\r\n\t\t\thasFaceNormal, hasFaceVertexNormal,\r\n\t\t\thasFaceColor, hasFaceVertexColor,\r\n\r\n\t\tvertex, face, faceA, faceB, hex, normal,\r\n\r\n\t\t\tuvLayer, uv, u, v,\r\n\r\n\t\t\tfaces = json.faces,\r\n\t\t\tvertices = json.vertices,\r\n\t\t\tnormals = json.normals,\r\n\t\t\tcolors = json.colors,\r\n\r\n\t\t\tnUvLayers = 0;\r\n\r\n\t\t\tif ( json.uvs !== undefined ) {\r\n\r\n\t\t\t\t// disregard empty arrays\r\n\r\n\t\t\t\tfor ( i = 0; i < json.uvs.length; i ++ ) {\r\n\r\n\t\t\t\t\tif ( json.uvs[ i ].length ) nUvLayers ++;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\r\n\r\n\t\t\t\t\tgeometry.faceVertexUvs[ i ] = [];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\toffset = 0;\r\n\t\t\tzLength = vertices.length;\r\n\r\n\t\t\twhile ( offset < zLength ) {\r\n\r\n\t\t\t\tvertex = new THREE.Vector3();\r\n\r\n\t\t\t\tvertex.x = vertices[ offset ++ ] * scale;\r\n\t\t\t\tvertex.y = vertices[ offset ++ ] * scale;\r\n\t\t\t\tvertex.z = vertices[ offset ++ ] * scale;\r\n\r\n\t\t\t\tgeometry.vertices.push( vertex );\r\n\r\n\t\t\t}\r\n\r\n\t\t\toffset = 0;\r\n\t\t\tzLength = faces.length;\r\n\r\n\t\t\twhile ( offset < zLength ) {\r\n\r\n\t\t\t\ttype = faces[ offset ++ ];\r\n\r\n\r\n\t\t\t\tisQuad              = isBitSet( type, 0 );\r\n\t\t\t\thasMaterial         = isBitSet( type, 1 );\r\n\t\t\t\thasFaceVertexUv     = isBitSet( type, 3 );\r\n\t\t\t\thasFaceNormal       = isBitSet( type, 4 );\r\n\t\t\t\thasFaceVertexNormal = isBitSet( type, 5 );\r\n\t\t\t\thasFaceColor\t     = isBitSet( type, 6 );\r\n\t\t\t\thasFaceVertexColor  = isBitSet( type, 7 );\r\n\r\n\t\t\t\t// console.log(\"type\", type, \"bits\", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);\r\n\r\n\t\t\t\tif ( isQuad ) {\r\n\r\n\t\t\t\t\tfaceA = new THREE.Face3();\r\n\t\t\t\t\tfaceA.a = faces[ offset ];\r\n\t\t\t\t\tfaceA.b = faces[ offset + 1 ];\r\n\t\t\t\t\tfaceA.c = faces[ offset + 3 ];\r\n\r\n\t\t\t\t\tfaceB = new THREE.Face3();\r\n\t\t\t\t\tfaceB.a = faces[ offset + 1 ];\r\n\t\t\t\t\tfaceB.b = faces[ offset + 2 ];\r\n\t\t\t\t\tfaceB.c = faces[ offset + 3 ];\r\n\r\n\t\t\t\t\toffset += 4;\r\n\r\n\t\t\t\t\tif ( hasMaterial ) {\r\n\r\n\t\t\t\t\t\tmaterialIndex = faces[ offset ++ ];\r\n\t\t\t\t\t\tfaceA.materialIndex = materialIndex;\r\n\t\t\t\t\t\tfaceB.materialIndex = materialIndex;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// to get face <=> uv index correspondence\r\n\r\n\t\t\t\t\tfi = geometry.faces.length;\r\n\r\n\t\t\t\t\tif ( hasFaceVertexUv ) {\r\n\r\n\t\t\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\r\n\r\n\t\t\t\t\t\t\tuvLayer = json.uvs[ i ];\r\n\r\n\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ] = [];\r\n\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi + 1 ] = [];\r\n\r\n\t\t\t\t\t\t\tfor ( j = 0; j < 4; j ++ ) {\r\n\r\n\t\t\t\t\t\t\t\tuvIndex = faces[ offset ++ ];\r\n\r\n\t\t\t\t\t\t\t\tu = uvLayer[ uvIndex * 2 ];\r\n\t\t\t\t\t\t\t\tv = uvLayer[ uvIndex * 2 + 1 ];\r\n\r\n\t\t\t\t\t\t\t\tuv = new THREE.Vector2( u, v );\r\n\r\n\t\t\t\t\t\t\t\tif ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );\r\n\t\t\t\t\t\t\t\tif ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( hasFaceNormal ) {\r\n\r\n\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\r\n\r\n\t\t\t\t\t\tfaceA.normal.set(\r\n\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\tnormals[ normalIndex ]\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\tfaceB.normal.copy( faceA.normal );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( hasFaceVertexNormal ) {\r\n\r\n\t\t\t\t\t\tfor ( i = 0; i < 4; i ++ ) {\r\n\r\n\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\r\n\r\n\t\t\t\t\t\t\tnormal = new THREE.Vector3(\r\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\t\tnormals[ normalIndex ]\r\n\t\t\t\t\t\t\t);\r\n\r\n\r\n\t\t\t\t\t\t\tif ( i !== 2 ) faceA.vertexNormals.push( normal );\r\n\t\t\t\t\t\t\tif ( i !== 0 ) faceB.vertexNormals.push( normal );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\r\n\t\t\t\t\tif ( hasFaceColor ) {\r\n\r\n\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\r\n\t\t\t\t\t\thex = colors[ colorIndex ];\r\n\r\n\t\t\t\t\t\tfaceA.color.setHex( hex );\r\n\t\t\t\t\t\tfaceB.color.setHex( hex );\r\n\r\n\t\t\t\t\t}\r\n\r\n\r\n\t\t\t\t\tif ( hasFaceVertexColor ) {\r\n\r\n\t\t\t\t\t\tfor ( i = 0; i < 4; i ++ ) {\r\n\r\n\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\r\n\t\t\t\t\t\t\thex = colors[ colorIndex ];\r\n\r\n\t\t\t\t\t\t\tif ( i !== 2 ) faceA.vertexColors.push( new THREE.Color( hex ) );\r\n\t\t\t\t\t\t\tif ( i !== 0 ) faceB.vertexColors.push( new THREE.Color( hex ) );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tgeometry.faces.push( faceA );\r\n\t\t\t\t\tgeometry.faces.push( faceB );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tface = new THREE.Face3();\r\n\t\t\t\t\tface.a = faces[ offset ++ ];\r\n\t\t\t\t\tface.b = faces[ offset ++ ];\r\n\t\t\t\t\tface.c = faces[ offset ++ ];\r\n\r\n\t\t\t\t\tif ( hasMaterial ) {\r\n\r\n\t\t\t\t\t\tmaterialIndex = faces[ offset ++ ];\r\n\t\t\t\t\t\tface.materialIndex = materialIndex;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// to get face <=> uv index correspondence\r\n\r\n\t\t\t\t\tfi = geometry.faces.length;\r\n\r\n\t\t\t\t\tif ( hasFaceVertexUv ) {\r\n\r\n\t\t\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\r\n\r\n\t\t\t\t\t\t\tuvLayer = json.uvs[ i ];\r\n\r\n\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ] = [];\r\n\r\n\t\t\t\t\t\t\tfor ( j = 0; j < 3; j ++ ) {\r\n\r\n\t\t\t\t\t\t\t\tuvIndex = faces[ offset ++ ];\r\n\r\n\t\t\t\t\t\t\t\tu = uvLayer[ uvIndex * 2 ];\r\n\t\t\t\t\t\t\t\tv = uvLayer[ uvIndex * 2 + 1 ];\r\n\r\n\t\t\t\t\t\t\t\tuv = new THREE.Vector2( u, v );\r\n\r\n\t\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ].push( uv );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( hasFaceNormal ) {\r\n\r\n\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\r\n\r\n\t\t\t\t\t\tface.normal.set(\r\n\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\tnormals[ normalIndex ]\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( hasFaceVertexNormal ) {\r\n\r\n\t\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\r\n\r\n\t\t\t\t\t\t\tnormal = new THREE.Vector3(\r\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\t\tnormals[ normalIndex ]\r\n\t\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\t\tface.vertexNormals.push( normal );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\r\n\t\t\t\t\tif ( hasFaceColor ) {\r\n\r\n\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\r\n\t\t\t\t\t\tface.color.setHex( colors[ colorIndex ] );\r\n\r\n\t\t\t\t\t}\r\n\r\n\r\n\t\t\t\t\tif ( hasFaceVertexColor ) {\r\n\r\n\t\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\r\n\t\t\t\t\t\t\tface.vertexColors.push( new THREE.Color( colors[ colorIndex ] ) );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tgeometry.faces.push( face );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t\tfunction parseSkin() {\r\n\r\n\t\t\tvar influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;\r\n\r\n\t\t\tif ( json.skinWeights ) {\r\n\r\n\t\t\t\tfor ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {\r\n\r\n\t\t\t\t\tvar x =                               json.skinWeights[ i ];\r\n\t\t\t\t\tvar y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;\r\n\t\t\t\t\tvar z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;\r\n\t\t\t\t\tvar w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;\r\n\r\n\t\t\t\t\tgeometry.skinWeights.push( new THREE.Vector4( x, y, z, w ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( json.skinIndices ) {\r\n\r\n\t\t\t\tfor ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {\r\n\r\n\t\t\t\t\tvar a =                               json.skinIndices[ i ];\r\n\t\t\t\t\tvar b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;\r\n\t\t\t\t\tvar c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;\r\n\t\t\t\t\tvar d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;\r\n\r\n\t\t\t\t\tgeometry.skinIndices.push( new THREE.Vector4( a, b, c, d ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry.bones = json.bones;\r\n\r\n\t\t\tif ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {\r\n\r\n\t\t\t\tconsole.warn( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +\r\n\t\t\t\t\tgeometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t\tfunction parseMorphing( scale ) {\r\n\r\n\t\t\tif ( json.morphTargets !== undefined ) {\r\n\r\n\t\t\t\tfor ( var i = 0, l = json.morphTargets.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\tgeometry.morphTargets[ i ] = {};\r\n\t\t\t\t\tgeometry.morphTargets[ i ].name = json.morphTargets[ i ].name;\r\n\t\t\t\t\tgeometry.morphTargets[ i ].vertices = [];\r\n\r\n\t\t\t\t\tvar dstVertices = geometry.morphTargets[ i ].vertices;\r\n\t\t\t\t\tvar srcVertices = json.morphTargets[ i ].vertices;\r\n\r\n\t\t\t\t\tfor ( var v = 0, vl = srcVertices.length; v < vl; v += 3 ) {\r\n\r\n\t\t\t\t\t\tvar vertex = new THREE.Vector3();\r\n\t\t\t\t\t\tvertex.x = srcVertices[ v ] * scale;\r\n\t\t\t\t\t\tvertex.y = srcVertices[ v + 1 ] * scale;\r\n\t\t\t\t\t\tvertex.z = srcVertices[ v + 2 ] * scale;\r\n\r\n\t\t\t\t\t\tdstVertices.push( vertex );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( json.morphColors !== undefined && json.morphColors.length > 0 ) {\r\n\r\n\t\t\t\tconsole.warn( 'THREE.JSONLoader: \"morphColors\" no longer supported. Using them as face colors.' );\r\n\r\n\t\t\t\tvar faces = geometry.faces;\r\n\t\t\t\tvar morphColors = json.morphColors[ 0 ].colors;\r\n\r\n\t\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\tfaces[ i ].color.fromArray( morphColors, i * 3 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseAnimations() {\r\n\r\n\t\t\tvar outputAnimations = [];\r\n\r\n\t\t\t// parse old style Bone/Hierarchy animations\r\n\t\t\tvar animations = [];\r\n\r\n\t\t\tif ( json.animation !== undefined ) {\r\n\r\n\t\t\t\tanimations.push( json.animation );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( json.animations !== undefined ) {\r\n\r\n\t\t\t\tif ( json.animations.length ) {\r\n\r\n\t\t\t\t\tanimations = animations.concat( json.animations );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tanimations.push( json.animations );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var i = 0; i < animations.length; i ++ ) {\r\n\r\n\t\t\t\tvar clip = THREE.AnimationClip.parseAnimation( animations[ i ], geometry.bones );\r\n\t\t\t\tif ( clip ) outputAnimations.push( clip );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// parse implicit morph animations\r\n\t\t\tif ( geometry.morphTargets ) {\r\n\r\n\t\t\t\t// TODO: Figure out what an appropraite FPS is for morph target animations -- defaulting to 10, but really it is completely arbitrary.\r\n\t\t\t\tvar morphAnimationClips = THREE.AnimationClip.CreateClipsFromMorphTargetSequences( geometry.morphTargets, 10 );\r\n\t\t\t\toutputAnimations = outputAnimations.concat( morphAnimationClips );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( outputAnimations.length > 0 ) geometry.animations = outputAnimations;\r\n\r\n\t\t};\r\n\r\n\t\tif ( json.materials === undefined || json.materials.length === 0 ) {\r\n\r\n\t\t\treturn { geometry: geometry };\r\n\r\n\t\t} else {\r\n\r\n\t\t\tvar materials = THREE.Loader.prototype.initMaterials( json.materials, texturePath, this.crossOrigin );\r\n\r\n\t\t\treturn { geometry: geometry, materials: materials };\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/loaders/LoadingManager.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.LoadingManager = function ( onLoad, onProgress, onError ) {\r\n\r\n\tvar scope = this;\r\n\r\n\tvar isLoading = false, itemsLoaded = 0, itemsTotal = 0;\r\n\r\n\tthis.onStart = undefined;\r\n\tthis.onLoad = onLoad;\r\n\tthis.onProgress = onProgress;\r\n\tthis.onError = onError;\r\n\r\n\tthis.itemStart = function ( url ) {\r\n\r\n\t\titemsTotal ++;\r\n\r\n\t\tif ( isLoading === false ) {\r\n\r\n\t\t\tif ( scope.onStart !== undefined ) {\r\n\r\n\t\t\t\tscope.onStart( url, itemsLoaded, itemsTotal );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tisLoading = true;\r\n\r\n\t};\r\n\r\n\tthis.itemEnd = function ( url ) {\r\n\r\n\t\titemsLoaded ++;\r\n\r\n\t\tif ( scope.onProgress !== undefined ) {\r\n\r\n\t\t\tscope.onProgress( url, itemsLoaded, itemsTotal );\r\n\r\n\t\t}\r\n\r\n\t\tif ( itemsLoaded === itemsTotal ) {\r\n\r\n\t\t\tisLoading = false;\r\n\r\n\t\t\tif ( scope.onLoad !== undefined ) {\r\n\r\n\t\t\t\tscope.onLoad();\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.itemError = function ( url ) {\r\n\r\n\t\tif ( scope.onError !== undefined ) {\r\n\r\n\t\t\tscope.onError( url );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n};\r\n\r\nTHREE.DefaultLoadingManager = new THREE.LoadingManager();\r\n\r\n// File:src/loaders/BufferGeometryLoader.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.BufferGeometryLoader = function ( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\r\n};\r\n\r\nTHREE.BufferGeometryLoader.prototype = {\r\n\r\n\tconstructor: THREE.BufferGeometryLoader,\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar loader = new THREE.XHRLoader( scope.manager );\r\n\t\tloader.load( url, function ( text ) {\r\n\r\n\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\r\n\r\n\t\t}, onProgress, onError );\r\n\r\n\t},\r\n\r\n\tparse: function ( json ) {\r\n\r\n\t\tvar geometry = new THREE.BufferGeometry();\r\n\r\n\t\tvar index = json.data.index;\r\n\r\n\t\tvar TYPED_ARRAYS = {\r\n\t\t\t'Int8Array': Int8Array,\r\n\t\t\t'Uint8Array': Uint8Array,\r\n\t\t\t'Uint8ClampedArray': Uint8ClampedArray,\r\n\t\t\t'Int16Array': Int16Array,\r\n\t\t\t'Uint16Array': Uint16Array,\r\n\t\t\t'Int32Array': Int32Array,\r\n\t\t\t'Uint32Array': Uint32Array,\r\n\t\t\t'Float32Array': Float32Array,\r\n\t\t\t'Float64Array': Float64Array\r\n\t\t};\r\n\r\n\t\tif ( index !== undefined ) {\r\n\r\n\t\t\tvar typedArray = new TYPED_ARRAYS[ index.type ]( index.array );\r\n\t\t\tgeometry.setIndex( new THREE.BufferAttribute( typedArray, 1 ) );\r\n\r\n\t\t}\r\n\r\n\t\tvar attributes = json.data.attributes;\r\n\r\n\t\tfor ( var key in attributes ) {\r\n\r\n\t\t\tvar attribute = attributes[ key ];\r\n\t\t\tvar typedArray = new TYPED_ARRAYS[ attribute.type ]( attribute.array );\r\n\r\n\t\t\tgeometry.addAttribute( key, new THREE.BufferAttribute( typedArray, attribute.itemSize, attribute.normalized ) );\r\n\r\n\t\t}\r\n\r\n\t\tvar groups = json.data.groups || json.data.drawcalls || json.data.offsets;\r\n\r\n\t\tif ( groups !== undefined ) {\r\n\r\n\t\t\tfor ( var i = 0, n = groups.length; i !== n; ++ i ) {\r\n\r\n\t\t\t\tvar group = groups[ i ];\r\n\r\n\t\t\t\tgeometry.addGroup( group.start, group.count, group.materialIndex );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar boundingSphere = json.data.boundingSphere;\r\n\r\n\t\tif ( boundingSphere !== undefined ) {\r\n\r\n\t\t\tvar center = new THREE.Vector3();\r\n\r\n\t\t\tif ( boundingSphere.center !== undefined ) {\r\n\r\n\t\t\t\tcenter.fromArray( boundingSphere.center );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry.boundingSphere = new THREE.Sphere( center, boundingSphere.radius );\r\n\r\n\t\t}\r\n\r\n\t\treturn geometry;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/loaders/MaterialLoader.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.MaterialLoader = function ( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\tthis.textures = {};\r\n\r\n};\r\n\r\nTHREE.MaterialLoader.prototype = {\r\n\r\n\tconstructor: THREE.MaterialLoader,\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar loader = new THREE.XHRLoader( scope.manager );\r\n\t\tloader.load( url, function ( text ) {\r\n\r\n\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\r\n\r\n\t\t}, onProgress, onError );\r\n\r\n\t},\r\n\r\n\tsetTextures: function ( value ) {\r\n\r\n\t\tthis.textures = value;\r\n\r\n\t},\r\n\r\n\tgetTexture: function ( name ) {\r\n\r\n\t\tvar textures = this.textures;\r\n\r\n\t\tif ( textures[ name ] === undefined ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.MaterialLoader: Undefined texture', name );\r\n\r\n\t\t}\r\n\r\n\t\treturn textures[ name ];\r\n\r\n\t},\r\n\r\n\tparse: function ( json ) {\r\n\r\n\t\tvar material = new THREE[ json.type ];\r\n\r\n\t\tif ( json.uuid !== undefined ) material.uuid = json.uuid;\r\n\t\tif ( json.name !== undefined ) material.name = json.name;\r\n\t\tif ( json.color !== undefined ) material.color.setHex( json.color );\r\n\t\tif ( json.roughness !== undefined ) material.roughness = json.roughness;\r\n\t\tif ( json.metalness !== undefined ) material.metalness = json.metalness;\r\n\t\tif ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );\r\n\t\tif ( json.specular !== undefined ) material.specular.setHex( json.specular );\r\n\t\tif ( json.shininess !== undefined ) material.shininess = json.shininess;\r\n\t\tif ( json.uniforms !== undefined ) material.uniforms = json.uniforms;\r\n\t\tif ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;\r\n\t\tif ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;\r\n\t\tif ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;\r\n\t\tif ( json.shading !== undefined ) material.shading = json.shading;\r\n\t\tif ( json.blending !== undefined ) material.blending = json.blending;\r\n\t\tif ( json.side !== undefined ) material.side = json.side;\r\n\t\tif ( json.opacity !== undefined ) material.opacity = json.opacity;\r\n\t\tif ( json.transparent !== undefined ) material.transparent = json.transparent;\r\n\t\tif ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;\r\n\t\tif ( json.depthTest !== undefined ) material.depthTest = json.depthTest;\r\n\t\tif ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;\r\n\t\tif ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;\r\n\t\tif ( json.wireframe !== undefined ) material.wireframe = json.wireframe;\r\n\t\tif ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;\r\n\r\n\t\t// for PointsMaterial\r\n\t\tif ( json.size !== undefined ) material.size = json.size;\r\n\t\tif ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;\r\n\r\n\t\t// maps\r\n\r\n\t\tif ( json.map !== undefined ) material.map = this.getTexture( json.map );\r\n\r\n\t\tif ( json.alphaMap !== undefined ) {\r\n\r\n\t\t\tmaterial.alphaMap = this.getTexture( json.alphaMap );\r\n\t\t\tmaterial.transparent = true;\r\n\r\n\t\t}\r\n\r\n\t\tif ( json.bumpMap !== undefined ) material.bumpMap = this.getTexture( json.bumpMap );\r\n\t\tif ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;\r\n\r\n\t\tif ( json.normalMap !== undefined ) material.normalMap = this.getTexture( json.normalMap );\r\n\t\tif ( json.normalScale !== undefined ) {\r\n\r\n\t\t\tvar normalScale = json.normalScale;\r\n\r\n\t\t\tif ( Array.isArray( normalScale ) === false ) {\r\n\r\n\t\t\t\t// Blender exporter used to export a scalar. See #7459\r\n\r\n\t\t\t\tnormalScale = [ normalScale, normalScale ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmaterial.normalScale = new THREE.Vector2().fromArray( normalScale );\r\n\r\n\t\t}\r\n\r\n\t\tif ( json.displacementMap !== undefined ) material.displacementMap = this.getTexture( json.displacementMap );\r\n\t\tif ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;\r\n\t\tif ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;\r\n\r\n\t\tif ( json.roughnessMap !== undefined ) material.roughnessMap = this.getTexture( json.roughnessMap );\r\n\t\tif ( json.metalnessMap !== undefined ) material.metalnessMap = this.getTexture( json.metalnessMap );\r\n\r\n\t\tif ( json.emissiveMap !== undefined ) material.emissiveMap = this.getTexture( json.emissiveMap );\r\n\t\tif ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;\r\n\r\n\t\tif ( json.specularMap !== undefined ) material.specularMap = this.getTexture( json.specularMap );\r\n\r\n\t\tif ( json.envMap !== undefined ) {\r\n\r\n\t\t\tmaterial.envMap = this.getTexture( json.envMap );\r\n\t\t\tmaterial.combine = THREE.MultiplyOperation;\r\n\r\n\t\t}\r\n\r\n\t\tif ( json.reflectivity ) material.reflectivity = json.reflectivity;\r\n\r\n\t\tif ( json.lightMap !== undefined ) material.lightMap = this.getTexture( json.lightMap );\r\n\t\tif ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;\r\n\r\n\t\tif ( json.aoMap !== undefined ) material.aoMap = this.getTexture( json.aoMap );\r\n\t\tif ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;\r\n\r\n\t\t// MultiMaterial\r\n\r\n\t\tif ( json.materials !== undefined ) {\r\n\r\n\t\t\tfor ( var i = 0, l = json.materials.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tmaterial.materials.push( this.parse( json.materials[ i ] ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn material;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/loaders/ObjectLoader.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.ObjectLoader = function ( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\tthis.texturePath = '';\r\n\r\n};\r\n\r\nTHREE.ObjectLoader.prototype = {\r\n\r\n\tconstructor: THREE.ObjectLoader,\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tif ( this.texturePath === '' ) {\r\n\r\n\t\t\tthis.texturePath = url.substring( 0, url.lastIndexOf( '/' ) + 1 );\r\n\r\n\t\t}\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar loader = new THREE.XHRLoader( scope.manager );\r\n\t\tloader.load( url, function ( text ) {\r\n\r\n\t\t\tscope.parse( JSON.parse( text ), onLoad );\r\n\r\n\t\t}, onProgress, onError );\r\n\r\n\t},\r\n\r\n\tsetTexturePath: function ( value ) {\r\n\r\n\t\tthis.texturePath = value;\r\n\r\n\t},\r\n\r\n\tsetCrossOrigin: function ( value ) {\r\n\r\n\t\tthis.crossOrigin = value;\r\n\r\n\t},\r\n\r\n\tparse: function ( json, onLoad ) {\r\n\r\n\t\tvar geometries = this.parseGeometries( json.geometries );\r\n\r\n\t\tvar images = this.parseImages( json.images, function () {\r\n\r\n\t\t\tif ( onLoad !== undefined ) onLoad( object );\r\n\r\n\t\t} );\r\n\r\n\t\tvar textures  = this.parseTextures( json.textures, images );\r\n\t\tvar materials = this.parseMaterials( json.materials, textures );\r\n\r\n\t\tvar object = this.parseObject( json.object, geometries, materials );\r\n\r\n\t\tif ( json.animations ) {\r\n\r\n\t\t\tobject.animations = this.parseAnimations( json.animations );\r\n\r\n\t\t}\r\n\r\n\t\tif ( json.images === undefined || json.images.length === 0 ) {\r\n\r\n\t\t\tif ( onLoad !== undefined ) onLoad( object );\r\n\r\n\t\t}\r\n\r\n\t\treturn object;\r\n\r\n\t},\r\n\r\n\tparseGeometries: function ( json ) {\r\n\r\n\t\tvar geometries = {};\r\n\r\n\t\tif ( json !== undefined ) {\r\n\r\n\t\t\tvar geometryLoader = new THREE.JSONLoader();\r\n\t\t\tvar bufferGeometryLoader = new THREE.BufferGeometryLoader();\r\n\r\n\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar geometry;\r\n\t\t\t\tvar data = json[ i ];\r\n\r\n\t\t\t\tswitch ( data.type ) {\r\n\r\n\t\t\t\t\tcase 'PlaneGeometry':\r\n\t\t\t\t\tcase 'PlaneBufferGeometry':\r\n\r\n\t\t\t\t\t\tgeometry = new THREE[ data.type ](\r\n\t\t\t\t\t\t\tdata.width,\r\n\t\t\t\t\t\t\tdata.height,\r\n\t\t\t\t\t\t\tdata.widthSegments,\r\n\t\t\t\t\t\t\tdata.heightSegments\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'BoxGeometry':\r\n\t\t\t\t\tcase 'BoxBufferGeometry':\r\n\t\t\t\t\tcase 'CubeGeometry': // backwards compatible\r\n\r\n\t\t\t\t\t\tgeometry = new THREE[ data.type ](\r\n\t\t\t\t\t\t\tdata.width,\r\n\t\t\t\t\t\t\tdata.height,\r\n\t\t\t\t\t\t\tdata.depth,\r\n\t\t\t\t\t\t\tdata.widthSegments,\r\n\t\t\t\t\t\t\tdata.heightSegments,\r\n\t\t\t\t\t\t\tdata.depthSegments\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'CircleGeometry':\r\n\t\t\t\t\tcase 'CircleBufferGeometry':\r\n\r\n\t\t\t\t\t\tgeometry = new THREE[ data.type ](\r\n\t\t\t\t\t\t\tdata.radius,\r\n\t\t\t\t\t\t\tdata.segments,\r\n\t\t\t\t\t\t\tdata.thetaStart,\r\n\t\t\t\t\t\t\tdata.thetaLength\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'CylinderGeometry':\r\n\t\t\t\t\tcase 'CylinderBufferGeometry':\r\n\r\n\t\t\t\t\t\tgeometry = new THREE[ data.type ](\r\n\t\t\t\t\t\t\tdata.radiusTop,\r\n\t\t\t\t\t\t\tdata.radiusBottom,\r\n\t\t\t\t\t\t\tdata.height,\r\n\t\t\t\t\t\t\tdata.radialSegments,\r\n\t\t\t\t\t\t\tdata.heightSegments,\r\n\t\t\t\t\t\t\tdata.openEnded,\r\n\t\t\t\t\t\t\tdata.thetaStart,\r\n\t\t\t\t\t\t\tdata.thetaLength\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'SphereGeometry':\r\n\t\t\t\t\tcase 'SphereBufferGeometry':\r\n\r\n\t\t\t\t\t\tgeometry = new THREE[ data.type ](\r\n\t\t\t\t\t\t\tdata.radius,\r\n\t\t\t\t\t\t\tdata.widthSegments,\r\n\t\t\t\t\t\t\tdata.heightSegments,\r\n\t\t\t\t\t\t\tdata.phiStart,\r\n\t\t\t\t\t\t\tdata.phiLength,\r\n\t\t\t\t\t\t\tdata.thetaStart,\r\n\t\t\t\t\t\t\tdata.thetaLength\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'DodecahedronGeometry':\r\n\r\n\t\t\t\t\t\tgeometry = new THREE.DodecahedronGeometry(\r\n\t\t\t\t\t\t\tdata.radius,\r\n\t\t\t\t\t\t\tdata.detail\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'IcosahedronGeometry':\r\n\r\n\t\t\t\t\t\tgeometry = new THREE.IcosahedronGeometry(\r\n\t\t\t\t\t\t\tdata.radius,\r\n\t\t\t\t\t\t\tdata.detail\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'OctahedronGeometry':\r\n\r\n\t\t\t\t\t\tgeometry = new THREE.OctahedronGeometry(\r\n\t\t\t\t\t\t\tdata.radius,\r\n\t\t\t\t\t\t\tdata.detail\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'TetrahedronGeometry':\r\n\r\n\t\t\t\t\t\tgeometry = new THREE.TetrahedronGeometry(\r\n\t\t\t\t\t\t\tdata.radius,\r\n\t\t\t\t\t\t\tdata.detail\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'RingGeometry':\r\n\t\t\t\t\tcase 'RingBufferGeometry':\r\n\r\n\t\t\t\t\t\tgeometry = new THREE[ data.type ](\r\n\t\t\t\t\t\t\tdata.innerRadius,\r\n\t\t\t\t\t\t\tdata.outerRadius,\r\n\t\t\t\t\t\t\tdata.thetaSegments,\r\n\t\t\t\t\t\t\tdata.phiSegments,\r\n\t\t\t\t\t\t\tdata.thetaStart,\r\n\t\t\t\t\t\t\tdata.thetaLength\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'TorusGeometry':\r\n\t\t\t\t\tcase 'TorusBufferGeometry':\r\n\r\n\t\t\t\t\t\tgeometry = new THREE[ data.type ](\r\n\t\t\t\t\t\t\tdata.radius,\r\n\t\t\t\t\t\t\tdata.tube,\r\n\t\t\t\t\t\t\tdata.radialSegments,\r\n\t\t\t\t\t\t\tdata.tubularSegments,\r\n\t\t\t\t\t\t\tdata.arc\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'TorusKnotGeometry':\r\n\t\t\t\t\tcase 'TorusKnotBufferGeometry':\r\n\r\n\t\t\t\t\t\tgeometry = new THREE[ data.type ](\r\n\t\t\t\t\t\t\tdata.radius,\r\n\t\t\t\t\t\t\tdata.tube,\r\n\t\t\t\t\t\t\tdata.tubularSegments,\r\n\t\t\t\t\t\t\tdata.radialSegments,\r\n\t\t\t\t\t\t\tdata.p,\r\n\t\t\t\t\t\t\tdata.q\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'LatheGeometry':\r\n\t\t\t\t\tcase 'LatheBufferGeometry':\r\n\r\n\t\t\t\t\t\tgeometry = new THREE[ data.type ](\r\n\t\t\t\t\t\t\tdata.points,\r\n\t\t\t\t\t\t\tdata.segments,\r\n\t\t\t\t\t\t\tdata.phiStart,\r\n\t\t\t\t\t\t\tdata.phiLength\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'BufferGeometry':\r\n\r\n\t\t\t\t\t\tgeometry = bufferGeometryLoader.parse( data );\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'Geometry':\r\n\r\n\t\t\t\t\t\tgeometry = geometryLoader.parse( data.data, this.texturePath ).geometry;\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tdefault:\r\n\r\n\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Unsupported geometry type \"' + data.type + '\"' );\r\n\r\n\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tgeometry.uuid = data.uuid;\r\n\r\n\t\t\t\tif ( data.name !== undefined ) geometry.name = data.name;\r\n\r\n\t\t\t\tgeometries[ data.uuid ] = geometry;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn geometries;\r\n\r\n\t},\r\n\r\n\tparseMaterials: function ( json, textures ) {\r\n\r\n\t\tvar materials = {};\r\n\r\n\t\tif ( json !== undefined ) {\r\n\r\n\t\t\tvar loader = new THREE.MaterialLoader();\r\n\t\t\tloader.setTextures( textures );\r\n\r\n\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar material = loader.parse( json[ i ] );\r\n\t\t\t\tmaterials[ material.uuid ] = material;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn materials;\r\n\r\n\t},\r\n\r\n\tparseAnimations: function ( json ) {\r\n\r\n\t\tvar animations = [];\r\n\r\n\t\tfor ( var i = 0; i < json.length; i ++ ) {\r\n\r\n\t\t\tvar clip = THREE.AnimationClip.parse( json[ i ] );\r\n\r\n\t\t\tanimations.push( clip );\r\n\r\n\t\t}\r\n\r\n\t\treturn animations;\r\n\r\n\t},\r\n\r\n\tparseImages: function ( json, onLoad ) {\r\n\r\n\t\tvar scope = this;\r\n\t\tvar images = {};\r\n\r\n\t\tfunction loadImage( url ) {\r\n\r\n\t\t\tscope.manager.itemStart( url );\r\n\r\n\t\t\treturn loader.load( url, function () {\r\n\r\n\t\t\t\tscope.manager.itemEnd( url );\r\n\r\n\t\t\t} );\r\n\r\n\t\t}\r\n\r\n\t\tif ( json !== undefined && json.length > 0 ) {\r\n\r\n\t\t\tvar manager = new THREE.LoadingManager( onLoad );\r\n\r\n\t\t\tvar loader = new THREE.ImageLoader( manager );\r\n\t\t\tloader.setCrossOrigin( this.crossOrigin );\r\n\r\n\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar image = json[ i ];\r\n\t\t\t\tvar path = /^(\\/\\/)|([a-z]+:(\\/\\/)?)/i.test( image.url ) ? image.url : scope.texturePath + image.url;\r\n\r\n\t\t\t\timages[ image.uuid ] = loadImage( path );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn images;\r\n\r\n\t},\r\n\r\n\tparseTextures: function ( json, images ) {\r\n\r\n\t\tfunction parseConstant( value ) {\r\n\r\n\t\t\tif ( typeof( value ) === 'number' ) return value;\r\n\r\n\t\t\tconsole.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );\r\n\r\n\t\t\treturn THREE[ value ];\r\n\r\n\t\t}\r\n\r\n\t\tvar textures = {};\r\n\r\n\t\tif ( json !== undefined ) {\r\n\r\n\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar data = json[ i ];\r\n\r\n\t\t\t\tif ( data.image === undefined ) {\r\n\r\n\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: No \"image\" specified for', data.uuid );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( images[ data.image ] === undefined ) {\r\n\r\n\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined image', data.image );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar texture = new THREE.Texture( images[ data.image ] );\r\n\t\t\t\ttexture.needsUpdate = true;\r\n\r\n\t\t\t\ttexture.uuid = data.uuid;\r\n\r\n\t\t\t\tif ( data.name !== undefined ) texture.name = data.name;\r\n\t\t\t\tif ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping );\r\n\t\t\t\tif ( data.offset !== undefined ) texture.offset = new THREE.Vector2( data.offset[ 0 ], data.offset[ 1 ] );\r\n\t\t\t\tif ( data.repeat !== undefined ) texture.repeat = new THREE.Vector2( data.repeat[ 0 ], data.repeat[ 1 ] );\r\n\t\t\t\tif ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter );\r\n\t\t\t\tif ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter );\r\n\t\t\t\tif ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;\r\n\t\t\t\tif ( Array.isArray( data.wrap ) ) {\r\n\r\n\t\t\t\t\ttexture.wrapS = parseConstant( data.wrap[ 0 ] );\r\n\t\t\t\t\ttexture.wrapT = parseConstant( data.wrap[ 1 ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttextures[ data.uuid ] = texture;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn textures;\r\n\r\n\t},\r\n\r\n\tparseObject: function () {\r\n\r\n\t\tvar matrix = new THREE.Matrix4();\r\n\r\n\t\treturn function ( data, geometries, materials ) {\r\n\r\n\t\t\tvar object;\r\n\r\n\t\t\tfunction getGeometry( name ) {\r\n\r\n\t\t\t\tif ( geometries[ name ] === undefined ) {\r\n\r\n\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined geometry', name );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn geometries[ name ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction getMaterial( name ) {\r\n\r\n\t\t\t\tif ( name === undefined ) return undefined;\r\n\r\n\t\t\t\tif ( materials[ name ] === undefined ) {\r\n\r\n\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined material', name );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn materials[ name ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tswitch ( data.type ) {\r\n\r\n\t\t\t\tcase 'Scene':\r\n\r\n\t\t\t\t\tobject = new THREE.Scene();\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'PerspectiveCamera':\r\n\r\n\t\t\t\t\tobject = new THREE.PerspectiveCamera(\r\n\t\t\t\t\t\t\tdata.fov, data.aspect, data.near, data.far );\r\n\r\n\t\t\t\t\tif ( data.focus !== undefined ) object.focus = data.focus;\r\n\t\t\t\t\tif ( data.zoom !== undefined ) object.zoom = data.zoom;\r\n\t\t\t\t\tif ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge;\r\n\t\t\t\t\tif ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset;\r\n\t\t\t\t\tif ( data.view !== undefined ) object.view = Object.assign( {}, data.view );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'OrthographicCamera':\r\n\r\n\t\t\t\t\tobject = new THREE.OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'AmbientLight':\r\n\r\n\t\t\t\t\tobject = new THREE.AmbientLight( data.color, data.intensity );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'DirectionalLight':\r\n\r\n\t\t\t\t\tobject = new THREE.DirectionalLight( data.color, data.intensity );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'PointLight':\r\n\r\n\t\t\t\t\tobject = new THREE.PointLight( data.color, data.intensity, data.distance, data.decay );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'SpotLight':\r\n\r\n\t\t\t\t\tobject = new THREE.SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'HemisphereLight':\r\n\r\n\t\t\t\t\tobject = new THREE.HemisphereLight( data.color, data.groundColor, data.intensity );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'Mesh':\r\n\r\n\t\t\t\t\tvar geometry = getGeometry( data.geometry );\r\n\t\t\t\t\tvar material = getMaterial( data.material );\r\n\r\n\t\t\t\t\tif ( geometry.bones && geometry.bones.length > 0 ) {\r\n\r\n\t\t\t\t\t\tobject = new THREE.SkinnedMesh( geometry, material );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tobject = new THREE.Mesh( geometry, material );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'LOD':\r\n\r\n\t\t\t\t\tobject = new THREE.LOD();\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'Line':\r\n\r\n\t\t\t\t\tobject = new THREE.Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'PointCloud':\r\n\t\t\t\tcase 'Points':\r\n\r\n\t\t\t\t\tobject = new THREE.Points( getGeometry( data.geometry ), getMaterial( data.material ) );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'Sprite':\r\n\r\n\t\t\t\t\tobject = new THREE.Sprite( getMaterial( data.material ) );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'Group':\r\n\r\n\t\t\t\t\tobject = new THREE.Group();\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tdefault:\r\n\r\n\t\t\t\t\tobject = new THREE.Object3D();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tobject.uuid = data.uuid;\r\n\r\n\t\t\tif ( data.name !== undefined ) object.name = data.name;\r\n\t\t\tif ( data.matrix !== undefined ) {\r\n\r\n\t\t\t\tmatrix.fromArray( data.matrix );\r\n\t\t\t\tmatrix.decompose( object.position, object.quaternion, object.scale );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tif ( data.position !== undefined ) object.position.fromArray( data.position );\r\n\t\t\t\tif ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );\r\n\t\t\t\tif ( data.scale !== undefined ) object.scale.fromArray( data.scale );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( data.castShadow !== undefined ) object.castShadow = data.castShadow;\r\n\t\t\tif ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;\r\n\r\n\t\t\tif ( data.visible !== undefined ) object.visible = data.visible;\r\n\t\t\tif ( data.userData !== undefined ) object.userData = data.userData;\r\n\r\n\t\t\tif ( data.children !== undefined ) {\r\n\r\n\t\t\t\tfor ( var child in data.children ) {\r\n\r\n\t\t\t\t\tobject.add( this.parseObject( data.children[ child ], geometries, materials ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( data.type === 'LOD' ) {\r\n\r\n\t\t\t\tvar levels = data.levels;\r\n\r\n\t\t\t\tfor ( var l = 0; l < levels.length; l ++ ) {\r\n\r\n\t\t\t\t\tvar level = levels[ l ];\r\n\t\t\t\t\tvar child = object.getObjectByProperty( 'uuid', level.object );\r\n\r\n\t\t\t\t\tif ( child !== undefined ) {\r\n\r\n\t\t\t\t\t\tobject.addLevel( child, level.distance );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn object;\r\n\r\n\t\t};\r\n\r\n\t}()\r\n\r\n};\r\n\r\n// File:src/loaders/TextureLoader.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.TextureLoader = function ( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\r\n};\r\n\r\nTHREE.TextureLoader.prototype = {\r\n\r\n\tconstructor: THREE.TextureLoader,\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar texture = new THREE.Texture();\r\n\r\n\t\tvar loader = new THREE.ImageLoader( this.manager );\r\n\t\tloader.setCrossOrigin( this.crossOrigin );\r\n\t\tloader.setPath( this.path );\r\n\t\tloader.load( url, function ( image ) {\r\n\r\n\t\t\ttexture.image = image;\r\n\t\t\ttexture.needsUpdate = true;\r\n\r\n\t\t\tif ( onLoad !== undefined ) {\r\n\r\n\t\t\t\tonLoad( texture );\r\n\r\n\t\t\t}\r\n\r\n\t\t}, onProgress, onError );\r\n\r\n\t\treturn texture;\r\n\r\n\t},\r\n\r\n\tsetCrossOrigin: function ( value ) {\r\n\r\n\t\tthis.crossOrigin = value;\r\n\r\n\t},\r\n\r\n\tsetPath: function ( value ) {\r\n\r\n\t\tthis.path = value;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/loaders/CubeTextureLoader.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.CubeTextureLoader = function ( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\r\n};\r\n\r\nTHREE.CubeTextureLoader.prototype = {\r\n\r\n\tconstructor: THREE.CubeTextureLoader,\r\n\r\n\tload: function ( urls, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar texture = new THREE.CubeTexture();\r\n\r\n\t\tvar loader = new THREE.ImageLoader( this.manager );\r\n\t\tloader.setCrossOrigin( this.crossOrigin );\r\n\t\tloader.setPath( this.path );\r\n\r\n\t\tvar loaded = 0;\r\n\r\n\t\tfunction loadTexture( i ) {\r\n\r\n\t\t\tloader.load( urls[ i ], function ( image ) {\r\n\r\n\t\t\t\ttexture.images[ i ] = image;\r\n\r\n\t\t\t\tloaded ++;\r\n\r\n\t\t\t\tif ( loaded === 6 ) {\r\n\r\n\t\t\t\t\ttexture.needsUpdate = true;\r\n\r\n\t\t\t\t\tif ( onLoad ) onLoad( texture );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}, undefined, onError );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var i = 0; i < urls.length; ++ i ) {\r\n\r\n\t\t\tloadTexture( i );\r\n\r\n\t\t}\r\n\r\n\t\treturn texture;\r\n\r\n\t},\r\n\r\n\tsetCrossOrigin: function ( value ) {\r\n\r\n\t\tthis.crossOrigin = value;\r\n\r\n\t},\r\n\r\n\tsetPath: function ( value ) {\r\n\r\n\t\tthis.path = value;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/loaders/BinaryTextureLoader.js\r\n\r\n/**\r\n * @author Nikos M. / https://github.com/foo123/\r\n *\r\n * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)\r\n */\r\n\r\nTHREE.DataTextureLoader = THREE.BinaryTextureLoader = function ( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\r\n\t// override in sub classes\r\n\tthis._parser = null;\r\n\r\n};\r\n\r\nTHREE.BinaryTextureLoader.prototype = {\r\n\r\n\tconstructor: THREE.BinaryTextureLoader,\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar texture = new THREE.DataTexture();\r\n\r\n\t\tvar loader = new THREE.XHRLoader( this.manager );\r\n\t\tloader.setResponseType( 'arraybuffer' );\r\n\r\n\t\tloader.load( url, function ( buffer ) {\r\n\r\n\t\t\tvar texData = scope._parser( buffer );\r\n\r\n\t\t\tif ( ! texData ) return;\r\n\r\n\t\t\tif ( undefined !== texData.image ) {\r\n\r\n\t\t\t\ttexture.image = texData.image;\r\n\r\n\t\t\t} else if ( undefined !== texData.data ) {\r\n\r\n\t\t\t\ttexture.image.width = texData.width;\r\n\t\t\t\ttexture.image.height = texData.height;\r\n\t\t\t\ttexture.image.data = texData.data;\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttexture.wrapS = undefined !== texData.wrapS ? texData.wrapS : THREE.ClampToEdgeWrapping;\r\n\t\t\ttexture.wrapT = undefined !== texData.wrapT ? texData.wrapT : THREE.ClampToEdgeWrapping;\r\n\r\n\t\t\ttexture.magFilter = undefined !== texData.magFilter ? texData.magFilter : THREE.LinearFilter;\r\n\t\t\ttexture.minFilter = undefined !== texData.minFilter ? texData.minFilter : THREE.LinearMipMapLinearFilter;\r\n\r\n\t\t\ttexture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;\r\n\r\n\t\t\tif ( undefined !== texData.format ) {\r\n\r\n\t\t\t\ttexture.format = texData.format;\r\n\r\n\t\t\t}\r\n\t\t\tif ( undefined !== texData.type ) {\r\n\r\n\t\t\t\ttexture.type = texData.type;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( undefined !== texData.mipmaps ) {\r\n\r\n\t\t\t\ttexture.mipmaps = texData.mipmaps;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( 1 === texData.mipmapCount ) {\r\n\r\n\t\t\t\ttexture.minFilter = THREE.LinearFilter;\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttexture.needsUpdate = true;\r\n\r\n\t\t\tif ( onLoad ) onLoad( texture, texData );\r\n\r\n\t\t}, onProgress, onError );\r\n\r\n\r\n\t\treturn texture;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/loaders/CompressedTextureLoader.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n *\r\n * Abstract Base class to block based textures loader (dds, pvr, ...)\r\n */\r\n\r\nTHREE.CompressedTextureLoader = function ( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\r\n\t// override in sub classes\r\n\tthis._parser = null;\r\n\r\n};\r\n\r\n\r\nTHREE.CompressedTextureLoader.prototype = {\r\n\r\n\tconstructor: THREE.CompressedTextureLoader,\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar images = [];\r\n\r\n\t\tvar texture = new THREE.CompressedTexture();\r\n\t\ttexture.image = images;\r\n\r\n\t\tvar loader = new THREE.XHRLoader( this.manager );\r\n\t\tloader.setPath( this.path );\r\n\t\tloader.setResponseType( 'arraybuffer' );\r\n\r\n\t\tfunction loadTexture( i ) {\r\n\r\n\t\t\tloader.load( url[ i ], function ( buffer ) {\r\n\r\n\t\t\t\tvar texDatas = scope._parser( buffer, true );\r\n\r\n\t\t\t\timages[ i ] = {\r\n\t\t\t\t\twidth: texDatas.width,\r\n\t\t\t\t\theight: texDatas.height,\r\n\t\t\t\t\tformat: texDatas.format,\r\n\t\t\t\t\tmipmaps: texDatas.mipmaps\r\n\t\t\t\t};\r\n\r\n\t\t\t\tloaded += 1;\r\n\r\n\t\t\t\tif ( loaded === 6 ) {\r\n\r\n\t\t\t\t\tif ( texDatas.mipmapCount === 1 )\r\n\t\t\t\t\t\ttexture.minFilter = THREE.LinearFilter;\r\n\r\n\t\t\t\t\ttexture.format = texDatas.format;\r\n\t\t\t\t\ttexture.needsUpdate = true;\r\n\r\n\t\t\t\t\tif ( onLoad ) onLoad( texture );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}, onProgress, onError );\r\n\r\n\t\t}\r\n\r\n\t\tif ( Array.isArray( url ) ) {\r\n\r\n\t\t\tvar loaded = 0;\r\n\r\n\t\t\tfor ( var i = 0, il = url.length; i < il; ++ i ) {\r\n\r\n\t\t\t\tloadTexture( i );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// compressed cubemap texture stored in a single DDS file\r\n\r\n\t\t\tloader.load( url, function ( buffer ) {\r\n\r\n\t\t\t\tvar texDatas = scope._parser( buffer, true );\r\n\r\n\t\t\t\tif ( texDatas.isCubemap ) {\r\n\r\n\t\t\t\t\tvar faces = texDatas.mipmaps.length / texDatas.mipmapCount;\r\n\r\n\t\t\t\t\tfor ( var f = 0; f < faces; f ++ ) {\r\n\r\n\t\t\t\t\t\timages[ f ] = { mipmaps : [] };\r\n\r\n\t\t\t\t\t\tfor ( var i = 0; i < texDatas.mipmapCount; i ++ ) {\r\n\r\n\t\t\t\t\t\t\timages[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );\r\n\t\t\t\t\t\t\timages[ f ].format = texDatas.format;\r\n\t\t\t\t\t\t\timages[ f ].width = texDatas.width;\r\n\t\t\t\t\t\t\timages[ f ].height = texDatas.height;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\ttexture.image.width = texDatas.width;\r\n\t\t\t\t\ttexture.image.height = texDatas.height;\r\n\t\t\t\t\ttexture.mipmaps = texDatas.mipmaps;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( texDatas.mipmapCount === 1 ) {\r\n\r\n\t\t\t\t\ttexture.minFilter = THREE.LinearFilter;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttexture.format = texDatas.format;\r\n\t\t\t\ttexture.needsUpdate = true;\r\n\r\n\t\t\t\tif ( onLoad ) onLoad( texture );\r\n\r\n\t\t\t}, onProgress, onError );\r\n\r\n\t\t}\r\n\r\n\t\treturn texture;\r\n\r\n\t},\r\n\r\n\tsetPath: function ( value ) {\r\n\r\n\t\tthis.path = value;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/materials/Material.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Material = function () {\r\n\r\n\tObject.defineProperty( this, 'id', { value: THREE.MaterialIdCount ++ } );\r\n\r\n\tthis.uuid = THREE.Math.generateUUID();\r\n\r\n\tthis.name = '';\r\n\tthis.type = 'Material';\r\n\r\n\tthis.side = THREE.FrontSide;\r\n\r\n\tthis.opacity = 1;\r\n\tthis.transparent = false;\r\n\r\n\tthis.blending = THREE.NormalBlending;\r\n\r\n\tthis.blendSrc = THREE.SrcAlphaFactor;\r\n\tthis.blendDst = THREE.OneMinusSrcAlphaFactor;\r\n\tthis.blendEquation = THREE.AddEquation;\r\n\tthis.blendSrcAlpha = null;\r\n\tthis.blendDstAlpha = null;\r\n\tthis.blendEquationAlpha = null;\r\n\r\n\tthis.depthFunc = THREE.LessEqualDepth;\r\n\tthis.depthTest = true;\r\n\tthis.depthWrite = true;\r\n\r\n\tthis.clippingPlanes = null;\r\n\tthis.clipShadows = false;\r\n\r\n\tthis.colorWrite = true;\r\n\r\n\tthis.precision = null; // override the renderer's default precision for this material\r\n\r\n\tthis.polygonOffset = false;\r\n\tthis.polygonOffsetFactor = 0;\r\n\tthis.polygonOffsetUnits = 0;\r\n\r\n\tthis.alphaTest = 0;\r\n\tthis.premultipliedAlpha = false;\r\n\r\n\tthis.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer\r\n\r\n\tthis.visible = true;\r\n\r\n\tthis._needsUpdate = true;\r\n\r\n};\r\n\r\nTHREE.Material.prototype = {\r\n\r\n\tconstructor: THREE.Material,\r\n\r\n\tget needsUpdate () {\r\n\r\n\t\treturn this._needsUpdate;\r\n\r\n\t},\r\n\r\n\tset needsUpdate ( value ) {\r\n\r\n\t\tif ( value === true ) this.update();\r\n\r\n\t\tthis._needsUpdate = value;\r\n\r\n\t},\r\n\r\n\tsetValues: function ( values ) {\r\n\r\n\t\tif ( values === undefined ) return;\r\n\r\n\t\tfor ( var key in values ) {\r\n\r\n\t\t\tvar newValue = values[ key ];\r\n\r\n\t\t\tif ( newValue === undefined ) {\r\n\r\n\t\t\t\tconsole.warn( \"THREE.Material: '\" + key + \"' parameter is undefined.\" );\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar currentValue = this[ key ];\r\n\r\n\t\t\tif ( currentValue === undefined ) {\r\n\r\n\t\t\t\tconsole.warn( \"THREE.\" + this.type + \": '\" + key + \"' is not a property of this material.\" );\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( currentValue instanceof THREE.Color ) {\r\n\r\n\t\t\t\tcurrentValue.set( newValue );\r\n\r\n\t\t\t} else if ( currentValue instanceof THREE.Vector3 && newValue instanceof THREE.Vector3 ) {\r\n\r\n\t\t\t\tcurrentValue.copy( newValue );\r\n\r\n\t\t\t} else if ( key === 'overdraw' ) {\r\n\r\n\t\t\t\t// ensure overdraw is backwards-compatible with legacy boolean type\r\n\t\t\t\tthis[ key ] = Number( newValue );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis[ key ] = newValue;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\ttoJSON: function ( meta ) {\r\n\r\n\t\tvar isRoot = meta === undefined;\r\n\r\n\t\tif ( isRoot ) {\r\n\r\n\t\t\tmeta = {\r\n\t\t\t\ttextures: {},\r\n\t\t\t\timages: {}\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\tvar data = {\r\n\t\t\tmetadata: {\r\n\t\t\t\tversion: 4.4,\r\n\t\t\t\ttype: 'Material',\r\n\t\t\t\tgenerator: 'Material.toJSON'\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t// standard Material serialization\r\n\t\tdata.uuid = this.uuid;\r\n\t\tdata.type = this.type;\r\n\t\tif ( this.name !== '' ) data.name = this.name;\r\n\r\n\t\tif ( this.color instanceof THREE.Color ) data.color = this.color.getHex();\r\n\r\n\t\tif ( this.roughness !== 0.5 ) data.roughness = this.roughness;\r\n\t\tif ( this.metalness !== 0.5 ) data.metalness = this.metalness;\r\n\r\n\t\tif ( this.emissive instanceof THREE.Color ) data.emissive = this.emissive.getHex();\r\n\t\tif ( this.specular instanceof THREE.Color ) data.specular = this.specular.getHex();\r\n\t\tif ( this.shininess !== undefined ) data.shininess = this.shininess;\r\n\r\n\t\tif ( this.map instanceof THREE.Texture ) data.map = this.map.toJSON( meta ).uuid;\r\n\t\tif ( this.alphaMap instanceof THREE.Texture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;\r\n\t\tif ( this.lightMap instanceof THREE.Texture ) data.lightMap = this.lightMap.toJSON( meta ).uuid;\r\n\t\tif ( this.bumpMap instanceof THREE.Texture ) {\r\n\r\n\t\t\tdata.bumpMap = this.bumpMap.toJSON( meta ).uuid;\r\n\t\t\tdata.bumpScale = this.bumpScale;\r\n\r\n\t\t}\r\n\t\tif ( this.normalMap instanceof THREE.Texture ) {\r\n\r\n\t\t\tdata.normalMap = this.normalMap.toJSON( meta ).uuid;\r\n\t\t\tdata.normalScale = this.normalScale.toArray();\r\n\r\n\t\t}\r\n\t\tif ( this.displacementMap instanceof THREE.Texture ) {\r\n\r\n\t\t\tdata.displacementMap = this.displacementMap.toJSON( meta ).uuid;\r\n\t\t\tdata.displacementScale = this.displacementScale;\r\n\t\t\tdata.displacementBias = this.displacementBias;\r\n\r\n\t\t}\r\n\t\tif ( this.roughnessMap instanceof THREE.Texture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;\r\n\t\tif ( this.metalnessMap instanceof THREE.Texture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;\r\n\r\n\t\tif ( this.emissiveMap instanceof THREE.Texture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;\r\n\t\tif ( this.specularMap instanceof THREE.Texture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;\r\n\r\n\t\tif ( this.envMap instanceof THREE.Texture ) {\r\n\r\n\t\t\tdata.envMap = this.envMap.toJSON( meta ).uuid;\r\n\t\t\tdata.reflectivity = this.reflectivity; // Scale behind envMap\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.size !== undefined ) data.size = this.size;\r\n\t\tif ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;\r\n\r\n\t\tif ( this.vertexColors !== undefined && this.vertexColors !== THREE.NoColors ) data.vertexColors = this.vertexColors;\r\n\t\tif ( this.shading !== undefined && this.shading !== THREE.SmoothShading ) data.shading = this.shading;\r\n\t\tif ( this.blending !== undefined && this.blending !== THREE.NormalBlending ) data.blending = this.blending;\r\n\t\tif ( this.side !== undefined && this.side !== THREE.FrontSide ) data.side = this.side;\r\n\r\n\t\tif ( this.opacity < 1 ) data.opacity = this.opacity;\r\n\t\tif ( this.transparent === true ) data.transparent = this.transparent;\r\n\t\tif ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;\r\n\t\tif ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;\r\n\t\tif ( this.wireframe === true ) data.wireframe = this.wireframe;\r\n\t\tif ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;\r\n\r\n\t\t// TODO: Copied from Object3D.toJSON\r\n\r\n\t\tfunction extractFromCache ( cache ) {\r\n\r\n\t\t\tvar values = [];\r\n\r\n\t\t\tfor ( var key in cache ) {\r\n\r\n\t\t\t\tvar data = cache[ key ];\r\n\t\t\t\tdelete data.metadata;\r\n\t\t\t\tvalues.push( data );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn values;\r\n\r\n\t\t}\r\n\r\n\t\tif ( isRoot ) {\r\n\r\n\t\t\tvar textures = extractFromCache( meta.textures );\r\n\t\t\tvar images = extractFromCache( meta.images );\r\n\r\n\t\t\tif ( textures.length > 0 ) data.textures = textures;\r\n\t\t\tif ( images.length > 0 ) data.images = images;\r\n\r\n\t\t}\r\n\r\n\t\treturn data;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\r\n\t},\r\n\r\n\tcopy: function ( source ) {\r\n\r\n\t\tthis.name = source.name;\r\n\r\n\t\tthis.side = source.side;\r\n\r\n\t\tthis.opacity = source.opacity;\r\n\t\tthis.transparent = source.transparent;\r\n\r\n\t\tthis.blending = source.blending;\r\n\r\n\t\tthis.blendSrc = source.blendSrc;\r\n\t\tthis.blendDst = source.blendDst;\r\n\t\tthis.blendEquation = source.blendEquation;\r\n\t\tthis.blendSrcAlpha = source.blendSrcAlpha;\r\n\t\tthis.blendDstAlpha = source.blendDstAlpha;\r\n\t\tthis.blendEquationAlpha = source.blendEquationAlpha;\r\n\r\n\t\tthis.depthFunc = source.depthFunc;\r\n\t\tthis.depthTest = source.depthTest;\r\n\t\tthis.depthWrite = source.depthWrite;\r\n\r\n\t\tthis.colorWrite = source.colorWrite;\r\n\r\n\t\tthis.precision = source.precision;\r\n\r\n\t\tthis.polygonOffset = source.polygonOffset;\r\n\t\tthis.polygonOffsetFactor = source.polygonOffsetFactor;\r\n\t\tthis.polygonOffsetUnits = source.polygonOffsetUnits;\r\n\r\n\t\tthis.alphaTest = source.alphaTest;\r\n\r\n\t\tthis.premultipliedAlpha = source.premultipliedAlpha;\r\n\r\n\t\tthis.overdraw = source.overdraw;\r\n\r\n\t\tthis.visible = source.visible;\r\n\t\tthis.clipShadows = source.clipShadows;\r\n\r\n\t\tvar srcPlanes = source.clippingPlanes,\r\n\t\t\tdstPlanes = null;\r\n\r\n\t\tif ( srcPlanes !== null ) {\r\n\r\n\t\t\tvar n = srcPlanes.length;\r\n\t\t\tdstPlanes = new Array( n );\r\n\r\n\t\t\tfor ( var i = 0; i !== n; ++ i )\r\n\t\t\t\tdstPlanes[ i ] = srcPlanes[ i ].clone();\r\n\r\n\t\t}\r\n\r\n\t\tthis.clippingPlanes = dstPlanes;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tupdate: function () {\r\n\r\n\t\tthis.dispatchEvent( { type: 'update' } );\r\n\r\n\t},\r\n\r\n\tdispose: function () {\r\n\r\n\t\tthis.dispatchEvent( { type: 'dispose' } );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.EventDispatcher.prototype.apply( THREE.Material.prototype );\r\n\r\nTHREE.MaterialIdCount = 0;\r\n\r\n// File:src/materials/LineBasicMaterial.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  opacity: <float>,\r\n *\r\n *  linewidth: <float>,\r\n *  linecap: \"round\",\r\n *  linejoin: \"round\",\r\n *\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  vertexColors: <bool>\r\n *\r\n *  fog: <bool>\r\n * }\r\n */\r\n\r\nTHREE.LineBasicMaterial = function ( parameters ) {\r\n\r\n\tTHREE.Material.call( this );\r\n\r\n\tthis.type = 'LineBasicMaterial';\r\n\r\n\tthis.color = new THREE.Color( 0xffffff );\r\n\r\n\tthis.linewidth = 1;\r\n\tthis.linecap = 'round';\r\n\tthis.linejoin = 'round';\r\n\r\n\tthis.blending = THREE.NormalBlending;\r\n\r\n\tthis.vertexColors = THREE.NoColors;\r\n\r\n\tthis.fog = true;\r\n\r\n\tthis.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.LineBasicMaterial.prototype = Object.create( THREE.Material.prototype );\r\nTHREE.LineBasicMaterial.prototype.constructor = THREE.LineBasicMaterial;\r\n\r\nTHREE.LineBasicMaterial.prototype.copy = function ( source ) {\r\n\r\n\tTHREE.Material.prototype.copy.call( this, source );\r\n\r\n\tthis.color.copy( source.color );\r\n\r\n\tthis.linewidth = source.linewidth;\r\n\tthis.linecap = source.linecap;\r\n\tthis.linejoin = source.linejoin;\r\n\r\n\tthis.vertexColors = source.vertexColors;\r\n\r\n\tthis.fog = source.fog;\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\n// File:src/materials/LineDashedMaterial.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  opacity: <float>,\r\n *\r\n *  linewidth: <float>,\r\n *\r\n *  scale: <float>,\r\n *  dashSize: <float>,\r\n *  gapSize: <float>,\r\n *\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  vertexColors: THREE.NoColors / THREE.FaceColors / THREE.VertexColors\r\n *\r\n *  fog: <bool>\r\n * }\r\n */\r\n\r\nTHREE.LineDashedMaterial = function ( parameters ) {\r\n\r\n\tTHREE.Material.call( this );\r\n\r\n\tthis.type = 'LineDashedMaterial';\r\n\r\n\tthis.color = new THREE.Color( 0xffffff );\r\n\r\n\tthis.linewidth = 1;\r\n\r\n\tthis.scale = 1;\r\n\tthis.dashSize = 3;\r\n\tthis.gapSize = 1;\r\n\r\n\tthis.blending = THREE.NormalBlending;\r\n\r\n\tthis.vertexColors = THREE.NoColors;\r\n\r\n\tthis.fog = true;\r\n\r\n\tthis.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.LineDashedMaterial.prototype = Object.create( THREE.Material.prototype );\r\nTHREE.LineDashedMaterial.prototype.constructor = THREE.LineDashedMaterial;\r\n\r\nTHREE.LineDashedMaterial.prototype.copy = function ( source ) {\r\n\r\n\tTHREE.Material.prototype.copy.call( this, source );\r\n\r\n\tthis.color.copy( source.color );\r\n\r\n\tthis.linewidth = source.linewidth;\r\n\r\n\tthis.scale = source.scale;\r\n\tthis.dashSize = source.dashSize;\r\n\tthis.gapSize = source.gapSize;\r\n\r\n\tthis.vertexColors = source.vertexColors;\r\n\r\n\tthis.fog = source.fog;\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\n// File:src/materials/MeshBasicMaterial.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  opacity: <float>,\r\n *  map: new THREE.Texture( <Image> ),\r\n *\r\n *  aoMap: new THREE.Texture( <Image> ),\r\n *  aoMapIntensity: <float>\r\n *\r\n *  specularMap: new THREE.Texture( <Image> ),\r\n *\r\n *  alphaMap: new THREE.Texture( <Image> ),\r\n *\r\n *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\r\n *  combine: THREE.Multiply,\r\n *  reflectivity: <float>,\r\n *  refractionRatio: <float>,\r\n *\r\n *  shading: THREE.SmoothShading,\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  wireframe: <boolean>,\r\n *  wireframeLinewidth: <float>,\r\n *\r\n *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,\r\n *\r\n *  skinning: <bool>,\r\n *  morphTargets: <bool>,\r\n *\r\n *  fog: <bool>\r\n * }\r\n */\r\n\r\nTHREE.MeshBasicMaterial = function ( parameters ) {\r\n\r\n\tTHREE.Material.call( this );\r\n\r\n\tthis.type = 'MeshBasicMaterial';\r\n\r\n\tthis.color = new THREE.Color( 0xffffff ); // emissive\r\n\r\n\tthis.map = null;\r\n\r\n\tthis.aoMap = null;\r\n\tthis.aoMapIntensity = 1.0;\r\n\r\n\tthis.specularMap = null;\r\n\r\n\tthis.alphaMap = null;\r\n\r\n\tthis.envMap = null;\r\n\tthis.combine = THREE.MultiplyOperation;\r\n\tthis.reflectivity = 1;\r\n\tthis.refractionRatio = 0.98;\r\n\r\n\tthis.fog = true;\r\n\r\n\tthis.shading = THREE.SmoothShading;\r\n\tthis.blending = THREE.NormalBlending;\r\n\r\n\tthis.wireframe = false;\r\n\tthis.wireframeLinewidth = 1;\r\n\tthis.wireframeLinecap = 'round';\r\n\tthis.wireframeLinejoin = 'round';\r\n\r\n\tthis.vertexColors = THREE.NoColors;\r\n\r\n\tthis.skinning = false;\r\n\tthis.morphTargets = false;\r\n\r\n\tthis.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.MeshBasicMaterial.prototype = Object.create( THREE.Material.prototype );\r\nTHREE.MeshBasicMaterial.prototype.constructor = THREE.MeshBasicMaterial;\r\n\r\nTHREE.MeshBasicMaterial.prototype.copy = function ( source ) {\r\n\r\n\tTHREE.Material.prototype.copy.call( this, source );\r\n\r\n\tthis.color.copy( source.color );\r\n\r\n\tthis.map = source.map;\r\n\r\n\tthis.aoMap = source.aoMap;\r\n\tthis.aoMapIntensity = source.aoMapIntensity;\r\n\r\n\tthis.specularMap = source.specularMap;\r\n\r\n\tthis.alphaMap = source.alphaMap;\r\n\r\n\tthis.envMap = source.envMap;\r\n\tthis.combine = source.combine;\r\n\tthis.reflectivity = source.reflectivity;\r\n\tthis.refractionRatio = source.refractionRatio;\r\n\r\n\tthis.fog = source.fog;\r\n\r\n\tthis.shading = source.shading;\r\n\r\n\tthis.wireframe = source.wireframe;\r\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\r\n\tthis.wireframeLinecap = source.wireframeLinecap;\r\n\tthis.wireframeLinejoin = source.wireframeLinejoin;\r\n\r\n\tthis.vertexColors = source.vertexColors;\r\n\r\n\tthis.skinning = source.skinning;\r\n\tthis.morphTargets = source.morphTargets;\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\n// File:src/materials/MeshDepthMaterial.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author bhouston / https://clara.io\r\n * @author WestLangley / http://github.com/WestLangley\r\n *\r\n * parameters = {\r\n *\r\n *  opacity: <float>,\r\n *\r\n *  map: new THREE.Texture( <Image> ),\r\n *\r\n *  alphaMap: new THREE.Texture( <Image> ),\r\n *\r\n *  displacementMap: new THREE.Texture( <Image> ),\r\n *  displacementScale: <float>,\r\n *  displacementBias: <float>,\r\n *\r\n *  wireframe: <boolean>,\r\n *  wireframeLinewidth: <float>\r\n * }\r\n */\r\n\r\nTHREE.MeshDepthMaterial = function ( parameters ) {\r\n\r\n\tTHREE.Material.call( this );\r\n\r\n\tthis.type = 'MeshDepthMaterial';\r\n\r\n\tthis.depthPacking = THREE.BasicDepthPacking;\r\n\r\n\tthis.skinning = false;\r\n\tthis.morphTargets = false;\r\n\r\n\tthis.map = null;\r\n\r\n\tthis.alphaMap = null;\r\n\r\n\tthis.displacementMap = null;\r\n\tthis.displacementScale = 1;\r\n\tthis.displacementBias = 0;\r\n\r\n\tthis.wireframe = false;\r\n\tthis.wireframeLinewidth = 1;\r\n\r\n\tthis.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.MeshDepthMaterial.prototype = Object.create( THREE.Material.prototype );\r\nTHREE.MeshDepthMaterial.prototype.constructor = THREE.MeshDepthMaterial;\r\n\r\nTHREE.MeshDepthMaterial.prototype.copy = function ( source ) {\r\n\r\n\tTHREE.Material.prototype.copy.call( this, source );\r\n\r\n\tthis.depthPacking = source.depthPacking;\r\n\r\n\tthis.skinning = source.skinning;\r\n\tthis.morphTargets = source.morphTargets;\r\n\r\n\tthis.map = source.map;\r\n\r\n\tthis.alphaMap = source.alphaMap;\r\n\r\n\tthis.displacementMap = source.displacementMap;\r\n\tthis.displacementScale = source.displacementScale;\r\n\tthis.displacementBias = source.displacementBias;\r\n\r\n\tthis.wireframe = source.wireframe;\r\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\n// File:src/materials/MeshLambertMaterial.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  opacity: <float>,\r\n *\r\n *  map: new THREE.Texture( <Image> ),\r\n *\r\n *  lightMap: new THREE.Texture( <Image> ),\r\n *  lightMapIntensity: <float>\r\n *\r\n *  aoMap: new THREE.Texture( <Image> ),\r\n *  aoMapIntensity: <float>\r\n *\r\n *  emissive: <hex>,\r\n *  emissiveIntensity: <float>\r\n *  emissiveMap: new THREE.Texture( <Image> ),\r\n *\r\n *  specularMap: new THREE.Texture( <Image> ),\r\n *\r\n *  alphaMap: new THREE.Texture( <Image> ),\r\n *\r\n *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\r\n *  combine: THREE.Multiply,\r\n *  reflectivity: <float>,\r\n *  refractionRatio: <float>,\r\n *\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  wireframe: <boolean>,\r\n *  wireframeLinewidth: <float>,\r\n *\r\n *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,\r\n *\r\n *  skinning: <bool>,\r\n *  morphTargets: <bool>,\r\n *  morphNormals: <bool>,\r\n *\r\n *\tfog: <bool>\r\n * }\r\n */\r\n\r\nTHREE.MeshLambertMaterial = function ( parameters ) {\r\n\r\n\tTHREE.Material.call( this );\r\n\r\n\tthis.type = 'MeshLambertMaterial';\r\n\r\n\tthis.color = new THREE.Color( 0xffffff ); // diffuse\r\n\r\n\tthis.map = null;\r\n\r\n\tthis.lightMap = null;\r\n\tthis.lightMapIntensity = 1.0;\r\n\r\n\tthis.aoMap = null;\r\n\tthis.aoMapIntensity = 1.0;\r\n\r\n\tthis.emissive = new THREE.Color( 0x000000 );\r\n\tthis.emissiveIntensity = 1.0;\r\n\tthis.emissiveMap = null;\r\n\r\n\tthis.specularMap = null;\r\n\r\n\tthis.alphaMap = null;\r\n\r\n\tthis.envMap = null;\r\n\tthis.combine = THREE.MultiplyOperation;\r\n\tthis.reflectivity = 1;\r\n\tthis.refractionRatio = 0.98;\r\n\r\n\tthis.fog = true;\r\n\r\n\tthis.blending = THREE.NormalBlending;\r\n\r\n\tthis.wireframe = false;\r\n\tthis.wireframeLinewidth = 1;\r\n\tthis.wireframeLinecap = 'round';\r\n\tthis.wireframeLinejoin = 'round';\r\n\r\n\tthis.vertexColors = THREE.NoColors;\r\n\r\n\tthis.skinning = false;\r\n\tthis.morphTargets = false;\r\n\tthis.morphNormals = false;\r\n\r\n\tthis.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.MeshLambertMaterial.prototype = Object.create( THREE.Material.prototype );\r\nTHREE.MeshLambertMaterial.prototype.constructor = THREE.MeshLambertMaterial;\r\n\r\nTHREE.MeshLambertMaterial.prototype.copy = function ( source ) {\r\n\r\n\tTHREE.Material.prototype.copy.call( this, source );\r\n\r\n\tthis.color.copy( source.color );\r\n\r\n\tthis.map = source.map;\r\n\r\n\tthis.lightMap = source.lightMap;\r\n\tthis.lightMapIntensity = source.lightMapIntensity;\r\n\r\n\tthis.aoMap = source.aoMap;\r\n\tthis.aoMapIntensity = source.aoMapIntensity;\r\n\r\n\tthis.emissive.copy( source.emissive );\r\n\tthis.emissiveMap = source.emissiveMap;\r\n\tthis.emissiveIntensity = source.emissiveIntensity;\r\n\r\n\tthis.specularMap = source.specularMap;\r\n\r\n\tthis.alphaMap = source.alphaMap;\r\n\r\n\tthis.envMap = source.envMap;\r\n\tthis.combine = source.combine;\r\n\tthis.reflectivity = source.reflectivity;\r\n\tthis.refractionRatio = source.refractionRatio;\r\n\r\n\tthis.fog = source.fog;\r\n\r\n\tthis.wireframe = source.wireframe;\r\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\r\n\tthis.wireframeLinecap = source.wireframeLinecap;\r\n\tthis.wireframeLinejoin = source.wireframeLinejoin;\r\n\r\n\tthis.vertexColors = source.vertexColors;\r\n\r\n\tthis.skinning = source.skinning;\r\n\tthis.morphTargets = source.morphTargets;\r\n\tthis.morphNormals = source.morphNormals;\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\n// File:src/materials/MeshNormalMaterial.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n *\r\n * parameters = {\r\n *  opacity: <float>,\r\n *\r\n *  wireframe: <boolean>,\r\n *  wireframeLinewidth: <float>\r\n * }\r\n */\r\n\r\nTHREE.MeshNormalMaterial = function ( parameters ) {\r\n\r\n\tTHREE.Material.call( this, parameters );\r\n\r\n\tthis.type = 'MeshNormalMaterial';\r\n\r\n\tthis.wireframe = false;\r\n\tthis.wireframeLinewidth = 1;\r\n\r\n\tthis.morphTargets = false;\r\n\r\n\tthis.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.MeshNormalMaterial.prototype = Object.create( THREE.Material.prototype );\r\nTHREE.MeshNormalMaterial.prototype.constructor = THREE.MeshNormalMaterial;\r\n\r\nTHREE.MeshNormalMaterial.prototype.copy = function ( source ) {\r\n\r\n\tTHREE.Material.prototype.copy.call( this, source );\r\n\r\n\tthis.wireframe = source.wireframe;\r\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\n// File:src/materials/MeshPhongMaterial.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  specular: <hex>,\r\n *  shininess: <float>,\r\n *  opacity: <float>,\r\n *\r\n *  map: new THREE.Texture( <Image> ),\r\n *\r\n *  lightMap: new THREE.Texture( <Image> ),\r\n *  lightMapIntensity: <float>\r\n *\r\n *  aoMap: new THREE.Texture( <Image> ),\r\n *  aoMapIntensity: <float>\r\n *\r\n *  emissive: <hex>,\r\n *  emissiveIntensity: <float>\r\n *  emissiveMap: new THREE.Texture( <Image> ),\r\n *\r\n *  bumpMap: new THREE.Texture( <Image> ),\r\n *  bumpScale: <float>,\r\n *\r\n *  normalMap: new THREE.Texture( <Image> ),\r\n *  normalScale: <Vector2>,\r\n *\r\n *  displacementMap: new THREE.Texture( <Image> ),\r\n *  displacementScale: <float>,\r\n *  displacementBias: <float>,\r\n *\r\n *  specularMap: new THREE.Texture( <Image> ),\r\n *\r\n *  alphaMap: new THREE.Texture( <Image> ),\r\n *\r\n *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\r\n *  combine: THREE.Multiply,\r\n *  reflectivity: <float>,\r\n *  refractionRatio: <float>,\r\n *\r\n *  shading: THREE.SmoothShading,\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  wireframe: <boolean>,\r\n *  wireframeLinewidth: <float>,\r\n *\r\n *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,\r\n *\r\n *  skinning: <bool>,\r\n *  morphTargets: <bool>,\r\n *  morphNormals: <bool>,\r\n *\r\n *\tfog: <bool>\r\n * }\r\n */\r\n\r\nTHREE.MeshPhongMaterial = function ( parameters ) {\r\n\r\n\tTHREE.Material.call( this );\r\n\r\n\tthis.type = 'MeshPhongMaterial';\r\n\r\n\tthis.color = new THREE.Color( 0xffffff ); // diffuse\r\n\tthis.specular = new THREE.Color( 0x111111 );\r\n\tthis.shininess = 30;\r\n\r\n\tthis.map = null;\r\n\r\n\tthis.lightMap = null;\r\n\tthis.lightMapIntensity = 1.0;\r\n\r\n\tthis.aoMap = null;\r\n\tthis.aoMapIntensity = 1.0;\r\n\r\n\tthis.emissive = new THREE.Color( 0x000000 );\r\n\tthis.emissiveIntensity = 1.0;\r\n\tthis.emissiveMap = null;\r\n\r\n\tthis.bumpMap = null;\r\n\tthis.bumpScale = 1;\r\n\r\n\tthis.normalMap = null;\r\n\tthis.normalScale = new THREE.Vector2( 1, 1 );\r\n\r\n\tthis.displacementMap = null;\r\n\tthis.displacementScale = 1;\r\n\tthis.displacementBias = 0;\r\n\r\n\tthis.specularMap = null;\r\n\r\n\tthis.alphaMap = null;\r\n\r\n\tthis.envMap = null;\r\n\tthis.combine = THREE.MultiplyOperation;\r\n\tthis.reflectivity = 1;\r\n\tthis.refractionRatio = 0.98;\r\n\r\n\tthis.fog = true;\r\n\r\n\tthis.shading = THREE.SmoothShading;\r\n\tthis.blending = THREE.NormalBlending;\r\n\r\n\tthis.wireframe = false;\r\n\tthis.wireframeLinewidth = 1;\r\n\tthis.wireframeLinecap = 'round';\r\n\tthis.wireframeLinejoin = 'round';\r\n\r\n\tthis.vertexColors = THREE.NoColors;\r\n\r\n\tthis.skinning = false;\r\n\tthis.morphTargets = false;\r\n\tthis.morphNormals = false;\r\n\r\n\tthis.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.MeshPhongMaterial.prototype = Object.create( THREE.Material.prototype );\r\nTHREE.MeshPhongMaterial.prototype.constructor = THREE.MeshPhongMaterial;\r\n\r\nTHREE.MeshPhongMaterial.prototype.copy = function ( source ) {\r\n\r\n\tTHREE.Material.prototype.copy.call( this, source );\r\n\r\n\tthis.color.copy( source.color );\r\n\tthis.specular.copy( source.specular );\r\n\tthis.shininess = source.shininess;\r\n\r\n\tthis.map = source.map;\r\n\r\n\tthis.lightMap = source.lightMap;\r\n\tthis.lightMapIntensity = source.lightMapIntensity;\r\n\r\n\tthis.aoMap = source.aoMap;\r\n\tthis.aoMapIntensity = source.aoMapIntensity;\r\n\r\n\tthis.emissive.copy( source.emissive );\r\n\tthis.emissiveMap = source.emissiveMap;\r\n\tthis.emissiveIntensity = source.emissiveIntensity;\r\n\r\n\tthis.bumpMap = source.bumpMap;\r\n\tthis.bumpScale = source.bumpScale;\r\n\r\n\tthis.normalMap = source.normalMap;\r\n\tthis.normalScale.copy( source.normalScale );\r\n\r\n\tthis.displacementMap = source.displacementMap;\r\n\tthis.displacementScale = source.displacementScale;\r\n\tthis.displacementBias = source.displacementBias;\r\n\r\n\tthis.specularMap = source.specularMap;\r\n\r\n\tthis.alphaMap = source.alphaMap;\r\n\r\n\tthis.envMap = source.envMap;\r\n\tthis.combine = source.combine;\r\n\tthis.reflectivity = source.reflectivity;\r\n\tthis.refractionRatio = source.refractionRatio;\r\n\r\n\tthis.fog = source.fog;\r\n\r\n\tthis.shading = source.shading;\r\n\r\n\tthis.wireframe = source.wireframe;\r\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\r\n\tthis.wireframeLinecap = source.wireframeLinecap;\r\n\tthis.wireframeLinejoin = source.wireframeLinejoin;\r\n\r\n\tthis.vertexColors = source.vertexColors;\r\n\r\n\tthis.skinning = source.skinning;\r\n\tthis.morphTargets = source.morphTargets;\r\n\tthis.morphNormals = source.morphNormals;\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\n// File:src/materials/MeshStandardMaterial.js\r\n\r\n/**\r\n * @author WestLangley / http://github.com/WestLangley\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  roughness: <float>,\r\n *  metalness: <float>,\r\n *  opacity: <float>,\r\n *\r\n *  map: new THREE.Texture( <Image> ),\r\n *\r\n *  lightMap: new THREE.Texture( <Image> ),\r\n *  lightMapIntensity: <float>\r\n *\r\n *  aoMap: new THREE.Texture( <Image> ),\r\n *  aoMapIntensity: <float>\r\n *\r\n *  emissive: <hex>,\r\n *  emissiveIntensity: <float>\r\n *  emissiveMap: new THREE.Texture( <Image> ),\r\n *\r\n *  bumpMap: new THREE.Texture( <Image> ),\r\n *  bumpScale: <float>,\r\n *\r\n *  normalMap: new THREE.Texture( <Image> ),\r\n *  normalScale: <Vector2>,\r\n *\r\n *  displacementMap: new THREE.Texture( <Image> ),\r\n *  displacementScale: <float>,\r\n *  displacementBias: <float>,\r\n *\r\n *  roughnessMap: new THREE.Texture( <Image> ),\r\n *\r\n *  metalnessMap: new THREE.Texture( <Image> ),\r\n *\r\n *  alphaMap: new THREE.Texture( <Image> ),\r\n *\r\n *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),\r\n *  envMapIntensity: <float>\r\n *\r\n *  refractionRatio: <float>,\r\n *\r\n *  shading: THREE.SmoothShading,\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  wireframe: <boolean>,\r\n *  wireframeLinewidth: <float>,\r\n *\r\n *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,\r\n *\r\n *  skinning: <bool>,\r\n *  morphTargets: <bool>,\r\n *  morphNormals: <bool>,\r\n *\r\n *\tfog: <bool>\r\n * }\r\n */\r\n\r\nTHREE.MeshStandardMaterial = function ( parameters ) {\r\n\r\n\tTHREE.Material.call( this );\r\n\r\n\tthis.defines = { 'STANDARD': '' };\r\n\r\n\tthis.type = 'MeshStandardMaterial';\r\n\r\n\tthis.color = new THREE.Color( 0xffffff ); // diffuse\r\n\tthis.roughness = 0.5;\r\n\tthis.metalness = 0.5;\r\n\r\n\tthis.map = null;\r\n\r\n\tthis.lightMap = null;\r\n\tthis.lightMapIntensity = 1.0;\r\n\r\n\tthis.aoMap = null;\r\n\tthis.aoMapIntensity = 1.0;\r\n\r\n\tthis.emissive = new THREE.Color( 0x000000 );\r\n\tthis.emissiveIntensity = 1.0;\r\n\tthis.emissiveMap = null;\r\n\r\n\tthis.bumpMap = null;\r\n\tthis.bumpScale = 1;\r\n\r\n\tthis.normalMap = null;\r\n\tthis.normalScale = new THREE.Vector2( 1, 1 );\r\n\r\n\tthis.displacementMap = null;\r\n\tthis.displacementScale = 1;\r\n\tthis.displacementBias = 0;\r\n\r\n\tthis.roughnessMap = null;\r\n\r\n\tthis.metalnessMap = null;\r\n\r\n\tthis.alphaMap = null;\r\n\r\n\tthis.envMap = null;\r\n\tthis.envMapIntensity = 1.0;\r\n\r\n\tthis.refractionRatio = 0.98;\r\n\r\n\tthis.fog = true;\r\n\r\n\tthis.shading = THREE.SmoothShading;\r\n\tthis.blending = THREE.NormalBlending;\r\n\r\n\tthis.wireframe = false;\r\n\tthis.wireframeLinewidth = 1;\r\n\tthis.wireframeLinecap = 'round';\r\n\tthis.wireframeLinejoin = 'round';\r\n\r\n\tthis.vertexColors = THREE.NoColors;\r\n\r\n\tthis.skinning = false;\r\n\tthis.morphTargets = false;\r\n\tthis.morphNormals = false;\r\n\r\n\tthis.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.MeshStandardMaterial.prototype = Object.create( THREE.Material.prototype );\r\nTHREE.MeshStandardMaterial.prototype.constructor = THREE.MeshStandardMaterial;\r\n\r\nTHREE.MeshStandardMaterial.prototype.copy = function ( source ) {\r\n\r\n\tTHREE.Material.prototype.copy.call( this, source );\r\n\r\n\tthis.defines = { 'STANDARD': '' };\r\n\r\n\tthis.color.copy( source.color );\r\n\tthis.roughness = source.roughness;\r\n\tthis.metalness = source.metalness;\r\n\r\n\tthis.map = source.map;\r\n\r\n\tthis.lightMap = source.lightMap;\r\n\tthis.lightMapIntensity = source.lightMapIntensity;\r\n\r\n\tthis.aoMap = source.aoMap;\r\n\tthis.aoMapIntensity = source.aoMapIntensity;\r\n\r\n\tthis.emissive.copy( source.emissive );\r\n\tthis.emissiveMap = source.emissiveMap;\r\n\tthis.emissiveIntensity = source.emissiveIntensity;\r\n\r\n\tthis.bumpMap = source.bumpMap;\r\n\tthis.bumpScale = source.bumpScale;\r\n\r\n\tthis.normalMap = source.normalMap;\r\n\tthis.normalScale.copy( source.normalScale );\r\n\r\n\tthis.displacementMap = source.displacementMap;\r\n\tthis.displacementScale = source.displacementScale;\r\n\tthis.displacementBias = source.displacementBias;\r\n\r\n\tthis.roughnessMap = source.roughnessMap;\r\n\r\n\tthis.metalnessMap = source.metalnessMap;\r\n\r\n\tthis.alphaMap = source.alphaMap;\r\n\r\n\tthis.envMap = source.envMap;\r\n\tthis.envMapIntensity = source.envMapIntensity;\r\n\r\n\tthis.refractionRatio = source.refractionRatio;\r\n\r\n\tthis.fog = source.fog;\r\n\r\n\tthis.shading = source.shading;\r\n\r\n\tthis.wireframe = source.wireframe;\r\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\r\n\tthis.wireframeLinecap = source.wireframeLinecap;\r\n\tthis.wireframeLinejoin = source.wireframeLinejoin;\r\n\r\n\tthis.vertexColors = source.vertexColors;\r\n\r\n\tthis.skinning = source.skinning;\r\n\tthis.morphTargets = source.morphTargets;\r\n\tthis.morphNormals = source.morphNormals;\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\n// File:src/materials/MeshPhysicalMaterial.js\r\n\r\n/**\r\n * @author WestLangley / http://github.com/WestLangley\r\n *\r\n * parameters = {\r\n *  reflectivity: <float>\r\n * }\r\n */\r\n\r\nTHREE.MeshPhysicalMaterial = function ( parameters ) {\r\n\r\n\tTHREE.MeshStandardMaterial.call( this );\r\n\r\n\tthis.defines = { 'PHYSICAL': '' };\r\n\r\n\tthis.type = 'MeshPhysicalMaterial';\r\n\r\n\tthis.reflectivity = 0.5; // maps to F0 = 0.04\r\n\r\n\tthis.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.MeshPhysicalMaterial.prototype = Object.create( THREE.MeshStandardMaterial.prototype );\r\nTHREE.MeshPhysicalMaterial.prototype.constructor = THREE.MeshPhysicalMaterial;\r\n\r\nTHREE.MeshPhysicalMaterial.prototype.copy = function ( source ) {\r\n\r\n\tTHREE.MeshStandardMaterial.prototype.copy.call( this, source );\r\n\r\n\tthis.defines = { 'PHYSICAL': '' };\r\n\r\n\tthis.reflectivity = source.reflectivity;\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\n// File:src/materials/MultiMaterial.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.MultiMaterial = function ( materials ) {\r\n\r\n\tthis.uuid = THREE.Math.generateUUID();\r\n\r\n\tthis.type = 'MultiMaterial';\r\n\r\n\tthis.materials = materials instanceof Array ? materials : [];\r\n\r\n\tthis.visible = true;\r\n\r\n};\r\n\r\nTHREE.MultiMaterial.prototype = {\r\n\r\n\tconstructor: THREE.MultiMaterial,\r\n\r\n\ttoJSON: function ( meta ) {\r\n\r\n\t\tvar output = {\r\n\t\t\tmetadata: {\r\n\t\t\t\tversion: 4.2,\r\n\t\t\t\ttype: 'material',\r\n\t\t\t\tgenerator: 'MaterialExporter'\r\n\t\t\t},\r\n\t\t\tuuid: this.uuid,\r\n\t\t\ttype: this.type,\r\n\t\t\tmaterials: []\r\n\t\t};\r\n\r\n\t\tvar materials = this.materials;\r\n\r\n\t\tfor ( var i = 0, l = materials.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar material = materials[ i ].toJSON( meta );\r\n\t\t\tdelete material.metadata;\r\n\r\n\t\t\toutput.materials.push( material );\r\n\r\n\t\t}\r\n\r\n\t\toutput.visible = this.visible;\r\n\r\n\t\treturn output;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\tvar material = new this.constructor();\r\n\r\n\t\tfor ( var i = 0; i < this.materials.length; i ++ ) {\r\n\r\n\t\t\tmaterial.materials.push( this.materials[ i ].clone() );\r\n\r\n\t\t}\r\n\r\n\t\tmaterial.visible = this.visible;\r\n\r\n\t\treturn material;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/materials/PointsMaterial.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  opacity: <float>,\r\n *  map: new THREE.Texture( <Image> ),\r\n *\r\n *  size: <float>,\r\n *  sizeAttenuation: <bool>,\r\n *\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  vertexColors: <bool>,\r\n *\r\n *  fog: <bool>\r\n * }\r\n */\r\n\r\nTHREE.PointsMaterial = function ( parameters ) {\r\n\r\n\tTHREE.Material.call( this );\r\n\r\n\tthis.type = 'PointsMaterial';\r\n\r\n\tthis.color = new THREE.Color( 0xffffff );\r\n\r\n\tthis.map = null;\r\n\r\n\tthis.size = 1;\r\n\tthis.sizeAttenuation = true;\r\n\r\n\tthis.blending = THREE.NormalBlending;\r\n\r\n\tthis.vertexColors = THREE.NoColors;\r\n\r\n\tthis.fog = true;\r\n\r\n\tthis.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.PointsMaterial.prototype = Object.create( THREE.Material.prototype );\r\nTHREE.PointsMaterial.prototype.constructor = THREE.PointsMaterial;\r\n\r\nTHREE.PointsMaterial.prototype.copy = function ( source ) {\r\n\r\n\tTHREE.Material.prototype.copy.call( this, source );\r\n\r\n\tthis.color.copy( source.color );\r\n\r\n\tthis.map = source.map;\r\n\r\n\tthis.size = source.size;\r\n\tthis.sizeAttenuation = source.sizeAttenuation;\r\n\r\n\tthis.vertexColors = source.vertexColors;\r\n\r\n\tthis.fog = source.fog;\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\n// File:src/materials/ShaderMaterial.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  defines: { \"label\" : \"value\" },\r\n *  uniforms: { \"parameter1\": { type: \"1f\", value: 1.0 }, \"parameter2\": { type: \"1i\" value2: 2 } },\r\n *\r\n *  fragmentShader: <string>,\r\n *  vertexShader: <string>,\r\n *\r\n *  shading: THREE.SmoothShading,\r\n *\r\n *  wireframe: <boolean>,\r\n *  wireframeLinewidth: <float>,\r\n *\r\n *  lights: <bool>,\r\n *\r\n *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,\r\n *\r\n *  skinning: <bool>,\r\n *  morphTargets: <bool>,\r\n *  morphNormals: <bool>,\r\n *\r\n *\tfog: <bool>\r\n * }\r\n */\r\n\r\nTHREE.ShaderMaterial = function ( parameters ) {\r\n\r\n\tTHREE.Material.call( this );\r\n\r\n\tthis.type = 'ShaderMaterial';\r\n\r\n\tthis.defines = {};\r\n\tthis.uniforms = {};\r\n\r\n\tthis.vertexShader = 'void main() {\\n\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}';\r\n\tthis.fragmentShader = 'void main() {\\n\\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\\n}';\r\n\r\n\tthis.shading = THREE.SmoothShading;\r\n\r\n\tthis.linewidth = 1;\r\n\r\n\tthis.wireframe = false;\r\n\tthis.wireframeLinewidth = 1;\r\n\r\n\tthis.fog = false; // set to use scene fog\r\n\r\n\tthis.lights = false; // set to use scene lights\r\n\tthis.clipping = false; // set to use user-defined clipping planes\r\n\r\n\tthis.vertexColors = THREE.NoColors; // set to use \"color\" attribute stream\r\n\r\n\tthis.skinning = false; // set to use skinning attribute streams\r\n\r\n\tthis.morphTargets = false; // set to use morph targets\r\n\tthis.morphNormals = false; // set to use morph normals\r\n\r\n\tthis.extensions = {\r\n\t\tderivatives: false, // set to use derivatives\r\n\t\tfragDepth: false, // set to use fragment depth values\r\n\t\tdrawBuffers: false, // set to use draw buffers\r\n\t\tshaderTextureLOD: false // set to use shader texture LOD\r\n\t};\r\n\r\n\t// When rendered geometry doesn't include these attributes but the material does,\r\n\t// use these default values in WebGL. This avoids errors when buffer data is missing.\r\n\tthis.defaultAttributeValues = {\r\n\t\t'color': [ 1, 1, 1 ],\r\n\t\t'uv': [ 0, 0 ],\r\n\t\t'uv2': [ 0, 0 ]\r\n\t};\r\n\r\n\tthis.index0AttributeName = undefined;\r\n\r\n\tif ( parameters !== undefined ) {\r\n\r\n\t\tif ( parameters.attributes !== undefined ) {\r\n\r\n\t\t\tconsole.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );\r\n\r\n\t\t}\r\n\r\n\t\tthis.setValues( parameters );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.ShaderMaterial.prototype = Object.create( THREE.Material.prototype );\r\nTHREE.ShaderMaterial.prototype.constructor = THREE.ShaderMaterial;\r\n\r\nTHREE.ShaderMaterial.prototype.copy = function ( source ) {\r\n\r\n\tTHREE.Material.prototype.copy.call( this, source );\r\n\r\n\tthis.fragmentShader = source.fragmentShader;\r\n\tthis.vertexShader = source.vertexShader;\r\n\r\n\tthis.uniforms = THREE.UniformsUtils.clone( source.uniforms );\r\n\r\n\tthis.defines = source.defines;\r\n\r\n\tthis.shading = source.shading;\r\n\r\n\tthis.wireframe = source.wireframe;\r\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\r\n\r\n\tthis.fog = source.fog;\r\n\r\n\tthis.lights = source.lights;\r\n\tthis.clipping = source.clipping;\r\n\r\n\tthis.vertexColors = source.vertexColors;\r\n\r\n\tthis.skinning = source.skinning;\r\n\r\n\tthis.morphTargets = source.morphTargets;\r\n\tthis.morphNormals = source.morphNormals;\r\n\r\n\tthis.extensions = source.extensions;\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\nTHREE.ShaderMaterial.prototype.toJSON = function ( meta ) {\r\n\r\n\tvar data = THREE.Material.prototype.toJSON.call( this, meta );\r\n\r\n\tdata.uniforms = this.uniforms;\r\n\tdata.vertexShader = this.vertexShader;\r\n\tdata.fragmentShader = this.fragmentShader;\r\n\r\n\treturn data;\r\n\r\n};\r\n\r\n// File:src/materials/RawShaderMaterial.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.RawShaderMaterial = function ( parameters ) {\r\n\r\n\tTHREE.ShaderMaterial.call( this, parameters );\r\n\r\n\tthis.type = 'RawShaderMaterial';\r\n\r\n};\r\n\r\nTHREE.RawShaderMaterial.prototype = Object.create( THREE.ShaderMaterial.prototype );\r\nTHREE.RawShaderMaterial.prototype.constructor = THREE.RawShaderMaterial;\r\n\r\n// File:src/materials/SpriteMaterial.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  opacity: <float>,\r\n *  map: new THREE.Texture( <Image> ),\r\n *\r\n *\tuvOffset: new THREE.Vector2(),\r\n *\tuvScale: new THREE.Vector2(),\r\n *\r\n *  fog: <bool>\r\n * }\r\n */\r\n\r\nTHREE.SpriteMaterial = function ( parameters ) {\r\n\r\n\tTHREE.Material.call( this );\r\n\r\n\tthis.type = 'SpriteMaterial';\r\n\r\n\tthis.color = new THREE.Color( 0xffffff );\r\n\tthis.map = null;\r\n\r\n\tthis.rotation = 0;\r\n\r\n\tthis.fog = false;\r\n\r\n\t// set parameters\r\n\r\n\tthis.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.SpriteMaterial.prototype = Object.create( THREE.Material.prototype );\r\nTHREE.SpriteMaterial.prototype.constructor = THREE.SpriteMaterial;\r\n\r\nTHREE.SpriteMaterial.prototype.copy = function ( source ) {\r\n\r\n\tTHREE.Material.prototype.copy.call( this, source );\r\n\r\n\tthis.color.copy( source.color );\r\n\tthis.map = source.map;\r\n\r\n\tthis.rotation = source.rotation;\r\n\r\n\tthis.fog = source.fog;\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\n// File:src/textures/Texture.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author szimek / https://github.com/szimek/\r\n */\r\n\r\nTHREE.Texture = function ( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {\r\n\r\n\tObject.defineProperty( this, 'id', { value: THREE.TextureIdCount ++ } );\r\n\r\n\tthis.uuid = THREE.Math.generateUUID();\r\n\r\n\tthis.name = '';\r\n\tthis.sourceFile = '';\r\n\r\n\tthis.image = image !== undefined ? image : THREE.Texture.DEFAULT_IMAGE;\r\n\tthis.mipmaps = [];\r\n\r\n\tthis.mapping = mapping !== undefined ? mapping : THREE.Texture.DEFAULT_MAPPING;\r\n\r\n\tthis.wrapS = wrapS !== undefined ? wrapS : THREE.ClampToEdgeWrapping;\r\n\tthis.wrapT = wrapT !== undefined ? wrapT : THREE.ClampToEdgeWrapping;\r\n\r\n\tthis.magFilter = magFilter !== undefined ? magFilter : THREE.LinearFilter;\r\n\tthis.minFilter = minFilter !== undefined ? minFilter : THREE.LinearMipMapLinearFilter;\r\n\r\n\tthis.anisotropy = anisotropy !== undefined ? anisotropy : 1;\r\n\r\n\tthis.format = format !== undefined ? format : THREE.RGBAFormat;\r\n\tthis.type = type !== undefined ? type : THREE.UnsignedByteType;\r\n\r\n\tthis.offset = new THREE.Vector2( 0, 0 );\r\n\tthis.repeat = new THREE.Vector2( 1, 1 );\r\n\r\n\tthis.generateMipmaps = true;\r\n\tthis.premultiplyAlpha = false;\r\n\tthis.flipY = true;\r\n\tthis.unpackAlignment = 4;\t// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)\r\n\r\n\r\n\t// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.\r\n\t//\r\n\t// Also changing the encoding after already used by a Material will not automatically make the Material\r\n\t// update.  You need to explicitly call Material.needsUpdate to trigger it to recompile.\r\n\tthis.encoding = encoding !== undefined ? encoding :  THREE.LinearEncoding;\r\n\r\n\tthis.version = 0;\r\n\tthis.onUpdate = null;\r\n\r\n};\r\n\r\nTHREE.Texture.DEFAULT_IMAGE = undefined;\r\nTHREE.Texture.DEFAULT_MAPPING = THREE.UVMapping;\r\n\r\nTHREE.Texture.prototype = {\r\n\r\n\tconstructor: THREE.Texture,\r\n\r\n\tset needsUpdate ( value ) {\r\n\r\n\t\tif ( value === true ) this.version ++;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\r\n\t},\r\n\r\n\tcopy: function ( source ) {\r\n\r\n\t\tthis.image = source.image;\r\n\t\tthis.mipmaps = source.mipmaps.slice( 0 );\r\n\r\n\t\tthis.mapping = source.mapping;\r\n\r\n\t\tthis.wrapS = source.wrapS;\r\n\t\tthis.wrapT = source.wrapT;\r\n\r\n\t\tthis.magFilter = source.magFilter;\r\n\t\tthis.minFilter = source.minFilter;\r\n\r\n\t\tthis.anisotropy = source.anisotropy;\r\n\r\n\t\tthis.format = source.format;\r\n\t\tthis.type = source.type;\r\n\r\n\t\tthis.offset.copy( source.offset );\r\n\t\tthis.repeat.copy( source.repeat );\r\n\r\n\t\tthis.generateMipmaps = source.generateMipmaps;\r\n\t\tthis.premultiplyAlpha = source.premultiplyAlpha;\r\n\t\tthis.flipY = source.flipY;\r\n\t\tthis.unpackAlignment = source.unpackAlignment;\r\n\t\tthis.encoding = source.encoding;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoJSON: function ( meta ) {\r\n\r\n\t\tif ( meta.textures[ this.uuid ] !== undefined ) {\r\n\r\n\t\t\treturn meta.textures[ this.uuid ];\r\n\r\n\t\t}\r\n\r\n\t\tfunction getDataURL( image ) {\r\n\r\n\t\t\tvar canvas;\r\n\r\n\t\t\tif ( image.toDataURL !== undefined ) {\r\n\r\n\t\t\t\tcanvas = image;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tcanvas = document.createElement( 'canvas' );\r\n\t\t\t\tcanvas.width = image.width;\r\n\t\t\t\tcanvas.height = image.height;\r\n\r\n\t\t\t\tcanvas.getContext( '2d' ).drawImage( image, 0, 0, image.width, image.height );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( canvas.width > 2048 || canvas.height > 2048 ) {\r\n\r\n\t\t\t\treturn canvas.toDataURL( 'image/jpeg', 0.6 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\treturn canvas.toDataURL( 'image/png' );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar output = {\r\n\t\t\tmetadata: {\r\n\t\t\t\tversion: 4.4,\r\n\t\t\t\ttype: 'Texture',\r\n\t\t\t\tgenerator: 'Texture.toJSON'\r\n\t\t\t},\r\n\r\n\t\t\tuuid: this.uuid,\r\n\t\t\tname: this.name,\r\n\r\n\t\t\tmapping: this.mapping,\r\n\r\n\t\t\trepeat: [ this.repeat.x, this.repeat.y ],\r\n\t\t\toffset: [ this.offset.x, this.offset.y ],\r\n\t\t\twrap: [ this.wrapS, this.wrapT ],\r\n\r\n\t\t\tminFilter: this.minFilter,\r\n\t\t\tmagFilter: this.magFilter,\r\n\t\t\tanisotropy: this.anisotropy\r\n\t\t};\r\n\r\n\t\tif ( this.image !== undefined ) {\r\n\r\n\t\t\t// TODO: Move to THREE.Image\r\n\r\n\t\t\tvar image = this.image;\r\n\r\n\t\t\tif ( image.uuid === undefined ) {\r\n\r\n\t\t\t\timage.uuid = THREE.Math.generateUUID(); // UGH\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( meta.images[ image.uuid ] === undefined ) {\r\n\r\n\t\t\t\tmeta.images[ image.uuid ] = {\r\n\t\t\t\t\tuuid: image.uuid,\r\n\t\t\t\t\turl: getDataURL( image )\r\n\t\t\t\t};\r\n\r\n\t\t\t}\r\n\r\n\t\t\toutput.image = image.uuid;\r\n\r\n\t\t}\r\n\r\n\t\tmeta.textures[ this.uuid ] = output;\r\n\r\n\t\treturn output;\r\n\r\n\t},\r\n\r\n\tdispose: function () {\r\n\r\n\t\tthis.dispatchEvent( { type: 'dispose' } );\r\n\r\n\t},\r\n\r\n\ttransformUv: function ( uv ) {\r\n\r\n\t\tif ( this.mapping !== THREE.UVMapping )  return;\r\n\r\n\t\tuv.multiply( this.repeat );\r\n\t\tuv.add( this.offset );\r\n\r\n\t\tif ( uv.x < 0 || uv.x > 1 ) {\r\n\r\n\t\t\tswitch ( this.wrapS ) {\r\n\r\n\t\t\t\tcase THREE.RepeatWrapping:\r\n\r\n\t\t\t\t\tuv.x = uv.x - Math.floor( uv.x );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase THREE.ClampToEdgeWrapping:\r\n\r\n\t\t\t\t\tuv.x = uv.x < 0 ? 0 : 1;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase THREE.MirroredRepeatWrapping:\r\n\r\n\t\t\t\t\tif ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {\r\n\r\n\t\t\t\t\t\tuv.x = Math.ceil( uv.x ) - uv.x;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tuv.x = uv.x - Math.floor( uv.x );\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( uv.y < 0 || uv.y > 1 ) {\r\n\r\n\t\t\tswitch ( this.wrapT ) {\r\n\r\n\t\t\t\tcase THREE.RepeatWrapping:\r\n\r\n\t\t\t\t\tuv.y = uv.y - Math.floor( uv.y );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase THREE.ClampToEdgeWrapping:\r\n\r\n\t\t\t\t\tuv.y = uv.y < 0 ? 0 : 1;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase THREE.MirroredRepeatWrapping:\r\n\r\n\t\t\t\t\tif ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {\r\n\r\n\t\t\t\t\t\tuv.y = Math.ceil( uv.y ) - uv.y;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tuv.y = uv.y - Math.floor( uv.y );\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.flipY ) {\r\n\r\n\t\t\tuv.y = 1 - uv.y;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.EventDispatcher.prototype.apply( THREE.Texture.prototype );\r\n\r\nTHREE.TextureIdCount = 0;\r\n\r\n// File:src/textures/DepthTexture.js\r\n\r\n/**\r\n * @author Matt DesLauriers / @mattdesl\r\n */\r\n\r\nTHREE.DepthTexture = function ( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {\r\n\r\n  THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, THREE.DepthFormat, type, anisotropy );\r\n\r\n  this.image = { width: width, height: height };\r\n\r\n  this.type = type !== undefined ? type : THREE.UnsignedShortType;\r\n\r\n  this.magFilter = magFilter !== undefined ? magFilter : THREE.NearestFilter;\r\n  this.minFilter = minFilter !== undefined ? minFilter : THREE.NearestFilter;\r\n\r\n  this.flipY = false;\r\n  this.generateMipmaps  = false;\r\n\r\n};\r\n\r\nTHREE.DepthTexture.prototype = Object.create( THREE.Texture.prototype );\r\nTHREE.DepthTexture.prototype.constructor = THREE.DepthTexture;\r\n\r\n// File:src/textures/CanvasTexture.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.CanvasTexture = function ( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\r\n\r\n\tTHREE.Texture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\r\n\r\n\tthis.needsUpdate = true;\r\n\r\n};\r\n\r\nTHREE.CanvasTexture.prototype = Object.create( THREE.Texture.prototype );\r\nTHREE.CanvasTexture.prototype.constructor = THREE.CanvasTexture;\r\n\r\n// File:src/textures/CubeTexture.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.CubeTexture = function ( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {\r\n\r\n\timages = images !== undefined ? images : [];\r\n\tmapping = mapping !== undefined ? mapping : THREE.CubeReflectionMapping;\r\n\r\n\tTHREE.Texture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\r\n\r\n\tthis.flipY = false;\r\n\r\n};\r\n\r\nTHREE.CubeTexture.prototype = Object.create( THREE.Texture.prototype );\r\nTHREE.CubeTexture.prototype.constructor = THREE.CubeTexture;\r\n\r\nObject.defineProperty( THREE.CubeTexture.prototype, 'images', {\r\n\r\n\tget: function () {\r\n\r\n\t\treturn this.image;\r\n\r\n\t},\r\n\r\n\tset: function ( value ) {\r\n\r\n\t\tthis.image = value;\r\n\r\n\t}\r\n\r\n} );\r\n\r\n// File:src/textures/CompressedTexture.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.CompressedTexture = function ( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {\r\n\r\n\tTHREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\r\n\r\n\tthis.image = { width: width, height: height };\r\n\tthis.mipmaps = mipmaps;\r\n\r\n\t// no flipping for cube textures\r\n\t// (also flipping doesn't work for compressed textures )\r\n\r\n\tthis.flipY = false;\r\n\r\n\t// can't generate mipmaps for compressed textures\r\n\t// mips must be embedded in DDS files\r\n\r\n\tthis.generateMipmaps = false;\r\n\r\n};\r\n\r\nTHREE.CompressedTexture.prototype = Object.create( THREE.Texture.prototype );\r\nTHREE.CompressedTexture.prototype.constructor = THREE.CompressedTexture;\r\n\r\n// File:src/textures/DataTexture.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.DataTexture = function ( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {\r\n\r\n\tTHREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\r\n\r\n\tthis.image = { data: data, width: width, height: height };\r\n\r\n\tthis.magFilter = magFilter !== undefined ? magFilter : THREE.NearestFilter;\r\n\tthis.minFilter = minFilter !== undefined ? minFilter : THREE.NearestFilter;\r\n\r\n\tthis.flipY = false;\r\n\tthis.generateMipmaps  = false;\r\n\r\n};\r\n\r\nTHREE.DataTexture.prototype = Object.create( THREE.Texture.prototype );\r\nTHREE.DataTexture.prototype.constructor = THREE.DataTexture;\r\n\r\n// File:src/textures/VideoTexture.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.VideoTexture = function ( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\r\n\r\n\tTHREE.Texture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\r\n\r\n\tthis.generateMipmaps = false;\r\n\r\n\tvar scope = this;\r\n\r\n\tfunction update() {\r\n\r\n\t\trequestAnimationFrame( update );\r\n\r\n\t\tif ( video.readyState >= video.HAVE_CURRENT_DATA ) {\r\n\r\n\t\t\tscope.needsUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tupdate();\r\n\r\n};\r\n\r\nTHREE.VideoTexture.prototype = Object.create( THREE.Texture.prototype );\r\nTHREE.VideoTexture.prototype.constructor = THREE.VideoTexture;\r\n\r\n// File:src/objects/Group.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Group = function () {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.type = 'Group';\r\n\r\n};\r\n\r\nTHREE.Group.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.Group.prototype.constructor = THREE.Group;\r\n\r\n// File:src/objects/Points.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Points = function ( geometry, material ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.type = 'Points';\r\n\r\n\tthis.geometry = geometry !== undefined ? geometry : new THREE.Geometry();\r\n\tthis.material = material !== undefined ? material : new THREE.PointsMaterial( { color: Math.random() * 0xffffff } );\r\n\r\n};\r\n\r\nTHREE.Points.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.Points.prototype.constructor = THREE.Points;\r\n\r\nTHREE.Points.prototype.raycast = ( function () {\r\n\r\n\tvar inverseMatrix = new THREE.Matrix4();\r\n\tvar ray = new THREE.Ray();\r\n\tvar sphere = new THREE.Sphere();\r\n\r\n\treturn function raycast( raycaster, intersects ) {\r\n\r\n\t\tvar object = this;\r\n\t\tvar geometry = this.geometry;\r\n\t\tvar matrixWorld = this.matrixWorld;\r\n\t\tvar threshold = raycaster.params.Points.threshold;\r\n\r\n\t\t// Checking boundingSphere distance to ray\r\n\r\n\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\r\n\r\n\t\tsphere.copy( geometry.boundingSphere );\r\n\t\tsphere.applyMatrix4( matrixWorld );\r\n\r\n\t\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\r\n\r\n\t\t//\r\n\r\n\t\tinverseMatrix.getInverse( matrixWorld );\r\n\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\r\n\r\n\t\tvar localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );\r\n\t\tvar localThresholdSq = localThreshold * localThreshold;\r\n\t\tvar position = new THREE.Vector3();\r\n\r\n\t\tfunction testPoint( point, index ) {\r\n\r\n\t\t\tvar rayPointDistanceSq = ray.distanceSqToPoint( point );\r\n\r\n\t\t\tif ( rayPointDistanceSq < localThresholdSq ) {\r\n\r\n\t\t\t\tvar intersectPoint = ray.closestPointToPoint( point );\r\n\t\t\t\tintersectPoint.applyMatrix4( matrixWorld );\r\n\r\n\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( intersectPoint );\r\n\r\n\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) return;\r\n\r\n\t\t\t\tintersects.push( {\r\n\r\n\t\t\t\t\tdistance: distance,\r\n\t\t\t\t\tdistanceToRay: Math.sqrt( rayPointDistanceSq ),\r\n\t\t\t\t\tpoint: intersectPoint.clone(),\r\n\t\t\t\t\tindex: index,\r\n\t\t\t\t\tface: null,\r\n\t\t\t\t\tobject: object\r\n\r\n\t\t\t\t} );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry instanceof THREE.BufferGeometry ) {\r\n\r\n\t\t\tvar index = geometry.index;\r\n\t\t\tvar attributes = geometry.attributes;\r\n\t\t\tvar positions = attributes.position.array;\r\n\r\n\t\t\tif ( index !== null ) {\r\n\r\n\t\t\t\tvar indices = index.array;\r\n\r\n\t\t\t\tfor ( var i = 0, il = indices.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tvar a = indices[ i ];\r\n\r\n\t\t\t\t\tposition.fromArray( positions, a * 3 );\r\n\r\n\t\t\t\t\ttestPoint( position, a );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tfor ( var i = 0, l = positions.length / 3; i < l; i ++ ) {\r\n\r\n\t\t\t\t\tposition.fromArray( positions, i * 3 );\r\n\r\n\t\t\t\t\ttestPoint( position, i );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tvar vertices = geometry.vertices;\r\n\r\n\t\t\tfor ( var i = 0, l = vertices.length; i < l; i ++ ) {\r\n\r\n\t\t\t\ttestPoint( vertices[ i ], i );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n}() );\r\n\r\nTHREE.Points.prototype.clone = function () {\r\n\r\n\treturn new this.constructor( this.geometry, this.material ).copy( this );\r\n\r\n};\r\n\r\n// File:src/objects/Line.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Line = function ( geometry, material, mode ) {\r\n\r\n\tif ( mode === 1 ) {\r\n\r\n\t\tconsole.warn( 'THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.' );\r\n\t\treturn new THREE.LineSegments( geometry, material );\r\n\r\n\t}\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.type = 'Line';\r\n\r\n\tthis.geometry = geometry !== undefined ? geometry : new THREE.Geometry();\r\n\tthis.material = material !== undefined ? material : new THREE.LineBasicMaterial( { color: Math.random() * 0xffffff } );\r\n\r\n};\r\n\r\nTHREE.Line.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.Line.prototype.constructor = THREE.Line;\r\n\r\nTHREE.Line.prototype.raycast = ( function () {\r\n\r\n\tvar inverseMatrix = new THREE.Matrix4();\r\n\tvar ray = new THREE.Ray();\r\n\tvar sphere = new THREE.Sphere();\r\n\r\n\treturn function raycast( raycaster, intersects ) {\r\n\r\n\t\tvar precision = raycaster.linePrecision;\r\n\t\tvar precisionSq = precision * precision;\r\n\r\n\t\tvar geometry = this.geometry;\r\n\t\tvar matrixWorld = this.matrixWorld;\r\n\r\n\t\t// Checking boundingSphere distance to ray\r\n\r\n\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\r\n\r\n\t\tsphere.copy( geometry.boundingSphere );\r\n\t\tsphere.applyMatrix4( matrixWorld );\r\n\r\n\t\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\r\n\r\n\t\t//\r\n\r\n\t\tinverseMatrix.getInverse( matrixWorld );\r\n\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\r\n\r\n\t\tvar vStart = new THREE.Vector3();\r\n\t\tvar vEnd = new THREE.Vector3();\r\n\t\tvar interSegment = new THREE.Vector3();\r\n\t\tvar interRay = new THREE.Vector3();\r\n\t\tvar step = this instanceof THREE.LineSegments ? 2 : 1;\r\n\r\n\t\tif ( geometry instanceof THREE.BufferGeometry ) {\r\n\r\n\t\t\tvar index = geometry.index;\r\n\t\t\tvar attributes = geometry.attributes;\r\n\t\t\tvar positions = attributes.position.array;\r\n\r\n\t\t\tif ( index !== null ) {\r\n\r\n\t\t\t\tvar indices = index.array;\r\n\r\n\t\t\t\tfor ( var i = 0, l = indices.length - 1; i < l; i += step ) {\r\n\r\n\t\t\t\t\tvar a = indices[ i ];\r\n\t\t\t\t\tvar b = indices[ i + 1 ];\r\n\r\n\t\t\t\t\tvStart.fromArray( positions, a * 3 );\r\n\t\t\t\t\tvEnd.fromArray( positions, b * 3 );\r\n\r\n\t\t\t\t\tvar distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\r\n\r\n\t\t\t\t\tif ( distSq > precisionSq ) continue;\r\n\r\n\t\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\r\n\r\n\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( interRay );\r\n\r\n\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\r\n\r\n\t\t\t\t\tintersects.push( {\r\n\r\n\t\t\t\t\t\tdistance: distance,\r\n\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\r\n\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\r\n\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\r\n\t\t\t\t\t\tindex: i,\r\n\t\t\t\t\t\tface: null,\r\n\t\t\t\t\t\tfaceIndex: null,\r\n\t\t\t\t\t\tobject: this\r\n\r\n\t\t\t\t\t} );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tfor ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) {\r\n\r\n\t\t\t\t\tvStart.fromArray( positions, 3 * i );\r\n\t\t\t\t\tvEnd.fromArray( positions, 3 * i + 3 );\r\n\r\n\t\t\t\t\tvar distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\r\n\r\n\t\t\t\t\tif ( distSq > precisionSq ) continue;\r\n\r\n\t\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\r\n\r\n\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( interRay );\r\n\r\n\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\r\n\r\n\t\t\t\t\tintersects.push( {\r\n\r\n\t\t\t\t\t\tdistance: distance,\r\n\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\r\n\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\r\n\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\r\n\t\t\t\t\t\tindex: i,\r\n\t\t\t\t\t\tface: null,\r\n\t\t\t\t\t\tfaceIndex: null,\r\n\t\t\t\t\t\tobject: this\r\n\r\n\t\t\t\t\t} );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( geometry instanceof THREE.Geometry ) {\r\n\r\n\t\t\tvar vertices = geometry.vertices;\r\n\t\t\tvar nbVertices = vertices.length;\r\n\r\n\t\t\tfor ( var i = 0; i < nbVertices - 1; i += step ) {\r\n\r\n\t\t\t\tvar distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );\r\n\r\n\t\t\t\tif ( distSq > precisionSq ) continue;\r\n\r\n\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\r\n\r\n\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( interRay );\r\n\r\n\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\r\n\r\n\t\t\t\tintersects.push( {\r\n\r\n\t\t\t\t\tdistance: distance,\r\n\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\r\n\t\t\t\t\t// point: raycaster.ray.at( distance ),\r\n\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\r\n\t\t\t\t\tindex: i,\r\n\t\t\t\t\tface: null,\r\n\t\t\t\t\tfaceIndex: null,\r\n\t\t\t\t\tobject: this\r\n\r\n\t\t\t\t} );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n}() );\r\n\r\nTHREE.Line.prototype.clone = function () {\r\n\r\n\treturn new this.constructor( this.geometry, this.material ).copy( this );\r\n\r\n};\r\n\r\n// DEPRECATED\r\n\r\nTHREE.LineStrip = 0;\r\nTHREE.LinePieces = 1;\r\n\r\n// File:src/objects/LineSegments.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.LineSegments = function ( geometry, material ) {\r\n\r\n\tTHREE.Line.call( this, geometry, material );\r\n\r\n\tthis.type = 'LineSegments';\r\n\r\n};\r\n\r\nTHREE.LineSegments.prototype = Object.create( THREE.Line.prototype );\r\nTHREE.LineSegments.prototype.constructor = THREE.LineSegments;\r\n\r\n// File:src/objects/Mesh.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author jonobr1 / http://jonobr1.com/\r\n */\r\n\r\nTHREE.Mesh = function ( geometry, material ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.type = 'Mesh';\r\n\r\n\tthis.geometry = geometry !== undefined ? geometry : new THREE.Geometry();\r\n\tthis.material = material !== undefined ? material : new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff } );\r\n\r\n\tthis.drawMode = THREE.TrianglesDrawMode;\r\n\r\n\tthis.updateMorphTargets();\r\n\r\n};\r\n\r\nTHREE.Mesh.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.Mesh.prototype.constructor = THREE.Mesh;\r\n\r\nTHREE.Mesh.prototype.setDrawMode = function ( value ) {\r\n\r\n\tthis.drawMode = value;\r\n\r\n};\r\n\r\nTHREE.Mesh.prototype.updateMorphTargets = function () {\r\n\r\n\tif ( this.geometry.morphTargets !== undefined && this.geometry.morphTargets.length > 0 ) {\r\n\r\n\t\tthis.morphTargetBase = - 1;\r\n\t\tthis.morphTargetInfluences = [];\r\n\t\tthis.morphTargetDictionary = {};\r\n\r\n\t\tfor ( var m = 0, ml = this.geometry.morphTargets.length; m < ml; m ++ ) {\r\n\r\n\t\t\tthis.morphTargetInfluences.push( 0 );\r\n\t\t\tthis.morphTargetDictionary[ this.geometry.morphTargets[ m ].name ] = m;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.Mesh.prototype.getMorphTargetIndexByName = function ( name ) {\r\n\r\n\tif ( this.morphTargetDictionary[ name ] !== undefined ) {\r\n\r\n\t\treturn this.morphTargetDictionary[ name ];\r\n\r\n\t}\r\n\r\n\tconsole.warn( 'THREE.Mesh.getMorphTargetIndexByName: morph target ' + name + ' does not exist. Returning 0.' );\r\n\r\n\treturn 0;\r\n\r\n};\r\n\r\n\r\nTHREE.Mesh.prototype.raycast = ( function () {\r\n\r\n\tvar inverseMatrix = new THREE.Matrix4();\r\n\tvar ray = new THREE.Ray();\r\n\tvar sphere = new THREE.Sphere();\r\n\r\n\tvar vA = new THREE.Vector3();\r\n\tvar vB = new THREE.Vector3();\r\n\tvar vC = new THREE.Vector3();\r\n\r\n\tvar tempA = new THREE.Vector3();\r\n\tvar tempB = new THREE.Vector3();\r\n\tvar tempC = new THREE.Vector3();\r\n\r\n\tvar uvA = new THREE.Vector2();\r\n\tvar uvB = new THREE.Vector2();\r\n\tvar uvC = new THREE.Vector2();\r\n\r\n\tvar barycoord = new THREE.Vector3();\r\n\r\n\tvar intersectionPoint = new THREE.Vector3();\r\n\tvar intersectionPointWorld = new THREE.Vector3();\r\n\r\n\tfunction uvIntersection( point, p1, p2, p3, uv1, uv2, uv3 ) {\r\n\r\n\t\tTHREE.Triangle.barycoordFromPoint( point, p1, p2, p3, barycoord );\r\n\r\n\t\tuv1.multiplyScalar( barycoord.x );\r\n\t\tuv2.multiplyScalar( barycoord.y );\r\n\t\tuv3.multiplyScalar( barycoord.z );\r\n\r\n\t\tuv1.add( uv2 ).add( uv3 );\r\n\r\n\t\treturn uv1.clone();\r\n\r\n\t}\r\n\r\n\tfunction checkIntersection( object, raycaster, ray, pA, pB, pC, point ) {\r\n\r\n\t\tvar intersect;\r\n\t\tvar material = object.material;\r\n\r\n\t\tif ( material.side === THREE.BackSide ) {\r\n\r\n\t\t\tintersect = ray.intersectTriangle( pC, pB, pA, true, point );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tintersect = ray.intersectTriangle( pA, pB, pC, material.side !== THREE.DoubleSide, point );\r\n\r\n\t\t}\r\n\r\n\t\tif ( intersect === null ) return null;\r\n\r\n\t\tintersectionPointWorld.copy( point );\r\n\t\tintersectionPointWorld.applyMatrix4( object.matrixWorld );\r\n\r\n\t\tvar distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );\r\n\r\n\t\tif ( distance < raycaster.near || distance > raycaster.far ) return null;\r\n\r\n\t\treturn {\r\n\t\t\tdistance: distance,\r\n\t\t\tpoint: intersectionPointWorld.clone(),\r\n\t\t\tobject: object\r\n\t\t};\r\n\r\n\t}\r\n\r\n\tfunction checkBufferGeometryIntersection( object, raycaster, ray, positions, uvs, a, b, c ) {\r\n\r\n\t\tvA.fromArray( positions, a * 3 );\r\n\t\tvB.fromArray( positions, b * 3 );\r\n\t\tvC.fromArray( positions, c * 3 );\r\n\r\n\t\tvar intersection = checkIntersection( object, raycaster, ray, vA, vB, vC, intersectionPoint );\r\n\r\n\t\tif ( intersection ) {\r\n\r\n\t\t\tif ( uvs ) {\r\n\r\n\t\t\t\tuvA.fromArray( uvs, a * 2 );\r\n\t\t\t\tuvB.fromArray( uvs, b * 2 );\r\n\t\t\t\tuvC.fromArray( uvs, c * 2 );\r\n\r\n\t\t\t\tintersection.uv = uvIntersection( intersectionPoint,  vA, vB, vC,  uvA, uvB, uvC );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tintersection.face = new THREE.Face3( a, b, c, THREE.Triangle.normal( vA, vB, vC ) );\r\n\t\t\tintersection.faceIndex = a;\r\n\r\n\t\t}\r\n\r\n\t\treturn intersection;\r\n\r\n\t}\r\n\r\n\treturn function raycast( raycaster, intersects ) {\r\n\r\n\t\tvar geometry = this.geometry;\r\n\t\tvar material = this.material;\r\n\t\tvar matrixWorld = this.matrixWorld;\r\n\r\n\t\tif ( material === undefined ) return;\r\n\r\n\t\t// Checking boundingSphere distance to ray\r\n\r\n\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\r\n\r\n\t\tsphere.copy( geometry.boundingSphere );\r\n\t\tsphere.applyMatrix4( matrixWorld );\r\n\r\n\t\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\r\n\r\n\t\t//\r\n\r\n\t\tinverseMatrix.getInverse( matrixWorld );\r\n\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\r\n\r\n\t\t// Check boundingBox before continuing\r\n\r\n\t\tif ( geometry.boundingBox !== null ) {\r\n\r\n\t\t\tif ( ray.intersectsBox( geometry.boundingBox ) === false ) return;\r\n\r\n\t\t}\r\n\r\n\t\tvar uvs, intersection;\r\n\r\n\t\tif ( geometry instanceof THREE.BufferGeometry ) {\r\n\r\n\t\t\tvar a, b, c;\r\n\t\t\tvar index = geometry.index;\r\n\t\t\tvar attributes = geometry.attributes;\r\n\t\t\tvar positions = attributes.position.array;\r\n\r\n\t\t\tif ( attributes.uv !== undefined ) {\r\n\r\n\t\t\t\tuvs = attributes.uv.array;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( index !== null ) {\r\n\r\n\t\t\t\tvar indices = index.array;\r\n\r\n\t\t\t\tfor ( var i = 0, l = indices.length; i < l; i += 3 ) {\r\n\r\n\t\t\t\t\ta = indices[ i ];\r\n\t\t\t\t\tb = indices[ i + 1 ];\r\n\t\t\t\t\tc = indices[ i + 2 ];\r\n\r\n\t\t\t\t\tintersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );\r\n\r\n\t\t\t\t\tif ( intersection ) {\r\n\r\n\t\t\t\t\t\tintersection.faceIndex = Math.floor( i / 3 ); // triangle number in indices buffer semantics\r\n\t\t\t\t\t\tintersects.push( intersection );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\r\n\t\t\t\tfor ( var i = 0, l = positions.length; i < l; i += 9 ) {\r\n\r\n\t\t\t\t\ta = i / 3;\r\n\t\t\t\t\tb = a + 1;\r\n\t\t\t\t\tc = a + 2;\r\n\r\n\t\t\t\t\tintersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );\r\n\r\n\t\t\t\t\tif ( intersection ) {\r\n\r\n\t\t\t\t\t\tintersection.index = a; // triangle number in positions buffer semantics\r\n\t\t\t\t\t\tintersects.push( intersection );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( geometry instanceof THREE.Geometry ) {\r\n\r\n\t\t\tvar fvA, fvB, fvC;\r\n\t\t\tvar isFaceMaterial = material instanceof THREE.MultiMaterial;\r\n\t\t\tvar materials = isFaceMaterial === true ? material.materials : null;\r\n\r\n\t\t\tvar vertices = geometry.vertices;\r\n\t\t\tvar faces = geometry.faces;\r\n\t\t\tvar faceVertexUvs = geometry.faceVertexUvs[ 0 ];\r\n\t\t\tif ( faceVertexUvs.length > 0 ) uvs = faceVertexUvs;\r\n\r\n\t\t\tfor ( var f = 0, fl = faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tvar face = faces[ f ];\r\n\t\t\t\tvar faceMaterial = isFaceMaterial === true ? materials[ face.materialIndex ] : material;\r\n\r\n\t\t\t\tif ( faceMaterial === undefined ) continue;\r\n\r\n\t\t\t\tfvA = vertices[ face.a ];\r\n\t\t\t\tfvB = vertices[ face.b ];\r\n\t\t\t\tfvC = vertices[ face.c ];\r\n\r\n\t\t\t\tif ( faceMaterial.morphTargets === true ) {\r\n\r\n\t\t\t\t\tvar morphTargets = geometry.morphTargets;\r\n\t\t\t\t\tvar morphInfluences = this.morphTargetInfluences;\r\n\r\n\t\t\t\t\tvA.set( 0, 0, 0 );\r\n\t\t\t\t\tvB.set( 0, 0, 0 );\r\n\t\t\t\t\tvC.set( 0, 0, 0 );\r\n\r\n\t\t\t\t\tfor ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {\r\n\r\n\t\t\t\t\t\tvar influence = morphInfluences[ t ];\r\n\r\n\t\t\t\t\t\tif ( influence === 0 ) continue;\r\n\r\n\t\t\t\t\t\tvar targets = morphTargets[ t ].vertices;\r\n\r\n\t\t\t\t\t\tvA.addScaledVector( tempA.subVectors( targets[ face.a ], fvA ), influence );\r\n\t\t\t\t\t\tvB.addScaledVector( tempB.subVectors( targets[ face.b ], fvB ), influence );\r\n\t\t\t\t\t\tvC.addScaledVector( tempC.subVectors( targets[ face.c ], fvC ), influence );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tvA.add( fvA );\r\n\t\t\t\t\tvB.add( fvB );\r\n\t\t\t\t\tvC.add( fvC );\r\n\r\n\t\t\t\t\tfvA = vA;\r\n\t\t\t\t\tfvB = vB;\r\n\t\t\t\t\tfvC = vC;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tintersection = checkIntersection( this, raycaster, ray, fvA, fvB, fvC, intersectionPoint );\r\n\r\n\t\t\t\tif ( intersection ) {\r\n\r\n\t\t\t\t\tif ( uvs ) {\r\n\r\n\t\t\t\t\t\tvar uvs_f = uvs[ f ];\r\n\t\t\t\t\t\tuvA.copy( uvs_f[ 0 ] );\r\n\t\t\t\t\t\tuvB.copy( uvs_f[ 1 ] );\r\n\t\t\t\t\t\tuvC.copy( uvs_f[ 2 ] );\r\n\r\n\t\t\t\t\t\tintersection.uv = uvIntersection( intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tintersection.face = face;\r\n\t\t\t\t\tintersection.faceIndex = f;\r\n\t\t\t\t\tintersects.push( intersection );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n}() );\r\n\r\nTHREE.Mesh.prototype.clone = function () {\r\n\r\n\treturn new this.constructor( this.geometry, this.material ).copy( this );\r\n\r\n};\r\n\r\n// File:src/objects/Bone.js\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author ikerr / http://verold.com\r\n */\r\n\r\nTHREE.Bone = function ( skin ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.type = 'Bone';\r\n\r\n\tthis.skin = skin;\r\n\r\n};\r\n\r\nTHREE.Bone.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.Bone.prototype.constructor = THREE.Bone;\r\n\r\nTHREE.Bone.prototype.copy = function ( source ) {\r\n\r\n\tTHREE.Object3D.prototype.copy.call( this, source );\r\n\r\n\tthis.skin = source.skin;\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\n// File:src/objects/Skeleton.js\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author michael guerrero / http://realitymeltdown.com\r\n * @author ikerr / http://verold.com\r\n */\r\n\r\nTHREE.Skeleton = function ( bones, boneInverses, useVertexTexture ) {\r\n\r\n\tthis.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;\r\n\r\n\tthis.identityMatrix = new THREE.Matrix4();\r\n\r\n\t// copy the bone array\r\n\r\n\tbones = bones || [];\r\n\r\n\tthis.bones = bones.slice( 0 );\r\n\r\n\t// create a bone texture or an array of floats\r\n\r\n\tif ( this.useVertexTexture ) {\r\n\r\n\t\t// layout (1 matrix = 4 pixels)\r\n\t\t//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)\r\n\t\t//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)\r\n\t\t//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)\r\n\t\t//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)\r\n\t\t//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)\r\n\r\n\t\t\r\n\t\tvar size = Math.sqrt( this.bones.length * 4 ); // 4 pixels needed for 1 matrix\r\n\t\tsize = THREE.Math.nextPowerOfTwo( Math.ceil( size ) );\r\n\t\tsize = Math.max( size, 4 );\r\n\r\n\t\tthis.boneTextureWidth = size;\r\n\t\tthis.boneTextureHeight = size;\r\n\r\n\t\tthis.boneMatrices = new Float32Array( this.boneTextureWidth * this.boneTextureHeight * 4 ); // 4 floats per RGBA pixel\r\n\t\tthis.boneTexture = new THREE.DataTexture( this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType );\r\n\r\n\t} else {\r\n\r\n\t\tthis.boneMatrices = new Float32Array( 16 * this.bones.length );\r\n\r\n\t}\r\n\r\n\t// use the supplied bone inverses or calculate the inverses\r\n\r\n\tif ( boneInverses === undefined ) {\r\n\r\n\t\tthis.calculateInverses();\r\n\r\n\t} else {\r\n\r\n\t\tif ( this.bones.length === boneInverses.length ) {\r\n\r\n\t\t\tthis.boneInverses = boneInverses.slice( 0 );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconsole.warn( 'THREE.Skeleton bonInverses is the wrong length.' );\r\n\r\n\t\t\tthis.boneInverses = [];\r\n\r\n\t\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\r\n\r\n\t\t\t\tthis.boneInverses.push( new THREE.Matrix4() );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.Skeleton.prototype.calculateInverses = function () {\r\n\r\n\tthis.boneInverses = [];\r\n\r\n\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\r\n\r\n\t\tvar inverse = new THREE.Matrix4();\r\n\r\n\t\tif ( this.bones[ b ] ) {\r\n\r\n\t\t\tinverse.getInverse( this.bones[ b ].matrixWorld );\r\n\r\n\t\t}\r\n\r\n\t\tthis.boneInverses.push( inverse );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.Skeleton.prototype.pose = function () {\r\n\r\n\tvar bone;\r\n\r\n\t// recover the bind-time world matrices\r\n\r\n\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\r\n\r\n\t\tbone = this.bones[ b ];\r\n\r\n\t\tif ( bone ) {\r\n\r\n\t\t\tbone.matrixWorld.getInverse( this.boneInverses[ b ] );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// compute the local matrices, positions, rotations and scales\r\n\r\n\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\r\n\r\n\t\tbone = this.bones[ b ];\r\n\r\n\t\tif ( bone ) {\r\n\r\n\t\t\tif ( bone.parent ) {\r\n\r\n\t\t\t\tbone.matrix.getInverse( bone.parent.matrixWorld );\r\n\t\t\t\tbone.matrix.multiply( bone.matrixWorld );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tbone.matrix.copy( bone.matrixWorld );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.Skeleton.prototype.update = ( function () {\r\n\r\n\tvar offsetMatrix = new THREE.Matrix4();\r\n\r\n\treturn function update() {\r\n\r\n\t\t// flatten bone matrices to array\r\n\r\n\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\r\n\r\n\t\t\t// compute the offset between the current and the original transform\r\n\r\n\t\t\tvar matrix = this.bones[ b ] ? this.bones[ b ].matrixWorld : this.identityMatrix;\r\n\r\n\t\t\toffsetMatrix.multiplyMatrices( matrix, this.boneInverses[ b ] );\r\n\t\t\toffsetMatrix.toArray( this.boneMatrices, b * 16 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.useVertexTexture ) {\r\n\r\n\t\t\tthis.boneTexture.needsUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n} )();\r\n\r\nTHREE.Skeleton.prototype.clone = function () {\r\n\r\n\treturn new THREE.Skeleton( this.bones, this.boneInverses, this.useVertexTexture );\r\n\r\n};\r\n\r\n// File:src/objects/SkinnedMesh.js\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author ikerr / http://verold.com\r\n */\r\n\r\nTHREE.SkinnedMesh = function ( geometry, material, useVertexTexture ) {\r\n\r\n\tTHREE.Mesh.call( this, geometry, material );\r\n\r\n\tthis.type = 'SkinnedMesh';\r\n\r\n\tthis.bindMode = \"attached\";\r\n\tthis.bindMatrix = new THREE.Matrix4();\r\n\tthis.bindMatrixInverse = new THREE.Matrix4();\r\n\r\n\t// init bones\r\n\r\n\t// TODO: remove bone creation as there is no reason (other than\r\n\t// convenience) for THREE.SkinnedMesh to do this.\r\n\r\n\tvar bones = [];\r\n\r\n\tif ( this.geometry && this.geometry.bones !== undefined ) {\r\n\r\n\t\tvar bone, gbone;\r\n\r\n\t\tfor ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {\r\n\r\n\t\t\tgbone = this.geometry.bones[ b ];\r\n\r\n\t\t\tbone = new THREE.Bone( this );\r\n\t\t\tbones.push( bone );\r\n\r\n\t\t\tbone.name = gbone.name;\r\n\t\t\tbone.position.fromArray( gbone.pos );\r\n\t\t\tbone.quaternion.fromArray( gbone.rotq );\r\n\t\t\tif ( gbone.scl !== undefined ) bone.scale.fromArray( gbone.scl );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {\r\n\r\n\t\t\tgbone = this.geometry.bones[ b ];\r\n\r\n\t\t\tif ( gbone.parent !== - 1 && gbone.parent !== null &&\r\n\t\t\t\t\tbones[ gbone.parent ] !== undefined ) {\r\n\r\n\t\t\t\tbones[ gbone.parent ].add( bones[ b ] );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis.add( bones[ b ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tthis.normalizeSkinWeights();\r\n\r\n\tthis.updateMatrixWorld( true );\r\n\tthis.bind( new THREE.Skeleton( bones, undefined, useVertexTexture ), this.matrixWorld );\r\n\r\n};\r\n\r\n\r\nTHREE.SkinnedMesh.prototype = Object.create( THREE.Mesh.prototype );\r\nTHREE.SkinnedMesh.prototype.constructor = THREE.SkinnedMesh;\r\n\r\nTHREE.SkinnedMesh.prototype.bind = function( skeleton, bindMatrix ) {\r\n\r\n\tthis.skeleton = skeleton;\r\n\r\n\tif ( bindMatrix === undefined ) {\r\n\r\n\t\tthis.updateMatrixWorld( true );\r\n\r\n\t\tthis.skeleton.calculateInverses();\r\n\r\n\t\tbindMatrix = this.matrixWorld;\r\n\r\n\t}\r\n\r\n\tthis.bindMatrix.copy( bindMatrix );\r\n\tthis.bindMatrixInverse.getInverse( bindMatrix );\r\n\r\n};\r\n\r\nTHREE.SkinnedMesh.prototype.pose = function () {\r\n\r\n\tthis.skeleton.pose();\r\n\r\n};\r\n\r\nTHREE.SkinnedMesh.prototype.normalizeSkinWeights = function () {\r\n\r\n\tif ( this.geometry instanceof THREE.Geometry ) {\r\n\r\n\t\tfor ( var i = 0; i < this.geometry.skinWeights.length; i ++ ) {\r\n\r\n\t\t\tvar sw = this.geometry.skinWeights[ i ];\r\n\r\n\t\t\tvar scale = 1.0 / sw.lengthManhattan();\r\n\r\n\t\t\tif ( scale !== Infinity ) {\r\n\r\n\t\t\t\tsw.multiplyScalar( scale );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tsw.set( 1, 0, 0, 0 ); // do something reasonable\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t} else if ( this.geometry instanceof THREE.BufferGeometry ) {\r\n\r\n\t\tvar vec = new THREE.Vector4();\r\n\r\n\t\tvar skinWeight = this.geometry.attributes.skinWeight;\r\n\r\n\t\tfor ( var i = 0; i < skinWeight.count; i ++ ) {\r\n\r\n\t\t\tvec.x = skinWeight.getX( i );\r\n\t\t\tvec.y = skinWeight.getY( i );\r\n\t\t\tvec.z = skinWeight.getZ( i );\r\n\t\t\tvec.w = skinWeight.getW( i );\r\n\r\n\t\t\tvar scale = 1.0 / vec.lengthManhattan();\r\n\r\n\t\t\tif ( scale !== Infinity ) {\r\n\r\n\t\t\t\tvec.multiplyScalar( scale );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tvec.set( 1, 0, 0, 0 ); // do something reasonable\r\n\r\n\t\t\t}\r\n\r\n\t\t\tskinWeight.setXYZW( i, vec.x, vec.y, vec.z, vec.w );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.SkinnedMesh.prototype.updateMatrixWorld = function( force ) {\r\n\r\n\tTHREE.Mesh.prototype.updateMatrixWorld.call( this, true );\r\n\r\n\tif ( this.bindMode === \"attached\" ) {\r\n\r\n\t\tthis.bindMatrixInverse.getInverse( this.matrixWorld );\r\n\r\n\t} else if ( this.bindMode === \"detached\" ) {\r\n\r\n\t\tthis.bindMatrixInverse.getInverse( this.bindMatrix );\r\n\r\n\t} else {\r\n\r\n\t\tconsole.warn( 'THREE.SkinnedMesh unrecognized bindMode: ' + this.bindMode );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.SkinnedMesh.prototype.clone = function() {\r\n\r\n\treturn new this.constructor( this.geometry, this.material, this.useVertexTexture ).copy( this );\r\n\r\n};\r\n\r\n// File:src/objects/LOD.js\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.LOD = function () {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.type = 'LOD';\r\n\r\n\tObject.defineProperties( this, {\r\n\t\tlevels: {\r\n\t\t\tenumerable: true,\r\n\t\t\tvalue: []\r\n\t\t}\r\n\t} );\r\n\r\n};\r\n\r\n\r\nTHREE.LOD.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.LOD.prototype.constructor = THREE.LOD;\r\n\r\nTHREE.LOD.prototype.addLevel = function ( object, distance ) {\r\n\r\n\tif ( distance === undefined ) distance = 0;\r\n\r\n\tdistance = Math.abs( distance );\r\n\r\n\tvar levels = this.levels;\r\n\r\n\tfor ( var l = 0; l < levels.length; l ++ ) {\r\n\r\n\t\tif ( distance < levels[ l ].distance ) {\r\n\r\n\t\t\tbreak;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tlevels.splice( l, 0, { distance: distance, object: object } );\r\n\r\n\tthis.add( object );\r\n\r\n};\r\n\r\nTHREE.LOD.prototype.getObjectForDistance = function ( distance ) {\r\n\r\n\tvar levels = this.levels;\r\n\r\n\tfor ( var i = 1, l = levels.length; i < l; i ++ ) {\r\n\r\n\t\tif ( distance < levels[ i ].distance ) {\r\n\r\n\t\t\tbreak;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn levels[ i - 1 ].object;\r\n\r\n};\r\n\r\nTHREE.LOD.prototype.raycast = ( function () {\r\n\r\n\tvar matrixPosition = new THREE.Vector3();\r\n\r\n\treturn function raycast( raycaster, intersects ) {\r\n\r\n\t\tmatrixPosition.setFromMatrixPosition( this.matrixWorld );\r\n\r\n\t\tvar distance = raycaster.ray.origin.distanceTo( matrixPosition );\r\n\r\n\t\tthis.getObjectForDistance( distance ).raycast( raycaster, intersects );\r\n\r\n\t};\r\n\r\n}() );\r\n\r\nTHREE.LOD.prototype.update = function () {\r\n\r\n\tvar v1 = new THREE.Vector3();\r\n\tvar v2 = new THREE.Vector3();\r\n\r\n\treturn function update( camera ) {\r\n\r\n\t\tvar levels = this.levels;\r\n\r\n\t\tif ( levels.length > 1 ) {\r\n\r\n\t\t\tv1.setFromMatrixPosition( camera.matrixWorld );\r\n\t\t\tv2.setFromMatrixPosition( this.matrixWorld );\r\n\r\n\t\t\tvar distance = v1.distanceTo( v2 );\r\n\r\n\t\t\tlevels[ 0 ].object.visible = true;\r\n\r\n\t\t\tfor ( var i = 1, l = levels.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tif ( distance >= levels[ i ].distance ) {\r\n\r\n\t\t\t\t\tlevels[ i - 1 ].object.visible = false;\r\n\t\t\t\t\tlevels[ i ].object.visible = true;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( ; i < l; i ++ ) {\r\n\r\n\t\t\t\tlevels[ i ].object.visible = false;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n}();\r\n\r\nTHREE.LOD.prototype.copy = function ( source ) {\r\n\r\n\tTHREE.Object3D.prototype.copy.call( this, source, false );\r\n\r\n\tvar levels = source.levels;\r\n\r\n\tfor ( var i = 0, l = levels.length; i < l; i ++ ) {\r\n\r\n\t\tvar level = levels[ i ];\r\n\r\n\t\tthis.addLevel( level.object.clone(), level.distance );\r\n\r\n\t}\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\nTHREE.LOD.prototype.toJSON = function ( meta ) {\r\n\r\n\tvar data = THREE.Object3D.prototype.toJSON.call( this, meta );\r\n\r\n\tdata.object.levels = [];\r\n\r\n\tvar levels = this.levels;\r\n\r\n\tfor ( var i = 0, l = levels.length; i < l; i ++ ) {\r\n\r\n\t\tvar level = levels[ i ];\r\n\r\n\t\tdata.object.levels.push( {\r\n\t\t\tobject: level.object.uuid,\r\n\t\t\tdistance: level.distance\r\n\t\t} );\r\n\r\n\t}\r\n\r\n\treturn data;\r\n\r\n};\r\n\r\n// File:src/objects/Sprite.js\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Sprite = ( function () {\r\n\r\n\tvar indices = new Uint16Array( [ 0, 1, 2,  0, 2, 3 ] );\r\n\tvar vertices = new Float32Array( [ - 0.5, - 0.5, 0,   0.5, - 0.5, 0,   0.5, 0.5, 0,   - 0.5, 0.5, 0 ] );\r\n\tvar uvs = new Float32Array( [ 0, 0,   1, 0,   1, 1,   0, 1 ] );\r\n\r\n\tvar geometry = new THREE.BufferGeometry();\r\n\tgeometry.setIndex( new THREE.BufferAttribute( indices, 1 ) );\r\n\tgeometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\r\n\tgeometry.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );\r\n\r\n\treturn function Sprite( material ) {\r\n\r\n\t\tTHREE.Object3D.call( this );\r\n\r\n\t\tthis.type = 'Sprite';\r\n\r\n\t\tthis.geometry = geometry;\r\n\t\tthis.material = ( material !== undefined ) ? material : new THREE.SpriteMaterial();\r\n\r\n\t};\r\n\r\n} )();\r\n\r\nTHREE.Sprite.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.Sprite.prototype.constructor = THREE.Sprite;\r\n\r\nTHREE.Sprite.prototype.raycast = ( function () {\r\n\r\n\tvar matrixPosition = new THREE.Vector3();\r\n\r\n\treturn function raycast( raycaster, intersects ) {\r\n\r\n\t\tmatrixPosition.setFromMatrixPosition( this.matrixWorld );\r\n\r\n\t\tvar distanceSq = raycaster.ray.distanceSqToPoint( matrixPosition );\r\n\t\tvar guessSizeSq = this.scale.x * this.scale.y / 4;\r\n\r\n\t\tif ( distanceSq > guessSizeSq ) {\r\n\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tintersects.push( {\r\n\r\n\t\t\tdistance: Math.sqrt( distanceSq ),\r\n\t\t\tpoint: this.position,\r\n\t\t\tface: null,\r\n\t\t\tobject: this\r\n\r\n\t\t} );\r\n\r\n\t};\r\n\r\n}() );\r\n\r\nTHREE.Sprite.prototype.clone = function () {\r\n\r\n\treturn new this.constructor( this.material ).copy( this );\r\n\r\n};\r\n\r\n// Backwards compatibility\r\n\r\nTHREE.Particle = THREE.Sprite;\r\n\r\n// File:src/objects/LensFlare.js\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.LensFlare = function ( texture, size, distance, blending, color ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.lensFlares = [];\r\n\r\n\tthis.positionScreen = new THREE.Vector3();\r\n\tthis.customUpdateCallback = undefined;\r\n\r\n\tif ( texture !== undefined ) {\r\n\r\n\t\tthis.add( texture, size, distance, blending, color );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.LensFlare.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.LensFlare.prototype.constructor = THREE.LensFlare;\r\n\r\n\r\n/*\r\n * Add: adds another flare\r\n */\r\n\r\nTHREE.LensFlare.prototype.add = function ( texture, size, distance, blending, color, opacity ) {\r\n\r\n\tif ( size === undefined ) size = - 1;\r\n\tif ( distance === undefined ) distance = 0;\r\n\tif ( opacity === undefined ) opacity = 1;\r\n\tif ( color === undefined ) color = new THREE.Color( 0xffffff );\r\n\tif ( blending === undefined ) blending = THREE.NormalBlending;\r\n\r\n\tdistance = Math.min( distance, Math.max( 0, distance ) );\r\n\r\n\tthis.lensFlares.push( {\r\n\t\ttexture: texture,\t// THREE.Texture\r\n\t\tsize: size, \t\t// size in pixels (-1 = use texture.width)\r\n\t\tdistance: distance, \t// distance (0-1) from light source (0=at light source)\r\n\t\tx: 0, y: 0, z: 0,\t// screen position (-1 => 1) z = 0 is in front z = 1 is back\r\n\t\tscale: 1, \t\t// scale\r\n\t\trotation: 0, \t\t// rotation\r\n\t\topacity: opacity,\t// opacity\r\n\t\tcolor: color,\t\t// color\r\n\t\tblending: blending\t// blending\r\n\t} );\r\n\r\n};\r\n\r\n/*\r\n * Update lens flares update positions on all flares based on the screen position\r\n * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.\r\n */\r\n\r\nTHREE.LensFlare.prototype.updateLensFlares = function () {\r\n\r\n\tvar f, fl = this.lensFlares.length;\r\n\tvar flare;\r\n\tvar vecX = - this.positionScreen.x * 2;\r\n\tvar vecY = - this.positionScreen.y * 2;\r\n\r\n\tfor ( f = 0; f < fl; f ++ ) {\r\n\r\n\t\tflare = this.lensFlares[ f ];\r\n\r\n\t\tflare.x = this.positionScreen.x + vecX * flare.distance;\r\n\t\tflare.y = this.positionScreen.y + vecY * flare.distance;\r\n\r\n\t\tflare.wantedRotation = flare.x * Math.PI * 0.25;\r\n\t\tflare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.LensFlare.prototype.copy = function ( source ) {\r\n\r\n\tTHREE.Object3D.prototype.copy.call( this, source );\r\n\r\n\tthis.positionScreen.copy( source.positionScreen );\r\n\tthis.customUpdateCallback = source.customUpdateCallback;\r\n\r\n\tfor ( var i = 0, l = source.lensFlares.length; i < l; i ++ ) {\r\n\r\n\t\tthis.lensFlares.push( source.lensFlares[ i ] );\r\n\r\n\t}\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\n// File:src/scenes/Scene.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Scene = function () {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.type = 'Scene';\r\n\r\n\tthis.fog = null;\r\n\tthis.overrideMaterial = null;\r\n\r\n\tthis.autoUpdate = true; // checked by the renderer\r\n\r\n};\r\n\r\nTHREE.Scene.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.Scene.prototype.constructor = THREE.Scene;\r\n\r\nTHREE.Scene.prototype.copy = function ( source, recursive ) {\r\n\r\n\tTHREE.Object3D.prototype.copy.call( this, source, recursive );\r\n\r\n\tif ( source.fog !== null ) this.fog = source.fog.clone();\r\n\tif ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();\r\n\r\n\tthis.autoUpdate = source.autoUpdate;\r\n\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\n// File:src/scenes/Fog.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Fog = function ( color, near, far ) {\r\n\r\n\tthis.name = '';\r\n\r\n\tthis.color = new THREE.Color( color );\r\n\r\n\tthis.near = ( near !== undefined ) ? near : 1;\r\n\tthis.far = ( far !== undefined ) ? far : 1000;\r\n\r\n};\r\n\r\nTHREE.Fog.prototype.clone = function () {\r\n\r\n\treturn new THREE.Fog( this.color.getHex(), this.near, this.far );\r\n\r\n};\r\n\r\n// File:src/scenes/FogExp2.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.FogExp2 = function ( color, density ) {\r\n\r\n\tthis.name = '';\r\n\r\n\tthis.color = new THREE.Color( color );\r\n\tthis.density = ( density !== undefined ) ? density : 0.00025;\r\n\r\n};\r\n\r\nTHREE.FogExp2.prototype.clone = function () {\r\n\r\n\treturn new THREE.FogExp2( this.color.getHex(), this.density );\r\n\r\n};\r\n\r\n// File:src/renderers/shaders/ShaderChunk.js\r\n\r\nTHREE.ShaderChunk = {};\r\n\r\n// File:src/renderers/shaders/ShaderChunk/alphamap_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'alphamap_fragment' ] = \"#ifdef USE_ALPHAMAP\\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/alphamap_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'alphamap_pars_fragment' ] = \"#ifdef USE_ALPHAMAP\\n\tuniform sampler2D alphaMap;\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/alphatest_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'alphatest_fragment' ] = \"#ifdef ALPHATEST\\n\tif ( diffuseColor.a < ALPHATEST ) discard;\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/aomap_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'aomap_fragment' ] = \"#ifdef USE_AOMAP\\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\\n\t#endif\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/aomap_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'aomap_pars_fragment' ] = \"#ifdef USE_AOMAP\\n\tuniform sampler2D aoMap;\\n\tuniform float aoMapIntensity;\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/begin_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'begin_vertex' ] = \"\\nvec3 transformed = vec3( position );\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/beginnormal_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'beginnormal_vertex' ] = \"\\nvec3 objectNormal = vec3( normal );\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/bsdfs.glsl\r\n\r\nTHREE.ShaderChunk[ 'bsdfs' ] = \"bool testLightInRange( const in float lightDistance, const in float cutoffDistance ) {\\n\treturn any( bvec2( cutoffDistance == 0.0, lightDistance < cutoffDistance ) );\\n}\\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\\n\t\tif( decayExponent > 0.0 ) {\\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\\n\t\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\\n\t\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\\n\t\t\treturn distanceFalloff * maxDistanceCutoffFactor;\\n#else\\n\t\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\\n#endif\\n\t\t}\\n\t\treturn 1.0;\\n}\\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\\n\treturn RECIPROCAL_PI * diffuseColor;\\n}\\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\\n}\\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\tfloat a2 = pow2( alpha );\\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\treturn 1.0 / ( gl * gv );\\n}\\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\tfloat a2 = pow2( alpha );\\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\treturn 0.5 / max( gv + gl, EPSILON );\\n}\\nfloat D_GGX( const in float alpha, const in float dotNH ) {\\n\tfloat a2 = pow2( alpha );\\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\\n}\\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\\n\tfloat alpha = pow2( roughness );\\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n\tvec3 F = F_Schlick( specularColor, dotLH );\\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\\n\tfloat D = D_GGX( alpha, dotNH );\\n\treturn F * ( G * D );\\n}\\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\\n\tvec4 r = roughness * c0 + c1;\\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\\n\treturn specularColor * AB.x + AB.y;\\n}\\nfloat G_BlinnPhong_Implicit( ) {\\n\treturn 0.25;\\n}\\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\\n}\\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n\tvec3 F = F_Schlick( specularColor, dotLH );\\n\tfloat G = G_BlinnPhong_Implicit( );\\n\tfloat D = D_BlinnPhong( shininess, dotNH );\\n\treturn F * ( G * D );\\n}\\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\\n}\\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/bumpmap_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'bumpmap_pars_fragment' ] = \"#ifdef USE_BUMPMAP\\n\tuniform sampler2D bumpMap;\\n\tuniform float bumpScale;\\n\tvec2 dHdxy_fwd() {\\n\t\tvec2 dSTdx = dFdx( vUv );\\n\t\tvec2 dSTdy = dFdy( vUv );\\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\\n\t\treturn vec2( dBx, dBy );\\n\t}\\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\\n\t\tvec3 vSigmaX = dFdx( surf_pos );\\n\t\tvec3 vSigmaY = dFdy( surf_pos );\\n\t\tvec3 vN = surf_norm;\\n\t\tvec3 R1 = cross( vSigmaY, vN );\\n\t\tvec3 R2 = cross( vN, vSigmaX );\\n\t\tfloat fDet = dot( vSigmaX, R1 );\\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\\n\t}\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/clipping_planes_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'clipping_planes_fragment' ] = \"#if NUM_CLIPPING_PLANES > 0\\n\tfor ( int i = 0; i < NUM_CLIPPING_PLANES; ++ i ) {\\n\t\tvec4 plane = clippingPlanes[ i ];\\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\\n\t}\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/clipping_planes_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'clipping_planes_pars_fragment' ] = \"#if NUM_CLIPPING_PLANES > 0\\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\\n\t\tvarying vec3 vViewPosition;\\n\t#endif\\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/clipping_planes_pars_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'clipping_planes_pars_vertex' ] = \"#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\\n\tvarying vec3 vViewPosition;\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/clipping_planes_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'clipping_planes_vertex' ] = \"#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\\n\tvViewPosition = - mvPosition.xyz;\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/color_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'color_fragment' ] = \"#ifdef USE_COLOR\\n\tdiffuseColor.rgb *= vColor;\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/color_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'color_pars_fragment' ] = \"#ifdef USE_COLOR\\n\tvarying vec3 vColor;\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/color_pars_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'color_pars_vertex' ] = \"#ifdef USE_COLOR\\n\tvarying vec3 vColor;\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/color_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'color_vertex' ] = \"#ifdef USE_COLOR\\n\tvColor.xyz = color.xyz;\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/common.glsl\r\n\r\nTHREE.ShaderChunk[ 'common' ] = \"#define PI 3.14159265359\\n#define PI2 6.28318530718\\n#define RECIPROCAL_PI 0.31830988618\\n#define RECIPROCAL_PI2 0.15915494\\n#define LOG2 1.442695\\n#define EPSILON 1e-6\\n#define saturate(a) clamp( a, 0.0, 1.0 )\\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\\nfloat pow2( const in float x ) { return x*x; }\\nfloat pow3( const in float x ) { return x*x*x; }\\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\\nhighp float rand( const in vec2 uv ) {\\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\\n\treturn fract(sin(sn) * c);\\n}\\nstruct IncidentLight {\\n\tvec3 color;\\n\tvec3 direction;\\n\tbool visible;\\n};\\nstruct ReflectedLight {\\n\tvec3 directDiffuse;\\n\tvec3 directSpecular;\\n\tvec3 indirectDiffuse;\\n\tvec3 indirectSpecular;\\n};\\nstruct GeometricContext {\\n\tvec3 position;\\n\tvec3 normal;\\n\tvec3 viewDir;\\n};\\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\\n}\\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\\n}\\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\\n\treturn - distance * planeNormal + point;\\n}\\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\\n}\\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/cube_uv_reflection_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'cube_uv_reflection_fragment' ] = \"#ifdef ENVMAP_TYPE_CUBE_UV\\nconst float cubeUV_textureSize = 1024.0;\\nint getFaceFromDirection(vec3 direction) {\\n\tvec3 absDirection = abs(direction);\\n\tint face = -1;\\n\tif( absDirection.x > absDirection.z ) {\\n\t\tif(absDirection.x > absDirection.y )\\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\\n\t\telse\\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\\n\t}\\n\telse {\\n\t\tif(absDirection.z > absDirection.y )\\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\\n\t\telse\\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\\n\t}\\n\treturn face;\\n}\\nfloat cubeUV_maxLods1 = log2(cubeUV_textureSize*0.25) - 1.0;\\nfloat cubeUV_rangeClamp = exp2((6.0 - 1.0) * 2.0);\\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\\n\tfloat dxRoughness = dFdx(roughness);\\n\tfloat dyRoughness = dFdy(roughness);\\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\\n\tfloat mipLevel = 0.5 * log2(d);\\n\treturn vec2(floor(mipLevel), fract(mipLevel));\\n}\\nfloat cubeUV_maxLods2 = log2(cubeUV_textureSize*0.25) - 2.0;\\nconst float cubeUV_rcpTextureSize = 1.0 / cubeUV_textureSize;\\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\\n\tbool bRes = mipLevel == 0.0;\\n\tscale =  bRes && (scale < a) ? a : scale;\\n\tvec3 r;\\n\tvec2 offset;\\n\tint face = getFaceFromDirection(direction);\\n\tfloat rcpPowScale = 1.0 / powScale;\\n\tif( face == 0) {\\n\t\tr = vec3(direction.x, -direction.z, direction.y);\\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\\n\t}\\n\telse if( face == 1) {\\n\t\tr = vec3(direction.y, direction.x, direction.z);\\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\\n\t}\\n\telse if( face == 2) {\\n\t\tr = vec3(direction.z, direction.x, direction.y);\\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\\n\t}\\n\telse if( face == 3) {\\n\t\tr = vec3(direction.x, direction.z, direction.y);\\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\\n\t}\\n\telse if( face == 4) {\\n\t\tr = vec3(direction.y, direction.x, -direction.z);\\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\\n\t}\\n\telse {\\n\t\tr = vec3(direction.z, -direction.x, direction.y);\\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\\n\t}\\n\tr = normalize(r);\\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\\n\tvec2 base = offset + vec2( texelOffset );\\n\treturn base + s * ( scale - 2.0 * texelOffset );\\n}\\nfloat cubeUV_maxLods3 = log2(cubeUV_textureSize*0.25) - 3.0;\\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\\n\tfloat r1 = floor(roughnessVal);\\n\tfloat r2 = r1 + 1.0;\\n\tfloat t = fract(roughnessVal);\\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\\n\tfloat s = mipInfo.y;\\n\tfloat level0 = mipInfo.x;\\n\tfloat level1 = level0 + 1.0;\\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\\n\tvec4 result = mix(color10, color20, t);\\n\treturn vec4(result.rgb, 1.0);\\n}\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/defaultnormal_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'defaultnormal_vertex' ] = \"#ifdef FLIP_SIDED\\n\tobjectNormal = -objectNormal;\\n#endif\\nvec3 transformedNormal = normalMatrix * objectNormal;\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/displacementmap_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'displacementmap_vertex' ] = \"#ifdef USE_DISPLACEMENTMAP\\n\ttransformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/displacementmap_pars_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'displacementmap_pars_vertex' ] = \"#ifdef USE_DISPLACEMENTMAP\\n\tuniform sampler2D displacementMap;\\n\tuniform float displacementScale;\\n\tuniform float displacementBias;\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/emissivemap_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'emissivemap_fragment' ] = \"#ifdef USE_EMISSIVEMAP\\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/emissivemap_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'emissivemap_pars_fragment' ] = \"#ifdef USE_EMISSIVEMAP\\n\tuniform sampler2D emissiveMap;\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/encodings_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'encodings_pars_fragment' ] = \"\\nvec4 LinearToLinear( in vec4 value ) {\\n  return value;\\n}\\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\\n  return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\\n}\\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\\n  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\\n}\\nvec4 sRGBToLinear( in vec4 value ) {\\n  return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\\n}\\nvec4 LinearTosRGB( in vec4 value ) {\\n  return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\\n}\\nvec4 RGBEToLinear( in vec4 value ) {\\n  return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\\n}\\nvec4 LinearToRGBE( in vec4 value ) {\\n  float maxComponent = max( max( value.r, value.g ), value.b );\\n  float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\\n  return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\\n}\\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\\n  return vec4( value.xyz * value.w * maxRange, 1.0 );\\n}\\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\\n  float maxRGB = max( value.x, max( value.g, value.b ) );\\n  float M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\\n  M            = ceil( M * 255.0 ) / 255.0;\\n  return vec4( value.rgb / ( M * maxRange ), M );\\n}\\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\\n    return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\\n}\\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\\n    float maxRGB = max( value.x, max( value.g, value.b ) );\\n    float D      = max( maxRange / maxRGB, 1.0 );\\n    D            = min( floor( D ) / 255.0, 1.0 );\\n    return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\\n}\\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\\nvec4 LinearToLogLuv( in vec4 value )  {\\n  vec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\\n  Xp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\\n  vec4 vResult;\\n  vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\\n  float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\\n  vResult.w = fract(Le);\\n  vResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\\n  return vResult;\\n}\\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\\nvec4 LogLuvToLinear( in vec4 value ) {\\n  float Le = value.z * 255.0 + value.w;\\n  vec3 Xp_Y_XYZp;\\n  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\\n  Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\\n  Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\\n  vec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\\n  return vec4( max(vRGB, 0.0), 1.0 );\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/encodings_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'encodings_fragment' ] = \"  gl_FragColor = linearToOutputTexel( gl_FragColor );\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/envmap_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'envmap_fragment' ] = \"#ifdef USE_ENVMAP\\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\\n\t\t#ifdef ENVMAP_MODE_REFLECTION\\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\\n\t\t#else\\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\\n\t\t#endif\\n\t#else\\n\t\tvec3 reflectVec = vReflect;\\n\t#endif\\n\t#ifdef DOUBLE_SIDED\\n\t\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\n\t#else\\n\t\tfloat flipNormal = 1.0;\\n\t#endif\\n\t#ifdef ENVMAP_TYPE_CUBE\\n\t\tvec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\\n\t\tvec2 sampleUV;\\n\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\\n\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\\n\t#elif defined( ENVMAP_TYPE_SPHERE )\\n\t\tvec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\\n\t#endif\\n\tenvColor = envMapTexelToLinear( envColor );\\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\\n\t#elif defined( ENVMAP_BLENDING_MIX )\\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\\n\t#elif defined( ENVMAP_BLENDING_ADD )\\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\\n\t#endif\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/envmap_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'envmap_pars_fragment' ] = \"#if defined( USE_ENVMAP ) || defined( PHYSICAL )\\n\tuniform float reflectivity;\\n\tuniform float envMapIntenstiy;\\n#endif\\n#ifdef USE_ENVMAP\\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\\n\t\tvarying vec3 vWorldPosition;\\n\t#endif\\n\t#ifdef ENVMAP_TYPE_CUBE\\n\t\tuniform samplerCube envMap;\\n\t#else\\n\t\tuniform sampler2D envMap;\\n\t#endif\\n\tuniform float flipEnvMap;\\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\\n\t\tuniform float refractionRatio;\\n\t#else\\n\t\tvarying vec3 vReflect;\\n\t#endif\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/envmap_pars_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'envmap_pars_vertex' ] = \"#ifdef USE_ENVMAP\\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\t\tvarying vec3 vWorldPosition;\\n\t#else\\n\t\tvarying vec3 vReflect;\\n\t\tuniform float refractionRatio;\\n\t#endif\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/envmap_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'envmap_vertex' ] = \"#ifdef USE_ENVMAP\\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\t\tvWorldPosition = worldPosition.xyz;\\n\t#else\\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\\n\t\t#ifdef ENVMAP_MODE_REFLECTION\\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\\n\t\t#else\\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\\n\t\t#endif\\n\t#endif\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/fog_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'fog_fragment' ] = \"#ifdef USE_FOG\\n\t#ifdef USE_LOGDEPTHBUF_EXT\\n\t\tfloat depth = gl_FragDepthEXT / gl_FragCoord.w;\\n\t#else\\n\t\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\\n\t#endif\\n\t#ifdef FOG_EXP2\\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );\\n\t#else\\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, depth );\\n\t#endif\\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/fog_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'fog_pars_fragment' ] = \"#ifdef USE_FOG\\n\tuniform vec3 fogColor;\\n\t#ifdef FOG_EXP2\\n\t\tuniform float fogDensity;\\n\t#else\\n\t\tuniform float fogNear;\\n\t\tuniform float fogFar;\\n\t#endif\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/lightmap_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'lightmap_fragment' ] = \"#ifdef USE_LIGHTMAP\\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/lightmap_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'lightmap_pars_fragment' ] = \"#ifdef USE_LIGHTMAP\\n\tuniform sampler2D lightMap;\\n\tuniform float lightMapIntensity;\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/lights_lambert_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'lights_lambert_vertex' ] = \"vec3 diffuse = vec3( 1.0 );\\nGeometricContext geometry;\\ngeometry.position = mvPosition.xyz;\\ngeometry.normal = normalize( transformedNormal );\\ngeometry.viewDir = normalize( -mvPosition.xyz );\\nGeometricContext backGeometry;\\nbackGeometry.position = geometry.position;\\nbackGeometry.normal = -geometry.normal;\\nbackGeometry.viewDir = geometry.viewDir;\\nvLightFront = vec3( 0.0 );\\n#ifdef DOUBLE_SIDED\\n\tvLightBack = vec3( 0.0 );\\n#endif\\nIncidentLight directLight;\\nfloat dotNL;\\nvec3 directLightColor_Diffuse;\\n#if NUM_POINT_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\\n\t\tdotNL = dot( geometry.normal, directLight.direction );\\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\t\t#ifdef DOUBLE_SIDED\\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\t\t#endif\\n\t}\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\\n\t\tdotNL = dot( geometry.normal, directLight.direction );\\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\t\t#ifdef DOUBLE_SIDED\\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\t\t#endif\\n\t}\\n#endif\\n#if NUM_DIR_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\\n\t\tdotNL = dot( geometry.normal, directLight.direction );\\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\t\t#ifdef DOUBLE_SIDED\\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\t\t#endif\\n\t}\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n\t\t#ifdef DOUBLE_SIDED\\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\\n\t\t#endif\\n\t}\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/lights_pars.glsl\r\n\r\nTHREE.ShaderChunk[ 'lights_pars' ] = \"uniform vec3 ambientLightColor;\\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\\n\tvec3 irradiance = ambientLightColor;\\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\t\tirradiance *= PI;\\n\t#endif\\n\treturn irradiance;\\n}\\n#if NUM_DIR_LIGHTS > 0\\n\tstruct DirectionalLight {\\n\t\tvec3 direction;\\n\t\tvec3 color;\\n\t\tint shadow;\\n\t\tfloat shadowBias;\\n\t\tfloat shadowRadius;\\n\t\tvec2 shadowMapSize;\\n\t};\\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\t\tdirectLight.color = directionalLight.color;\\n\t\tdirectLight.direction = directionalLight.direction;\\n\t\tdirectLight.visible = true;\\n\t}\\n#endif\\n#if NUM_POINT_LIGHTS > 0\\n\tstruct PointLight {\\n\t\tvec3 position;\\n\t\tvec3 color;\\n\t\tfloat distance;\\n\t\tfloat decay;\\n\t\tint shadow;\\n\t\tfloat shadowBias;\\n\t\tfloat shadowRadius;\\n\t\tvec2 shadowMapSize;\\n\t};\\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\t\tvec3 lVector = pointLight.position - geometry.position;\\n\t\tdirectLight.direction = normalize( lVector );\\n\t\tfloat lightDistance = length( lVector );\\n\t\tif ( testLightInRange( lightDistance, pointLight.distance ) ) {\\n\t\t\tdirectLight.color = pointLight.color;\\n\t\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\\n\t\t\tdirectLight.visible = true;\\n\t\t} else {\\n\t\t\tdirectLight.color = vec3( 0.0 );\\n\t\t\tdirectLight.visible = false;\\n\t\t}\\n\t}\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\tstruct SpotLight {\\n\t\tvec3 position;\\n\t\tvec3 direction;\\n\t\tvec3 color;\\n\t\tfloat distance;\\n\t\tfloat decay;\\n\t\tfloat coneCos;\\n\t\tfloat penumbraCos;\\n\t\tint shadow;\\n\t\tfloat shadowBias;\\n\t\tfloat shadowRadius;\\n\t\tvec2 shadowMapSize;\\n\t};\\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\\n\t\tvec3 lVector = spotLight.position - geometry.position;\\n\t\tdirectLight.direction = normalize( lVector );\\n\t\tfloat lightDistance = length( lVector );\\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\\n\t\tif ( all( bvec2( angleCos > spotLight.coneCos, testLightInRange( lightDistance, spotLight.distance ) ) ) ) {\\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\\n\t\t\tdirectLight.color = spotLight.color;\\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\\n\t\t\tdirectLight.visible = true;\\n\t\t} else {\\n\t\t\tdirectLight.color = vec3( 0.0 );\\n\t\t\tdirectLight.visible = false;\\n\t\t}\\n\t}\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\tstruct HemisphereLight {\\n\t\tvec3 direction;\\n\t\tvec3 skyColor;\\n\t\tvec3 groundColor;\\n\t};\\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\t\t\tirradiance *= PI;\\n\t\t#endif\\n\t\treturn irradiance;\\n\t}\\n#endif\\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\\n\t\t#ifdef DOUBLE_SIDED\\n\t\t\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\n\t\t#else\\n\t\t\tfloat flipNormal = 1.0;\\n\t\t#endif\\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\\n\t\t#ifdef ENVMAP_TYPE_CUBE\\n\t\t\tvec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\\n\t\t\t#ifdef TEXTURE_LOD_EXT\\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\\n\t\t\t#else\\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\\n\t\t\t#endif\\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\t\t\tvec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\\n\t\t#else\\n\t\t\tvec4 envMapColor = vec4( 0.0 );\\n\t\t#endif\\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\\n\t}\\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\\n\t}\\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\\n\t\t#ifdef ENVMAP_MODE_REFLECTION\\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\\n\t\t#else\\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\\n\t\t#endif\\n\t\t#ifdef DOUBLE_SIDED\\n\t\t\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\n\t\t#else\\n\t\t\tfloat flipNormal = 1.0;\\n\t\t#endif\\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\\n\t\t#ifdef ENVMAP_TYPE_CUBE\\n\t\t\tvec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\\n\t\t\t#ifdef TEXTURE_LOD_EXT\\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\\n\t\t\t#else\\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\\n\t\t\t#endif\\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\t\t\tvec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\\n\t\t\tvec2 sampleUV;\\n\t\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\\n\t\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\\n\t\t\t#ifdef TEXTURE_LOD_EXT\\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\\n\t\t\t#else\\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\\n\t\t\t#endif\\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\\n\t\t\tvec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\\n\t\t\t#ifdef TEXTURE_LOD_EXT\\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\\n\t\t\t#else\\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\\n\t\t\t#endif\\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\t\t#endif\\n\t\treturn envMapColor.rgb * envMapIntensity;\\n\t}\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/lights_phong_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'lights_phong_fragment' ] = \"BlinnPhongMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb;\\nmaterial.specularColor = specular;\\nmaterial.specularShininess = shininess;\\nmaterial.specularStrength = specularStrength;\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'lights_phong_pars_fragment' ] = \"varying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\tvarying vec3 vNormal;\\n#endif\\nstruct BlinnPhongMaterial {\\n\tvec3\tdiffuseColor;\\n\tvec3\tspecularColor;\\n\tfloat\tspecularShininess;\\n\tfloat\tspecularStrength;\\n};\\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\tvec3 irradiance = dotNL * directLight.color;\\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\t\tirradiance *= PI;\\n\t#endif\\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\\n}\\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\\n#define Material_LightProbeLOD( material )\t(0)\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/lights_physical_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'lights_physical_fragment' ] = \"PhysicalMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\\n#ifdef STANDARD\\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\\n#else\\n\tmaterial.specularColor = mix( vec3( 0.16 * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/lights_physical_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'lights_physical_pars_fragment' ] = \"struct PhysicalMaterial {\\n\tvec3\tdiffuseColor;\\n\tfloat\tspecularRoughness;\\n\tvec3\tspecularColor;\\n\t#ifndef STANDARD\\n\t#endif\\n};\\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\tvec3 irradiance = dotNL * directLight.color;\\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\t\tirradiance *= PI;\\n\t#endif\\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\\n}\\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\treflectedLight.indirectSpecular += radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\\n}\\n#define RE_Direct\t\t\t\tRE_Direct_Physical\\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/lights_template.glsl\r\n\r\nTHREE.ShaderChunk[ 'lights_template' ] = \"\\nGeometricContext geometry;\\ngeometry.position = - vViewPosition;\\ngeometry.normal = normal;\\ngeometry.viewDir = normalize( vViewPosition );\\nIncidentLight directLight;\\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\\n\tPointLight pointLight;\\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\t\tpointLight = pointLights[ i ];\\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\\n\t\t#ifdef USE_SHADOWMAP\\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\\n\t\t#endif\\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\t}\\n#endif\\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\\n\tSpotLight spotLight;\\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\t\tspotLight = spotLights[ i ];\\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\\n\t\t#ifdef USE_SHADOWMAP\\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\t\t#endif\\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\t}\\n#endif\\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\\n\tDirectionalLight directionalLight;\\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\t\tdirectionalLight = directionalLights[ i ];\\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\\n\t\t#ifdef USE_SHADOWMAP\\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\t\t#endif\\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\t}\\n#endif\\n#if defined( RE_IndirectDiffuse )\\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\\n\t#ifdef USE_LIGHTMAP\\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\t\t\tlightMapIrradiance *= PI;\\n\t\t#endif\\n\t\tirradiance += lightMapIrradiance;\\n\t#endif\\n\t#if ( NUM_HEMI_LIGHTS > 0 )\\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n\t\t}\\n\t#endif\\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\\n\t \tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\\n\t#endif\\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\\n#endif\\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\\n\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\\n\tRE_IndirectSpecular( radiance, geometry, material, reflectedLight );\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/logdepthbuf_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'logdepthbuf_fragment' ] = \"#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\\n\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'logdepthbuf_pars_fragment' ] = \"#ifdef USE_LOGDEPTHBUF\\n\tuniform float logDepthBufFC;\\n\t#ifdef USE_LOGDEPTHBUF_EXT\\n\t\tvarying float vFragDepth;\\n\t#endif\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'logdepthbuf_pars_vertex' ] = \"#ifdef USE_LOGDEPTHBUF\\n\t#ifdef USE_LOGDEPTHBUF_EXT\\n\t\tvarying float vFragDepth;\\n\t#endif\\n\tuniform float logDepthBufFC;\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/logdepthbuf_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'logdepthbuf_vertex' ] = \"#ifdef USE_LOGDEPTHBUF\\n\tgl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\\n\t#ifdef USE_LOGDEPTHBUF_EXT\\n\t\tvFragDepth = 1.0 + gl_Position.w;\\n\t#else\\n\t\tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\\n\t#endif\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/map_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'map_fragment' ] = \"#ifdef USE_MAP\\n\tvec4 texelColor = texture2D( map, vUv );\\n\ttexelColor = mapTexelToLinear( texelColor );\\n\tdiffuseColor *= texelColor;\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/map_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'map_pars_fragment' ] = \"#ifdef USE_MAP\\n\tuniform sampler2D map;\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/map_particle_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'map_particle_fragment' ] = \"#ifdef USE_MAP\\n\tvec4 mapTexel = texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/map_particle_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'map_particle_pars_fragment' ] = \"#ifdef USE_MAP\\n\tuniform vec4 offsetRepeat;\\n\tuniform sampler2D map;\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/metalnessmap_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'metalnessmap_fragment' ] = \"float metalnessFactor = metalness;\\n#ifdef USE_METALNESSMAP\\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\\n\tmetalnessFactor *= texelMetalness.r;\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/metalnessmap_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'metalnessmap_pars_fragment' ] = \"#ifdef USE_METALNESSMAP\\n\tuniform sampler2D metalnessMap;\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/morphnormal_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'morphnormal_vertex' ] = \"#ifdef USE_MORPHNORMALS\\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/morphtarget_pars_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'morphtarget_pars_vertex' ] = \"#ifdef USE_MORPHTARGETS\\n\t#ifndef USE_MORPHNORMALS\\n\tuniform float morphTargetInfluences[ 8 ];\\n\t#else\\n\tuniform float morphTargetInfluences[ 4 ];\\n\t#endif\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/morphtarget_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'morphtarget_vertex' ] = \"#ifdef USE_MORPHTARGETS\\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\\n\t#ifndef USE_MORPHNORMALS\\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\\n\t#endif\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/normal_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'normal_fragment' ] = \"#ifdef FLAT_SHADED\\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\\n\tvec3 normal = normalize( cross( fdx, fdy ) );\\n#else\\n\tvec3 normal = normalize( vNormal );\\n\t#ifdef DOUBLE_SIDED\\n\t\tnormal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\\n\t#endif\\n#endif\\n#ifdef USE_NORMALMAP\\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\\n#elif defined( USE_BUMPMAP )\\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/normalmap_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'normalmap_pars_fragment' ] = \"#ifdef USE_NORMALMAP\\n\tuniform sampler2D normalMap;\\n\tuniform vec2 normalScale;\\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\\n\t\tvec2 st0 = dFdx( vUv.st );\\n\t\tvec2 st1 = dFdy( vUv.st );\\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\\n\t\tvec3 N = normalize( surf_norm );\\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\\n\t\tmapN.xy = normalScale * mapN.xy;\\n\t\tmat3 tsn = mat3( S, T, N );\\n\t\treturn normalize( tsn * mapN );\\n\t}\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/packing.glsl\r\n\r\nTHREE.ShaderChunk[ 'packing' ] = \"vec3 packNormalToRGB( const in vec3 normal ) {\\n  return normalize( normal ) * 0.5 + 0.5;\\n}\\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\\n  return 1.0 - 2.0 * rgb.xyz;\\n}\\nvec4 packDepthToRGBA( const in float value ) {\\n\tconst vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );\\n\tconst vec4 bit_mask = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );\\n\tvec4 res = mod( value * bit_shift * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );\\n\tres -= res.xxyz * bit_mask;\\n\treturn res;\\n}\\nfloat unpackRGBAToDepth( const in vec4 rgba ) {\\n\tconst vec4 bitSh = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\\n\treturn dot( rgba, bitSh );\\n}\\nfloat viewZToOrthoDepth( const in float viewZ, const in float near, const in float far ) {\\n  return ( viewZ + near ) / ( near - far );\\n}\\nfloat OrthoDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\\n  return linearClipZ * ( near - far ) - near;\\n}\\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\\n  return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\\n}\\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\\n  return ( near * far ) / ( ( far - near ) * invClipZ - far );\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/premultiplied_alpha_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'premultiplied_alpha_fragment' ] = \"#ifdef PREMULTIPLIED_ALPHA\\n\tgl_FragColor.rgb *= gl_FragColor.a;\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/project_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'project_vertex' ] = \"#ifdef USE_SKINNING\\n\tvec4 mvPosition = modelViewMatrix * skinned;\\n#else\\n\tvec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\\n#endif\\ngl_Position = projectionMatrix * mvPosition;\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/roughnessmap_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'roughnessmap_fragment' ] = \"float roughnessFactor = roughness;\\n#ifdef USE_ROUGHNESSMAP\\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\\n\troughnessFactor *= texelRoughness.r;\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/roughnessmap_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'roughnessmap_pars_fragment' ] = \"#ifdef USE_ROUGHNESSMAP\\n\tuniform sampler2D roughnessMap;\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'shadowmap_pars_fragment' ] = \"#ifdef USE_SHADOWMAP\\n\t#if NUM_DIR_LIGHTS > 0\\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\\n\t#endif\\n\t#if NUM_SPOT_LIGHTS > 0\\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\\n\t#endif\\n\t#if NUM_POINT_LIGHTS > 0\\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\\n\t#endif\\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\\n\t}\\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\\n\t\tvec2 f = fract( uv * size + 0.5 );\\n\t\tfloat a = mix( lb, lt, f.y );\\n\t\tfloat b = mix( rb, rt, f.y );\\n\t\tfloat c = mix( a, b, f.x );\\n\t\treturn c;\\n\t}\\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\\n\t\tshadowCoord.xyz /= shadowCoord.w;\\n\t\tshadowCoord.z += shadowBias;\\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\\n\t\tbool inFrustum = all( inFrustumVec );\\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\\n\t\tbool frustumTest = all( frustumTestVec );\\n\t\tif ( frustumTest ) {\\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\\n\t\t\treturn (\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\n\t\t\t) * ( 1.0 / 9.0 );\\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\\n\t\t\treturn (\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\n\t\t\t) * ( 1.0 / 9.0 );\\n\t\t#else\\n\t\t\treturn texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\\n\t\t#endif\\n\t\t}\\n\t\treturn 1.0;\\n\t}\\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\\n\t\tvec3 absV = abs( v );\\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\\n\t\tabsV *= scaleToCube;\\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\\n\t\tvec2 planar = v.xy;\\n\t\tfloat almostATexel = 1.5 * texelSizeY;\\n\t\tfloat almostOne = 1.0 - almostATexel;\\n\t\tif ( absV.z >= almostOne ) {\\n\t\t\tif ( v.z > 0.0 )\\n\t\t\t\tplanar.x = 4.0 - v.x;\\n\t\t} else if ( absV.x >= almostOne ) {\\n\t\t\tfloat signX = sign( v.x );\\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\\n\t\t} else if ( absV.y >= almostOne ) {\\n\t\t\tfloat signY = sign( v.y );\\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\\n\t\t\tplanar.y = v.z * signY - 2.0;\\n\t\t}\\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\\n\t}\\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\\n\t\tvec3 lightToPosition = shadowCoord.xyz;\\n\t\tvec3 bd3D = normalize( lightToPosition );\\n\t\tfloat dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\\n\t\t\treturn (\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\\n\t\t\t) * ( 1.0 / 9.0 );\\n\t\t#else\\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\\n\t\t#endif\\n\t}\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'shadowmap_pars_vertex' ] = \"#ifdef USE_SHADOWMAP\\n\t#if NUM_DIR_LIGHTS > 0\\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\\n\t#endif\\n\t#if NUM_SPOT_LIGHTS > 0\\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\\n\t#endif\\n\t#if NUM_POINT_LIGHTS > 0\\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\\n\t#endif\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/shadowmap_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'shadowmap_vertex' ] = \"#ifdef USE_SHADOWMAP\\n\t#if NUM_DIR_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\\n\t}\\n\t#endif\\n\t#if NUM_SPOT_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\\n\t}\\n\t#endif\\n\t#if NUM_POINT_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\\n\t}\\n\t#endif\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/shadowmask_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'shadowmask_pars_fragment' ] = \"float getShadowMask() {\\n\tfloat shadow = 1.0;\\n\t#ifdef USE_SHADOWMAP\\n\t#if NUM_DIR_LIGHTS > 0\\n\tDirectionalLight directionalLight;\\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\t\tdirectionalLight = directionalLights[ i ];\\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\t}\\n\t#endif\\n\t#if NUM_SPOT_LIGHTS > 0\\n\tSpotLight spotLight;\\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\t\tspotLight = spotLights[ i ];\\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\t}\\n\t#endif\\n\t#if NUM_POINT_LIGHTS > 0\\n\tPointLight pointLight;\\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\t\tpointLight = pointLights[ i ];\\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\\n\t}\\n\t#endif\\n\t#endif\\n\treturn shadow;\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/skinbase_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'skinbase_vertex' ] = \"#ifdef USE_SKINNING\\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/skinning_pars_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'skinning_pars_vertex' ] = \"#ifdef USE_SKINNING\\n\tuniform mat4 bindMatrix;\\n\tuniform mat4 bindMatrixInverse;\\n\t#ifdef BONE_TEXTURE\\n\t\tuniform sampler2D boneTexture;\\n\t\tuniform int boneTextureWidth;\\n\t\tuniform int boneTextureHeight;\\n\t\tmat4 getBoneMatrix( const in float i ) {\\n\t\t\tfloat j = i * 4.0;\\n\t\t\tfloat x = mod( j, float( boneTextureWidth ) );\\n\t\t\tfloat y = floor( j / float( boneTextureWidth ) );\\n\t\t\tfloat dx = 1.0 / float( boneTextureWidth );\\n\t\t\tfloat dy = 1.0 / float( boneTextureHeight );\\n\t\t\ty = dy * ( y + 0.5 );\\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\\n\t\t\treturn bone;\\n\t\t}\\n\t#else\\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\\n\t\tmat4 getBoneMatrix( const in float i ) {\\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\\n\t\t\treturn bone;\\n\t\t}\\n\t#endif\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/skinning_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'skinning_vertex' ] = \"#ifdef USE_SKINNING\\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\\n\tvec4 skinned = vec4( 0.0 );\\n\tskinned += boneMatX * skinVertex * skinWeight.x;\\n\tskinned += boneMatY * skinVertex * skinWeight.y;\\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\\n\tskinned += boneMatW * skinVertex * skinWeight.w;\\n\tskinned  = bindMatrixInverse * skinned;\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/skinnormal_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'skinnormal_vertex' ] = \"#ifdef USE_SKINNING\\n\tmat4 skinMatrix = mat4( 0.0 );\\n\tskinMatrix += skinWeight.x * boneMatX;\\n\tskinMatrix += skinWeight.y * boneMatY;\\n\tskinMatrix += skinWeight.z * boneMatZ;\\n\tskinMatrix += skinWeight.w * boneMatW;\\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/specularmap_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'specularmap_fragment' ] = \"float specularStrength;\\n#ifdef USE_SPECULARMAP\\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\\n\tspecularStrength = texelSpecular.r;\\n#else\\n\tspecularStrength = 1.0;\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/specularmap_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'specularmap_pars_fragment' ] = \"#ifdef USE_SPECULARMAP\\n\tuniform sampler2D specularMap;\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/tonemapping_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'tonemapping_fragment' ] = \"#if defined( TONE_MAPPING )\\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/tonemapping_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'tonemapping_pars_fragment' ] = \"#define saturate(a) clamp( a, 0.0, 1.0 )\\nuniform float toneMappingExposure;\\nuniform float toneMappingWhitePoint;\\nvec3 LinearToneMapping( vec3 color ) {\\n  return toneMappingExposure * color;\\n}\\nvec3 ReinhardToneMapping( vec3 color ) {\\n  color *= toneMappingExposure;\\n  return saturate( color / ( vec3( 1.0 ) + color ) );\\n}\\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\\nvec3 Uncharted2ToneMapping( vec3 color ) {\\n  color *= toneMappingExposure;\\n  return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\\n}\\nvec3 OptimizedCineonToneMapping( vec3 color ) {\\n  color *= toneMappingExposure;\\n  color = max( vec3( 0.0 ), color - 0.004 );\\n  return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/uv2_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'uv2_pars_fragment' ] = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\tvarying vec2 vUv2;\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/uv2_pars_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'uv2_pars_vertex' ] = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\tattribute vec2 uv2;\\n\tvarying vec2 vUv2;\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/uv2_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'uv2_vertex' ] = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\tvUv2 = uv2;\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/uv_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'uv_pars_fragment' ] = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\tvarying vec2 vUv;\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/uv_pars_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'uv_pars_vertex' ] = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\tvarying vec2 vUv;\\n\tuniform vec4 offsetRepeat;\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/uv_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'uv_vertex' ] = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/worldpos_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'worldpos_vertex' ] = \"#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( PHYSICAL ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\\n\t#ifdef USE_SKINNING\\n\t\tvec4 worldPosition = modelMatrix * skinned;\\n\t#else\\n\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\\n\t#endif\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/UniformsUtils.js\r\n\r\n/**\r\n * Uniform Utilities\r\n */\r\n\r\nTHREE.UniformsUtils = {\r\n\r\n\tmerge: function ( uniforms ) {\r\n\r\n\t\tvar merged = {};\r\n\r\n\t\tfor ( var u = 0; u < uniforms.length; u ++ ) {\r\n\r\n\t\t\tvar tmp = this.clone( uniforms[ u ] );\r\n\r\n\t\t\tfor ( var p in tmp ) {\r\n\r\n\t\t\t\tmerged[ p ] = tmp[ p ];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn merged;\r\n\r\n\t},\r\n\r\n\tclone: function ( uniforms_src ) {\r\n\r\n\t\tvar uniforms_dst = {};\r\n\r\n\t\tfor ( var u in uniforms_src ) {\r\n\r\n\t\t\tuniforms_dst[ u ] = {};\r\n\r\n\t\t\tfor ( var p in uniforms_src[ u ] ) {\r\n\r\n\t\t\t\tvar parameter_src = uniforms_src[ u ][ p ];\r\n\r\n\t\t\t\tif ( parameter_src instanceof THREE.Color ||\r\n\t\t\t\t\t parameter_src instanceof THREE.Vector2 ||\r\n\t\t\t\t\t parameter_src instanceof THREE.Vector3 ||\r\n\t\t\t\t\t parameter_src instanceof THREE.Vector4 ||\r\n\t\t\t\t\t parameter_src instanceof THREE.Matrix3 ||\r\n\t\t\t\t\t parameter_src instanceof THREE.Matrix4 ||\r\n\t\t\t\t\t parameter_src instanceof THREE.Texture ) {\r\n\r\n\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src.clone();\r\n\r\n\t\t\t\t} else if ( Array.isArray( parameter_src ) ) {\r\n\r\n\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src.slice();\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn uniforms_dst;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/renderers/shaders/UniformsLib.js\r\n\r\n/**\r\n * Uniforms library for shared webgl shaders\r\n */\r\n\r\nTHREE.UniformsLib = {\r\n\r\n\tcommon: {\r\n\r\n\t\t\"diffuse\": { type: \"c\", value: new THREE.Color( 0xeeeeee ) },\r\n\t\t\"opacity\": { type: \"1f\", value: 1.0 },\r\n\r\n\t\t\"map\": { type: \"t\", value: null },\r\n\t\t\"offsetRepeat\": { type: \"v4\", value: new THREE.Vector4( 0, 0, 1, 1 ) },\r\n\r\n\t\t\"specularMap\": { type: \"t\", value: null },\r\n\t\t\"alphaMap\": { type: \"t\", value: null },\r\n\r\n\t\t\"envMap\": { type: \"t\", value: null },\r\n\t\t\"flipEnvMap\": { type: \"1f\", value: - 1 },\r\n\t\t\"reflectivity\": { type: \"1f\", value: 1.0 },\r\n\t\t\"refractionRatio\": { type: \"1f\", value: 0.98 }\r\n\r\n\t},\r\n\r\n\taomap: {\r\n\r\n\t\t\"aoMap\": { type: \"t\", value: null },\r\n\t\t\"aoMapIntensity\": { type: \"1f\", value: 1 }\r\n\r\n\t},\r\n\r\n\tlightmap: {\r\n\r\n\t\t\"lightMap\": { type: \"t\", value: null },\r\n\t\t\"lightMapIntensity\": { type: \"1f\", value: 1 }\r\n\r\n\t},\r\n\r\n\temissivemap: {\r\n\r\n\t\t\"emissiveMap\": { type: \"t\", value: null }\r\n\r\n\t},\r\n\r\n\tbumpmap: {\r\n\r\n\t\t\"bumpMap\": { type: \"t\", value: null },\r\n\t\t\"bumpScale\": { type: \"1f\", value: 1 }\r\n\r\n\t},\r\n\r\n\tnormalmap: {\r\n\r\n\t\t\"normalMap\": { type: \"t\", value: null },\r\n\t\t\"normalScale\": { type: \"v2\", value: new THREE.Vector2( 1, 1 ) }\r\n\r\n\t},\r\n\r\n\tdisplacementmap: {\r\n\r\n\t\t\"displacementMap\": { type: \"t\", value: null },\r\n\t\t\"displacementScale\": { type: \"1f\", value: 1 },\r\n\t\t\"displacementBias\": { type: \"1f\", value: 0 }\r\n\r\n\t},\r\n\r\n\troughnessmap: {\r\n\r\n\t\t\"roughnessMap\": { type: \"t\", value: null }\r\n\r\n\t},\r\n\r\n\tmetalnessmap: {\r\n\r\n\t\t\"metalnessMap\": { type: \"t\", value: null }\r\n\r\n\t},\r\n\r\n\tfog: {\r\n\r\n\t\t\"fogDensity\": { type: \"1f\", value: 0.00025 },\r\n\t\t\"fogNear\": { type: \"1f\", value: 1 },\r\n\t\t\"fogFar\": { type: \"1f\", value: 2000 },\r\n\t\t\"fogColor\": { type: \"c\", value: new THREE.Color( 0xffffff ) }\r\n\r\n\t},\r\n\r\n\tlights: {\r\n\r\n\t\t\"ambientLightColor\": { type: \"3fv\", value: [] },\r\n\r\n\t\t\"directionalLights\": { type: \"sa\", value: [], properties: {\r\n\t\t\t\"direction\": { type: \"v3\" },\r\n\t\t\t\"color\": { type: \"c\" },\r\n\r\n\t\t\t\"shadow\": { type: \"1i\" },\r\n\t\t\t\"shadowBias\": { type: \"1f\" },\r\n\t\t\t\"shadowRadius\": { type: \"1f\" },\r\n\t\t\t\"shadowMapSize\": { type: \"v2\" }\r\n\t\t} },\r\n\r\n\t\t\"directionalShadowMap\": { type: \"tv\", value: [] },\r\n\t\t\"directionalShadowMatrix\": { type: \"m4v\", value: [] },\r\n\r\n\t\t\"spotLights\": { type: \"sa\", value: [], properties: {\r\n\t\t\t\"color\": { type: \"c\" },\r\n\t\t\t\"position\": { type: \"v3\" },\r\n\t\t\t\"direction\": { type: \"v3\" },\r\n\t\t\t\"distance\": { type: \"1f\" },\r\n\t\t\t\"coneCos\": { type: \"1f\" },\r\n\t\t\t\"penumbraCos\": { type: \"1f\" },\r\n\t\t\t\"decay\": { type: \"1f\" },\r\n\r\n\t\t\t\"shadow\": { type: \"1i\" },\r\n\t\t\t\"shadowBias\": { type: \"1f\" },\r\n\t\t\t\"shadowRadius\": { type: \"1f\" },\r\n\t\t\t\"shadowMapSize\": { type: \"v2\" }\r\n\t\t} },\r\n\r\n\t\t\"spotShadowMap\": { type: \"tv\", value: [] },\r\n\t\t\"spotShadowMatrix\": { type: \"m4v\", value: [] },\r\n\r\n\t\t\"pointLights\": { type: \"sa\", value: [], properties: {\r\n\t\t\t\"color\": { type: \"c\" },\r\n\t\t\t\"position\": { type: \"v3\" },\r\n\t\t\t\"decay\": { type: \"1f\" },\r\n\t\t\t\"distance\": { type: \"1f\" },\r\n\r\n\t\t\t\"shadow\": { type: \"1i\" },\r\n\t\t\t\"shadowBias\": { type: \"1f\" },\r\n\t\t\t\"shadowRadius\": { type: \"1f\" },\r\n\t\t\t\"shadowMapSize\": { type: \"v2\" }\r\n\t\t} },\r\n\r\n\t\t\"pointShadowMap\": { type: \"tv\", value: [] },\r\n\t\t\"pointShadowMatrix\": { type: \"m4v\", value: [] },\r\n\r\n\t\t\"hemisphereLights\": { type: \"sa\", value: [], properties: {\r\n\t\t\t\"direction\": { type: \"v3\" },\r\n\t\t\t\"skyColor\": { type: \"c\" },\r\n\t\t\t\"groundColor\": { type: \"c\" }\r\n\t\t} }\r\n\r\n\t},\r\n\r\n\tpoints: {\r\n\r\n\t\t\"diffuse\": { type: \"c\", value: new THREE.Color( 0xeeeeee ) },\r\n\t\t\"opacity\": { type: \"1f\", value: 1.0 },\r\n\t\t\"size\": { type: \"1f\", value: 1.0 },\r\n\t\t\"scale\": { type: \"1f\", value: 1.0 },\r\n\t\t\"map\": { type: \"t\", value: null },\r\n\t\t\"offsetRepeat\": { type: \"v4\", value: new THREE.Vector4( 0, 0, 1, 1 ) }\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/renderers/shaders/ShaderLib/cube_frag.glsl\r\n\r\nTHREE.ShaderChunk[ 'cube_frag' ] = \"uniform samplerCube tCube;\\nuniform float tFlip;\\nvarying vec3 vWorldPosition;\\n#include <common>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\\n\t#include <logdepthbuf_fragment>\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderLib/cube_vert.glsl\r\n\r\nTHREE.ShaderChunk[ 'cube_vert' ] = \"varying vec3 vWorldPosition;\\n#include <common>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\tvWorldPosition = transformDirection( position, modelMatrix );\\n\t#include <begin_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderLib/depth_frag.glsl\r\n\r\nTHREE.ShaderChunk[ 'depth_frag' ] = \"#if DEPTH_PACKING == 3200\\n\tuniform float opacity;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec4 diffuseColor = vec4( 1.0 );\\n\t#if DEPTH_PACKING == 3200\\n\t\tdiffuseColor.a = opacity;\\n\t#endif\\n\t#include <map_fragment>\\n\t#include <alphamap_fragment>\\n\t#include <alphatest_fragment>\\n\t#include <logdepthbuf_fragment>\\n\t#if DEPTH_PACKING == 3200\\n\t\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\\n\t#elif DEPTH_PACKING == 3201\\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\\n\t#endif\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderLib/depth_vert.glsl\r\n\r\nTHREE.ShaderChunk[ 'depth_vert' ] = \"#include <common>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <uv_vertex>\\n\t#include <skinbase_vertex>\\n\t#include <begin_vertex>\\n\t#include <displacementmap_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderLib/distanceRGBA_frag.glsl\r\n\r\nTHREE.ShaderChunk[ 'distanceRGBA_frag' ] = \"uniform vec3 lightPos;\\nvarying vec4 vWorldPosition;\\n#include <common>\\n#include <packing>\\n#include <clipping_planes_pars_fragment>\\nvoid main () {\\n\t#include <clipping_planes_fragment>\\n\tgl_FragColor = packDepthToRGBA( length( vWorldPosition.xyz - lightPos.xyz ) / 1000.0 );\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderLib/distanceRGBA_vert.glsl\r\n\r\nTHREE.ShaderChunk[ 'distanceRGBA_vert' ] = \"varying vec4 vWorldPosition;\\n#include <common>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <skinbase_vertex>\\n\t#include <begin_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <project_vertex>\\n\t#include <worldpos_vertex>\\n\t#include <clipping_planes_vertex>\\n\tvWorldPosition = worldPosition;\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderLib/equirect_frag.glsl\r\n\r\nTHREE.ShaderChunk[ 'equirect_frag' ] = \"uniform sampler2D tEquirect;\\nuniform float tFlip;\\nvarying vec3 vWorldPosition;\\n#include <common>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec3 direction = normalize( vWorldPosition );\\n\tvec2 sampleUV;\\n\tsampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\\n\t#include <logdepthbuf_fragment>\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderLib/equirect_vert.glsl\r\n\r\nTHREE.ShaderChunk[ 'equirect_vert' ] = \"varying vec3 vWorldPosition;\\n#include <common>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\tvWorldPosition = transformDirection( position, modelMatrix );\\n\t#include <begin_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderLib/linedashed_frag.glsl\r\n\r\nTHREE.ShaderChunk[ 'linedashed_frag' ] = \"uniform vec3 diffuse;\\nuniform float opacity;\\nuniform float dashSize;\\nuniform float totalSize;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\\n\t\tdiscard;\\n\t}\\n\tvec3 outgoingLight = vec3( 0.0 );\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\t#include <logdepthbuf_fragment>\\n\t#include <color_fragment>\\n\toutgoingLight = diffuseColor.rgb;\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderLib/linedashed_vert.glsl\r\n\r\nTHREE.ShaderChunk[ 'linedashed_vert' ] = \"uniform float scale;\\nattribute float lineDistance;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <color_vertex>\\n\tvLineDistance = scale * lineDistance;\\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\\n\tgl_Position = projectionMatrix * mvPosition;\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderLib/meshbasic_frag.glsl\r\n\r\nTHREE.ShaderChunk[ 'meshbasic_frag' ] = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#ifndef FLAT_SHADED\\n\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\t#include <logdepthbuf_fragment>\\n\t#include <map_fragment>\\n\t#include <color_fragment>\\n\t#include <alphamap_fragment>\\n\t#include <alphatest_fragment>\\n\t#include <specularmap_fragment>\\n\tReflectedLight reflectedLight;\\n\treflectedLight.directDiffuse = vec3( 0.0 );\\n\treflectedLight.directSpecular = vec3( 0.0 );\\n\treflectedLight.indirectDiffuse = diffuseColor.rgb;\\n\treflectedLight.indirectSpecular = vec3( 0.0 );\\n\t#include <aomap_fragment>\\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\\n\t#include <envmap_fragment>\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderLib/meshbasic_vert.glsl\r\n\r\nTHREE.ShaderChunk[ 'meshbasic_vert' ] = \"#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <uv_vertex>\\n\t#include <uv2_vertex>\\n\t#include <color_vertex>\\n\t#include <skinbase_vertex>\\n\t#ifdef USE_ENVMAP\\n\t#include <beginnormal_vertex>\\n\t#include <morphnormal_vertex>\\n\t#include <skinnormal_vertex>\\n\t#include <defaultnormal_vertex>\\n\t#endif\\n\t#include <begin_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <worldpos_vertex>\\n\t#include <clipping_planes_vertex>\\n\t#include <envmap_vertex>\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderLib/meshlambert_frag.glsl\r\n\r\nTHREE.ShaderChunk[ 'meshlambert_frag' ] = \"uniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float opacity;\\nvarying vec3 vLightFront;\\n#ifdef DOUBLE_SIDED\\n\tvarying vec3 vLightBack;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <fog_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <shadowmask_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\tvec3 totalEmissiveRadiance = emissive;\\n\t#include <logdepthbuf_fragment>\\n\t#include <map_fragment>\\n\t#include <color_fragment>\\n\t#include <alphamap_fragment>\\n\t#include <alphatest_fragment>\\n\t#include <specularmap_fragment>\\n\t#include <emissivemap_fragment>\\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\\n\t#include <lightmap_fragment>\\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\\n\t#ifdef DOUBLE_SIDED\\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\\n\t#else\\n\t\treflectedLight.directDiffuse = vLightFront;\\n\t#endif\\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\\n\t#include <aomap_fragment>\\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\\n\t#include <envmap_fragment>\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderLib/meshlambert_vert.glsl\r\n\r\nTHREE.ShaderChunk[ 'meshlambert_vert' ] = \"#define LAMBERT\\nvarying vec3 vLightFront;\\n#ifdef DOUBLE_SIDED\\n\tvarying vec3 vLightBack;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <color_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <uv_vertex>\\n\t#include <uv2_vertex>\\n\t#include <color_vertex>\\n\t#include <beginnormal_vertex>\\n\t#include <morphnormal_vertex>\\n\t#include <skinbase_vertex>\\n\t#include <skinnormal_vertex>\\n\t#include <defaultnormal_vertex>\\n\t#include <begin_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n\t#include <worldpos_vertex>\\n\t#include <envmap_vertex>\\n\t#include <lights_lambert_vertex>\\n\t#include <shadowmap_vertex>\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderLib/meshphong_frag.glsl\r\n\r\nTHREE.ShaderChunk[ 'meshphong_frag' ] = \"#define PHONG\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform vec3 specular;\\nuniform float shininess;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <lights_phong_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\tvec3 totalEmissiveRadiance = emissive;\\n\t#include <logdepthbuf_fragment>\\n\t#include <map_fragment>\\n\t#include <color_fragment>\\n\t#include <alphamap_fragment>\\n\t#include <alphatest_fragment>\\n\t#include <specularmap_fragment>\\n\t#include <normal_fragment>\\n\t#include <emissivemap_fragment>\\n\t#include <lights_phong_fragment>\\n\t#include <lights_template>\\n\t#include <aomap_fragment>\\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\t#include <envmap_fragment>\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderLib/meshphong_vert.glsl\r\n\r\nTHREE.ShaderChunk[ 'meshphong_vert' ] = \"#define PHONG\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <uv_vertex>\\n\t#include <uv2_vertex>\\n\t#include <color_vertex>\\n\t#include <beginnormal_vertex>\\n\t#include <morphnormal_vertex>\\n\t#include <skinbase_vertex>\\n\t#include <skinnormal_vertex>\\n\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\tvNormal = normalize( transformedNormal );\\n#endif\\n\t#include <begin_vertex>\\n\t#include <displacementmap_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n\tvViewPosition = - mvPosition.xyz;\\n\t#include <worldpos_vertex>\\n\t#include <envmap_vertex>\\n\t#include <shadowmap_vertex>\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderLib/meshphysical_frag.glsl\r\n\r\nTHREE.ShaderChunk[ 'meshphysical_frag' ] = \"#define PHYSICAL\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float roughness;\\nuniform float metalness;\\nuniform float opacity;\\nuniform float envMapIntensity;\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <cube_uv_reflection_fragment>\\n#include <lights_pars>\\n#include <lights_physical_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <roughnessmap_pars_fragment>\\n#include <metalnessmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\tvec3 totalEmissiveRadiance = emissive;\\n\t#include <logdepthbuf_fragment>\\n\t#include <map_fragment>\\n\t#include <color_fragment>\\n\t#include <alphamap_fragment>\\n\t#include <alphatest_fragment>\\n\t#include <specularmap_fragment>\\n\t#include <roughnessmap_fragment>\\n\t#include <metalnessmap_fragment>\\n\t#include <normal_fragment>\\n\t#include <emissivemap_fragment>\\n\t#include <lights_physical_fragment>\\n\t#include <lights_template>\\n\t#include <aomap_fragment>\\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderLib/meshphysical_vert.glsl\r\n\r\nTHREE.ShaderChunk[ 'meshphysical_vert' ] = \"#define PHYSICAL\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <uv_vertex>\\n\t#include <uv2_vertex>\\n\t#include <color_vertex>\\n\t#include <beginnormal_vertex>\\n\t#include <morphnormal_vertex>\\n\t#include <skinbase_vertex>\\n\t#include <skinnormal_vertex>\\n\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\tvNormal = normalize( transformedNormal );\\n#endif\\n\t#include <begin_vertex>\\n\t#include <displacementmap_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n\tvViewPosition = - mvPosition.xyz;\\n\t#include <worldpos_vertex>\\n\t#include <shadowmap_vertex>\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderLib/normal_frag.glsl\r\n\r\nTHREE.ShaderChunk[ 'normal_frag' ] = \"uniform float opacity;\\nvarying vec3 vNormal;\\n#include <common>\\n#include <packing>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tgl_FragColor = vec4( packNormalToRGB( vNormal ), opacity );\\n\t#include <logdepthbuf_fragment>\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderLib/normal_vert.glsl\r\n\r\nTHREE.ShaderChunk[ 'normal_vert' ] = \"varying vec3 vNormal;\\n#include <common>\\n#include <morphtarget_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\tvNormal = normalize( normalMatrix * normal );\\n\t#include <begin_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderLib/points_frag.glsl\r\n\r\nTHREE.ShaderChunk[ 'points_frag' ] = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#include <common>\\n#include <color_pars_fragment>\\n#include <map_particle_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec3 outgoingLight = vec3( 0.0 );\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\t#include <logdepthbuf_fragment>\\n\t#include <map_particle_fragment>\\n\t#include <color_fragment>\\n\t#include <alphatest_fragment>\\n\toutgoingLight = diffuseColor.rgb;\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderLib/points_vert.glsl\r\n\r\nTHREE.ShaderChunk[ 'points_vert' ] = \"uniform float size;\\nuniform float scale;\\n#include <common>\\n#include <color_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <color_vertex>\\n\t#include <begin_vertex>\\n\t#include <project_vertex>\\n\t#ifdef USE_SIZEATTENUATION\\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\\n\t#else\\n\t\tgl_PointSize = size;\\n\t#endif\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n\t#include <worldpos_vertex>\\n\t#include <shadowmap_vertex>\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderLib.js\r\n\r\n/**\r\n * Webgl Shader Library for three.js\r\n *\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author mikael emtinger / http://gomo.se/\r\n */\r\n\r\n\r\nTHREE.ShaderLib = {\r\n\r\n\t'basic': {\r\n\r\n\t\tuniforms: THREE.UniformsUtils.merge( [\r\n\r\n\t\t\tTHREE.UniformsLib[ 'common' ],\r\n\t\t\tTHREE.UniformsLib[ 'aomap' ],\r\n\t\t\tTHREE.UniformsLib[ 'fog' ]\r\n\r\n\t\t] ),\r\n\r\n\t\tvertexShader: THREE.ShaderChunk[ 'meshbasic_vert' ],\r\n\t\tfragmentShader: THREE.ShaderChunk[ 'meshbasic_frag' ]\r\n\r\n\t},\r\n\r\n\t'lambert': {\r\n\r\n\t\tuniforms: THREE.UniformsUtils.merge( [\r\n\r\n\t\t\tTHREE.UniformsLib[ 'common' ],\r\n\t\t\tTHREE.UniformsLib[ 'aomap' ],\r\n\t\t\tTHREE.UniformsLib[ 'lightmap' ],\r\n\t\t\tTHREE.UniformsLib[ 'emissivemap' ],\r\n\t\t\tTHREE.UniformsLib[ 'fog' ],\r\n\t\t\tTHREE.UniformsLib[ 'lights' ],\r\n\r\n\t\t\t{\r\n\t\t\t\t\"emissive\" : { type: \"c\", value: new THREE.Color( 0x000000 ) }\r\n\t\t\t}\r\n\r\n\t\t] ),\r\n\r\n\t\tvertexShader: THREE.ShaderChunk[ 'meshlambert_vert' ],\r\n\t\tfragmentShader: THREE.ShaderChunk[ 'meshlambert_frag' ]\r\n\r\n\t},\r\n\r\n\t'phong': {\r\n\r\n\t\tuniforms: THREE.UniformsUtils.merge( [\r\n\r\n\t\t\tTHREE.UniformsLib[ 'common' ],\r\n\t\t\tTHREE.UniformsLib[ 'aomap' ],\r\n\t\t\tTHREE.UniformsLib[ 'lightmap' ],\r\n\t\t\tTHREE.UniformsLib[ 'emissivemap' ],\r\n\t\t\tTHREE.UniformsLib[ 'bumpmap' ],\r\n\t\t\tTHREE.UniformsLib[ 'normalmap' ],\r\n\t\t\tTHREE.UniformsLib[ 'displacementmap' ],\r\n\t\t\tTHREE.UniformsLib[ 'fog' ],\r\n\t\t\tTHREE.UniformsLib[ 'lights' ],\r\n\r\n\t\t\t{\r\n\t\t\t\t\"emissive\" : { type: \"c\", value: new THREE.Color( 0x000000 ) },\r\n\t\t\t\t\"specular\" : { type: \"c\", value: new THREE.Color( 0x111111 ) },\r\n\t\t\t\t\"shininess\": { type: \"1f\", value: 30 }\r\n\t\t\t}\r\n\r\n\t\t] ),\r\n\r\n\t\tvertexShader: THREE.ShaderChunk[ 'meshphong_vert' ],\r\n\t\tfragmentShader: THREE.ShaderChunk[ 'meshphong_frag' ]\r\n\r\n\t},\r\n\r\n\t'standard': {\r\n\r\n\t\tuniforms: THREE.UniformsUtils.merge( [\r\n\r\n\t\t\tTHREE.UniformsLib[ 'common' ],\r\n\t\t\tTHREE.UniformsLib[ 'aomap' ],\r\n\t\t\tTHREE.UniformsLib[ 'lightmap' ],\r\n\t\t\tTHREE.UniformsLib[ 'emissivemap' ],\r\n\t\t\tTHREE.UniformsLib[ 'bumpmap' ],\r\n\t\t\tTHREE.UniformsLib[ 'normalmap' ],\r\n\t\t\tTHREE.UniformsLib[ 'displacementmap' ],\r\n\t\t\tTHREE.UniformsLib[ 'roughnessmap' ],\r\n\t\t\tTHREE.UniformsLib[ 'metalnessmap' ],\r\n\t\t\tTHREE.UniformsLib[ 'fog' ],\r\n\t\t\tTHREE.UniformsLib[ 'lights' ],\r\n\r\n\t\t\t{\r\n\t\t\t\t\"emissive\" : { type: \"c\", value: new THREE.Color( 0x000000 ) },\r\n\t\t\t\t\"roughness\": { type: \"1f\", value: 0.5 },\r\n\t\t\t\t\"metalness\": { type: \"1f\", value: 0 },\r\n\t\t\t\t\"envMapIntensity\" : { type: \"1f\", value: 1 } // temporary\r\n\t\t\t}\r\n\r\n\t\t] ),\r\n\r\n\t\tvertexShader: THREE.ShaderChunk[ 'meshphysical_vert' ],\r\n\t\tfragmentShader: THREE.ShaderChunk[ 'meshphysical_frag' ]\r\n\r\n\t},\r\n\r\n\t'points': {\r\n\r\n\t\tuniforms: THREE.UniformsUtils.merge( [\r\n\r\n\t\t\tTHREE.UniformsLib[ 'points' ],\r\n\t\t\tTHREE.UniformsLib[ 'fog' ]\r\n\r\n\t\t] ),\r\n\r\n\t\tvertexShader: THREE.ShaderChunk[ 'points_vert' ],\r\n\t\tfragmentShader: THREE.ShaderChunk[ 'points_frag' ]\r\n\r\n\t},\r\n\r\n\t'dashed': {\r\n\r\n\t\tuniforms: THREE.UniformsUtils.merge( [\r\n\r\n\t\t\tTHREE.UniformsLib[ 'common' ],\r\n\t\t\tTHREE.UniformsLib[ 'fog' ],\r\n\r\n\t\t\t{\r\n\t\t\t\t\"scale\"    : { type: \"1f\", value: 1 },\r\n\t\t\t\t\"dashSize\" : { type: \"1f\", value: 1 },\r\n\t\t\t\t\"totalSize\": { type: \"1f\", value: 2 }\r\n\t\t\t}\r\n\r\n\t\t] ),\r\n\r\n\t\tvertexShader: THREE.ShaderChunk[ 'linedashed_vert' ],\r\n\t\tfragmentShader: THREE.ShaderChunk[ 'linedashed_frag' ]\r\n\r\n\t},\r\n\r\n\t'depth': {\r\n\r\n\t\tuniforms: THREE.UniformsUtils.merge( [\r\n\r\n\t\t\tTHREE.UniformsLib[ 'common' ],\r\n\t\t\tTHREE.UniformsLib[ 'displacementmap' ]\r\n\r\n\t\t] ),\r\n\r\n\t\tvertexShader: THREE.ShaderChunk[ 'depth_vert' ],\r\n\t\tfragmentShader: THREE.ShaderChunk[ 'depth_frag' ]\r\n\r\n\t},\r\n\r\n\t'normal': {\r\n\r\n\t\tuniforms: {\r\n\r\n\t\t\t\"opacity\" : { type: \"1f\", value: 1.0 }\r\n\r\n\t\t},\r\n\r\n\t\tvertexShader: THREE.ShaderChunk[ 'normal_vert' ],\r\n\t\tfragmentShader: THREE.ShaderChunk[ 'normal_frag' ]\r\n\r\n\t},\r\n\r\n\t/* -------------------------------------------------------------------------\r\n\t//\tCube map shader\r\n\t ------------------------------------------------------------------------- */\r\n\r\n\t'cube': {\r\n\r\n\t\tuniforms: {\r\n\t\t\t\"tCube\": { type: \"t\", value: null },\r\n\t\t\t\"tFlip\": { type: \"1f\", value: - 1 }\r\n\t\t},\r\n\r\n\t\tvertexShader: THREE.ShaderChunk[ 'cube_vert' ],\r\n\t\tfragmentShader: THREE.ShaderChunk[ 'cube_frag' ]\r\n\r\n\t},\r\n\r\n\t/* -------------------------------------------------------------------------\r\n\t//\tCube map shader\r\n\t ------------------------------------------------------------------------- */\r\n\r\n\t'equirect': {\r\n\r\n\t\tuniforms: {\r\n\t\t\t\"tEquirect\": { type: \"t\", value: null },\r\n\t\t\t\"tFlip\": { type: \"1f\", value: - 1 }\r\n\t\t},\r\n\r\n\t\tvertexShader: THREE.ShaderChunk[ 'equirect_vert' ],\r\n\t\tfragmentShader: THREE.ShaderChunk[ 'equirect_frag' ]\r\n\r\n\t},\r\n\r\n\t'distanceRGBA': {\r\n\r\n\t\tuniforms: {\r\n\r\n\t\t\t\"lightPos\": { type: \"v3\", value: new THREE.Vector3() }\r\n\r\n\t\t},\r\n\r\n\t\tvertexShader: THREE.ShaderChunk[ 'distanceRGBA_vert' ],\r\n\t\tfragmentShader: THREE.ShaderChunk[ 'distanceRGBA_frag' ]\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.ShaderLib[ 'physical' ] = {\r\n\r\n\tuniforms: THREE.UniformsUtils.merge( [\r\n\r\n\t\tTHREE.ShaderLib[ 'standard' ].uniforms,\r\n\r\n\t\t{\r\n\t\t\t// future\r\n\t\t}\r\n\r\n\t] ),\r\n\r\n\tvertexShader: THREE.ShaderChunk[ 'meshphysical_vert' ],\r\n\tfragmentShader: THREE.ShaderChunk[ 'meshphysical_frag' ]\r\n\r\n};\r\n\r\n\r\n// File:src/renderers/WebGLRenderer.js\r\n\r\n/**\r\n * @author supereggbert / http://www.paulbrunt.co.uk/\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author szimek / https://github.com/szimek/\r\n * @author tschw\r\n */\r\n\r\nTHREE.WebGLRenderer = function ( parameters ) {\r\n\r\n\tconsole.log( 'THREE.WebGLRenderer', THREE.REVISION );\r\n\r\n\tparameters = parameters || {};\r\n\r\n\tvar _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElement( 'canvas' ),\r\n\t_context = parameters.context !== undefined ? parameters.context : null,\r\n\r\n\t_alpha = parameters.alpha !== undefined ? parameters.alpha : false,\r\n\t_depth = parameters.depth !== undefined ? parameters.depth : true,\r\n\t_stencil = parameters.stencil !== undefined ? parameters.stencil : true,\r\n\t_antialias = parameters.antialias !== undefined ? parameters.antialias : false,\r\n\t_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,\r\n\t_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false;\r\n\r\n\tvar lights = [];\r\n\r\n\tvar opaqueObjects = [];\r\n\tvar opaqueObjectsLastIndex = - 1;\r\n\tvar transparentObjects = [];\r\n\tvar transparentObjectsLastIndex = - 1;\r\n\r\n\tvar morphInfluences = new Float32Array( 8 );\r\n\r\n\tvar sprites = [];\r\n\tvar lensFlares = [];\r\n\r\n\t// public properties\r\n\r\n\tthis.domElement = _canvas;\r\n\tthis.context = null;\r\n\r\n\t// clearing\r\n\r\n\tthis.autoClear = true;\r\n\tthis.autoClearColor = true;\r\n\tthis.autoClearDepth = true;\r\n\tthis.autoClearStencil = true;\r\n\r\n\t// scene graph\r\n\r\n\tthis.sortObjects = true;\r\n\r\n\t// user-defined clipping\r\n\r\n\tthis.clippingPlanes = [];\r\n\tthis.localClippingEnabled = false;\r\n\r\n\t// physically based shading\r\n\r\n\tthis.gammaFactor = 2.0;\t// for backwards compatibility\r\n\tthis.gammaInput = false;\r\n\tthis.gammaOutput = false;\r\n\r\n\t// physical lights\r\n\r\n\tthis.physicallyCorrectLights = false;\r\n\r\n\t// tone mapping\r\n\r\n\tthis.toneMapping = THREE.LinearToneMapping;\r\n\tthis.toneMappingExposure = 1.0;\r\n\tthis.toneMappingWhitePoint = 1.0;\r\n\r\n\t// morphs\r\n\r\n\tthis.maxMorphTargets = 8;\r\n\tthis.maxMorphNormals = 4;\r\n\r\n\t// flags\r\n\r\n\tthis.autoScaleCubemaps = true;\r\n\r\n\t// internal properties\r\n\r\n\tvar _this = this,\r\n\r\n\t// internal state cache\r\n\r\n\t_currentProgram = null,\r\n\t_currentRenderTarget = null,\r\n\t_currentFramebuffer = null,\r\n\t_currentMaterialId = - 1,\r\n\t_currentGeometryProgram = '',\r\n\t_currentCamera = null,\r\n\r\n\t_currentScissor = new THREE.Vector4(),\r\n\t_currentScissorTest = null,\r\n\r\n\t_currentViewport = new THREE.Vector4(),\r\n\r\n\t//\r\n\r\n\t_usedTextureUnits = 0,\r\n\r\n\t//\r\n\r\n\t_clearColor = new THREE.Color( 0x000000 ),\r\n\t_clearAlpha = 0,\r\n\r\n\t_width = _canvas.width,\r\n\t_height = _canvas.height,\r\n\r\n\t_pixelRatio = 1,\r\n\r\n\t_scissor = new THREE.Vector4( 0, 0, _width, _height ),\r\n\t_scissorTest = false,\r\n\r\n\t_viewport = new THREE.Vector4( 0, 0, _width, _height ),\r\n\r\n\t// frustum\r\n\r\n\t_frustum = new THREE.Frustum(),\r\n\r\n\t// clipping\r\n\r\n\t_clippingEnabled = false,\r\n\t_localClippingEnabled = false,\r\n\t_clipRenderingShadows = false,\r\n\r\n\t_numClippingPlanes = 0,\r\n\t_clippingPlanesUniform = {\r\n\t\t\ttype: '4fv', value: null, needsUpdate: false },\r\n\r\n\t_globalClippingState = null,\r\n\t_numGlobalClippingPlanes = 0,\r\n\r\n\t_matrix3 = new THREE.Matrix3(),\r\n\t_sphere = new THREE.Sphere(),\r\n\t_plane = new THREE.Plane(),\r\n\r\n\r\n\t// camera matrices cache\r\n\r\n\t_projScreenMatrix = new THREE.Matrix4(),\r\n\r\n\t_vector3 = new THREE.Vector3(),\r\n\r\n\t// light arrays cache\r\n\r\n\t_lights = {\r\n\r\n\t\thash: '',\r\n\r\n\t\tambient: [ 0, 0, 0 ],\r\n\t\tdirectional: [],\r\n\t\tdirectionalShadowMap: [],\r\n\t\tdirectionalShadowMatrix: [],\r\n\t\tspot: [],\r\n\t\tspotShadowMap: [],\r\n\t\tspotShadowMatrix: [],\r\n\t\tpoint: [],\r\n\t\tpointShadowMap: [],\r\n\t\tpointShadowMatrix: [],\r\n\t\themi: [],\r\n\r\n\t\tshadows: []\r\n\r\n\t},\r\n\r\n\t// info\r\n\r\n\t_infoMemory = {\r\n\r\n\t\tgeometries: 0,\r\n\t\ttextures: 0\r\n\r\n\t},\r\n\r\n\t_infoRender = {\r\n\r\n\t\tcalls: 0,\r\n\t\tvertices: 0,\r\n\t\tfaces: 0,\r\n\t\tpoints: 0\r\n\r\n\t};\r\n\r\n\tthis.info = {\r\n\r\n\t\trender: _infoRender,\r\n\t\tmemory: _infoMemory,\r\n\t\tprograms: null\r\n\r\n\t};\r\n\r\n\r\n\t// initialize\r\n\r\n\tvar _gl;\r\n\r\n\ttry {\r\n\r\n\t\tvar attributes = {\r\n\t\t\talpha: _alpha,\r\n\t\t\tdepth: _depth,\r\n\t\t\tstencil: _stencil,\r\n\t\t\tantialias: _antialias,\r\n\t\t\tpremultipliedAlpha: _premultipliedAlpha,\r\n\t\t\tpreserveDrawingBuffer: _preserveDrawingBuffer\r\n\t\t};\r\n\r\n\t\t_gl = _context || _canvas.getContext( 'webgl', attributes ) || _canvas.getContext( 'experimental-webgl', attributes );\r\n\r\n\t\tif ( _gl === null ) {\r\n\r\n\t\t\tif ( _canvas.getContext( 'webgl' ) !== null ) {\r\n\r\n\t\t\t\tthrow 'Error creating WebGL context with your selected attributes.';\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthrow 'Error creating WebGL context.';\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// Some experimental-webgl implementations do not have getShaderPrecisionFormat\r\n\r\n\t\tif ( _gl.getShaderPrecisionFormat === undefined ) {\r\n\r\n\t\t\t_gl.getShaderPrecisionFormat = function () {\r\n\r\n\t\t\t\treturn { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };\r\n\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\t_canvas.addEventListener( 'webglcontextlost', onContextLost, false );\r\n\r\n\t} catch ( error ) {\r\n\r\n\t\tconsole.error( 'THREE.WebGLRenderer: ' + error );\r\n\r\n\t}\r\n\r\n\tvar _isWebGL2 = (typeof WebGL2RenderingContext !== 'undefined' && _gl instanceof WebGL2RenderingContext);\r\n\tvar extensions = new THREE.WebGLExtensions( _gl );\r\n\r\n\textensions.get( 'WEBGL_depth_texture' );\r\n\textensions.get( 'OES_texture_float' );\r\n\textensions.get( 'OES_texture_float_linear' );\r\n\textensions.get( 'OES_texture_half_float' );\r\n\textensions.get( 'OES_texture_half_float_linear' );\r\n\textensions.get( 'OES_standard_derivatives' );\r\n\textensions.get( 'ANGLE_instanced_arrays' );\r\n\r\n\tif ( extensions.get( 'OES_element_index_uint' ) ) {\r\n\r\n\t\tTHREE.BufferGeometry.MaxIndex = 4294967296;\r\n\r\n\t}\r\n\r\n\tvar capabilities = new THREE.WebGLCapabilities( _gl, extensions, parameters );\r\n\r\n\tvar state = new THREE.WebGLState( _gl, extensions, paramThreeToGL );\r\n\tvar properties = new THREE.WebGLProperties();\r\n\tvar objects = new THREE.WebGLObjects( _gl, properties, this.info );\r\n\tvar programCache = new THREE.WebGLPrograms( this, capabilities );\r\n\tvar lightCache = new THREE.WebGLLights();\r\n\r\n\tthis.info.programs = programCache.programs;\r\n\r\n\tvar bufferRenderer = new THREE.WebGLBufferRenderer( _gl, extensions, _infoRender );\r\n\tvar indexedBufferRenderer = new THREE.WebGLIndexedBufferRenderer( _gl, extensions, _infoRender );\r\n\r\n\t//\r\n\r\n\tfunction getTargetPixelRatio() {\r\n\r\n\t\treturn _currentRenderTarget === null ? _pixelRatio : 1;\r\n\r\n\t}\r\n\r\n\tfunction glClearColor( r, g, b, a ) {\r\n\r\n\t\tif ( _premultipliedAlpha === true ) {\r\n\r\n\t\t\tr *= a; g *= a; b *= a;\r\n\r\n\t\t}\r\n\r\n\t\tstate.clearColor( r, g, b, a );\r\n\r\n\t}\r\n\r\n\tfunction setDefaultGLState() {\r\n\r\n\t\tstate.init();\r\n\r\n\t\tstate.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );\r\n\t\tstate.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );\r\n\r\n\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\r\n\r\n\t}\r\n\r\n\tfunction resetGLState() {\r\n\r\n\t\t_currentProgram = null;\r\n\t\t_currentCamera = null;\r\n\r\n\t\t_currentGeometryProgram = '';\r\n\t\t_currentMaterialId = - 1;\r\n\r\n\t\tstate.reset();\r\n\r\n\t}\r\n\r\n\tsetDefaultGLState();\r\n\r\n\tthis.context = _gl;\r\n\tthis.capabilities = capabilities;\r\n\tthis.extensions = extensions;\r\n\tthis.properties = properties;\r\n\tthis.state = state;\r\n\r\n\t// shadow map\r\n\r\n\tvar shadowMap = new THREE.WebGLShadowMap( this, _lights, objects );\r\n\r\n\tthis.shadowMap = shadowMap;\r\n\r\n\r\n\t// Plugins\r\n\r\n\tvar spritePlugin = new THREE.SpritePlugin( this, sprites );\r\n\tvar lensFlarePlugin = new THREE.LensFlarePlugin( this, lensFlares );\r\n\r\n\t// API\r\n\r\n\tthis.getContext = function () {\r\n\r\n\t\treturn _gl;\r\n\r\n\t};\r\n\r\n\tthis.getContextAttributes = function () {\r\n\r\n\t\treturn _gl.getContextAttributes();\r\n\r\n\t};\r\n\r\n\tthis.forceContextLoss = function () {\r\n\r\n\t\textensions.get( 'WEBGL_lose_context' ).loseContext();\r\n\r\n\t};\r\n\r\n\tthis.getMaxAnisotropy = ( function () {\r\n\r\n\t\tvar value;\r\n\r\n\t\treturn function getMaxAnisotropy() {\r\n\r\n\t\t\tif ( value !== undefined ) return value;\r\n\r\n\t\t\tvar extension = extensions.get( 'EXT_texture_filter_anisotropic' );\r\n\r\n\t\t\tif ( extension !== null ) {\r\n\r\n\t\t\t\tvalue = _gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tvalue = 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn value;\r\n\r\n\t\t};\r\n\r\n\t} )();\r\n\r\n\tthis.getPrecision = function () {\r\n\r\n\t\treturn capabilities.precision;\r\n\r\n\t};\r\n\r\n\tthis.getPixelRatio = function () {\r\n\r\n\t\treturn _pixelRatio;\r\n\r\n\t};\r\n\r\n\tthis.setPixelRatio = function ( value ) {\r\n\r\n\t\tif ( value === undefined ) return;\r\n\r\n\t\t_pixelRatio = value;\r\n\r\n\t\tthis.setSize( _viewport.z, _viewport.w, false );\r\n\r\n\t};\r\n\r\n\tthis.getSize = function () {\r\n\r\n\t\treturn {\r\n\t\t\twidth: _width,\r\n\t\t\theight: _height\r\n\t\t};\r\n\r\n\t};\r\n\r\n\tthis.setSize = function ( width, height, updateStyle ) {\r\n\r\n\t\t_width = width;\r\n\t\t_height = height;\r\n\r\n\t\t_canvas.width = width * _pixelRatio;\r\n\t\t_canvas.height = height * _pixelRatio;\r\n\r\n\t\tif ( updateStyle !== false ) {\r\n\r\n\t\t\t_canvas.style.width = width + 'px';\r\n\t\t\t_canvas.style.height = height + 'px';\r\n\r\n\t\t}\r\n\r\n\t\tthis.setViewport( 0, 0, width, height );\r\n\r\n\t};\r\n\r\n\tthis.setViewport = function ( x, y, width, height ) {\r\n\r\n\t\tstate.viewport( _viewport.set( x, y, width, height ) );\r\n\r\n\t};\r\n\r\n\tthis.setScissor = function ( x, y, width, height ) {\r\n\r\n\t\tstate.scissor( _scissor.set( x, y, width, height ) );\r\n\r\n\t};\r\n\r\n\tthis.setScissorTest = function ( boolean ) {\r\n\r\n\t\tstate.setScissorTest( _scissorTest = boolean );\r\n\r\n\t};\r\n\r\n\t// Clearing\r\n\r\n\tthis.getClearColor = function () {\r\n\r\n\t\treturn _clearColor;\r\n\r\n\t};\r\n\r\n\tthis.setClearColor = function ( color, alpha ) {\r\n\r\n\t\t_clearColor.set( color );\r\n\r\n\t\t_clearAlpha = alpha !== undefined ? alpha : 1;\r\n\r\n\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\r\n\r\n\t};\r\n\r\n\tthis.getClearAlpha = function () {\r\n\r\n\t\treturn _clearAlpha;\r\n\r\n\t};\r\n\r\n\tthis.setClearAlpha = function ( alpha ) {\r\n\r\n\t\t_clearAlpha = alpha;\r\n\r\n\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\r\n\r\n\t};\r\n\r\n\tthis.clear = function ( color, depth, stencil ) {\r\n\r\n\t\tvar bits = 0;\r\n\r\n\t\tif ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;\r\n\t\tif ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;\r\n\t\tif ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;\r\n\r\n\t\t_gl.clear( bits );\r\n\r\n\t};\r\n\r\n\tthis.clearColor = function () {\r\n\r\n\t\tthis.clear( true, false, false );\r\n\r\n\t};\r\n\r\n\tthis.clearDepth = function () {\r\n\r\n\t\tthis.clear( false, true, false );\r\n\r\n\t};\r\n\r\n\tthis.clearStencil = function () {\r\n\r\n\t\tthis.clear( false, false, true );\r\n\r\n\t};\r\n\r\n\tthis.clearTarget = function ( renderTarget, color, depth, stencil ) {\r\n\r\n\t\tthis.setRenderTarget( renderTarget );\r\n\t\tthis.clear( color, depth, stencil );\r\n\r\n\t};\r\n\r\n\t// Reset\r\n\r\n\tthis.resetGLState = resetGLState;\r\n\r\n\tthis.dispose = function() {\r\n\r\n\t\t_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );\r\n\r\n\t};\r\n\r\n\t// Events\r\n\r\n\tfunction onContextLost( event ) {\r\n\r\n\t\tevent.preventDefault();\r\n\r\n\t\tresetGLState();\r\n\t\tsetDefaultGLState();\r\n\r\n\t\tproperties.clear();\r\n\r\n\t}\r\n\r\n\tfunction onTextureDispose( event ) {\r\n\r\n\t\tvar texture = event.target;\r\n\r\n\t\ttexture.removeEventListener( 'dispose', onTextureDispose );\r\n\r\n\t\tdeallocateTexture( texture );\r\n\r\n\t\t_infoMemory.textures --;\r\n\r\n\r\n\t}\r\n\r\n\tfunction onRenderTargetDispose( event ) {\r\n\r\n\t\tvar renderTarget = event.target;\r\n\r\n\t\trenderTarget.removeEventListener( 'dispose', onRenderTargetDispose );\r\n\r\n\t\tdeallocateRenderTarget( renderTarget );\r\n\r\n\t\t_infoMemory.textures --;\r\n\r\n\t}\r\n\r\n\tfunction onMaterialDispose( event ) {\r\n\r\n\t\tvar material = event.target;\r\n\r\n\t\tmaterial.removeEventListener( 'dispose', onMaterialDispose );\r\n\r\n\t\tdeallocateMaterial( material );\r\n\r\n\t}\r\n\r\n\t// Buffer deallocation\r\n\r\n\tfunction deallocateTexture( texture ) {\r\n\r\n\t\tvar textureProperties = properties.get( texture );\r\n\r\n\t\tif ( texture.image && textureProperties.__image__webglTextureCube ) {\r\n\r\n\t\t\t// cube texture\r\n\r\n\t\t\t_gl.deleteTexture( textureProperties.__image__webglTextureCube );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// 2D texture\r\n\r\n\t\t\tif ( textureProperties.__webglInit === undefined ) return;\r\n\r\n\t\t\t_gl.deleteTexture( textureProperties.__webglTexture );\r\n\r\n\t\t}\r\n\r\n\t\t// remove all webgl properties\r\n\t\tproperties.delete( texture );\r\n\r\n\t}\r\n\r\n\tfunction deallocateRenderTarget( renderTarget ) {\r\n\r\n\t\tvar renderTargetProperties = properties.get( renderTarget );\r\n\t\tvar textureProperties = properties.get( renderTarget.texture );\r\n\r\n\t\tif ( ! renderTarget ) return;\r\n\r\n\t\tif ( textureProperties.__webglTexture !== undefined ) {\r\n\r\n\t\t\t_gl.deleteTexture( textureProperties.__webglTexture );\r\n\r\n\t\t}\r\n\r\n\t\tif ( renderTarget.depthTexture ) {\r\n\r\n\t\t\trenderTarget.depthTexture.dispose();\r\n\r\n\t\t}\r\n\r\n\t\tif ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {\r\n\r\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\t\t_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );\r\n\t\t\t\tif ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\t_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );\r\n\t\t\tif ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );\r\n\r\n\t\t}\r\n\r\n\t\tproperties.delete( renderTarget.texture );\r\n\t\tproperties.delete( renderTarget );\r\n\r\n\t}\r\n\r\n\tfunction deallocateMaterial( material ) {\r\n\r\n\t\treleaseMaterialProgramReference( material );\r\n\r\n\t\tproperties.delete( material );\r\n\r\n\t}\r\n\r\n\r\n\tfunction releaseMaterialProgramReference( material ) {\r\n\r\n\t\tvar programInfo = properties.get( material ).program;\r\n\r\n\t\tmaterial.program = undefined;\r\n\r\n\t\tif ( programInfo !== undefined ) {\r\n\r\n\t\t\tprogramCache.releaseProgram( programInfo );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// Buffer rendering\r\n\r\n\tthis.renderBufferImmediate = function ( object, program, material ) {\r\n\r\n\t\tstate.initAttributes();\r\n\r\n\t\tvar buffers = properties.get( object );\r\n\r\n\t\tif ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();\r\n\t\tif ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();\r\n\t\tif ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();\r\n\t\tif ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();\r\n\r\n\t\tvar attributes = program.getAttributes();\r\n\r\n\t\tif ( object.hasPositions ) {\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.position );\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );\r\n\r\n\t\t\tstate.enableAttribute( attributes.position );\r\n\t\t\t_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( object.hasNormals ) {\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.normal );\r\n\r\n\t\t\tif ( material.type !== 'MeshPhongMaterial' && material.type !== 'MeshStandardMaterial' && material.type !== 'MeshPhysicalMaterial' && material.shading === THREE.FlatShading ) {\r\n\r\n\t\t\t\tfor ( var i = 0, l = object.count * 3; i < l; i += 9 ) {\r\n\r\n\t\t\t\t\tvar array = object.normalArray;\r\n\r\n\t\t\t\t\tvar nx = ( array[ i + 0 ] + array[ i + 3 ] + array[ i + 6 ] ) / 3;\r\n\t\t\t\t\tvar ny = ( array[ i + 1 ] + array[ i + 4 ] + array[ i + 7 ] ) / 3;\r\n\t\t\t\t\tvar nz = ( array[ i + 2 ] + array[ i + 5 ] + array[ i + 8 ] ) / 3;\r\n\r\n\t\t\t\t\tarray[ i + 0 ] = nx;\r\n\t\t\t\t\tarray[ i + 1 ] = ny;\r\n\t\t\t\t\tarray[ i + 2 ] = nz;\r\n\r\n\t\t\t\t\tarray[ i + 3 ] = nx;\r\n\t\t\t\t\tarray[ i + 4 ] = ny;\r\n\t\t\t\t\tarray[ i + 5 ] = nz;\r\n\r\n\t\t\t\t\tarray[ i + 6 ] = nx;\r\n\t\t\t\t\tarray[ i + 7 ] = ny;\r\n\t\t\t\t\tarray[ i + 8 ] = nz;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );\r\n\r\n\t\t\tstate.enableAttribute( attributes.normal );\r\n\r\n\t\t\t_gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( object.hasUvs && material.map ) {\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.uv );\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );\r\n\r\n\t\t\tstate.enableAttribute( attributes.uv );\r\n\r\n\t\t\t_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( object.hasColors && material.vertexColors !== THREE.NoColors ) {\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.color );\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );\r\n\r\n\t\t\tstate.enableAttribute( attributes.color );\r\n\r\n\t\t\t_gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t}\r\n\r\n\t\tstate.disableUnusedAttributes();\r\n\r\n\t\t_gl.drawArrays( _gl.TRIANGLES, 0, object.count );\r\n\r\n\t\tobject.count = 0;\r\n\r\n\t};\r\n\r\n\tthis.renderBufferDirect = function ( camera, fog, geometry, material, object, group ) {\r\n\r\n\t\tsetMaterial( material );\r\n\r\n\t\tvar program = setProgram( camera, fog, material, object );\r\n\r\n\t\tvar updateBuffers = false;\r\n\t\tvar geometryProgram = geometry.id + '_' + program.id + '_' + material.wireframe;\r\n\r\n\t\tif ( geometryProgram !== _currentGeometryProgram ) {\r\n\r\n\t\t\t_currentGeometryProgram = geometryProgram;\r\n\t\t\tupdateBuffers = true;\r\n\r\n\t\t}\r\n\r\n\t\t// morph targets\r\n\r\n\t\tvar morphTargetInfluences = object.morphTargetInfluences;\r\n\r\n\t\tif ( morphTargetInfluences !== undefined ) {\r\n\r\n\t\t\tvar activeInfluences = [];\r\n\r\n\t\t\tfor ( var i = 0, l = morphTargetInfluences.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar influence = morphTargetInfluences[ i ];\r\n\t\t\t\tactiveInfluences.push( [ influence, i ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tactiveInfluences.sort( absNumericalSort );\r\n\r\n\t\t\tif ( activeInfluences.length > 8 ) {\r\n\r\n\t\t\t\tactiveInfluences.length = 8;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar morphAttributes = geometry.morphAttributes;\r\n\r\n\t\t\tfor ( var i = 0, l = activeInfluences.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar influence = activeInfluences[ i ];\r\n\t\t\t\tmorphInfluences[ i ] = influence[ 0 ];\r\n\r\n\t\t\t\tif ( influence[ 0 ] !== 0 ) {\r\n\r\n\t\t\t\t\tvar index = influence[ 1 ];\r\n\r\n\t\t\t\t\tif ( material.morphTargets === true && morphAttributes.position ) geometry.addAttribute( 'morphTarget' + i, morphAttributes.position[ index ] );\r\n\t\t\t\t\tif ( material.morphNormals === true && morphAttributes.normal ) geometry.addAttribute( 'morphNormal' + i, morphAttributes.normal[ index ] );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tif ( material.morphTargets === true ) geometry.removeAttribute( 'morphTarget' + i );\r\n\t\t\t\t\tif ( material.morphNormals === true ) geometry.removeAttribute( 'morphNormal' + i );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tprogram.getUniforms().setValue(\r\n\t\t\t\t\t_gl, 'morphTargetInfluences', morphInfluences );\r\n\r\n\t\t\tupdateBuffers = true;\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tvar index = geometry.index;\r\n\t\tvar position = geometry.attributes.position;\r\n\r\n\t\tif ( material.wireframe === true ) {\r\n\r\n\t\t\tindex = objects.getWireframeAttribute( geometry );\r\n\r\n\t\t}\r\n\r\n\t\tvar renderer;\r\n\r\n\t\tif ( index !== null ) {\r\n\r\n\t\t\trenderer = indexedBufferRenderer;\r\n\t\t\trenderer.setIndex( index );\r\n\r\n\t\t} else {\r\n\r\n\t\t\trenderer = bufferRenderer;\r\n\r\n\t\t}\r\n\r\n\t\tif ( updateBuffers ) {\r\n\r\n\t\t\tsetupVertexAttributes( material, program, geometry );\r\n\r\n\t\t\tif ( index !== null ) {\r\n\r\n\t\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, objects.getAttributeBuffer( index ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tvar dataStart = 0;\r\n\t\tvar dataCount = Infinity;\r\n\r\n\t\tif ( index !== null ) {\r\n\r\n\t\t\tdataCount = index.count;\r\n\r\n\t\t} else if ( position !== undefined ) {\r\n\r\n\t\t\tdataCount = position.count;\r\n\r\n\t\t}\r\n\r\n\t\tvar rangeStart = geometry.drawRange.start;\r\n\t\tvar rangeCount = geometry.drawRange.count;\r\n\r\n\t\tvar groupStart = group !== null ? group.start : 0;\r\n\t\tvar groupCount = group !== null ? group.count : Infinity;\r\n\r\n\t\tvar drawStart = Math.max( dataStart, rangeStart, groupStart );\r\n\t\tvar drawEnd = Math.min( dataStart + dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;\r\n\r\n\t\tvar drawCount = Math.max( 0, drawEnd - drawStart + 1 );\r\n\r\n\t\t//\r\n\r\n\t\tif ( object instanceof THREE.Mesh ) {\r\n\r\n\t\t\tif ( material.wireframe === true ) {\r\n\r\n\t\t\t\tstate.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );\r\n\t\t\t\trenderer.setMode( _gl.LINES );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tswitch ( object.drawMode ) {\r\n\r\n\t\t\t\t\tcase THREE.TrianglesDrawMode:\r\n\t\t\t\t\t\trenderer.setMode( _gl.TRIANGLES );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase THREE.TriangleStripDrawMode:\r\n\t\t\t\t\t\trenderer.setMode( _gl.TRIANGLE_STRIP );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase THREE.TriangleFanDrawMode:\r\n\t\t\t\t\t\trenderer.setMode( _gl.TRIANGLE_FAN );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t} else if ( object instanceof THREE.Line ) {\r\n\r\n\t\t\tvar lineWidth = material.linewidth;\r\n\r\n\t\t\tif ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material\r\n\r\n\t\t\tstate.setLineWidth( lineWidth * getTargetPixelRatio() );\r\n\r\n\t\t\tif ( object instanceof THREE.LineSegments ) {\r\n\r\n\t\t\t\trenderer.setMode( _gl.LINES );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\trenderer.setMode( _gl.LINE_STRIP );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( object instanceof THREE.Points ) {\r\n\r\n\t\t\trenderer.setMode( _gl.POINTS );\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry instanceof THREE.InstancedBufferGeometry ) {\r\n\r\n\t\t\tif ( geometry.maxInstancedCount > 0 ) {\r\n\r\n\t\t\t\trenderer.renderInstances( geometry, drawStart, drawCount );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\trenderer.render( drawStart, drawCount );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction setupVertexAttributes( material, program, geometry, startIndex ) {\r\n\r\n\t\tvar extension;\r\n\r\n\t\tif ( geometry instanceof THREE.InstancedBufferGeometry ) {\r\n\r\n\t\t\textension = extensions.get( 'ANGLE_instanced_arrays' );\r\n\r\n\t\t\tif ( extension === null ) {\r\n\r\n\t\t\t\tconsole.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\r\n\t\t\t\treturn;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( startIndex === undefined ) startIndex = 0;\r\n\r\n\t\tstate.initAttributes();\r\n\r\n\t\tvar geometryAttributes = geometry.attributes;\r\n\r\n\t\tvar programAttributes = program.getAttributes();\r\n\r\n\t\tvar materialDefaultAttributeValues = material.defaultAttributeValues;\r\n\r\n\t\tfor ( var name in programAttributes ) {\r\n\r\n\t\t\tvar programAttribute = programAttributes[ name ];\r\n\r\n\t\t\tif ( programAttribute >= 0 ) {\r\n\r\n\t\t\t\tvar geometryAttribute = geometryAttributes[ name ];\r\n\r\n\t\t\t\tif ( geometryAttribute !== undefined ) {\r\n\r\n\t\t\t\t\tvar type = _gl.FLOAT;\r\n\t\t\t\t\tvar array = geometryAttribute.array;\r\n\t\t\t\t\tvar normalized = geometryAttribute.normalized;\r\n\r\n\t\t\t\t\tif ( array instanceof Float32Array ) {\r\n\r\n\t\t\t\t\t\ttype = _gl.FLOAT;\r\n\r\n\t\t\t\t\t} else if ( array instanceof Float64Array ) {\r\n\r\n\t\t\t\t\t\tconsole.warn(\"Unsupported data buffer format: Float64Array\");\r\n\r\n\t\t\t\t\t} else if ( array instanceof Uint16Array ) {\r\n\r\n\t\t\t\t\t\ttype = _gl.UNSIGNED_SHORT;\r\n\r\n\t\t\t\t\t} else if ( array instanceof Int16Array ) {\r\n\r\n\t\t\t\t\t\ttype = _gl.SHORT;\r\n\r\n\t\t\t\t\t} else if ( array instanceof Uint32Array ) {\r\n\r\n\t\t\t\t\t\ttype = _gl.UNSIGNED_INT;\r\n\r\n\t\t\t\t\t} else if ( array instanceof Int32Array ) {\r\n\r\n\t\t\t\t\t\ttype = _gl.INT;\r\n\r\n\t\t\t\t\t} else if ( array instanceof Int8Array ) {\r\n\r\n\t\t\t\t\t\ttype = _gl.BYTE;\r\n\r\n\t\t\t\t\t} else if ( array instanceof Uint8Array ) {\r\n\r\n\t\t\t\t\t\ttype = _gl.UNSIGNED_BYTE;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tvar size = geometryAttribute.itemSize;\r\n\t\t\t\t\tvar buffer = objects.getAttributeBuffer( geometryAttribute );\r\n\r\n\t\t\t\t\tif ( geometryAttribute instanceof THREE.InterleavedBufferAttribute ) {\r\n\r\n\t\t\t\t\t\tvar data = geometryAttribute.data;\r\n\t\t\t\t\t\tvar stride = data.stride;\r\n\t\t\t\t\t\tvar offset = geometryAttribute.offset;\r\n\r\n\t\t\t\t\t\tif ( data instanceof THREE.InstancedInterleavedBuffer ) {\r\n\r\n\t\t\t\t\t\t\tstate.enableAttributeAndDivisor( programAttribute, data.meshPerAttribute, extension );\r\n\r\n\t\t\t\t\t\t\tif ( geometry.maxInstancedCount === undefined ) {\r\n\r\n\t\t\t\t\t\t\t\tgeometry.maxInstancedCount = data.meshPerAttribute * data.count;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tstate.enableAttribute( programAttribute );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );\r\n\t\t\t\t\t\t_gl.vertexAttribPointer( programAttribute, size, type, normalized, stride * data.array.BYTES_PER_ELEMENT, ( startIndex * stride + offset ) * data.array.BYTES_PER_ELEMENT );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tif ( geometryAttribute instanceof THREE.InstancedBufferAttribute ) {\r\n\r\n\t\t\t\t\t\t\tstate.enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute, extension );\r\n\r\n\t\t\t\t\t\t\tif ( geometry.maxInstancedCount === undefined ) {\r\n\r\n\t\t\t\t\t\t\t\tgeometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tstate.enableAttribute( programAttribute );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );\r\n\t\t\t\t\t\t_gl.vertexAttribPointer( programAttribute, size, type, normalized, 0, startIndex * size * geometryAttribute.array.BYTES_PER_ELEMENT );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else if ( materialDefaultAttributeValues !== undefined ) {\r\n\r\n\t\t\t\t\tvar value = materialDefaultAttributeValues[ name ];\r\n\r\n\t\t\t\t\tif ( value !== undefined ) {\r\n\r\n\t\t\t\t\t\tswitch ( value.length ) {\r\n\r\n\t\t\t\t\t\t\tcase 2:\r\n\t\t\t\t\t\t\t\t_gl.vertexAttrib2fv( programAttribute, value );\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\tcase 3:\r\n\t\t\t\t\t\t\t\t_gl.vertexAttrib3fv( programAttribute, value );\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\tcase 4:\r\n\t\t\t\t\t\t\t\t_gl.vertexAttrib4fv( programAttribute, value );\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\t\t_gl.vertexAttrib1fv( programAttribute, value );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tstate.disableUnusedAttributes();\r\n\r\n\t}\r\n\r\n\t// Sorting\r\n\r\n\tfunction absNumericalSort( a, b ) {\r\n\r\n\t\treturn Math.abs( b[ 0 ] ) - Math.abs( a[ 0 ] );\r\n\r\n\t}\r\n\r\n\tfunction painterSortStable ( a, b ) {\r\n\r\n\t\tif ( a.object.renderOrder !== b.object.renderOrder ) {\r\n\r\n\t\t\treturn a.object.renderOrder - b.object.renderOrder;\r\n\r\n\t\t} else if ( a.material.id !== b.material.id ) {\r\n\r\n\t\t\treturn a.material.id - b.material.id;\r\n\r\n\t\t} else if ( a.z !== b.z ) {\r\n\r\n\t\t\treturn a.z - b.z;\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn a.id - b.id;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction reversePainterSortStable ( a, b ) {\r\n\r\n\t\tif ( a.object.renderOrder !== b.object.renderOrder ) {\r\n\r\n\t\t\treturn a.object.renderOrder - b.object.renderOrder;\r\n\r\n\t\t} if ( a.z !== b.z ) {\r\n\r\n\t\t\treturn b.z - a.z;\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn a.id - b.id;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// Rendering\r\n\r\n\tthis.render = function ( scene, camera, renderTarget, forceClear ) {\r\n\r\n\t\tif ( camera instanceof THREE.Camera === false ) {\r\n\r\n\t\t\tconsole.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tvar fog = scene.fog;\r\n\r\n\t\t// reset caching for this frame\r\n\r\n\t\t_currentGeometryProgram = '';\r\n\t\t_currentMaterialId = - 1;\r\n\t\t_currentCamera = null;\r\n\r\n\t\t// update scene graph\r\n\r\n\t\tif ( scene.autoUpdate === true ) scene.updateMatrixWorld();\r\n\r\n\t\t// update camera matrices and frustum\r\n\r\n\t\tif ( camera.parent === null ) camera.updateMatrixWorld();\r\n\r\n\t\tcamera.matrixWorldInverse.getInverse( camera.matrixWorld );\r\n\r\n\t\t_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\r\n\t\t_frustum.setFromMatrix( _projScreenMatrix );\r\n\r\n\t\tlights.length = 0;\r\n\r\n\t\topaqueObjectsLastIndex = - 1;\r\n\t\ttransparentObjectsLastIndex = - 1;\r\n\r\n\t\tsprites.length = 0;\r\n\t\tlensFlares.length = 0;\r\n\r\n\t\tsetupGlobalClippingPlanes( this.clippingPlanes, camera );\r\n\r\n\t\tprojectObject( scene, camera );\r\n\r\n\r\n\t\topaqueObjects.length = opaqueObjectsLastIndex + 1;\r\n\t\ttransparentObjects.length = transparentObjectsLastIndex + 1;\r\n\r\n\t\tif ( _this.sortObjects === true ) {\r\n\r\n\t\t\topaqueObjects.sort( painterSortStable );\r\n\t\t\ttransparentObjects.sort( reversePainterSortStable );\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tif ( _clippingEnabled ) {\r\n\r\n\t\t\t_clipRenderingShadows = true;\r\n\t\t\tsetupClippingPlanes( null );\r\n\r\n\t\t}\r\n\r\n\t\tsetupShadows( lights );\r\n\r\n\t\tshadowMap.render( scene, camera );\r\n\r\n\t\tsetupLights( lights, camera );\r\n\r\n\t\tif ( _clippingEnabled ) {\r\n\r\n\t\t\t_clipRenderingShadows = false;\r\n\t\t\tresetGlobalClippingState();\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\t_infoRender.calls = 0;\r\n\t\t_infoRender.vertices = 0;\r\n\t\t_infoRender.faces = 0;\r\n\t\t_infoRender.points = 0;\r\n\r\n\t\tif ( renderTarget === undefined ) {\r\n\r\n\t\t\trenderTarget = null;\r\n\r\n\t\t}\r\n\r\n\t\tthis.setRenderTarget( renderTarget );\r\n\r\n\t\tif ( this.autoClear || forceClear ) {\r\n\r\n\t\t\tthis.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tif ( scene.overrideMaterial ) {\r\n\r\n\t\t\tvar overrideMaterial = scene.overrideMaterial;\r\n\r\n\t\t\trenderObjects( opaqueObjects, camera, fog, overrideMaterial );\r\n\t\t\trenderObjects( transparentObjects, camera, fog, overrideMaterial );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// opaque pass (front-to-back order)\r\n\r\n\t\t\tstate.setBlending( THREE.NoBlending );\r\n\t\t\trenderObjects( opaqueObjects, camera, fog );\r\n\r\n\t\t\t// transparent pass (back-to-front order)\r\n\r\n\t\t\trenderObjects( transparentObjects, camera, fog );\r\n\r\n\t\t}\r\n\r\n\t\t// custom render plugins (post pass)\r\n\r\n\t\tspritePlugin.render( scene, camera );\r\n\t\tlensFlarePlugin.render( scene, camera, _currentViewport );\r\n\r\n\t\t// Generate mipmap if we're using any kind of mipmap filtering\r\n\r\n\t\tif ( renderTarget ) {\r\n\r\n\t\t\tvar texture = renderTarget.texture;\r\n\r\n\t\t\tif ( texture.generateMipmaps && isPowerOfTwo( renderTarget ) &&\r\n\t\t\t\t\ttexture.minFilter !== THREE.NearestFilter &&\r\n\t\t\t\t\ttexture.minFilter !== THREE.LinearFilter ) {\r\n\r\n\t\t\t\tupdateRenderTargetMipmap( renderTarget );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// Ensure depth buffer writing is enabled so it can be cleared on next render\r\n\r\n\t\tstate.setDepthTest( true );\r\n\t\tstate.setDepthWrite( true );\r\n\t\tstate.setColorWrite( true );\r\n\r\n\t\t// _gl.finish();\r\n\r\n\t};\r\n\r\n\tfunction pushRenderItem( object, geometry, material, z, group ) {\r\n\r\n\t\tvar array, index;\r\n\r\n\t\t// allocate the next position in the appropriate array\r\n\r\n\t\tif ( material.transparent ) {\r\n\r\n\t\t\tarray = transparentObjects;\r\n\t\t\tindex = ++ transparentObjectsLastIndex;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tarray = opaqueObjects;\r\n\t\t\tindex = ++ opaqueObjectsLastIndex;\r\n\r\n\t\t}\r\n\r\n\t\t// recycle existing render item or grow the array\r\n\r\n\t\tvar renderItem = array[ index ];\r\n\r\n\t\tif ( renderItem !== undefined ) {\r\n\r\n\t\t\trenderItem.id = object.id;\r\n\t\t\trenderItem.object = object;\r\n\t\t\trenderItem.geometry = geometry;\r\n\t\t\trenderItem.material = material;\r\n\t\t\trenderItem.z = _vector3.z;\r\n\t\t\trenderItem.group = group;\r\n\r\n\t\t} else {\r\n\r\n\t\t\trenderItem = {\r\n\t\t\t\tid: object.id,\r\n\t\t\t\tobject: object,\r\n\t\t\t\tgeometry: geometry,\r\n\t\t\t\tmaterial: material,\r\n\t\t\t\tz: _vector3.z,\r\n\t\t\t\tgroup: group\r\n\t\t\t};\r\n\r\n\t\t\t// assert( index === array.length );\r\n\t\t\tarray.push( renderItem );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction isObjectViewable( object ) {\r\n\r\n\t\tvar geometry = object.geometry;\r\n\r\n\t\tif ( geometry.boundingSphere === null )\r\n\t\t\tgeometry.computeBoundingSphere();\r\n\r\n\t\tvar sphere = _sphere.\r\n\t\t\t\tcopy( geometry.boundingSphere ).\r\n\t\t\t\tapplyMatrix4( object.matrixWorld );\r\n\r\n\t\tif ( ! _frustum.intersectsSphere( sphere ) ) return false;\r\n\t\tif ( _numClippingPlanes === 0 ) return true;\r\n\r\n\t\tvar planes = _this.clippingPlanes,\r\n\r\n\t\t\tcenter = sphere.center,\r\n\t\t\tnegRad = - sphere.radius,\r\n\t\t\ti = 0;\r\n\r\n\t\tdo {\r\n\r\n\t\t\t// out when deeper than radius in the negative halfspace\r\n\t\t\tif ( planes[ i ].distanceToPoint( center ) < negRad ) return false;\r\n\r\n\t\t} while ( ++ i !== _numClippingPlanes );\r\n\r\n\t\treturn true;\r\n\r\n\t}\r\n\r\n\tfunction projectObject( object, camera ) {\r\n\r\n\t\tif ( object.visible === false ) return;\r\n\r\n\t\tif ( object.layers.test( camera.layers ) ) {\r\n\r\n\t\t\tif ( object instanceof THREE.Light ) {\r\n\r\n\t\t\t\tlights.push( object );\r\n\r\n\t\t\t} else if ( object instanceof THREE.Sprite ) {\r\n\r\n\t\t\t\tif ( object.frustumCulled === false || isObjectViewable( object ) === true ) {\r\n\r\n\t\t\t\t\tsprites.push( object );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( object instanceof THREE.LensFlare ) {\r\n\r\n\t\t\t\tlensFlares.push( object );\r\n\r\n\t\t\t} else if ( object instanceof THREE.ImmediateRenderObject ) {\r\n\r\n\t\t\t\tif ( _this.sortObjects === true ) {\r\n\r\n\t\t\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld );\r\n\t\t\t\t\t_vector3.applyProjection( _projScreenMatrix );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tpushRenderItem( object, null, object.material, _vector3.z, null );\r\n\r\n\t\t\t} else if ( object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Points ) {\r\n\r\n\t\t\t\tif ( object instanceof THREE.SkinnedMesh ) {\r\n\r\n\t\t\t\t\tobject.skeleton.update();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( object.frustumCulled === false || isObjectViewable( object ) === true ) {\r\n\r\n\t\t\t\t\tvar material = object.material;\r\n\r\n\t\t\t\t\tif ( material.visible === true ) {\r\n\r\n\t\t\t\t\t\tif ( _this.sortObjects === true ) {\r\n\r\n\t\t\t\t\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld );\r\n\t\t\t\t\t\t\t_vector3.applyProjection( _projScreenMatrix );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tvar geometry = objects.update( object );\r\n\r\n\t\t\t\t\t\tif ( material instanceof THREE.MultiMaterial ) {\r\n\r\n\t\t\t\t\t\t\tvar groups = geometry.groups;\r\n\t\t\t\t\t\t\tvar materials = material.materials;\r\n\r\n\t\t\t\t\t\t\tfor ( var i = 0, l = groups.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\t\t\t\tvar group = groups[ i ];\r\n\t\t\t\t\t\t\t\tvar groupMaterial = materials[ group.materialIndex ];\r\n\r\n\t\t\t\t\t\t\t\tif ( groupMaterial.visible === true ) {\r\n\r\n\t\t\t\t\t\t\t\t\tpushRenderItem( object, geometry, groupMaterial, _vector3.z, group );\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tpushRenderItem( object, geometry, material, _vector3.z, null );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar children = object.children;\r\n\r\n\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\r\n\r\n\t\t\tprojectObject( children[ i ], camera );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction renderObjects( renderList, camera, fog, overrideMaterial ) {\r\n\r\n\t\tfor ( var i = 0, l = renderList.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar renderItem = renderList[ i ];\r\n\r\n\t\t\tvar object = renderItem.object;\r\n\t\t\tvar geometry = renderItem.geometry;\r\n\t\t\tvar material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;\r\n\t\t\tvar group = renderItem.group;\r\n\r\n\t\t\tobject.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );\r\n\t\t\tobject.normalMatrix.getNormalMatrix( object.modelViewMatrix );\r\n\r\n\t\t\tif ( object instanceof THREE.ImmediateRenderObject ) {\r\n\r\n\t\t\t\tsetMaterial( material );\r\n\r\n\t\t\t\tvar program = setProgram( camera, fog, material, object );\r\n\r\n\t\t\t\t_currentGeometryProgram = '';\r\n\r\n\t\t\t\tobject.render( function ( object ) {\r\n\r\n\t\t\t\t\t_this.renderBufferImmediate( object, program, material );\r\n\r\n\t\t\t\t} );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t_this.renderBufferDirect( camera, fog, geometry, material, object, group );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction initMaterial( material, fog, object ) {\r\n\r\n\t\tvar materialProperties = properties.get( material );\r\n\r\n\t\tvar parameters = programCache.getParameters(\r\n\t\t\t\tmaterial, _lights, fog, _numClippingPlanes, object );\r\n\r\n\t\tvar code = programCache.getProgramCode( material, parameters );\r\n\r\n\t\tvar program = materialProperties.program;\r\n\t\tvar programChange = true;\r\n\r\n\t\tif ( program === undefined ) {\r\n\r\n\t\t\t// new material\r\n\t\t\tmaterial.addEventListener( 'dispose', onMaterialDispose );\r\n\r\n\t\t} else if ( program.code !== code ) {\r\n\r\n\t\t\t// changed glsl or parameters\r\n\t\t\treleaseMaterialProgramReference( material );\r\n\r\n\t\t} else if ( parameters.shaderID !== undefined ) {\r\n\r\n\t\t\t// same glsl and uniform list\r\n\t\t\treturn;\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// only rebuild uniform list\r\n\t\t\tprogramChange = false;\r\n\r\n\t\t}\r\n\r\n\t\tif ( programChange ) {\r\n\r\n\t\t\tif ( parameters.shaderID ) {\r\n\r\n\t\t\t\tvar shader = THREE.ShaderLib[ parameters.shaderID ];\r\n\r\n\t\t\t\tmaterialProperties.__webglShader = {\r\n\t\t\t\t\tname: material.type,\r\n\t\t\t\t\tuniforms: THREE.UniformsUtils.clone( shader.uniforms ),\r\n\t\t\t\t\tvertexShader: shader.vertexShader,\r\n\t\t\t\t\tfragmentShader: shader.fragmentShader\r\n\t\t\t\t};\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tmaterialProperties.__webglShader = {\r\n\t\t\t\t\tname: material.type,\r\n\t\t\t\t\tuniforms: material.uniforms,\r\n\t\t\t\t\tvertexShader: material.vertexShader,\r\n\t\t\t\t\tfragmentShader: material.fragmentShader\r\n\t\t\t\t};\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmaterial.__webglShader = materialProperties.__webglShader;\r\n\r\n\t\t\tprogram = programCache.acquireProgram( material, parameters, code );\r\n\r\n\t\t\tmaterialProperties.program = program;\r\n\t\t\tmaterial.program = program;\r\n\r\n\t\t}\r\n\r\n\t\tvar attributes = program.getAttributes();\r\n\r\n\t\tif ( material.morphTargets ) {\r\n\r\n\t\t\tmaterial.numSupportedMorphTargets = 0;\r\n\r\n\t\t\tfor ( var i = 0; i < _this.maxMorphTargets; i ++ ) {\r\n\r\n\t\t\t\tif ( attributes[ 'morphTarget' + i ] >= 0 ) {\r\n\r\n\t\t\t\t\tmaterial.numSupportedMorphTargets ++;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.morphNormals ) {\r\n\r\n\t\t\tmaterial.numSupportedMorphNormals = 0;\r\n\r\n\t\t\tfor ( var i = 0; i < _this.maxMorphNormals; i ++ ) {\r\n\r\n\t\t\t\tif ( attributes[ 'morphNormal' + i ] >= 0 ) {\r\n\r\n\t\t\t\t\tmaterial.numSupportedMorphNormals ++;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar uniforms = materialProperties.__webglShader.uniforms;\r\n\r\n\t\tif ( ! ( material instanceof THREE.ShaderMaterial ) &&\r\n\t\t\t\t! ( material instanceof THREE.RawShaderMaterial ) ||\r\n\t\t\t\tmaterial.clipping === true ) {\r\n\r\n\t\t\tmaterialProperties.numClippingPlanes = _numClippingPlanes;\r\n\t\t\tuniforms.clippingPlanes = _clippingPlanesUniform;\r\n\r\n\t\t}\r\n\r\n\t\tif ( material instanceof THREE.MeshPhongMaterial ||\r\n\t\t\t\tmaterial instanceof THREE.MeshLambertMaterial ||\r\n\t\t\t\tmaterial instanceof THREE.MeshStandardMaterial ||\r\n\t\t\t\tmaterial.lights ) {\r\n\r\n\t\t\t// store the light setup it was created for\r\n\r\n\t\t\tmaterialProperties.lightsHash = _lights.hash;\r\n\r\n\t\t\t// wire up the material to this renderer's lighting state\r\n\r\n\t\t\tuniforms.ambientLightColor.value = _lights.ambient;\r\n\t\t\tuniforms.directionalLights.value = _lights.directional;\r\n\t\t\tuniforms.spotLights.value = _lights.spot;\r\n\t\t\tuniforms.pointLights.value = _lights.point;\r\n\t\t\tuniforms.hemisphereLights.value = _lights.hemi;\r\n\r\n\t\t\tuniforms.directionalShadowMap.value = _lights.directionalShadowMap;\r\n\t\t\tuniforms.directionalShadowMatrix.value = _lights.directionalShadowMatrix;\r\n\t\t\tuniforms.spotShadowMap.value = _lights.spotShadowMap;\r\n\t\t\tuniforms.spotShadowMatrix.value = _lights.spotShadowMatrix;\r\n\t\t\tuniforms.pointShadowMap.value = _lights.pointShadowMap;\r\n\t\t\tuniforms.pointShadowMatrix.value = _lights.pointShadowMatrix;\r\n\r\n\t\t}\r\n\r\n\t\tvar progUniforms = materialProperties.program.getUniforms(),\r\n\t\t\tuniformsList =\r\n\t\t\t\t\tTHREE.WebGLUniforms.seqWithValue( progUniforms.seq, uniforms );\r\n\r\n\t\tmaterialProperties.uniformsList = uniformsList;\r\n\t\tmaterialProperties.dynamicUniforms =\r\n\t\t\t\tTHREE.WebGLUniforms.splitDynamic( uniformsList, uniforms );\r\n\r\n\t}\r\n\r\n\tfunction setMaterial( material ) {\r\n\r\n\t\tsetMaterialFaces( material );\r\n\r\n\t\tif ( material.transparent === true ) {\r\n\r\n\t\t\tstate.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tstate.setBlending( THREE.NoBlending );\r\n\r\n\t\t}\r\n\r\n\t\tstate.setDepthFunc( material.depthFunc );\r\n\t\tstate.setDepthTest( material.depthTest );\r\n\t\tstate.setDepthWrite( material.depthWrite );\r\n\t\tstate.setColorWrite( material.colorWrite );\r\n\t\tstate.setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );\r\n\r\n\t}\r\n\r\n\tfunction setMaterialFaces( material ) {\r\n\r\n\t\tmaterial.side !== THREE.DoubleSide ? state.enable( _gl.CULL_FACE ) : state.disable( _gl.CULL_FACE );\r\n\t\tstate.setFlipSided( material.side === THREE.BackSide );\r\n\r\n\t}\r\n\r\n\tfunction setProgram( camera, fog, material, object ) {\r\n\r\n\t\t_usedTextureUnits = 0;\r\n\r\n\t\tvar materialProperties = properties.get( material );\r\n\r\n\t\tif ( _clippingEnabled ) {\r\n\r\n\t\t\tif ( _localClippingEnabled || camera !== _currentCamera ) {\r\n\r\n\t\t\t\tvar useCache =\r\n\t\t\t\t\t\tcamera === _currentCamera &&\r\n\t\t\t\t\t\tmaterial.id === _currentMaterialId;\r\n\r\n\t\t\t\t// we might want to call this function with some ClippingGroup\r\n\t\t\t\t// object instead of the material, once it becomes feasible\r\n\t\t\t\t// (#8465, #8379)\r\n\t\t\t\tsetClippingState(\r\n\t\t\t\t\t\tmaterial.clippingPlanes, material.clipShadows,\r\n\t\t\t\t\t\tcamera, materialProperties, useCache );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( materialProperties.numClippingPlanes !== undefined &&\r\n\t\t\t\tmaterialProperties.numClippingPlanes !== _numClippingPlanes ) {\r\n\r\n\t\t\t\tmaterial.needsUpdate = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( materialProperties.program === undefined ) {\r\n\r\n\t\t\tmaterial.needsUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t\tif ( materialProperties.lightsHash !== undefined &&\r\n\t\t\tmaterialProperties.lightsHash !== _lights.hash ) {\r\n\r\n\t\t\tmaterial.needsUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.needsUpdate ) {\r\n\r\n\t\t\tinitMaterial( material, fog, object );\r\n\t\t\tmaterial.needsUpdate = false;\r\n\r\n\t\t}\r\n\r\n\t\tvar refreshProgram = false;\r\n\t\tvar refreshMaterial = false;\r\n\t\tvar refreshLights = false;\r\n\r\n\t\tvar program = materialProperties.program,\r\n\t\t\tp_uniforms = program.getUniforms(),\r\n\t\t\tm_uniforms = materialProperties.__webglShader.uniforms;\r\n\r\n\t\tif ( program.id !== _currentProgram ) {\r\n\r\n\t\t\t_gl.useProgram( program.program );\r\n\t\t\t_currentProgram = program.id;\r\n\r\n\t\t\trefreshProgram = true;\r\n\t\t\trefreshMaterial = true;\r\n\t\t\trefreshLights = true;\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.id !== _currentMaterialId ) {\r\n\r\n\t\t\t_currentMaterialId = material.id;\r\n\r\n\t\t\trefreshMaterial = true;\r\n\r\n\t\t}\r\n\r\n\t\tif ( refreshProgram || camera !== _currentCamera ) {\r\n\r\n\t\t\tp_uniforms.set( _gl, camera, 'projectionMatrix' );\r\n\r\n\t\t\tif ( capabilities.logarithmicDepthBuffer ) {\r\n\r\n\t\t\t\tp_uniforms.setValue( _gl, 'logDepthBufFC',\r\n\t\t\t\t\t\t2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t\tif ( camera !== _currentCamera ) {\r\n\r\n\t\t\t\t_currentCamera = camera;\r\n\r\n\t\t\t\t// lighting uniforms depend on the camera so enforce an update\r\n\t\t\t\t// now, in case this material supports lights - or later, when\r\n\t\t\t\t// the next material that does gets activated:\r\n\r\n\t\t\t\trefreshMaterial = true;\t\t// set to true on material change\r\n\t\t\t\trefreshLights = true;\t\t// remains set until update done\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// load material specific uniforms\r\n\t\t\t// (shader material also gets them for the sake of genericity)\r\n\r\n\t\t\tif ( material instanceof THREE.ShaderMaterial ||\r\n\t\t\t\t material instanceof THREE.MeshPhongMaterial ||\r\n\t\t\t\t material instanceof THREE.MeshStandardMaterial ||\r\n\t\t\t\t material.envMap ) {\r\n\r\n\t\t\t\tvar uCamPos = p_uniforms.map.cameraPosition;\r\n\r\n\t\t\t\tif ( uCamPos !== undefined ) {\r\n\r\n\t\t\t\t\tuCamPos.setValue( _gl,\r\n\t\t\t\t\t\t\t_vector3.setFromMatrixPosition( camera.matrixWorld ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( material instanceof THREE.MeshPhongMaterial ||\r\n\t\t\t\t material instanceof THREE.MeshLambertMaterial ||\r\n\t\t\t\t material instanceof THREE.MeshBasicMaterial ||\r\n\t\t\t\t material instanceof THREE.MeshStandardMaterial ||\r\n\t\t\t\t material instanceof THREE.ShaderMaterial ||\r\n\t\t\t\t material.skinning ) {\r\n\r\n\t\t\t\tp_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tp_uniforms.set( _gl, _this, 'toneMappingExposure' );\r\n\t\t\tp_uniforms.set( _gl, _this, 'toneMappingWhitePoint' );\r\n\r\n\t\t}\r\n\r\n\t\t// skinning uniforms must be set even if material didn't change\r\n\t\t// auto-setting of texture unit for bone texture must go before other textures\r\n\t\t// not sure why, but otherwise weird things happen\r\n\r\n\t\tif ( material.skinning ) {\r\n\r\n\t\t\tp_uniforms.setOptional( _gl, object, 'bindMatrix' );\r\n\t\t\tp_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );\r\n\r\n\t\t\tvar skeleton = object.skeleton;\r\n\r\n\t\t\tif ( skeleton ) {\r\n\r\n\t\t\t\tif ( capabilities.floatVertexTextures && skeleton.useVertexTexture ) {\r\n\r\n\t\t\t\t\tp_uniforms.set( _gl, skeleton, 'boneTexture' );\r\n\t\t\t\t\tp_uniforms.set( _gl, skeleton, 'boneTextureWidth' );\r\n\t\t\t\t\tp_uniforms.set( _gl, skeleton, 'boneTextureHeight' );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tp_uniforms.setOptional( _gl, skeleton, 'boneMatrices' );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( refreshMaterial ) {\r\n\r\n\t\t\tif ( material instanceof THREE.MeshPhongMaterial ||\r\n\t\t\t\t material instanceof THREE.MeshLambertMaterial ||\r\n\t\t\t\t material instanceof THREE.MeshStandardMaterial ||\r\n\t\t\t\t material.lights ) {\r\n\r\n\t\t\t\t// the current material requires lighting info\r\n\r\n\t\t\t\t// note: all lighting uniforms are always set correctly\r\n\t\t\t\t// they simply reference the renderer's state for their\r\n\t\t\t\t// values\r\n\t\t\t\t//\r\n\t\t\t\t// use the current material's .needsUpdate flags to set\r\n\t\t\t\t// the GL state when required\r\n\r\n\t\t\t\tmarkUniformsLightsNeedsUpdate( m_uniforms, refreshLights );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// refresh uniforms common to several materials\r\n\r\n\t\t\tif ( fog && material.fog ) {\r\n\r\n\t\t\t\trefreshUniformsFog( m_uniforms, fog );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( material instanceof THREE.MeshBasicMaterial ||\r\n\t\t\t\t material instanceof THREE.MeshLambertMaterial ||\r\n\t\t\t\t material instanceof THREE.MeshPhongMaterial ||\r\n\t\t\t\t material instanceof THREE.MeshStandardMaterial ||\r\n\t\t\t\t material instanceof THREE.MeshDepthMaterial ) {\r\n\r\n\t\t\t\trefreshUniformsCommon( m_uniforms, material );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// refresh single material specific uniforms\r\n\r\n\t\t\tif ( material instanceof THREE.LineBasicMaterial ) {\r\n\r\n\t\t\t\trefreshUniformsLine( m_uniforms, material );\r\n\r\n\t\t\t} else if ( material instanceof THREE.LineDashedMaterial ) {\r\n\r\n\t\t\t\trefreshUniformsLine( m_uniforms, material );\r\n\t\t\t\trefreshUniformsDash( m_uniforms, material );\r\n\r\n\t\t\t} else if ( material instanceof THREE.PointsMaterial ) {\r\n\r\n\t\t\t\trefreshUniformsPoints( m_uniforms, material );\r\n\r\n\t\t\t} else if ( material instanceof THREE.MeshLambertMaterial ) {\r\n\r\n\t\t\t\trefreshUniformsLambert( m_uniforms, material );\r\n\r\n\t\t\t} else if ( material instanceof THREE.MeshPhongMaterial ) {\r\n\r\n\t\t\t\trefreshUniformsPhong( m_uniforms, material );\r\n\r\n\t\t\t} else if ( material instanceof THREE.MeshPhysicalMaterial ) {\r\n\r\n\t\t\t\trefreshUniformsPhysical( m_uniforms, material );\r\n\r\n\t\t\t} else if ( material instanceof THREE.MeshStandardMaterial ) {\r\n\r\n\t\t\t\trefreshUniformsStandard( m_uniforms, material );\r\n\r\n\t\t\t} else if ( material instanceof THREE.MeshDepthMaterial ) {\r\n\r\n\t\t\t\tif ( material.displacementMap ) {\r\n\r\n\t\t\t\t\tm_uniforms.displacementMap.value = material.displacementMap;\r\n\t\t\t\t\tm_uniforms.displacementScale.value = material.displacementScale;\r\n\t\t\t\t\tm_uniforms.displacementBias.value = material.displacementBias;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( material instanceof THREE.MeshNormalMaterial ) {\r\n\r\n\t\t\t\tm_uniforms.opacity.value = material.opacity;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tTHREE.WebGLUniforms.upload(\r\n\t\t\t\t\t_gl, materialProperties.uniformsList, m_uniforms, _this );\r\n\r\n\t\t}\r\n\r\n\r\n\t\t// common matrices\r\n\r\n\t\tp_uniforms.set( _gl, object, 'modelViewMatrix' );\r\n\t\tp_uniforms.set( _gl, object, 'normalMatrix' );\r\n\t\tp_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );\r\n\r\n\r\n\t\t// dynamic uniforms\r\n\r\n\t\tvar dynUniforms = materialProperties.dynamicUniforms;\r\n\r\n\t\tif ( dynUniforms !== null ) {\r\n\r\n\t\t\tTHREE.WebGLUniforms.evalDynamic(\r\n\t\t\t\t\tdynUniforms, m_uniforms, object, camera );\r\n\r\n\t\t\tTHREE.WebGLUniforms.upload( _gl, dynUniforms, m_uniforms, _this );\r\n\r\n\t\t}\r\n\r\n\t\treturn program;\r\n\r\n\t}\r\n\r\n\t// Uniforms (refresh uniforms objects)\r\n\r\n\tfunction refreshUniformsCommon ( uniforms, material ) {\r\n\r\n\t\tuniforms.opacity.value = material.opacity;\r\n\r\n\t\tuniforms.diffuse.value = material.color;\r\n\r\n\t\tif ( material.emissive ) {\r\n\r\n\t\t\tuniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );\r\n\r\n\t\t}\r\n\r\n\t\tuniforms.map.value = material.map;\r\n\t\tuniforms.specularMap.value = material.specularMap;\r\n\t\tuniforms.alphaMap.value = material.alphaMap;\r\n\r\n\t\tif ( material.aoMap ) {\r\n\r\n\t\t\tuniforms.aoMap.value = material.aoMap;\r\n\t\t\tuniforms.aoMapIntensity.value = material.aoMapIntensity;\r\n\r\n\t\t}\r\n\r\n\t\t// uv repeat and offset setting priorities\r\n\t\t// 1. color map\r\n\t\t// 2. specular map\r\n\t\t// 3. normal map\r\n\t\t// 4. bump map\r\n\t\t// 5. alpha map\r\n\t\t// 6. emissive map\r\n\r\n\t\tvar uvScaleMap;\r\n\r\n\t\tif ( material.map ) {\r\n\r\n\t\t\tuvScaleMap = material.map;\r\n\r\n\t\t} else if ( material.specularMap ) {\r\n\r\n\t\t\tuvScaleMap = material.specularMap;\r\n\r\n\t\t} else if ( material.displacementMap ) {\r\n\r\n\t\t\tuvScaleMap = material.displacementMap;\r\n\r\n\t\t} else if ( material.normalMap ) {\r\n\r\n\t\t\tuvScaleMap = material.normalMap;\r\n\r\n\t\t} else if ( material.bumpMap ) {\r\n\r\n\t\t\tuvScaleMap = material.bumpMap;\r\n\r\n\t\t} else if ( material.roughnessMap ) {\r\n\r\n\t\t\tuvScaleMap = material.roughnessMap;\r\n\r\n\t\t} else if ( material.metalnessMap ) {\r\n\r\n\t\t\tuvScaleMap = material.metalnessMap;\r\n\r\n\t\t} else if ( material.alphaMap ) {\r\n\r\n\t\t\tuvScaleMap = material.alphaMap;\r\n\r\n\t\t} else if ( material.emissiveMap ) {\r\n\r\n\t\t\tuvScaleMap = material.emissiveMap;\r\n\r\n\t\t}\r\n\r\n\t\tif ( uvScaleMap !== undefined ) {\r\n\r\n\t\t\tif ( uvScaleMap instanceof THREE.WebGLRenderTarget ) {\r\n\r\n\t\t\t\tuvScaleMap = uvScaleMap.texture;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar offset = uvScaleMap.offset;\r\n\t\t\tvar repeat = uvScaleMap.repeat;\r\n\r\n\t\t\tuniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );\r\n\r\n\t\t}\r\n\r\n\t\tuniforms.envMap.value = material.envMap;\r\n\t\tuniforms.flipEnvMap.value = ( material.envMap instanceof THREE.WebGLRenderTargetCube ) ? 1 : - 1;\r\n\r\n\t\tuniforms.reflectivity.value = material.reflectivity;\r\n\t\tuniforms.refractionRatio.value = material.refractionRatio;\r\n\r\n\t}\r\n\r\n\tfunction refreshUniformsLine ( uniforms, material ) {\r\n\r\n\t\tuniforms.diffuse.value = material.color;\r\n\t\tuniforms.opacity.value = material.opacity;\r\n\r\n\t}\r\n\r\n\tfunction refreshUniformsDash ( uniforms, material ) {\r\n\r\n\t\tuniforms.dashSize.value = material.dashSize;\r\n\t\tuniforms.totalSize.value = material.dashSize + material.gapSize;\r\n\t\tuniforms.scale.value = material.scale;\r\n\r\n\t}\r\n\r\n\tfunction refreshUniformsPoints ( uniforms, material ) {\r\n\r\n\t\tuniforms.diffuse.value = material.color;\r\n\t\tuniforms.opacity.value = material.opacity;\r\n\t\tuniforms.size.value = material.size * _pixelRatio;\r\n\t\tuniforms.scale.value = _canvas.clientHeight * 0.5;\r\n\r\n\t\tuniforms.map.value = material.map;\r\n\r\n\t\tif ( material.map !== null ) {\r\n\r\n\t\t\tvar offset = material.map.offset;\r\n\t\t\tvar repeat = material.map.repeat;\r\n\r\n\t\t\tuniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction refreshUniformsFog ( uniforms, fog ) {\r\n\r\n\t\tuniforms.fogColor.value = fog.color;\r\n\r\n\t\tif ( fog instanceof THREE.Fog ) {\r\n\r\n\t\t\tuniforms.fogNear.value = fog.near;\r\n\t\t\tuniforms.fogFar.value = fog.far;\r\n\r\n\t\t} else if ( fog instanceof THREE.FogExp2 ) {\r\n\r\n\t\t\tuniforms.fogDensity.value = fog.density;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction refreshUniformsLambert ( uniforms, material ) {\r\n\r\n\t\tif ( material.lightMap ) {\r\n\r\n\t\t\tuniforms.lightMap.value = material.lightMap;\r\n\t\t\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.emissiveMap ) {\r\n\r\n\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction refreshUniformsPhong ( uniforms, material ) {\r\n\r\n\t\tuniforms.specular.value = material.specular;\r\n\t\tuniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )\r\n\r\n\t\tif ( material.lightMap ) {\r\n\r\n\t\t\tuniforms.lightMap.value = material.lightMap;\r\n\t\t\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.emissiveMap ) {\r\n\r\n\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.bumpMap ) {\r\n\r\n\t\t\tuniforms.bumpMap.value = material.bumpMap;\r\n\t\t\tuniforms.bumpScale.value = material.bumpScale;\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.normalMap ) {\r\n\r\n\t\t\tuniforms.normalMap.value = material.normalMap;\r\n\t\t\tuniforms.normalScale.value.copy( material.normalScale );\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.displacementMap ) {\r\n\r\n\t\t\tuniforms.displacementMap.value = material.displacementMap;\r\n\t\t\tuniforms.displacementScale.value = material.displacementScale;\r\n\t\t\tuniforms.displacementBias.value = material.displacementBias;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction refreshUniformsStandard ( uniforms, material ) {\r\n\r\n\t\tuniforms.roughness.value = material.roughness;\r\n\t\tuniforms.metalness.value = material.metalness;\r\n\r\n\t\tif ( material.roughnessMap ) {\r\n\r\n\t\t\tuniforms.roughnessMap.value = material.roughnessMap;\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.metalnessMap ) {\r\n\r\n\t\t\tuniforms.metalnessMap.value = material.metalnessMap;\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.lightMap ) {\r\n\r\n\t\t\tuniforms.lightMap.value = material.lightMap;\r\n\t\t\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.emissiveMap ) {\r\n\r\n\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.bumpMap ) {\r\n\r\n\t\t\tuniforms.bumpMap.value = material.bumpMap;\r\n\t\t\tuniforms.bumpScale.value = material.bumpScale;\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.normalMap ) {\r\n\r\n\t\t\tuniforms.normalMap.value = material.normalMap;\r\n\t\t\tuniforms.normalScale.value.copy( material.normalScale );\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.displacementMap ) {\r\n\r\n\t\t\tuniforms.displacementMap.value = material.displacementMap;\r\n\t\t\tuniforms.displacementScale.value = material.displacementScale;\r\n\t\t\tuniforms.displacementBias.value = material.displacementBias;\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.envMap ) {\r\n\r\n\t\t\t//uniforms.envMap.value = material.envMap; // part of uniforms common\r\n\t\t\tuniforms.envMapIntensity.value = material.envMapIntensity;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction refreshUniformsPhysical ( uniforms, material ) {\r\n\r\n\t\trefreshUniformsStandard( uniforms, material );\r\n\r\n\t}\r\n\r\n\t// If uniforms are marked as clean, they don't need to be loaded to the GPU.\r\n\r\n\tfunction markUniformsLightsNeedsUpdate ( uniforms, value ) {\r\n\r\n\t\tuniforms.ambientLightColor.needsUpdate = value;\r\n\r\n\t\tuniforms.directionalLights.needsUpdate = value;\r\n\t\tuniforms.pointLights.needsUpdate = value;\r\n\t\tuniforms.spotLights.needsUpdate = value;\r\n\t\tuniforms.hemisphereLights.needsUpdate = value;\r\n\r\n\t}\r\n\r\n\t// Lighting\r\n\r\n\tfunction setupShadows ( lights ) {\r\n\r\n\t\tvar lightShadowsLength = 0;\r\n\r\n\t\tfor ( var i = 0, l = lights.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar light = lights[ i ];\r\n\r\n\t\t\tif ( light.castShadow ) {\r\n\r\n\t\t\t\t_lights.shadows[ lightShadowsLength ++ ] = light;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t_lights.shadows.length = lightShadowsLength;\r\n\r\n\t}\r\n\r\n\tfunction setupLights ( lights, camera ) {\r\n\r\n\t\tvar l, ll, light,\r\n\t\tr = 0, g = 0, b = 0,\r\n\t\tcolor,\r\n\t\tintensity,\r\n\t\tdistance,\r\n\r\n\t\tviewMatrix = camera.matrixWorldInverse,\r\n\r\n\t\tdirectionalLength = 0,\r\n\t\tpointLength = 0,\r\n\t\tspotLength = 0,\r\n\t\themiLength = 0;\r\n\r\n\t\tfor ( l = 0, ll = lights.length; l < ll; l ++ ) {\r\n\r\n\t\t\tlight = lights[ l ];\r\n\r\n\t\t\tcolor = light.color;\r\n\t\t\tintensity = light.intensity;\r\n\t\t\tdistance = light.distance;\r\n\r\n\t\t\tif ( light instanceof THREE.AmbientLight ) {\r\n\r\n\t\t\t\tr += color.r * intensity;\r\n\t\t\t\tg += color.g * intensity;\r\n\t\t\t\tb += color.b * intensity;\r\n\r\n\t\t\t} else if ( light instanceof THREE.DirectionalLight ) {\r\n\r\n\t\t\t\tvar uniforms = lightCache.get( light );\r\n\r\n\t\t\t\tuniforms.color.copy( light.color ).multiplyScalar( light.intensity );\r\n\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\r\n\t\t\t\t_vector3.setFromMatrixPosition( light.target.matrixWorld );\r\n\t\t\t\tuniforms.direction.sub( _vector3 );\r\n\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\r\n\r\n\t\t\t\tuniforms.shadow = light.castShadow;\r\n\r\n\t\t\t\tif ( light.castShadow ) {\r\n\r\n\t\t\t\t\tuniforms.shadowBias = light.shadow.bias;\r\n\t\t\t\t\tuniforms.shadowRadius = light.shadow.radius;\r\n\t\t\t\t\tuniforms.shadowMapSize = light.shadow.mapSize;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_lights.directionalShadowMap[ directionalLength ] = light.shadow.map;\r\n\t\t\t\t_lights.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;\r\n\t\t\t\t_lights.directional[ directionalLength ++ ] = uniforms;\r\n\r\n\t\t\t} else if ( light instanceof THREE.SpotLight ) {\r\n\r\n\t\t\t\tvar uniforms = lightCache.get( light );\r\n\r\n\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\r\n\t\t\t\tuniforms.position.applyMatrix4( viewMatrix );\r\n\r\n\t\t\t\tuniforms.color.copy( color ).multiplyScalar( intensity );\r\n\t\t\t\tuniforms.distance = distance;\r\n\r\n\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\r\n\t\t\t\t_vector3.setFromMatrixPosition( light.target.matrixWorld );\r\n\t\t\t\tuniforms.direction.sub( _vector3 );\r\n\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\r\n\r\n\t\t\t\tuniforms.coneCos = Math.cos( light.angle );\r\n\t\t\t\tuniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );\r\n\t\t\t\tuniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;\r\n\r\n\t\t\t\tuniforms.shadow = light.castShadow;\r\n\r\n\t\t\t\tif ( light.castShadow ) {\r\n\r\n\t\t\t\t\tuniforms.shadowBias = light.shadow.bias;\r\n\t\t\t\t\tuniforms.shadowRadius = light.shadow.radius;\r\n\t\t\t\t\tuniforms.shadowMapSize = light.shadow.mapSize;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_lights.spotShadowMap[ spotLength ] = light.shadow.map;\r\n\t\t\t\t_lights.spotShadowMatrix[ spotLength ] = light.shadow.matrix;\r\n\t\t\t\t_lights.spot[ spotLength ++ ] = uniforms;\r\n\r\n\t\t\t} else if ( light instanceof THREE.PointLight ) {\r\n\r\n\t\t\t\tvar uniforms = lightCache.get( light );\r\n\r\n\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\r\n\t\t\t\tuniforms.position.applyMatrix4( viewMatrix );\r\n\r\n\t\t\t\tuniforms.color.copy( light.color ).multiplyScalar( light.intensity );\r\n\t\t\t\tuniforms.distance = light.distance;\r\n\t\t\t\tuniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;\r\n\r\n\t\t\t\tuniforms.shadow = light.castShadow;\r\n\r\n\t\t\t\tif ( light.castShadow ) {\r\n\r\n\t\t\t\t\tuniforms.shadowBias = light.shadow.bias;\r\n\t\t\t\t\tuniforms.shadowRadius = light.shadow.radius;\r\n\t\t\t\t\tuniforms.shadowMapSize = light.shadow.mapSize;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_lights.pointShadowMap[ pointLength ] = light.shadow.map;\r\n\r\n\t\t\t\tif ( _lights.pointShadowMatrix[ pointLength ] === undefined ) {\r\n\r\n\t\t\t\t\t_lights.pointShadowMatrix[ pointLength ] = new THREE.Matrix4();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// for point lights we set the shadow matrix to be a translation-only matrix\r\n\t\t\t\t// equal to inverse of the light's position\r\n\t\t\t\t_vector3.setFromMatrixPosition( light.matrixWorld ).negate();\r\n\t\t\t\t_lights.pointShadowMatrix[ pointLength ].identity().setPosition( _vector3 );\r\n\r\n\t\t\t\t_lights.point[ pointLength ++ ] = uniforms;\r\n\r\n\t\t\t} else if ( light instanceof THREE.HemisphereLight ) {\r\n\r\n\t\t\t\tvar uniforms = lightCache.get( light );\r\n\r\n\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\r\n\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\r\n\t\t\t\tuniforms.direction.normalize();\r\n\r\n\t\t\t\tuniforms.skyColor.copy( light.color ).multiplyScalar( intensity );\r\n\t\t\t\tuniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );\r\n\r\n\t\t\t\t_lights.hemi[ hemiLength ++ ] = uniforms;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t_lights.ambient[ 0 ] = r;\r\n\t\t_lights.ambient[ 1 ] = g;\r\n\t\t_lights.ambient[ 2 ] = b;\r\n\r\n\t\t_lights.directional.length = directionalLength;\r\n\t\t_lights.spot.length = spotLength;\r\n\t\t_lights.point.length = pointLength;\r\n\t\t_lights.hemi.length = hemiLength;\r\n\r\n\t\t_lights.hash = directionalLength + ',' + pointLength + ',' + spotLength + ',' + hemiLength + ',' + _lights.shadows.length;\r\n\r\n\t}\r\n\r\n\t// Clipping\r\n\r\n\tfunction setupGlobalClippingPlanes( planes, camera ) {\r\n\r\n\t\t_clippingEnabled =\r\n\t\t\t\t_this.clippingPlanes.length !== 0 ||\r\n\t\t\t\t_this.localClippingEnabled ||\r\n\t\t\t\t// enable state of previous frame - the clipping code has to\r\n\t\t\t\t// run another frame in order to reset the state:\r\n\t\t\t\t_numGlobalClippingPlanes !== 0 ||\r\n\t\t\t\t_localClippingEnabled;\r\n\r\n\t\t_localClippingEnabled = _this.localClippingEnabled;\r\n\r\n\t\t_globalClippingState = setupClippingPlanes( planes, camera, 0 );\r\n\t\t_numGlobalClippingPlanes = planes !== null ? planes.length : 0;\r\n\r\n\t}\r\n\r\n\tfunction setupClippingPlanes( planes, camera, dstOffset, skipTransform ) {\r\n\r\n\t\tvar nPlanes = planes !== null ? planes.length : 0,\r\n\t\t\tdstArray = null;\r\n\r\n\t\tif ( nPlanes !== 0 ) {\r\n\r\n\t\t\tdstArray = _clippingPlanesUniform.value;\r\n\r\n\t\t\tif ( skipTransform !== true || dstArray === null ) {\r\n\r\n\t\t\t\tvar flatSize = dstOffset + nPlanes * 4,\r\n\t\t\t\t\tviewMatrix = camera.matrixWorldInverse,\r\n\t\t\t\t\tviewNormalMatrix = _matrix3.getNormalMatrix( viewMatrix );\r\n\r\n\t\t\t\tif ( dstArray === null || dstArray.length < flatSize ) {\r\n\r\n\t\t\t\t\tdstArray = new Float32Array( flatSize );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor ( var i = 0, i4 = dstOffset; i !== nPlanes; ++ i, i4 += 4 ) {\r\n\r\n\t\t\t\t\tvar plane = _plane.copy( planes[ i ] ).\r\n\t\t\t\t\t\t\tapplyMatrix4( viewMatrix, viewNormalMatrix );\r\n\r\n\t\t\t\t\tplane.normal.toArray( dstArray, i4 );\r\n\t\t\t\t\tdstArray[ i4 + 3 ] = plane.constant;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_clippingPlanesUniform.value = dstArray;\r\n\t\t\t_clippingPlanesUniform.needsUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t\t_numClippingPlanes = nPlanes;\r\n\t\treturn dstArray;\r\n\r\n\t}\r\n\r\n\tfunction resetGlobalClippingState() {\r\n\r\n\t\tif ( _clippingPlanesUniform.value !== _globalClippingState ) {\r\n\r\n\t\t\t_clippingPlanesUniform.value = _globalClippingState;\r\n\t\t\t_clippingPlanesUniform.needsUpdate = _numGlobalClippingPlanes > 0;\r\n\r\n\t\t}\r\n\r\n\t\t_numClippingPlanes = _numGlobalClippingPlanes;\r\n\r\n\t}\r\n\r\n\tfunction setClippingState( planes, clipShadows, camera, cache, fromCache ) {\r\n\r\n\t\tif ( ! _localClippingEnabled ||\r\n\t\t\t\tplanes === null || planes.length === 0 ||\r\n\t\t\t\t_clipRenderingShadows && ! clipShadows ) {\r\n\t\t\t// there's no local clipping\r\n\r\n\t\t\tif ( _clipRenderingShadows ) {\r\n\t\t\t\t// there's no global clipping\r\n\r\n\t\t\t\tsetupClippingPlanes( null );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tresetGlobalClippingState();\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tvar nGlobal = _clipRenderingShadows ? 0 : _numGlobalClippingPlanes,\r\n\t\t\t\tlGlobal = nGlobal * 4,\r\n\r\n\t\t\t\tdstArray = cache.clippingState || null;\r\n\r\n\t\t\t_clippingPlanesUniform.value = dstArray; // ensure unique state\r\n\r\n\t\t\tdstArray = setupClippingPlanes(\r\n\t\t\t\t\tplanes, camera, lGlobal, fromCache );\r\n\r\n\t\t\tfor ( var i = 0; i !== lGlobal; ++ i ) {\r\n\r\n\t\t\t\tdstArray[ i ] = _globalClippingState[ i ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tcache.clippingState = dstArray;\r\n\t\t\t_numClippingPlanes += nGlobal;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\r\n\t// GL state setting\r\n\r\n\tthis.setFaceCulling = function ( cullFace, frontFaceDirection ) {\r\n\r\n\t\tif ( cullFace === THREE.CullFaceNone ) {\r\n\r\n\t\t\tstate.disable( _gl.CULL_FACE );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tif ( frontFaceDirection === THREE.FrontFaceDirectionCW ) {\r\n\r\n\t\t\t\t_gl.frontFace( _gl.CW );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t_gl.frontFace( _gl.CCW );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( cullFace === THREE.CullFaceBack ) {\r\n\r\n\t\t\t\t_gl.cullFace( _gl.BACK );\r\n\r\n\t\t\t} else if ( cullFace === THREE.CullFaceFront ) {\r\n\r\n\t\t\t\t_gl.cullFace( _gl.FRONT );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t_gl.cullFace( _gl.FRONT_AND_BACK );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tstate.enable( _gl.CULL_FACE );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t// Textures\r\n\r\n\tfunction allocTextureUnit() {\r\n\r\n\t\tvar textureUnit = _usedTextureUnits;\r\n\r\n\t\tif ( textureUnit >= capabilities.maxTextures ) {\r\n\r\n\t\t\tconsole.warn( 'WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );\r\n\r\n\t\t}\r\n\r\n\t\t_usedTextureUnits += 1;\r\n\r\n\t\treturn textureUnit;\r\n\r\n\t}\r\n\r\n\tfunction setTextureParameters ( textureType, texture, isPowerOfTwoImage ) {\r\n\r\n\t\tvar extension;\r\n\r\n\t\tif ( isPowerOfTwoImage ) {\r\n\r\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );\r\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );\r\n\r\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );\r\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );\r\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );\r\n\r\n\t\t\tif ( texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping ) {\r\n\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.', texture );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );\r\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );\r\n\r\n\t\t\tif ( texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter ) {\r\n\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.', texture );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\textension = extensions.get( 'EXT_texture_filter_anisotropic' );\r\n\r\n\t\tif ( extension ) {\r\n\r\n\t\t\tif ( texture.type === THREE.FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) return;\r\n\t\t\tif ( texture.type === THREE.HalfFloatType && extensions.get( 'OES_texture_half_float_linear' ) === null ) return;\r\n\r\n\t\t\tif ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {\r\n\r\n\t\t\t\t_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, _this.getMaxAnisotropy() ) );\r\n\t\t\t\tproperties.get( texture ).__currentAnisotropy = texture.anisotropy;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction uploadTexture( textureProperties, texture, slot ) {\r\n\r\n\t\tif ( textureProperties.__webglInit === undefined ) {\r\n\r\n\t\t\ttextureProperties.__webglInit = true;\r\n\r\n\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\r\n\r\n\t\t\ttextureProperties.__webglTexture = _gl.createTexture();\r\n\r\n\t\t\t_infoMemory.textures ++;\r\n\r\n\t\t}\r\n\r\n\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\r\n\t\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\r\n\r\n\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\r\n\t\t_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );\r\n\t\t_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );\r\n\r\n\t\tvar image = clampToMaxSize( texture.image, capabilities.maxTextureSize );\r\n\r\n\t\tif ( textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( image ) === false ) {\r\n\r\n\t\t\timage = makePowerOfTwo( image );\r\n\r\n\t\t}\r\n\r\n\t\tvar isPowerOfTwoImage = isPowerOfTwo( image ),\r\n\t\tglFormat = paramThreeToGL( texture.format ),\r\n\t\tglType = paramThreeToGL( texture.type );\r\n\r\n\t\tsetTextureParameters( _gl.TEXTURE_2D, texture, isPowerOfTwoImage );\r\n\r\n\t\tvar mipmap, mipmaps = texture.mipmaps;\r\n\r\n\t\tif ( texture instanceof THREE.DepthTexture ) {\r\n\r\n\t\t\t// populate depth texture with dummy data\r\n\r\n\t\t\tvar internalFormat = _gl.DEPTH_COMPONENT;\r\n\r\n\t\t\tif ( texture.type === THREE.FloatType ) {\r\n\r\n\t\t\t\tif ( !_isWebGL2 ) throw new Error('Float Depth Texture only supported in WebGL2.0');\r\n\t\t\t\tinternalFormat = _gl.DEPTH_COMPONENT32F;\r\n\r\n\t\t\t} else if ( _isWebGL2 ) {\r\n\r\n\t\t\t\t// WebGL 2.0 requires signed internalformat for glTexImage2D\r\n\t\t\t\tinternalFormat = _gl.DEPTH_COMPONENT16;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tstate.texImage2D( _gl.TEXTURE_2D, 0, internalFormat, image.width, image.height, 0, glFormat, glType, null );\r\n\r\n\t\t} else if ( texture instanceof THREE.DataTexture ) {\r\n\r\n\t\t\t// use manually created mipmaps if available\r\n\t\t\t// if there are no manual mipmaps\r\n\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\r\n\r\n\t\t\tif ( mipmaps.length > 0 && isPowerOfTwoImage ) {\r\n\r\n\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tmipmap = mipmaps[ i ];\r\n\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttexture.generateMipmaps = false;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( texture instanceof THREE.CompressedTexture ) {\r\n\r\n\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tmipmap = mipmaps[ i ];\r\n\r\n\t\t\t\tif ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {\r\n\r\n\t\t\t\t\tif ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {\r\n\r\n\t\t\t\t\t\tstate.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()\" );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// regular Texture (image, video, canvas)\r\n\r\n\t\t\t// use manually created mipmaps if available\r\n\t\t\t// if there are no manual mipmaps\r\n\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\r\n\r\n\t\t\tif ( mipmaps.length > 0 && isPowerOfTwoImage ) {\r\n\r\n\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tmipmap = mipmaps[ i ];\r\n\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttexture.generateMipmaps = false;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, image );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( texture.generateMipmaps && isPowerOfTwoImage ) _gl.generateMipmap( _gl.TEXTURE_2D );\r\n\r\n\t\ttextureProperties.__version = texture.version;\r\n\r\n\t\tif ( texture.onUpdate ) texture.onUpdate( texture );\r\n\r\n\t}\r\n\r\n\tfunction setTexture2D( texture, slot ) {\r\n\r\n\t\tif ( texture instanceof THREE.WebGLRenderTarget ) texture = texture.texture;\r\n\r\n\t\tvar textureProperties = properties.get( texture );\r\n\r\n\t\tif ( texture.version > 0 && textureProperties.__version !== texture.version ) {\r\n\r\n\t\t\tvar image = texture.image;\r\n\r\n\t\t\tif ( image === undefined ) {\r\n\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined', texture );\r\n\t\t\t\treturn;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( image.complete === false ) {\r\n\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete', texture );\r\n\t\t\t\treturn;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tuploadTexture( textureProperties, texture, slot );\r\n\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\r\n\t\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\r\n\r\n\t}\r\n\r\n\tfunction clampToMaxSize ( image, maxSize ) {\r\n\r\n\t\tif ( image.width > maxSize || image.height > maxSize ) {\r\n\r\n\t\t\t// Warning: Scaling through the canvas will only work with images that use\r\n\t\t\t// premultiplied alpha.\r\n\r\n\t\t\tvar scale = maxSize / Math.max( image.width, image.height );\r\n\r\n\t\t\tvar canvas = document.createElement( 'canvas' );\r\n\t\t\tcanvas.width = Math.floor( image.width * scale );\r\n\t\t\tcanvas.height = Math.floor( image.height * scale );\r\n\r\n\t\t\tvar context = canvas.getContext( '2d' );\r\n\t\t\tcontext.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );\r\n\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );\r\n\r\n\t\t\treturn canvas;\r\n\r\n\t\t}\r\n\r\n\t\treturn image;\r\n\r\n\t}\r\n\r\n\tfunction isPowerOfTwo( image ) {\r\n\r\n\t\treturn THREE.Math.isPowerOfTwo( image.width ) && THREE.Math.isPowerOfTwo( image.height );\r\n\r\n\t}\r\n\r\n\tfunction textureNeedsPowerOfTwo( texture ) {\r\n\r\n\t\tif ( texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping ) return true;\r\n\t\tif ( texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter ) return true;\r\n\r\n\t\treturn false;\r\n\r\n\t}\r\n\r\n\tfunction makePowerOfTwo( image ) {\r\n\r\n\t\tif ( image instanceof HTMLImageElement || image instanceof HTMLCanvasElement ) {\r\n\r\n\t\t\tvar canvas = document.createElement( 'canvas' );\r\n\t\t\tcanvas.width = THREE.Math.nearestPowerOfTwo( image.width );\r\n\t\t\tcanvas.height = THREE.Math.nearestPowerOfTwo( image.height );\r\n\r\n\t\t\tvar context = canvas.getContext( '2d' );\r\n\t\t\tcontext.drawImage( image, 0, 0, canvas.width, canvas.height );\r\n\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: image is not power of two (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );\r\n\r\n\t\t\treturn canvas;\r\n\r\n\t\t}\r\n\r\n\t\treturn image;\r\n\r\n\t}\r\n\r\n\tfunction setCubeTexture ( texture, slot ) {\r\n\r\n\t\tvar textureProperties = properties.get( texture );\r\n\r\n\t\tif ( texture.image.length === 6 ) {\r\n\r\n\t\t\tif ( texture.version > 0 && textureProperties.__version !== texture.version ) {\r\n\r\n\t\t\t\tif ( ! textureProperties.__image__webglTextureCube ) {\r\n\r\n\t\t\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\r\n\r\n\t\t\t\t\ttextureProperties.__image__webglTextureCube = _gl.createTexture();\r\n\r\n\t\t\t\t\t_infoMemory.textures ++;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\r\n\t\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );\r\n\r\n\t\t\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\r\n\r\n\t\t\t\tvar isCompressed = texture instanceof THREE.CompressedTexture;\r\n\t\t\t\tvar isDataTexture = texture.image[ 0 ] instanceof THREE.DataTexture;\r\n\r\n\t\t\t\tvar cubeImage = [];\r\n\r\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\t\t\tif ( _this.autoScaleCubemaps && ! isCompressed && ! isDataTexture ) {\r\n\r\n\t\t\t\t\t\tcubeImage[ i ] = clampToMaxSize( texture.image[ i ], capabilities.maxCubemapSize );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tcubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar image = cubeImage[ 0 ],\r\n\t\t\t\tisPowerOfTwoImage = isPowerOfTwo( image ),\r\n\t\t\t\tglFormat = paramThreeToGL( texture.format ),\r\n\t\t\t\tglType = paramThreeToGL( texture.type );\r\n\r\n\t\t\t\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isPowerOfTwoImage );\r\n\r\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\t\t\tif ( ! isCompressed ) {\r\n\r\n\t\t\t\t\t\tif ( isDataTexture ) {\r\n\r\n\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tvar mipmap, mipmaps = cubeImage[ i ].mipmaps;\r\n\r\n\t\t\t\t\t\tfor ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\t\t\tmipmap = mipmaps[ j ];\r\n\r\n\t\t\t\t\t\t\tif ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {\r\n\r\n\t\t\t\t\t\t\t\tif ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {\r\n\r\n\t\t\t\t\t\t\t\t\tstate.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );\r\n\r\n\t\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setCubeTexture()\" );\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( texture.generateMipmaps && isPowerOfTwoImage ) {\r\n\r\n\t\t\t\t\t_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttextureProperties.__version = texture.version;\r\n\r\n\t\t\t\tif ( texture.onUpdate ) texture.onUpdate( texture );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\r\n\t\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction setCubeTextureDynamic ( texture, slot ) {\r\n\r\n\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\r\n\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, properties.get( texture ).__webglTexture );\r\n\r\n\t}\r\n\r\n\tvar setTextureWarned = false;\r\n\tthis.setTexture = function( texture, slot ) {\r\n\r\n\t\tif ( ! setTextureWarned ) {\r\n\r\n\t\t\tconsole.warn( \"THREE.WebGLRenderer: .setTexture is deprecated, \" +\r\n\t\t\t\t\"use setTexture2D instead.\" );\r\n\t\t\tsetTextureWarned = true;\r\n\r\n\t\t}\r\n\r\n\t\tsetTexture2D( texture, slot );\r\n\r\n\t};\r\n\r\n\tthis.allocTextureUnit = allocTextureUnit;\r\n\tthis.setTexture2D = setTexture2D;\r\n\tthis.setTextureCube = function( texture, slot ) {\r\n\r\n\t\tif ( texture instanceof THREE.CubeTexture ||\r\n\t\t\t ( Array.isArray( texture.image ) && texture.image.length === 6 ) ) {\r\n\r\n\t\t\t// CompressedTexture can have Array in image :/\r\n\r\n\t\t\tsetCubeTexture( texture, slot );\r\n\r\n\t\t} else {\r\n\t\t\t// assumed: texture instanceof THREE.WebGLRenderTargetCube\r\n\r\n\t\t\tsetCubeTextureDynamic( texture.texture, slot );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t// Render targets\r\n\r\n\t// Setup storage for target texture and bind it to correct framebuffer\r\n\tfunction setupFrameBufferTexture ( framebuffer, renderTarget, attachment, textureTarget ) {\r\n\r\n\t\tvar glFormat = paramThreeToGL( renderTarget.texture.format );\r\n\t\tvar glType = paramThreeToGL( renderTarget.texture.type );\r\n\t\tstate.texImage2D( textureTarget, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );\r\n\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\r\n\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, attachment, textureTarget, properties.get( renderTarget.texture ).__webglTexture, 0 );\r\n\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );\r\n\r\n\t}\r\n\r\n\t// Setup storage for internal depth/stencil buffers and bind to correct framebuffer\r\n\tfunction setupRenderBufferStorage ( renderbuffer, renderTarget ) {\r\n\r\n\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );\r\n\r\n\t\tif ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {\r\n\r\n\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );\r\n\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\r\n\r\n\t\t} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {\r\n\r\n\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );\r\n\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// FIXME: We don't support !depth !stencil\r\n\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );\r\n\r\n\t\t}\r\n\r\n\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );\r\n\r\n\t}\r\n\r\n\t// Setup resources for a Depth Texture for a FBO (needs an extension)\r\n\tfunction setupDepthTexture ( framebuffer, renderTarget ) {\r\n\r\n\t\tvar isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );\r\n\t\tif ( isCube ) throw new Error('Depth Texture with cube render targets is not supported!');\r\n\r\n\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\r\n\r\n\t\tif ( !( renderTarget.depthTexture instanceof THREE.DepthTexture ) ) {\r\n\r\n\t\t\tthrow new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');\r\n\r\n\t\t}\r\n\r\n\t\t// upload an empty depth texture with framebuffer size\r\n\t\tif ( !properties.get( renderTarget.depthTexture ).__webglTexture ||\r\n\t\t\t\trenderTarget.depthTexture.image.width !== renderTarget.width ||\r\n\t\t\t\trenderTarget.depthTexture.image.height !== renderTarget.height ) {\r\n\t\t\trenderTarget.depthTexture.image.width = renderTarget.width;\r\n\t\t\trenderTarget.depthTexture.image.height = renderTarget.height;\r\n\t\t\trenderTarget.depthTexture.needsUpdate = true;\r\n\t\t}\r\n\r\n\t\t_this.setTexture( renderTarget.depthTexture, 0 );\r\n\r\n\t\tvar webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;\r\n\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );\r\n\r\n\t}\r\n\r\n\t// Setup GL resources for a non-texture depth buffer\r\n\tfunction setupDepthRenderbuffer( renderTarget ) {\r\n\r\n\t\tvar renderTargetProperties = properties.get( renderTarget );\r\n\r\n\t\tvar isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );\r\n\r\n\t\tif ( renderTarget.depthTexture ) {\r\n\r\n\t\t\tif ( isCube ) throw new Error('target.depthTexture not supported in Cube render targets');\r\n\r\n\t\t\tsetupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tif ( isCube ) {\r\n\r\n\t\t\t\trenderTargetProperties.__webglDepthbuffer = [];\r\n\r\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[ i ] );\r\n\t\t\t\t\trenderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();\r\n\t\t\t\t\tsetupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );\r\n\t\t\t\trenderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();\r\n\t\t\t\tsetupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );\r\n\r\n\t}\r\n\r\n\t// Set up GL resources for the render target\r\n\tfunction setupRenderTarget( renderTarget ) {\r\n\r\n\t\tvar renderTargetProperties = properties.get( renderTarget );\r\n\t\tvar textureProperties = properties.get( renderTarget.texture );\r\n\r\n\t\trenderTarget.addEventListener( 'dispose', onRenderTargetDispose );\r\n\r\n\t\ttextureProperties.__webglTexture = _gl.createTexture();\r\n\r\n\t\t_infoMemory.textures ++;\r\n\r\n\t\tvar isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );\r\n\t\tvar isTargetPowerOfTwo = THREE.Math.isPowerOfTwo( renderTarget.width ) && THREE.Math.isPowerOfTwo( renderTarget.height );\r\n\r\n\t\t// Setup framebuffer\r\n\r\n\t\tif ( isCube ) {\r\n\r\n\t\t\trenderTargetProperties.__webglFramebuffer = [];\r\n\r\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\t\trenderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\trenderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();\r\n\r\n\t\t}\r\n\r\n\t\t// Setup color buffer\r\n\r\n\t\tif ( isCube ) {\r\n\r\n\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );\r\n\t\t\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo );\r\n\r\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\t\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\r\n\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, null );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\r\n\t\t\tsetTextureParameters( _gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo );\r\n\t\t\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D );\r\n\r\n\t\t\tif ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );\r\n\t\t\tstate.bindTexture( _gl.TEXTURE_2D, null );\r\n\r\n\t\t}\r\n\r\n\t\t// Setup depth and stencil buffers\r\n\r\n\t\tif ( renderTarget.depthBuffer ) {\r\n\r\n\t\t\tsetupDepthRenderbuffer( renderTarget );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tthis.getCurrentRenderTarget = function() {\r\n\r\n\t\treturn _currentRenderTarget;\r\n\r\n\t};\r\n\r\n\tthis.setRenderTarget = function ( renderTarget ) {\r\n\r\n\t\t_currentRenderTarget = renderTarget;\r\n\r\n\t\tif ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {\r\n\r\n\t\t\tsetupRenderTarget( renderTarget );\r\n\r\n\t\t}\r\n\r\n\t\tvar isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );\r\n\t\tvar framebuffer;\r\n\r\n\t\tif ( renderTarget ) {\r\n\r\n\t\t\tvar renderTargetProperties = properties.get( renderTarget );\r\n\r\n\t\t\tif ( isCube ) {\r\n\r\n\t\t\t\tframebuffer = renderTargetProperties.__webglFramebuffer[ renderTarget.activeCubeFace ];\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tframebuffer = renderTargetProperties.__webglFramebuffer;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_currentScissor.copy( renderTarget.scissor );\r\n\t\t\t_currentScissorTest = renderTarget.scissorTest;\r\n\r\n\t\t\t_currentViewport.copy( renderTarget.viewport );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tframebuffer = null;\r\n\r\n\t\t\t_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio );\r\n\t\t\t_currentScissorTest = _scissorTest;\r\n\r\n\t\t\t_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio );\r\n\r\n\t\t}\r\n\r\n\t\tif ( _currentFramebuffer !== framebuffer ) {\r\n\r\n\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\r\n\t\t\t_currentFramebuffer = framebuffer;\r\n\r\n\t\t}\r\n\r\n\t\tstate.scissor( _currentScissor );\r\n\t\tstate.setScissorTest( _currentScissorTest );\r\n\r\n\t\tstate.viewport( _currentViewport );\r\n\r\n\t\tif ( isCube ) {\r\n\r\n\t\t\tvar textureProperties = properties.get( renderTarget.texture );\r\n\t\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, renderTarget.activeMipMapLevel );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer ) {\r\n\r\n\t\tif ( renderTarget instanceof THREE.WebGLRenderTarget === false ) {\r\n\r\n\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tvar framebuffer = properties.get( renderTarget ).__webglFramebuffer;\r\n\r\n\t\tif ( framebuffer ) {\r\n\r\n\t\t\tvar restore = false;\r\n\r\n\t\t\tif ( framebuffer !== _currentFramebuffer ) {\r\n\r\n\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\r\n\r\n\t\t\t\trestore = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttry {\r\n\r\n\t\t\t\tvar texture = renderTarget.texture;\r\n\r\n\t\t\t\tif ( texture.format !== THREE.RGBAFormat && paramThreeToGL( texture.format ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_FORMAT ) ) {\r\n\r\n\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );\r\n\t\t\t\t\treturn;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( texture.type !== THREE.UnsignedByteType &&\r\n\t\t\t\t     paramThreeToGL( texture.type ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_TYPE ) &&\r\n\t\t\t\t     ! ( texture.type === THREE.FloatType && extensions.get( 'WEBGL_color_buffer_float' ) ) &&\r\n\t\t\t\t     ! ( texture.type === THREE.HalfFloatType && extensions.get( 'EXT_color_buffer_half_float' ) ) ) {\r\n\r\n\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );\r\n\t\t\t\t\treturn;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {\r\n\r\n\t\t\t\t\t// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)\r\n\r\n\t\t\t\t\tif ( ( x > 0 && x <= ( renderTarget.width - width ) ) && ( y > 0 && y <= ( renderTarget.height - height ) ) ) {\r\n\r\n\t\t\t\t\t\t_gl.readPixels( x, y, width, height, paramThreeToGL( texture.format ), paramThreeToGL( texture.type ), buffer );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} finally {\r\n\r\n\t\t\t\tif ( restore ) {\r\n\r\n\t\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, _currentFramebuffer );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction updateRenderTargetMipmap( renderTarget ) {\r\n\r\n\t\tvar target = renderTarget instanceof THREE.WebGLRenderTargetCube ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;\r\n\t\tvar texture = properties.get( renderTarget.texture ).__webglTexture;\r\n\r\n\t\tstate.bindTexture( target, texture );\r\n\t\t_gl.generateMipmap( target );\r\n\t\tstate.bindTexture( target, null );\r\n\r\n\t}\r\n\r\n\t// Fallback filters for non-power-of-2 textures\r\n\r\n\tfunction filterFallback ( f ) {\r\n\r\n\t\tif ( f === THREE.NearestFilter || f === THREE.NearestMipMapNearestFilter || f === THREE.NearestMipMapLinearFilter ) {\r\n\r\n\t\t\treturn _gl.NEAREST;\r\n\r\n\t\t}\r\n\r\n\t\treturn _gl.LINEAR;\r\n\r\n\t}\r\n\r\n\t// Map three.js constants to WebGL constants\r\n\r\n\tfunction paramThreeToGL ( p ) {\r\n\r\n\t\tvar extension;\r\n\r\n\t\tif ( p === THREE.RepeatWrapping ) return _gl.REPEAT;\r\n\t\tif ( p === THREE.ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;\r\n\t\tif ( p === THREE.MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;\r\n\r\n\t\tif ( p === THREE.NearestFilter ) return _gl.NEAREST;\r\n\t\tif ( p === THREE.NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;\r\n\t\tif ( p === THREE.NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;\r\n\r\n\t\tif ( p === THREE.LinearFilter ) return _gl.LINEAR;\r\n\t\tif ( p === THREE.LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;\r\n\t\tif ( p === THREE.LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;\r\n\r\n\t\tif ( p === THREE.UnsignedByteType ) return _gl.UNSIGNED_BYTE;\r\n\t\tif ( p === THREE.UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;\r\n\t\tif ( p === THREE.UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;\r\n\t\tif ( p === THREE.UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;\r\n\r\n\t\tif ( p === THREE.ByteType ) return _gl.BYTE;\r\n\t\tif ( p === THREE.ShortType ) return _gl.SHORT;\r\n\t\tif ( p === THREE.UnsignedShortType ) return _gl.UNSIGNED_SHORT;\r\n\t\tif ( p === THREE.IntType ) return _gl.INT;\r\n\t\tif ( p === THREE.UnsignedIntType ) return _gl.UNSIGNED_INT;\r\n\t\tif ( p === THREE.FloatType ) return _gl.FLOAT;\r\n\r\n\t\textension = extensions.get( 'OES_texture_half_float' );\r\n\r\n\t\tif ( extension !== null ) {\r\n\r\n\t\t\tif ( p === THREE.HalfFloatType ) return extension.HALF_FLOAT_OES;\r\n\r\n\t\t}\r\n\r\n\t\tif ( p === THREE.AlphaFormat ) return _gl.ALPHA;\r\n\t\tif ( p === THREE.RGBFormat ) return _gl.RGB;\r\n\t\tif ( p === THREE.RGBAFormat ) return _gl.RGBA;\r\n\t\tif ( p === THREE.LuminanceFormat ) return _gl.LUMINANCE;\r\n\t\tif ( p === THREE.LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;\r\n\t\tif ( p === THREE.DepthFormat ) return _gl.DEPTH_COMPONENT;\r\n\r\n\t\tif ( p === THREE.AddEquation ) return _gl.FUNC_ADD;\r\n\t\tif ( p === THREE.SubtractEquation ) return _gl.FUNC_SUBTRACT;\r\n\t\tif ( p === THREE.ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;\r\n\r\n\t\tif ( p === THREE.ZeroFactor ) return _gl.ZERO;\r\n\t\tif ( p === THREE.OneFactor ) return _gl.ONE;\r\n\t\tif ( p === THREE.SrcColorFactor ) return _gl.SRC_COLOR;\r\n\t\tif ( p === THREE.OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;\r\n\t\tif ( p === THREE.SrcAlphaFactor ) return _gl.SRC_ALPHA;\r\n\t\tif ( p === THREE.OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;\r\n\t\tif ( p === THREE.DstAlphaFactor ) return _gl.DST_ALPHA;\r\n\t\tif ( p === THREE.OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;\r\n\r\n\t\tif ( p === THREE.DstColorFactor ) return _gl.DST_COLOR;\r\n\t\tif ( p === THREE.OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;\r\n\t\tif ( p === THREE.SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;\r\n\r\n\t\textension = extensions.get( 'WEBGL_compressed_texture_s3tc' );\r\n\r\n\t\tif ( extension !== null ) {\r\n\r\n\t\t\tif ( p === THREE.RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;\r\n\t\t\tif ( p === THREE.RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;\r\n\t\t\tif ( p === THREE.RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;\r\n\t\t\tif ( p === THREE.RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;\r\n\r\n\t\t}\r\n\r\n\t\textension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );\r\n\r\n\t\tif ( extension !== null ) {\r\n\r\n\t\t\tif ( p === THREE.RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;\r\n\t\t\tif ( p === THREE.RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;\r\n\t\t\tif ( p === THREE.RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;\r\n\t\t\tif ( p === THREE.RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;\r\n\r\n\t\t}\r\n\r\n\t\textension = extensions.get( 'WEBGL_compressed_texture_etc1' );\r\n\r\n\t\tif ( extension !== null ) {\r\n\r\n\t\t\tif ( p === THREE.RGB_ETC1_Format ) return extension.COMPRESSED_RGB_ETC1_WEBGL;\r\n\r\n\t\t}\r\n\r\n\t\textension = extensions.get( 'EXT_blend_minmax' );\r\n\r\n\t\tif ( extension !== null ) {\r\n\r\n\t\t\tif ( p === THREE.MinEquation ) return extension.MIN_EXT;\r\n\t\t\tif ( p === THREE.MaxEquation ) return extension.MAX_EXT;\r\n\r\n\t\t}\r\n\r\n\t\treturn 0;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/renderers/WebGLRenderTarget.js\r\n\r\n/**\r\n * @author szimek / https://github.com/szimek/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author Marius Kintel / https://github.com/kintel\r\n */\r\n\r\n/*\r\n In options, we can specify:\r\n * Texture parameters for an auto-generated target texture\r\n * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers\r\n*/\r\nTHREE.WebGLRenderTarget = function ( width, height, options ) {\r\n\r\n\tthis.uuid = THREE.Math.generateUUID();\r\n\r\n\tthis.width = width;\r\n\tthis.height = height;\r\n\r\n\tthis.scissor = new THREE.Vector4( 0, 0, width, height );\r\n\tthis.scissorTest = false;\r\n\r\n\tthis.viewport = new THREE.Vector4( 0, 0, width, height );\r\n\r\n\toptions = options || {};\r\n\r\n\tif ( options.minFilter === undefined ) options.minFilter = THREE.LinearFilter;\r\n\r\n\tthis.texture = new THREE.Texture( undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );\r\n\r\n\tthis.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;\r\n\tthis.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;\r\n\tthis.depthTexture = null;\r\n\r\n};\r\n\r\nTHREE.WebGLRenderTarget.prototype = {\r\n\r\n\tconstructor: THREE.WebGLRenderTarget,\r\n\r\n\tsetSize: function ( width, height ) {\r\n\r\n\t\tif ( this.width !== width || this.height !== height ) {\r\n\r\n\t\t\tthis.width = width;\r\n\t\t\tthis.height = height;\r\n\r\n\t\t\tthis.dispose();\r\n\r\n\t\t}\r\n\r\n\t\tthis.viewport.set( 0, 0, width, height );\r\n\t\tthis.scissor.set( 0, 0, width, height );\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\r\n\t},\r\n\r\n\tcopy: function ( source ) {\r\n\r\n\t\tthis.width = source.width;\r\n\t\tthis.height = source.height;\r\n\r\n\t\tthis.viewport.copy( source.viewport );\r\n\r\n\t\tthis.texture = source.texture.clone();\r\n\r\n\t\tthis.depthBuffer = source.depthBuffer;\r\n\t\tthis.stencilBuffer = source.stencilBuffer;\r\n\t\tthis.depthTexture = source.depthTexture;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdispose: function () {\r\n\r\n\t\tthis.dispatchEvent( { type: 'dispose' } );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.EventDispatcher.prototype.apply( THREE.WebGLRenderTarget.prototype );\r\n\r\n// File:src/renderers/WebGLRenderTargetCube.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com\r\n */\r\n\r\nTHREE.WebGLRenderTargetCube = function ( width, height, options ) {\r\n\r\n\tTHREE.WebGLRenderTarget.call( this, width, height, options );\r\n\r\n\tthis.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5\r\n\tthis.activeMipMapLevel = 0;\r\n\r\n};\r\n\r\nTHREE.WebGLRenderTargetCube.prototype = Object.create( THREE.WebGLRenderTarget.prototype );\r\nTHREE.WebGLRenderTargetCube.prototype.constructor = THREE.WebGLRenderTargetCube;\r\n\r\n// File:src/renderers/webgl/WebGLBufferRenderer.js\r\n\r\n/**\r\n* @author mrdoob / http://mrdoob.com/\r\n*/\r\n\r\nTHREE.WebGLBufferRenderer = function ( _gl, extensions, _infoRender ) {\r\n\r\n\tvar mode;\r\n\r\n\tfunction setMode( value ) {\r\n\r\n\t\tmode = value;\r\n\r\n\t}\r\n\r\n\tfunction render( start, count ) {\r\n\r\n\t\t_gl.drawArrays( mode, start, count );\r\n\r\n\t\t_infoRender.calls ++;\r\n\t\t_infoRender.vertices += count;\r\n\t\tif ( mode === _gl.TRIANGLES ) _infoRender.faces += count / 3;\r\n\r\n\t}\r\n\r\n\tfunction renderInstances( geometry ) {\r\n\r\n\t\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\r\n\r\n\t\tif ( extension === null ) {\r\n\r\n\t\t\tconsole.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tvar position = geometry.attributes.position;\r\n\r\n\t\tvar count = 0;\r\n\r\n\t\tif ( position instanceof THREE.InterleavedBufferAttribute ) {\r\n\r\n\t\t\tcount = position.data.count;\r\n\r\n\t\t\textension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tcount = position.count;\r\n\r\n\t\t\textension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );\r\n\r\n\t\t}\r\n\r\n\t\t_infoRender.calls ++;\r\n\t\t_infoRender.vertices += count * geometry.maxInstancedCount;\r\n\t\tif ( mode === _gl.TRIANGLES ) _infoRender.faces += geometry.maxInstancedCount * count / 3;\r\n\r\n\t}\r\n\r\n\tthis.setMode = setMode;\r\n\tthis.render = render;\r\n\tthis.renderInstances = renderInstances;\r\n\r\n};\r\n\r\n// File:src/renderers/webgl/WebGLIndexedBufferRenderer.js\r\n\r\n/**\r\n* @author mrdoob / http://mrdoob.com/\r\n*/\r\n\r\nTHREE.WebGLIndexedBufferRenderer = function ( _gl, extensions, _infoRender ) {\r\n\r\n\tvar mode;\r\n\r\n\tfunction setMode( value ) {\r\n\r\n\t\tmode = value;\r\n\r\n\t}\r\n\r\n\tvar type, size;\r\n\r\n\tfunction setIndex( index ) {\r\n\r\n\t\tif ( index.array instanceof Uint32Array && extensions.get( 'OES_element_index_uint' ) ) {\r\n\r\n\t\t\ttype = _gl.UNSIGNED_INT;\r\n\t\t\tsize = 4;\r\n\r\n\t\t} else {\r\n\r\n\t\t\ttype = _gl.UNSIGNED_SHORT;\r\n\t\t\tsize = 2;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction render( start, count ) {\r\n\r\n\t\t_gl.drawElements( mode, count, type, start * size );\r\n\r\n\t\t_infoRender.calls ++;\r\n\t\t_infoRender.vertices += count;\r\n\t\tif ( mode === _gl.TRIANGLES ) _infoRender.faces += count / 3;\r\n\r\n\t}\r\n\r\n\tfunction renderInstances( geometry, start, count ) {\r\n\r\n\t\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\r\n\r\n\t\tif ( extension === null ) {\r\n\r\n\t\t\tconsole.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\textension.drawElementsInstancedANGLE( mode, count, type, start * size, geometry.maxInstancedCount );\r\n\r\n\t\t_infoRender.calls ++;\r\n\t\t_infoRender.vertices += count * geometry.maxInstancedCount;\r\n\t\tif ( mode === _gl.TRIANGLES ) _infoRender.faces += geometry.maxInstancedCount * count / 3;\r\n\t}\r\n\r\n\tthis.setMode = setMode;\r\n\tthis.setIndex = setIndex;\r\n\tthis.render = render;\r\n\tthis.renderInstances = renderInstances;\r\n\r\n};\r\n\r\n// File:src/renderers/webgl/WebGLExtensions.js\r\n\r\n/**\r\n* @author mrdoob / http://mrdoob.com/\r\n*/\r\n\r\nTHREE.WebGLExtensions = function ( gl ) {\r\n\r\n\tvar extensions = {};\r\n\r\n\tthis.get = function ( name ) {\r\n\r\n\t\tif ( extensions[ name ] !== undefined ) {\r\n\r\n\t\t\treturn extensions[ name ];\r\n\r\n\t\t}\r\n\r\n\t\tvar extension;\r\n\r\n\t\tswitch ( name ) {\r\n\r\n\t\t\tcase 'WEBGL_depth_texture':\r\n\t\t\t\textension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );\r\n\r\n\t\t\tcase 'EXT_texture_filter_anisotropic':\r\n\t\t\t\textension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'WEBGL_compressed_texture_s3tc':\r\n\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'WEBGL_compressed_texture_pvrtc':\r\n\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'WEBGL_compressed_texture_etc1':\r\n\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_etc1' );\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tdefault:\r\n\t\t\t\textension = gl.getExtension( name );\r\n\r\n\t\t}\r\n\r\n\t\tif ( extension === null ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );\r\n\r\n\t\t}\r\n\r\n\t\textensions[ name ] = extension;\r\n\r\n\t\treturn extension;\r\n\r\n\t};\r\n\r\n};\r\n\r\n// File:src/renderers/webgl/WebGLCapabilities.js\r\n\r\nTHREE.WebGLCapabilities = function ( gl, extensions, parameters ) {\r\n\r\n\tfunction getMaxPrecision( precision ) {\r\n\r\n\t\tif ( precision === 'highp' ) {\r\n\r\n\t\t\tif ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&\r\n\t\t\t     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {\r\n\r\n\t\t\t\treturn 'highp';\r\n\r\n\t\t\t}\r\n\r\n\t\t\tprecision = 'mediump';\r\n\r\n\t\t}\r\n\r\n\t\tif ( precision === 'mediump' ) {\r\n\r\n\t\t\tif ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&\r\n\t\t\t     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {\r\n\r\n\t\t\t\treturn 'mediump';\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn 'lowp';\r\n\r\n\t}\r\n\r\n\tthis.getMaxPrecision = getMaxPrecision;\r\n\r\n\tthis.precision = parameters.precision !== undefined ? parameters.precision : 'highp',\r\n\tthis.logarithmicDepthBuffer = parameters.logarithmicDepthBuffer !== undefined ? parameters.logarithmicDepthBuffer : false;\r\n\r\n\tthis.maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );\r\n\tthis.maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );\r\n\tthis.maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );\r\n\tthis.maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );\r\n\r\n\tthis.maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );\r\n\tthis.maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );\r\n\tthis.maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );\r\n\tthis.maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );\r\n\r\n\tthis.vertexTextures = this.maxVertexTextures > 0;\r\n\tthis.floatFragmentTextures = !! extensions.get( 'OES_texture_float' );\r\n\tthis.floatVertexTextures = this.vertexTextures && this.floatFragmentTextures;\r\n\r\n\tvar _maxPrecision = getMaxPrecision( this.precision );\r\n\r\n\tif ( _maxPrecision !== this.precision ) {\r\n\r\n\t\tconsole.warn( 'THREE.WebGLRenderer:', this.precision, 'not supported, using', _maxPrecision, 'instead.' );\r\n\t\tthis.precision = _maxPrecision;\r\n\r\n\t}\r\n\r\n\tif ( this.logarithmicDepthBuffer ) {\r\n\r\n\t\tthis.logarithmicDepthBuffer = !! extensions.get( 'EXT_frag_depth' );\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/renderers/webgl/WebGLGeometries.js\r\n\r\n/**\r\n* @author mrdoob / http://mrdoob.com/\r\n*/\r\n\r\nTHREE.WebGLGeometries = function ( gl, properties, info ) {\r\n\r\n\tvar geometries = {};\r\n\r\n\tfunction get( object ) {\r\n\r\n\t\tvar geometry = object.geometry;\r\n\r\n\t\tif ( geometries[ geometry.id ] !== undefined ) {\r\n\r\n\t\t\treturn geometries[ geometry.id ];\r\n\r\n\t\t}\r\n\r\n\t\tgeometry.addEventListener( 'dispose', onGeometryDispose );\r\n\r\n\t\tvar buffergeometry;\r\n\r\n\t\tif ( geometry instanceof THREE.BufferGeometry ) {\r\n\r\n\t\t\tbuffergeometry = geometry;\r\n\r\n\t\t} else if ( geometry instanceof THREE.Geometry ) {\r\n\r\n\t\t\tif ( geometry._bufferGeometry === undefined ) {\r\n\r\n\t\t\t\tgeometry._bufferGeometry = new THREE.BufferGeometry().setFromObject( object );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tbuffergeometry = geometry._bufferGeometry;\r\n\r\n\t\t}\r\n\r\n\t\tgeometries[ geometry.id ] = buffergeometry;\r\n\r\n\t\tinfo.memory.geometries ++;\r\n\r\n\t\treturn buffergeometry;\r\n\r\n\t}\r\n\r\n\tfunction onGeometryDispose( event ) {\r\n\r\n\t\tvar geometry = event.target;\r\n\t\tvar buffergeometry = geometries[ geometry.id ];\r\n\r\n\t\tif ( buffergeometry.index !== null ) {\r\n\r\n\t\t\tdeleteAttribute( buffergeometry.index );\r\n\r\n\t\t}\r\n\r\n\t\tdeleteAttributes( buffergeometry.attributes );\r\n\r\n\t\tgeometry.removeEventListener( 'dispose', onGeometryDispose );\r\n\r\n\t\tdelete geometries[ geometry.id ];\r\n\r\n\t\t// TODO\r\n\r\n\t\tvar property = properties.get( geometry );\r\n\r\n\t\tif ( property.wireframe ) {\r\n\r\n\t\t\tdeleteAttribute( property.wireframe );\r\n\r\n\t\t}\r\n\r\n\t\tproperties.delete( geometry );\r\n\r\n\t\tvar bufferproperty = properties.get( buffergeometry );\r\n\r\n\t\tif ( bufferproperty.wireframe ) {\r\n\r\n\t\t\tdeleteAttribute( bufferproperty.wireframe );\r\n\r\n\t\t}\r\n\r\n\t\tproperties.delete( buffergeometry );\r\n\r\n\t\t//\r\n\r\n\t\tinfo.memory.geometries --;\r\n\r\n\t}\r\n\r\n\tfunction getAttributeBuffer( attribute ) {\r\n\r\n\t\tif ( attribute instanceof THREE.InterleavedBufferAttribute ) {\r\n\r\n\t\t\treturn properties.get( attribute.data ).__webglBuffer;\r\n\r\n\t\t}\r\n\r\n\t\treturn properties.get( attribute ).__webglBuffer;\r\n\r\n\t}\r\n\r\n\tfunction deleteAttribute( attribute ) {\r\n\r\n\t\tvar buffer = getAttributeBuffer( attribute );\r\n\r\n\t\tif ( buffer !== undefined ) {\r\n\r\n\t\t\tgl.deleteBuffer( buffer );\r\n\t\t\tremoveAttributeBuffer( attribute );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction deleteAttributes( attributes ) {\r\n\r\n\t\tfor ( var name in attributes ) {\r\n\r\n\t\t\tdeleteAttribute( attributes[ name ] );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction removeAttributeBuffer( attribute ) {\r\n\r\n\t\tif ( attribute instanceof THREE.InterleavedBufferAttribute ) {\r\n\r\n\t\t\tproperties.delete( attribute.data );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tproperties.delete( attribute );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tthis.get = get;\r\n\r\n};\r\n\r\n// File:src/renderers/webgl/WebGLLights.js\r\n\r\n/**\r\n* @author mrdoob / http://mrdoob.com/\r\n*/\r\n\r\nTHREE.WebGLLights = function () {\r\n\r\n\tvar lights = {};\r\n\r\n\tthis.get = function ( light ) {\r\n\r\n\t\tif ( lights[ light.id ] !== undefined ) {\r\n\r\n\t\t\treturn lights[ light.id ];\r\n\r\n\t\t}\r\n\r\n\t\tvar uniforms;\r\n\r\n\t\tswitch ( light.type ) {\r\n\r\n\t\t\tcase 'DirectionalLight':\r\n\t\t\t\tuniforms = {\r\n\t\t\t\t\tdirection: new THREE.Vector3(),\r\n\t\t\t\t\tcolor: new THREE.Color(),\r\n\r\n\t\t\t\t\tshadow: false,\r\n\t\t\t\t\tshadowBias: 0,\r\n\t\t\t\t\tshadowRadius: 1,\r\n\t\t\t\t\tshadowMapSize: new THREE.Vector2()\r\n\t\t\t\t};\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'SpotLight':\r\n\t\t\t\tuniforms = {\r\n\t\t\t\t\tposition: new THREE.Vector3(),\r\n\t\t\t\t\tdirection: new THREE.Vector3(),\r\n\t\t\t\t\tcolor: new THREE.Color(),\r\n\t\t\t\t\tdistance: 0,\r\n\t\t\t\t\tconeCos: 0,\r\n\t\t\t\t\tpenumbraCos: 0,\r\n\t\t\t\t\tdecay: 0,\r\n\r\n\t\t\t\t\tshadow: false,\r\n\t\t\t\t\tshadowBias: 0,\r\n\t\t\t\t\tshadowRadius: 1,\r\n\t\t\t\t\tshadowMapSize: new THREE.Vector2()\r\n\t\t\t\t};\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'PointLight':\r\n\t\t\t\tuniforms = {\r\n\t\t\t\t\tposition: new THREE.Vector3(),\r\n\t\t\t\t\tcolor: new THREE.Color(),\r\n\t\t\t\t\tdistance: 0,\r\n\t\t\t\t\tdecay: 0,\r\n\r\n\t\t\t\t\tshadow: false,\r\n\t\t\t\t\tshadowBias: 0,\r\n\t\t\t\t\tshadowRadius: 1,\r\n\t\t\t\t\tshadowMapSize: new THREE.Vector2()\r\n\t\t\t\t};\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'HemisphereLight':\r\n\t\t\t\tuniforms = {\r\n\t\t\t\t\tdirection: new THREE.Vector3(),\r\n\t\t\t\t\tskyColor: new THREE.Color(),\r\n\t\t\t\t\tgroundColor: new THREE.Color()\r\n\t\t\t\t};\r\n\t\t\t\tbreak;\r\n\r\n\t\t}\r\n\r\n\t\tlights[ light.id ] = uniforms;\r\n\r\n\t\treturn uniforms;\r\n\r\n\t};\r\n\r\n};\r\n\r\n// File:src/renderers/webgl/WebGLObjects.js\r\n\r\n/**\r\n* @author mrdoob / http://mrdoob.com/\r\n*/\r\n\r\nTHREE.WebGLObjects = function ( gl, properties, info ) {\r\n\r\n\tvar geometries = new THREE.WebGLGeometries( gl, properties, info );\r\n\r\n\t//\r\n\r\n\tfunction update( object ) {\r\n\r\n\t\t// TODO: Avoid updating twice (when using shadowMap). Maybe add frame counter.\r\n\r\n\t\tvar geometry = geometries.get( object );\r\n\r\n\t\tif ( object.geometry instanceof THREE.Geometry ) {\r\n\r\n\t\t\tgeometry.updateFromObject( object );\r\n\r\n\t\t}\r\n\r\n\t\tvar index = geometry.index;\r\n\t\tvar attributes = geometry.attributes;\r\n\r\n\t\tif ( index !== null ) {\r\n\r\n\t\t\tupdateAttribute( index, gl.ELEMENT_ARRAY_BUFFER );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var name in attributes ) {\r\n\r\n\t\t\tupdateAttribute( attributes[ name ], gl.ARRAY_BUFFER );\r\n\r\n\t\t}\r\n\r\n\t\t// morph targets\r\n\r\n\t\tvar morphAttributes = geometry.morphAttributes;\r\n\r\n\t\tfor ( var name in morphAttributes ) {\r\n\r\n\t\t\tvar array = morphAttributes[ name ];\r\n\r\n\t\t\tfor ( var i = 0, l = array.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tupdateAttribute( array[ i ], gl.ARRAY_BUFFER );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn geometry;\r\n\r\n\t}\r\n\r\n\tfunction updateAttribute( attribute, bufferType ) {\r\n\r\n\t\tvar data = ( attribute instanceof THREE.InterleavedBufferAttribute ) ? attribute.data : attribute;\r\n\r\n\t\tvar attributeProperties = properties.get( data );\r\n\r\n\t\tif ( attributeProperties.__webglBuffer === undefined ) {\r\n\r\n\t\t\tcreateBuffer( attributeProperties, data, bufferType );\r\n\r\n\t\t} else if ( attributeProperties.version !== data.version ) {\r\n\r\n\t\t\tupdateBuffer( attributeProperties, data, bufferType );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction createBuffer( attributeProperties, data, bufferType ) {\r\n\r\n\t\tattributeProperties.__webglBuffer = gl.createBuffer();\r\n\t\tgl.bindBuffer( bufferType, attributeProperties.__webglBuffer );\r\n\r\n\t\tvar usage = data.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;\r\n\r\n\t\tgl.bufferData( bufferType, data.array, usage );\r\n\r\n\t\tattributeProperties.version = data.version;\r\n\r\n\t}\r\n\r\n\tfunction updateBuffer( attributeProperties, data, bufferType ) {\r\n\r\n\t\tgl.bindBuffer( bufferType, attributeProperties.__webglBuffer );\r\n\r\n\t\tif ( data.dynamic === false || data.updateRange.count === - 1 ) {\r\n\r\n\t\t\t// Not using update ranges\r\n\r\n\t\t\tgl.bufferSubData( bufferType, 0, data.array );\r\n\r\n\t\t} else if ( data.updateRange.count === 0 ) {\r\n\r\n\t\t\tconsole.error( 'THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.' );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tgl.bufferSubData( bufferType, data.updateRange.offset * data.array.BYTES_PER_ELEMENT,\r\n\t\t\t\t\t\t\t  data.array.subarray( data.updateRange.offset, data.updateRange.offset + data.updateRange.count ) );\r\n\r\n\t\t\tdata.updateRange.count = 0; // reset range\r\n\r\n\t\t}\r\n\r\n\t\tattributeProperties.version = data.version;\r\n\r\n\t}\r\n\r\n\tfunction getAttributeBuffer( attribute ) {\r\n\r\n\t\tif ( attribute instanceof THREE.InterleavedBufferAttribute ) {\r\n\r\n\t\t\treturn properties.get( attribute.data ).__webglBuffer;\r\n\r\n\t\t}\r\n\r\n\t\treturn properties.get( attribute ).__webglBuffer;\r\n\r\n\t}\r\n\r\n\tfunction getWireframeAttribute( geometry ) {\r\n\r\n\t\tvar property = properties.get( geometry );\r\n\r\n\t\tif ( property.wireframe !== undefined ) {\r\n\r\n\t\t\treturn property.wireframe;\r\n\r\n\t\t}\r\n\r\n\t\tvar indices = [];\r\n\r\n\t\tvar index = geometry.index;\r\n\t\tvar attributes = geometry.attributes;\r\n\t\tvar position = attributes.position;\r\n\r\n\t\t// console.time( 'wireframe' );\r\n\r\n\t\tif ( index !== null ) {\r\n\r\n\t\t\tvar edges = {};\r\n\t\t\tvar array = index.array;\r\n\r\n\t\t\tfor ( var i = 0, l = array.length; i < l; i += 3 ) {\r\n\r\n\t\t\t\tvar a = array[ i + 0 ];\r\n\t\t\t\tvar b = array[ i + 1 ];\r\n\t\t\t\tvar c = array[ i + 2 ];\r\n\r\n\t\t\t\tif ( checkEdge( edges, a, b ) ) indices.push( a, b );\r\n\t\t\t\tif ( checkEdge( edges, b, c ) ) indices.push( b, c );\r\n\t\t\t\tif ( checkEdge( edges, c, a ) ) indices.push( c, a );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tvar array = attributes.position.array;\r\n\r\n\t\t\tfor ( var i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {\r\n\r\n\t\t\t\tvar a = i + 0;\r\n\t\t\t\tvar b = i + 1;\r\n\t\t\t\tvar c = i + 2;\r\n\r\n\t\t\t\tindices.push( a, b, b, c, c, a );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// console.timeEnd( 'wireframe' );\r\n\r\n\t\tvar TypeArray = position.count > 65535 ? Uint32Array : Uint16Array;\r\n\t\tvar attribute = new THREE.BufferAttribute( new TypeArray( indices ), 1 );\r\n\r\n\t\tupdateAttribute( attribute, gl.ELEMENT_ARRAY_BUFFER );\r\n\r\n\t\tproperty.wireframe = attribute;\r\n\r\n\t\treturn attribute;\r\n\r\n\t}\r\n\r\n\tfunction checkEdge( edges, a, b ) {\r\n\r\n\t\tif ( a > b ) {\r\n\r\n\t\t\tvar tmp = a;\r\n\t\t\ta = b;\r\n\t\t\tb = tmp;\r\n\r\n\t\t}\r\n\r\n\t\tvar list = edges[ a ];\r\n\r\n\t\tif ( list === undefined ) {\r\n\r\n\t\t\tedges[ a ] = [ b ];\r\n\t\t\treturn true;\r\n\r\n\t\t} else if ( list.indexOf( b ) === -1 ) {\r\n\r\n\t\t\tlist.push( b );\r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\r\n\t}\r\n\r\n\tthis.getAttributeBuffer = getAttributeBuffer;\r\n\tthis.getWireframeAttribute = getWireframeAttribute;\r\n\r\n\tthis.update = update;\r\n\r\n};\r\n\r\n// File:src/renderers/webgl/WebGLProgram.js\r\n\r\nTHREE.WebGLProgram = ( function () {\r\n\r\n\tvar programIdCount = 0;\r\n\r\n\tfunction getEncodingComponents( encoding ) {\r\n\r\n\t\tswitch ( encoding ) {\r\n\r\n\t\t\tcase THREE.LinearEncoding:\r\n\t\t\t\treturn [ 'Linear','( value )' ];\r\n\t\t\tcase THREE.sRGBEncoding:\r\n\t\t\t\treturn [ 'sRGB','( value )' ];\r\n\t\t\tcase THREE.RGBEEncoding:\r\n\t\t\t\treturn [ 'RGBE','( value )' ];\r\n\t\t\tcase THREE.RGBM7Encoding:\r\n\t\t\t\treturn [ 'RGBM','( value, 7.0 )' ];\r\n\t\t\tcase THREE.RGBM16Encoding:\r\n\t\t\t\treturn [ 'RGBM','( value, 16.0 )' ];\r\n\t\t\tcase THREE.RGBDEncoding:\r\n\t\t\t\treturn [ 'RGBD','( value, 256.0 )' ];\r\n\t\t\tcase THREE.GammaEncoding:\r\n\t\t\t\treturn [ 'Gamma','( value, float( GAMMA_FACTOR ) )' ];\r\n\t\t\tdefault:\r\n\t\t\t\tthrow new Error( 'unsupported encoding: ' + encoding );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction getTexelDecodingFunction( functionName, encoding ) {\r\n\r\n\t\tvar components = getEncodingComponents( encoding );\r\n\t\treturn \"vec4 \" + functionName + \"( vec4 value ) { return \" + components[ 0 ] + \"ToLinear\" + components[ 1 ] + \"; }\";\r\n\r\n\t}\r\n\r\n\tfunction getTexelEncodingFunction( functionName, encoding ) {\r\n\r\n\t\tvar components = getEncodingComponents( encoding );\r\n\t\treturn \"vec4 \" + functionName + \"( vec4 value ) { return LinearTo\" + components[ 0 ] + components[ 1 ] + \"; }\";\r\n\r\n\t}\r\n\r\n\tfunction getToneMappingFunction( functionName, toneMapping ) {\r\n\r\n\t\tvar toneMappingName;\r\n\r\n\t\tswitch ( toneMapping ) {\r\n\r\n\t\t\tcase THREE.LinearToneMapping:\r\n\t\t\t\ttoneMappingName = \"Linear\";\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase THREE.ReinhardToneMapping:\r\n\t\t\t\ttoneMappingName = \"Reinhard\";\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase THREE.Uncharted2ToneMapping:\r\n\t\t\t\ttoneMappingName = \"Uncharted2\";\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase THREE.CineonToneMapping:\r\n\t\t\t\ttoneMappingName = \"OptimizedCineon\";\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tdefault:\r\n\t\t\t\tthrow new Error( 'unsupported toneMapping: ' + toneMapping );\r\n\r\n\t\t}\r\n\r\n\t\treturn \"vec3 \" + functionName + \"( vec3 color ) { return \" + toneMappingName + \"ToneMapping( color ); }\";\r\n\r\n\t}\r\n\r\n\tfunction generateExtensions( extensions, parameters, rendererExtensions ) {\r\n\r\n\t\textensions = extensions || {};\r\n\r\n\t\tvar chunks = [\r\n\t\t\t( extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.normalMap || parameters.flatShading ) ? '#extension GL_OES_standard_derivatives : enable' : '',\r\n\t\t\t( extensions.fragDepth || parameters.logarithmicDepthBuffer ) && rendererExtensions.get( 'EXT_frag_depth' ) ? '#extension GL_EXT_frag_depth : enable' : '',\r\n\t\t\t( extensions.drawBuffers ) && rendererExtensions.get( 'WEBGL_draw_buffers' ) ? '#extension GL_EXT_draw_buffers : require' : '',\r\n\t\t\t( extensions.shaderTextureLOD || parameters.envMap ) && rendererExtensions.get( 'EXT_shader_texture_lod' ) ? '#extension GL_EXT_shader_texture_lod : enable' : '',\r\n\t\t];\r\n\r\n\t\treturn chunks.filter( filterEmptyLine ).join( '\\n' );\r\n\r\n\t}\r\n\r\n\tfunction generateDefines( defines ) {\r\n\r\n\t\tvar chunks = [];\r\n\r\n\t\tfor ( var name in defines ) {\r\n\r\n\t\t\tvar value = defines[ name ];\r\n\r\n\t\t\tif ( value === false ) continue;\r\n\r\n\t\t\tchunks.push( '#define ' + name + ' ' + value );\r\n\r\n\t\t}\r\n\r\n\t\treturn chunks.join( '\\n' );\r\n\r\n\t}\r\n\r\n\tfunction fetchAttributeLocations( gl, program, identifiers ) {\r\n\r\n\t\tvar attributes = {};\r\n\r\n\t\tvar n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );\r\n\r\n\t\tfor ( var i = 0; i < n; i ++ ) {\r\n\r\n\t\t\tvar info = gl.getActiveAttrib( program, i );\r\n\t\t\tvar name = info.name;\r\n\r\n\t\t\t// console.log(\"THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:\", name, i );\r\n\r\n\t\t\tattributes[ name ] = gl.getAttribLocation( program, name );\r\n\r\n\t\t}\r\n\r\n\t\treturn attributes;\r\n\r\n\t}\r\n\r\n\tfunction filterEmptyLine( string ) {\r\n\r\n\t\treturn string !== '';\r\n\r\n\t}\r\n\r\n\tfunction replaceLightNums( string, parameters ) {\r\n\r\n\t\treturn string\r\n\t\t\t.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )\r\n\t\t\t.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )\r\n\t\t\t.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )\r\n\t\t\t.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights );\r\n\r\n\t}\r\n\r\n\tfunction parseIncludes( string ) {\r\n\r\n\t\tvar pattern = /#include +<([\\w\\d.]+)>/g;\r\n\r\n\t\tfunction replace( match, include ) {\r\n\r\n\t\t\tvar replace = THREE.ShaderChunk[ include ];\r\n\r\n\t\t\tif ( replace === undefined ) {\r\n\r\n\t\t\t\tthrow new Error( 'Can not resolve #include <' + include + '>' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn parseIncludes( replace );\r\n\r\n\t\t}\r\n\r\n\t\treturn string.replace( pattern, replace );\r\n\r\n\t}\r\n\r\n\tfunction unrollLoops( string ) {\r\n\r\n\t\tvar pattern = /for \\( int i \\= (\\d+)\\; i < (\\d+)\\; i \\+\\+ \\) \\{([\\s\\S]+?)(?=\\})\\}/g;\r\n\r\n\t\tfunction replace( match, start, end, snippet ) {\r\n\r\n\t\t\tvar unroll = '';\r\n\r\n\t\t\tfor ( var i = parseInt( start ); i < parseInt( end ); i ++ ) {\r\n\r\n\t\t\t\tunroll += snippet.replace( /\\[ i \\]/g, '[ ' + i + ' ]' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn unroll;\r\n\r\n\t\t}\r\n\r\n\t\treturn string.replace( pattern, replace );\r\n\r\n\t}\r\n\r\n\treturn function WebGLProgram( renderer, code, material, parameters ) {\r\n\r\n\t\tvar gl = renderer.context;\r\n\r\n\t\tvar extensions = material.extensions;\r\n\t\tvar defines = material.defines;\r\n\r\n\t\tvar vertexShader = material.__webglShader.vertexShader;\r\n\t\tvar fragmentShader = material.__webglShader.fragmentShader;\r\n\r\n\t\tvar shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';\r\n\r\n\t\tif ( parameters.shadowMapType === THREE.PCFShadowMap ) {\r\n\r\n\t\t\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';\r\n\r\n\t\t} else if ( parameters.shadowMapType === THREE.PCFSoftShadowMap ) {\r\n\r\n\t\t\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';\r\n\r\n\t\t}\r\n\r\n\t\tvar envMapTypeDefine = 'ENVMAP_TYPE_CUBE';\r\n\t\tvar envMapModeDefine = 'ENVMAP_MODE_REFLECTION';\r\n\t\tvar envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\r\n\r\n\t\tif ( parameters.envMap ) {\r\n\r\n\t\t\tswitch ( material.envMap.mapping ) {\r\n\r\n\t\t\t\tcase THREE.CubeReflectionMapping:\r\n\t\t\t\tcase THREE.CubeRefractionMapping:\r\n\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_CUBE';\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase THREE.CubeUVReflectionMapping:\r\n\t\t\t\tcase THREE.CubeUVRefractionMapping:\r\n\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase THREE.EquirectangularReflectionMapping:\r\n\t\t\t\tcase THREE.EquirectangularRefractionMapping:\r\n\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase THREE.SphericalReflectionMapping:\r\n\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_SPHERE';\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tswitch ( material.envMap.mapping ) {\r\n\r\n\t\t\t\tcase THREE.CubeRefractionMapping:\r\n\t\t\t\tcase THREE.EquirectangularRefractionMapping:\r\n\t\t\t\t\tenvMapModeDefine = 'ENVMAP_MODE_REFRACTION';\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tswitch ( material.combine ) {\r\n\r\n\t\t\t\tcase THREE.MultiplyOperation:\r\n\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase THREE.MixOperation:\r\n\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MIX';\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase THREE.AddOperation:\r\n\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_ADD';\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;\r\n\r\n\t\t// console.log( 'building new program ' );\r\n\r\n\t\t//\r\n\r\n\t\tvar customExtensions = generateExtensions( extensions, parameters, renderer.extensions );\r\n\r\n\t\tvar customDefines = generateDefines( defines );\r\n\r\n\t\t//\r\n\r\n\t\tvar program = gl.createProgram();\r\n\r\n\t\tvar prefixVertex, prefixFragment;\r\n\r\n\t\tif ( material instanceof THREE.RawShaderMaterial ) {\r\n\r\n\t\t\tprefixVertex = '';\r\n\t\t\tprefixFragment = '';\r\n\r\n\t\t} else {\r\n\r\n\t\t\tprefixVertex = [\r\n\r\n\t\t\t\t'precision ' + parameters.precision + ' float;',\r\n\t\t\t\t'precision ' + parameters.precision + ' int;',\r\n\r\n\t\t\t\t'#define SHADER_NAME ' + material.__webglShader.name,\r\n\r\n\t\t\t\tcustomDefines,\r\n\r\n\t\t\t\tparameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',\r\n\r\n\t\t\t\t'#define GAMMA_FACTOR ' + gammaFactorDefine,\r\n\r\n\t\t\t\t'#define MAX_BONES ' + parameters.maxBones,\r\n\r\n\t\t\t\tparameters.map ? '#define USE_MAP' : '',\r\n\t\t\t\tparameters.envMap ? '#define USE_ENVMAP' : '',\r\n\t\t\t\tparameters.envMap ? '#define ' + envMapModeDefine : '',\r\n\t\t\t\tparameters.lightMap ? '#define USE_LIGHTMAP' : '',\r\n\t\t\t\tparameters.aoMap ? '#define USE_AOMAP' : '',\r\n\t\t\t\tparameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',\r\n\t\t\t\tparameters.bumpMap ? '#define USE_BUMPMAP' : '',\r\n\t\t\t\tparameters.normalMap ? '#define USE_NORMALMAP' : '',\r\n\t\t\t\tparameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',\r\n\t\t\t\tparameters.specularMap ? '#define USE_SPECULARMAP' : '',\r\n\t\t\t\tparameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',\r\n\t\t\t\tparameters.metalnessMap ? '#define USE_METALNESSMAP' : '',\r\n\t\t\t\tparameters.alphaMap ? '#define USE_ALPHAMAP' : '',\r\n\t\t\t\tparameters.vertexColors ? '#define USE_COLOR' : '',\r\n\r\n\t\t\t\tparameters.flatShading ? '#define FLAT_SHADED' : '',\r\n\r\n\t\t\t\tparameters.skinning ? '#define USE_SKINNING' : '',\r\n\t\t\t\tparameters.useVertexTexture ? '#define BONE_TEXTURE' : '',\r\n\r\n\t\t\t\tparameters.morphTargets ? '#define USE_MORPHTARGETS' : '',\r\n\t\t\t\tparameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',\r\n\t\t\t\tparameters.doubleSided ? '#define DOUBLE_SIDED' : '',\r\n\t\t\t\tparameters.flipSided ? '#define FLIP_SIDED' : '',\r\n\r\n\t\t\t\t'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,\r\n\r\n\t\t\t\tparameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\r\n\t\t\t\tparameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\r\n\r\n\t\t\t\tparameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',\r\n\r\n\t\t\t\tparameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\r\n\t\t\t\tparameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',\r\n\r\n\t\t\t\t'uniform mat4 modelMatrix;',\r\n\t\t\t\t'uniform mat4 modelViewMatrix;',\r\n\t\t\t\t'uniform mat4 projectionMatrix;',\r\n\t\t\t\t'uniform mat4 viewMatrix;',\r\n\t\t\t\t'uniform mat3 normalMatrix;',\r\n\t\t\t\t'uniform vec3 cameraPosition;',\r\n\r\n\t\t\t\t'attribute vec3 position;',\r\n\t\t\t\t'attribute vec3 normal;',\r\n\t\t\t\t'attribute vec2 uv;',\r\n\r\n\t\t\t\t'#ifdef USE_COLOR',\r\n\r\n\t\t\t\t'\tattribute vec3 color;',\r\n\r\n\t\t\t\t'#endif',\r\n\r\n\t\t\t\t'#ifdef USE_MORPHTARGETS',\r\n\r\n\t\t\t\t'\tattribute vec3 morphTarget0;',\r\n\t\t\t\t'\tattribute vec3 morphTarget1;',\r\n\t\t\t\t'\tattribute vec3 morphTarget2;',\r\n\t\t\t\t'\tattribute vec3 morphTarget3;',\r\n\r\n\t\t\t\t'\t#ifdef USE_MORPHNORMALS',\r\n\r\n\t\t\t\t'\t\tattribute vec3 morphNormal0;',\r\n\t\t\t\t'\t\tattribute vec3 morphNormal1;',\r\n\t\t\t\t'\t\tattribute vec3 morphNormal2;',\r\n\t\t\t\t'\t\tattribute vec3 morphNormal3;',\r\n\r\n\t\t\t\t'\t#else',\r\n\r\n\t\t\t\t'\t\tattribute vec3 morphTarget4;',\r\n\t\t\t\t'\t\tattribute vec3 morphTarget5;',\r\n\t\t\t\t'\t\tattribute vec3 morphTarget6;',\r\n\t\t\t\t'\t\tattribute vec3 morphTarget7;',\r\n\r\n\t\t\t\t'\t#endif',\r\n\r\n\t\t\t\t'#endif',\r\n\r\n\t\t\t\t'#ifdef USE_SKINNING',\r\n\r\n\t\t\t\t'\tattribute vec4 skinIndex;',\r\n\t\t\t\t'\tattribute vec4 skinWeight;',\r\n\r\n\t\t\t\t'#endif',\r\n\r\n\t\t\t\t'\\n'\r\n\r\n\t\t\t].filter( filterEmptyLine ).join( '\\n' );\r\n\r\n\t\t\tprefixFragment = [\r\n\r\n\t\t\t\tcustomExtensions,\r\n\r\n\t\t\t\t'precision ' + parameters.precision + ' float;',\r\n\t\t\t\t'precision ' + parameters.precision + ' int;',\r\n\r\n\t\t\t\t'#define SHADER_NAME ' + material.__webglShader.name,\r\n\r\n\t\t\t\tcustomDefines,\r\n\r\n\t\t\t\tparameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',\r\n\r\n\t\t\t\t'#define GAMMA_FACTOR ' + gammaFactorDefine,\r\n\r\n\t\t\t\t( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',\r\n\t\t\t\t( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',\r\n\r\n\t\t\t\tparameters.map ? '#define USE_MAP' : '',\r\n\t\t\t\tparameters.envMap ? '#define USE_ENVMAP' : '',\r\n\t\t\t\tparameters.envMap ? '#define ' + envMapTypeDefine : '',\r\n\t\t\t\tparameters.envMap ? '#define ' + envMapModeDefine : '',\r\n\t\t\t\tparameters.envMap ? '#define ' + envMapBlendingDefine : '',\r\n\t\t\t\tparameters.lightMap ? '#define USE_LIGHTMAP' : '',\r\n\t\t\t\tparameters.aoMap ? '#define USE_AOMAP' : '',\r\n\t\t\t\tparameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',\r\n\t\t\t\tparameters.bumpMap ? '#define USE_BUMPMAP' : '',\r\n\t\t\t\tparameters.normalMap ? '#define USE_NORMALMAP' : '',\r\n\t\t\t\tparameters.specularMap ? '#define USE_SPECULARMAP' : '',\r\n\t\t\t\tparameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',\r\n\t\t\t\tparameters.metalnessMap ? '#define USE_METALNESSMAP' : '',\r\n\t\t\t\tparameters.alphaMap ? '#define USE_ALPHAMAP' : '',\r\n\t\t\t\tparameters.vertexColors ? '#define USE_COLOR' : '',\r\n\r\n\t\t\t\tparameters.flatShading ? '#define FLAT_SHADED' : '',\r\n\r\n\t\t\t\tparameters.doubleSided ? '#define DOUBLE_SIDED' : '',\r\n\t\t\t\tparameters.flipSided ? '#define FLIP_SIDED' : '',\r\n\r\n\t\t\t\t'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,\r\n\r\n\t\t\t\tparameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\r\n\t\t\t\tparameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\r\n\r\n\t\t\t\tparameters.premultipliedAlpha ? \"#define PREMULTIPLIED_ALPHA\" : '',\r\n\r\n\t\t\t\tparameters.physicallyCorrectLights ? \"#define PHYSICALLY_CORRECT_LIGHTS\" : '',\r\n\r\n\t\t\t\tparameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\r\n\t\t\t\tparameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',\r\n\r\n\t\t\t\tparameters.envMap && renderer.extensions.get( 'EXT_shader_texture_lod' ) ? '#define TEXTURE_LOD_EXT' : '',\r\n\r\n\t\t\t\t'uniform mat4 viewMatrix;',\r\n\t\t\t\t'uniform vec3 cameraPosition;',\r\n\r\n\t\t\t\t( parameters.toneMapping !== THREE.NoToneMapping ) ? \"#define TONE_MAPPING\" : '',\r\n\t\t\t\t( parameters.toneMapping !== THREE.NoToneMapping ) ? THREE.ShaderChunk[ 'tonemapping_pars_fragment' ] : '',  // this code is required here because it is used by the toneMapping() function defined below\r\n\t\t\t\t( parameters.toneMapping !== THREE.NoToneMapping ) ? getToneMappingFunction( \"toneMapping\", parameters.toneMapping ) : '',\r\n\r\n\t\t\t\t( parameters.outputEncoding || parameters.mapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding ) ? THREE.ShaderChunk[ 'encodings_pars_fragment' ] : '', // this code is required here because it is used by the various encoding/decoding function defined below\r\n\t\t\t\tparameters.mapEncoding ? getTexelDecodingFunction( 'mapTexelToLinear', parameters.mapEncoding ) : '',\r\n\t\t\t\tparameters.envMapEncoding ? getTexelDecodingFunction( 'envMapTexelToLinear', parameters.envMapEncoding ) : '',\r\n\t\t\t\tparameters.emissiveMapEncoding ? getTexelDecodingFunction( 'emissiveMapTexelToLinear', parameters.emissiveMapEncoding ) : '',\r\n\t\t\t\tparameters.outputEncoding ? getTexelEncodingFunction( \"linearToOutputTexel\", parameters.outputEncoding ) : '',\r\n\r\n\t\t\t\tparameters.depthPacking ? \"#define DEPTH_PACKING \" + material.depthPacking : '',\r\n\r\n\t\t\t\t'\\n'\r\n\r\n\t\t\t].filter( filterEmptyLine ).join( '\\n' );\r\n\r\n\t\t}\r\n\r\n\t\tvertexShader = parseIncludes( vertexShader, parameters );\r\n\t\tvertexShader = replaceLightNums( vertexShader, parameters );\r\n\r\n\t\tfragmentShader = parseIncludes( fragmentShader, parameters );\r\n\t\tfragmentShader = replaceLightNums( fragmentShader, parameters );\r\n\r\n\t\tif ( material instanceof THREE.ShaderMaterial === false ) {\r\n\r\n\t\t\tvertexShader = unrollLoops( vertexShader );\r\n\t\t\tfragmentShader = unrollLoops( fragmentShader );\r\n\r\n\t\t}\r\n\r\n\t\tvar vertexGlsl = prefixVertex + vertexShader;\r\n\t\tvar fragmentGlsl = prefixFragment + fragmentShader;\r\n\r\n\t\t// console.log( '*VERTEX*', vertexGlsl );\r\n\t\t// console.log( '*FRAGMENT*', fragmentGlsl );\r\n\r\n\t\tvar glVertexShader = THREE.WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );\r\n\t\tvar glFragmentShader = THREE.WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );\r\n\r\n\t\tgl.attachShader( program, glVertexShader );\r\n\t\tgl.attachShader( program, glFragmentShader );\r\n\r\n\t\t// Force a particular attribute to index 0.\r\n\r\n\t\tif ( material.index0AttributeName !== undefined ) {\r\n\r\n\t\t\tgl.bindAttribLocation( program, 0, material.index0AttributeName );\r\n\r\n\t\t} else if ( parameters.morphTargets === true ) {\r\n\r\n\t\t\t// programs with morphTargets displace position out of attribute 0\r\n\t\t\tgl.bindAttribLocation( program, 0, 'position' );\r\n\r\n\t\t}\r\n\r\n\t\tgl.linkProgram( program );\r\n\r\n\t\tvar programLog = gl.getProgramInfoLog( program );\r\n\t\tvar vertexLog = gl.getShaderInfoLog( glVertexShader );\r\n\t\tvar fragmentLog = gl.getShaderInfoLog( glFragmentShader );\r\n\r\n\t\tvar runnable = true;\r\n\t\tvar haveDiagnostics = true;\r\n\r\n\t\t// console.log( '**VERTEX**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );\r\n\t\t// console.log( '**FRAGMENT**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );\r\n\r\n\t\tif ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {\r\n\r\n\t\t\trunnable = false;\r\n\r\n\t\t\tconsole.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter( program, gl.VALIDATE_STATUS ), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog );\r\n\r\n\t\t} else if ( programLog !== '' ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );\r\n\r\n\t\t} else if ( vertexLog === '' || fragmentLog === '' ) {\r\n\r\n\t\t\thaveDiagnostics = false;\r\n\r\n\t\t}\r\n\r\n\t\tif ( haveDiagnostics ) {\r\n\r\n\t\t\tthis.diagnostics = {\r\n\r\n\t\t\t\trunnable: runnable,\r\n\t\t\t\tmaterial: material,\r\n\r\n\t\t\t\tprogramLog: programLog,\r\n\r\n\t\t\t\tvertexShader: {\r\n\r\n\t\t\t\t\tlog: vertexLog,\r\n\t\t\t\t\tprefix: prefixVertex\r\n\r\n\t\t\t\t},\r\n\r\n\t\t\t\tfragmentShader: {\r\n\r\n\t\t\t\t\tlog: fragmentLog,\r\n\t\t\t\t\tprefix: prefixFragment\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\t// clean up\r\n\r\n\t\tgl.deleteShader( glVertexShader );\r\n\t\tgl.deleteShader( glFragmentShader );\r\n\r\n\t\t// set up caching for uniform locations\r\n\r\n\t\tvar cachedUniforms;\r\n\r\n\t\tthis.getUniforms = function() {\r\n\r\n\t\t\tif ( cachedUniforms === undefined ) {\r\n\r\n\t\t\t\tcachedUniforms =\r\n\t\t\t\t\t\tnew THREE.WebGLUniforms( gl, program, renderer );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn cachedUniforms;\r\n\r\n\t\t};\r\n\r\n\t\t// set up caching for attribute locations\r\n\r\n\t\tvar cachedAttributes;\r\n\r\n\t\tthis.getAttributes = function() {\r\n\r\n\t\t\tif ( cachedAttributes === undefined ) {\r\n\r\n\t\t\t\tcachedAttributes = fetchAttributeLocations( gl, program );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn cachedAttributes;\r\n\r\n\t\t};\r\n\r\n\t\t// free resource\r\n\r\n\t\tthis.destroy = function() {\r\n\r\n\t\t\tgl.deleteProgram( program );\r\n\t\t\tthis.program = undefined;\r\n\r\n\t\t};\r\n\r\n\t\t// DEPRECATED\r\n\r\n\t\tObject.defineProperties( this, {\r\n\r\n\t\t\tuniforms: {\r\n\t\t\t\tget: function() {\r\n\r\n\t\t\t\t\tconsole.warn( 'THREE.WebGLProgram: .uniforms is now .getUniforms().' );\r\n\t\t\t\t\treturn this.getUniforms();\r\n\r\n\t\t\t\t}\r\n\t\t\t},\r\n\r\n\t\t\tattributes: {\r\n\t\t\t\tget: function() {\r\n\r\n\t\t\t\t\tconsole.warn( 'THREE.WebGLProgram: .attributes is now .getAttributes().' );\r\n\t\t\t\t\treturn this.getAttributes();\r\n\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t} );\r\n\r\n\r\n\t\t//\r\n\r\n\t\tthis.id = programIdCount ++;\r\n\t\tthis.code = code;\r\n\t\tthis.usedTimes = 1;\r\n\t\tthis.program = program;\r\n\t\tthis.vertexShader = glVertexShader;\r\n\t\tthis.fragmentShader = glFragmentShader;\r\n\r\n\t\treturn this;\r\n\r\n\t};\r\n\r\n} )();\r\n\r\n// File:src/renderers/webgl/WebGLPrograms.js\r\n\r\nTHREE.WebGLPrograms = function ( renderer, capabilities ) {\r\n\r\n\tvar programs = [];\r\n\r\n\tvar shaderIDs = {\r\n\t\tMeshDepthMaterial: 'depth',\r\n\t\tMeshNormalMaterial: 'normal',\r\n\t\tMeshBasicMaterial: 'basic',\r\n\t\tMeshLambertMaterial: 'lambert',\r\n\t\tMeshPhongMaterial: 'phong',\r\n\t\tMeshStandardMaterial: 'physical',\r\n\t\tMeshPhysicalMaterial: 'physical',\r\n\t\tLineBasicMaterial: 'basic',\r\n\t\tLineDashedMaterial: 'dashed',\r\n\t\tPointsMaterial: 'points'\r\n\t};\r\n\r\n\tvar parameterNames = [\r\n\t\t\"precision\", \"supportsVertexTextures\", \"map\", \"mapEncoding\", \"envMap\", \"envMapMode\", \"envMapEncoding\",\r\n\t\t\"lightMap\", \"aoMap\", \"emissiveMap\", \"emissiveMapEncoding\", \"bumpMap\", \"normalMap\", \"displacementMap\", \"specularMap\",\r\n\t\t\"roughnessMap\", \"metalnessMap\",\r\n\t\t\"alphaMap\", \"combine\", \"vertexColors\", \"fog\", \"useFog\", \"fogExp\",\r\n\t\t\"flatShading\", \"sizeAttenuation\", \"logarithmicDepthBuffer\", \"skinning\",\r\n\t\t\"maxBones\", \"useVertexTexture\", \"morphTargets\", \"morphNormals\",\r\n\t\t\"maxMorphTargets\", \"maxMorphNormals\", \"premultipliedAlpha\",\r\n\t\t\"numDirLights\", \"numPointLights\", \"numSpotLights\", \"numHemiLights\",\r\n\t\t\"shadowMapEnabled\", \"shadowMapType\", \"toneMapping\", 'physicallyCorrectLights',\r\n\t\t\"alphaTest\", \"doubleSided\", \"flipSided\", \"numClippingPlanes\", \"depthPacking\"\r\n\t];\r\n\r\n\r\n\tfunction allocateBones ( object ) {\r\n\r\n\t\tif ( capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture ) {\r\n\r\n\t\t\treturn 1024;\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// default for when object is not specified\r\n\t\t\t// ( for example when prebuilding shader to be used with multiple objects )\r\n\t\t\t//\r\n\t\t\t//  - leave some extra space for other uniforms\r\n\t\t\t//  - limit here is ANGLE's 254 max uniform vectors\r\n\t\t\t//    (up to 54 should be safe)\r\n\r\n\t\t\tvar nVertexUniforms = capabilities.maxVertexUniforms;\r\n\t\t\tvar nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );\r\n\r\n\t\t\tvar maxBones = nVertexMatrices;\r\n\r\n\t\t\tif ( object !== undefined && object instanceof THREE.SkinnedMesh ) {\r\n\r\n\t\t\t\tmaxBones = Math.min( object.skeleton.bones.length, maxBones );\r\n\r\n\t\t\t\tif ( maxBones < object.skeleton.bones.length ) {\r\n\r\n\t\t\t\t\tconsole.warn( 'WebGLRenderer: too many bones - ' + object.skeleton.bones.length + ', this GPU supports just ' + maxBones + ' (try OpenGL instead of ANGLE)' );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn maxBones;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction getTextureEncodingFromMap( map, gammaOverrideLinear ) {\r\n\r\n\t\tvar encoding;\r\n\r\n\t\tif ( ! map ) {\r\n\r\n\t\t\tencoding = THREE.LinearEncoding;\r\n\r\n\t\t} else if ( map instanceof THREE.Texture ) {\r\n\r\n\t\t\tencoding = map.encoding;\r\n\r\n\t\t} else if ( map instanceof THREE.WebGLRenderTarget ) {\r\n\r\n\t\t\tencoding = map.texture.encoding;\r\n\r\n\t\t}\r\n\r\n\t\t// add backwards compatibility for WebGLRenderer.gammaInput/gammaOutput parameter, should probably be removed at some point.\r\n\t\tif ( encoding === THREE.LinearEncoding && gammaOverrideLinear ) {\r\n\r\n\t\t\tencoding = THREE.GammaEncoding;\r\n\r\n\t\t}\r\n\r\n\t\treturn encoding;\r\n\r\n\t}\r\n\r\n\tthis.getParameters = function ( material, lights, fog, nClipPlanes, object ) {\r\n\r\n\t\tvar shaderID = shaderIDs[ material.type ];\r\n\r\n\t\t// heuristics to create shader parameters according to lights in the scene\r\n\t\t// (not to blow over maxLights budget)\r\n\r\n\t\tvar maxBones = allocateBones( object );\r\n\t\tvar precision = renderer.getPrecision();\r\n\r\n\t\tif ( material.precision !== null ) {\r\n\r\n\t\t\tprecision = capabilities.getMaxPrecision( material.precision );\r\n\r\n\t\t\tif ( precision !== material.precision ) {\r\n\r\n\t\t\t\tconsole.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar parameters = {\r\n\r\n\t\t\tshaderID: shaderID,\r\n\r\n\t\t\tprecision: precision,\r\n\t\t\tsupportsVertexTextures: capabilities.vertexTextures,\r\n\t\t\toutputEncoding: getTextureEncodingFromMap( renderer.getCurrentRenderTarget(), renderer.gammaOutput ),\r\n\t\t\tmap: !! material.map,\r\n\t\t\tmapEncoding: getTextureEncodingFromMap( material.map, renderer.gammaInput ),\r\n\t\t\tenvMap: !! material.envMap,\r\n\t\t\tenvMapMode: material.envMap && material.envMap.mapping,\r\n\t\t\tenvMapEncoding: getTextureEncodingFromMap( material.envMap, renderer.gammaInput ),\r\n\t\t\tenvMapCubeUV: ( !! material.envMap ) && ( ( material.envMap.mapping === THREE.CubeUVReflectionMapping ) || ( material.envMap.mapping === THREE.CubeUVRefractionMapping ) ),\r\n\t\t\tlightMap: !! material.lightMap,\r\n\t\t\taoMap: !! material.aoMap,\r\n\t\t\temissiveMap: !! material.emissiveMap,\r\n\t\t\temissiveMapEncoding: getTextureEncodingFromMap( material.emissiveMap, renderer.gammaInput ),\r\n\t\t\tbumpMap: !! material.bumpMap,\r\n\t\t\tnormalMap: !! material.normalMap,\r\n\t\t\tdisplacementMap: !! material.displacementMap,\r\n\t\t\troughnessMap: !! material.roughnessMap,\r\n\t\t\tmetalnessMap: !! material.metalnessMap,\r\n\t\t\tspecularMap: !! material.specularMap,\r\n\t\t\talphaMap: !! material.alphaMap,\r\n\r\n\t\t\tcombine: material.combine,\r\n\r\n\t\t\tvertexColors: material.vertexColors,\r\n\r\n\t\t\tfog: fog,\r\n\t\t\tuseFog: material.fog,\r\n\t\t\tfogExp: fog instanceof THREE.FogExp2,\r\n\r\n\t\t\tflatShading: material.shading === THREE.FlatShading,\r\n\r\n\t\t\tsizeAttenuation: material.sizeAttenuation,\r\n\t\t\tlogarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,\r\n\r\n\t\t\tskinning: material.skinning,\r\n\t\t\tmaxBones: maxBones,\r\n\t\t\tuseVertexTexture: capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture,\r\n\r\n\t\t\tmorphTargets: material.morphTargets,\r\n\t\t\tmorphNormals: material.morphNormals,\r\n\t\t\tmaxMorphTargets: renderer.maxMorphTargets,\r\n\t\t\tmaxMorphNormals: renderer.maxMorphNormals,\r\n\r\n\t\t\tnumDirLights: lights.directional.length,\r\n\t\t\tnumPointLights: lights.point.length,\r\n\t\t\tnumSpotLights: lights.spot.length,\r\n\t\t\tnumHemiLights: lights.hemi.length,\r\n\r\n\t\t\tnumClippingPlanes: nClipPlanes,\r\n\r\n\t\t\tshadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && lights.shadows.length > 0,\r\n\t\t\tshadowMapType: renderer.shadowMap.type,\r\n\r\n\t\t\ttoneMapping: renderer.toneMapping,\r\n\t\t\tphysicallyCorrectLights: renderer.physicallyCorrectLights,\r\n\r\n\t\t\tpremultipliedAlpha: material.premultipliedAlpha,\r\n\r\n\t\t\talphaTest: material.alphaTest,\r\n\t\t\tdoubleSided: material.side === THREE.DoubleSide,\r\n\t\t\tflipSided: material.side === THREE.BackSide,\r\n\r\n\t\t\tdepthPacking: ( material.depthPacking !== undefined ) ? material.depthPacking : false\r\n\r\n\t\t};\r\n\r\n\t\treturn parameters;\r\n\r\n\t};\r\n\r\n\tthis.getProgramCode = function ( material, parameters ) {\r\n\r\n\t\tvar array = [];\r\n\r\n\t\tif ( parameters.shaderID ) {\r\n\r\n\t\t\tarray.push( parameters.shaderID );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tarray.push( material.fragmentShader );\r\n\t\t\tarray.push( material.vertexShader );\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.defines !== undefined ) {\r\n\r\n\t\t\tfor ( var name in material.defines ) {\r\n\r\n\t\t\t\tarray.push( name );\r\n\t\t\t\tarray.push( material.defines[ name ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var i = 0; i < parameterNames.length; i ++ ) {\r\n\r\n\t\t\tarray.push( parameters[ parameterNames[ i ] ] );\r\n\r\n\t\t}\r\n\r\n\t\treturn array.join();\r\n\r\n\t};\r\n\r\n\tthis.acquireProgram = function ( material, parameters, code ) {\r\n\r\n\t\tvar program;\r\n\r\n\t\t// Check if code has been already compiled\r\n\t\tfor ( var p = 0, pl = programs.length; p < pl; p ++ ) {\r\n\r\n\t\t\tvar programInfo = programs[ p ];\r\n\r\n\t\t\tif ( programInfo.code === code ) {\r\n\r\n\t\t\t\tprogram = programInfo;\r\n\t\t\t\t++ program.usedTimes;\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( program === undefined ) {\r\n\r\n\t\t\tprogram = new THREE.WebGLProgram( renderer, code, material, parameters );\r\n\t\t\tprograms.push( program );\r\n\r\n\t\t}\r\n\r\n\t\treturn program;\r\n\r\n\t};\r\n\r\n\tthis.releaseProgram = function( program ) {\r\n\r\n\t\tif ( -- program.usedTimes === 0 ) {\r\n\r\n\t\t\t// Remove from unordered set\r\n\t\t\tvar i = programs.indexOf( program );\r\n\t\t\tprograms[ i ] = programs[ programs.length - 1 ];\r\n\t\t\tprograms.pop();\r\n\r\n\t\t\t// Free WebGL resources\r\n\t\t\tprogram.destroy();\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t// Exposed for resource monitoring & error feedback via renderer.info:\r\n\tthis.programs = programs;\r\n\r\n};\r\n\r\n// File:src/renderers/webgl/WebGLProperties.js\r\n\r\n/**\r\n* @author fordacious / fordacious.github.io\r\n*/\r\n\r\nTHREE.WebGLProperties = function () {\r\n\r\n\tvar properties = {};\r\n\r\n\tthis.get = function ( object ) {\r\n\r\n\t\tvar uuid = object.uuid;\r\n\t\tvar map = properties[ uuid ];\r\n\r\n\t\tif ( map === undefined ) {\r\n\r\n\t\t\tmap = {};\r\n\t\t\tproperties[ uuid ] = map;\r\n\r\n\t\t}\r\n\r\n\t\treturn map;\r\n\r\n\t};\r\n\r\n\tthis.delete = function ( object ) {\r\n\r\n\t\tdelete properties[ object.uuid ];\r\n\r\n\t};\r\n\r\n\tthis.clear = function () {\r\n\r\n\t\tproperties = {};\r\n\r\n\t};\r\n\r\n};\r\n\r\n// File:src/renderers/webgl/WebGLShader.js\r\n\r\nTHREE.WebGLShader = ( function () {\r\n\r\n\tfunction addLineNumbers( string ) {\r\n\r\n\t\tvar lines = string.split( '\\n' );\r\n\r\n\t\tfor ( var i = 0; i < lines.length; i ++ ) {\r\n\r\n\t\t\tlines[ i ] = ( i + 1 ) + ': ' + lines[ i ];\r\n\r\n\t\t}\r\n\r\n\t\treturn lines.join( '\\n' );\r\n\r\n\t}\r\n\r\n\treturn function WebGLShader( gl, type, string ) {\r\n\r\n\t\tvar shader = gl.createShader( type );\r\n\r\n\t\tgl.shaderSource( shader, string );\r\n\t\tgl.compileShader( shader );\r\n\r\n\t\tif ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {\r\n\r\n\t\t\tconsole.error( 'THREE.WebGLShader: Shader couldn\\'t compile.' );\r\n\r\n\t\t}\r\n\r\n\t\tif ( gl.getShaderInfoLog( shader ) !== '' ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );\r\n\r\n\t\t}\r\n\r\n\t\t// --enable-privileged-webgl-extension\r\n\t\t// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );\r\n\r\n\t\treturn shader;\r\n\r\n\t};\r\n\r\n} )();\r\n\r\n// File:src/renderers/webgl/WebGLShadowMap.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.WebGLShadowMap = function ( _renderer, _lights, _objects ) {\r\n\r\n\tvar _gl = _renderer.context,\r\n\t_state = _renderer.state,\r\n\t_frustum = new THREE.Frustum(),\r\n\t_projScreenMatrix = new THREE.Matrix4(),\r\n\r\n\t_lightShadows = _lights.shadows,\r\n\r\n\t_shadowMapSize = new THREE.Vector2(),\r\n\r\n\t_lookTarget = new THREE.Vector3(),\r\n\t_lightPositionWorld = new THREE.Vector3(),\r\n\r\n\t_renderList = [],\r\n\r\n\t_MorphingFlag = 1,\r\n\t_SkinningFlag = 2,\r\n\r\n\t_NumberOfMaterialVariants = ( _MorphingFlag | _SkinningFlag ) + 1,\r\n\r\n\t_depthMaterials = new Array( _NumberOfMaterialVariants ),\r\n\t_distanceMaterials = new Array( _NumberOfMaterialVariants ),\r\n\r\n\t_materialCache = {};\r\n\r\n\tvar cubeDirections = [\r\n\t\tnew THREE.Vector3( 1, 0, 0 ), new THREE.Vector3( - 1, 0, 0 ), new THREE.Vector3( 0, 0, 1 ),\r\n\t\tnew THREE.Vector3( 0, 0, - 1 ), new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, - 1, 0 )\r\n\t];\r\n\r\n\tvar cubeUps = [\r\n\t\tnew THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, 1, 0 ),\r\n\t\tnew THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, 0, 1 ),\tnew THREE.Vector3( 0, 0, - 1 )\r\n\t];\r\n\r\n\tvar cube2DViewPorts = [\r\n\t\tnew THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4(),\r\n\t\tnew THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4()\r\n\t];\r\n\r\n\t// init\r\n\r\n\tvar depthMaterialTemplate = new THREE.MeshDepthMaterial();\r\n\tdepthMaterialTemplate.depthPacking = THREE.RGBADepthPacking;\r\n\tdepthMaterialTemplate.clipping = true;\r\n\r\n\tvar distanceShader = THREE.ShaderLib[ \"distanceRGBA\" ];\r\n\tvar distanceUniforms = THREE.UniformsUtils.clone( distanceShader.uniforms );\r\n\r\n\tfor ( var i = 0; i !== _NumberOfMaterialVariants; ++ i ) {\r\n\r\n\t\tvar useMorphing = ( i & _MorphingFlag ) !== 0;\r\n\t\tvar useSkinning = ( i & _SkinningFlag ) !== 0;\r\n\r\n\t\tvar depthMaterial = depthMaterialTemplate.clone();\r\n\t\tdepthMaterial.morphTargets = useMorphing;\r\n\t\tdepthMaterial.skinning = useSkinning;\r\n\r\n\t\t_depthMaterials[ i ] = depthMaterial;\r\n\r\n\t\tvar distanceMaterial = new THREE.ShaderMaterial( {\r\n\t\t\tdefines: {\r\n\t\t\t\t'USE_SHADOWMAP': ''\r\n\t\t\t},\r\n\t\t\tuniforms: distanceUniforms,\r\n\t\t\tvertexShader: distanceShader.vertexShader,\r\n\t\t\tfragmentShader: distanceShader.fragmentShader,\r\n\t\t\tmorphTargets: useMorphing,\r\n\t\t\tskinning: useSkinning,\r\n\t\t\tclipping: true\r\n\t\t} );\r\n\r\n\t\t_distanceMaterials[ i ] = distanceMaterial;\r\n\r\n\t}\r\n\r\n\t//\r\n\r\n\tvar scope = this;\r\n\r\n\tthis.enabled = false;\r\n\r\n\tthis.autoUpdate = true;\r\n\tthis.needsUpdate = false;\r\n\r\n\tthis.type = THREE.PCFShadowMap;\r\n\tthis.cullFace = THREE.CullFaceFront;\r\n\r\n\tthis.render = function ( scene, camera ) {\r\n\r\n\t\tif ( scope.enabled === false ) return;\r\n\t\tif ( scope.autoUpdate === false && scope.needsUpdate === false ) return;\r\n\r\n\t\tif ( _lightShadows.length === 0 ) return;\r\n\r\n\t\t// Set GL state for depth map.\r\n\t\t_state.clearColor( 1, 1, 1, 1 );\r\n\t\t_state.disable( _gl.BLEND );\r\n\t\t_state.enable( _gl.CULL_FACE );\r\n\t\t_gl.frontFace( _gl.CCW );\r\n\t\t_gl.cullFace( scope.cullFace === THREE.CullFaceFront ? _gl.FRONT : _gl.BACK );\r\n\t\t_state.setDepthTest( true );\r\n\t\t_state.setScissorTest( false );\r\n\r\n\t\t// render depth map\r\n\r\n\t\tvar faceCount, isPointLight;\r\n\r\n\t\tfor ( var i = 0, il = _lightShadows.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar light = _lightShadows[ i ];\r\n\r\n\t\t\tvar shadow = light.shadow;\r\n\t\t\tvar shadowCamera = shadow.camera;\r\n\r\n\t\t\t_shadowMapSize.copy( shadow.mapSize );\r\n\r\n\t\t\tif ( light instanceof THREE.PointLight ) {\r\n\r\n\t\t\t\tfaceCount = 6;\r\n\t\t\t\tisPointLight = true;\r\n\r\n\t\t\t\tvar vpWidth = _shadowMapSize.x;\r\n\t\t\t\tvar vpHeight = _shadowMapSize.y;\r\n\r\n\t\t\t\t// These viewports map a cube-map onto a 2D texture with the\r\n\t\t\t\t// following orientation:\r\n\t\t\t\t//\r\n\t\t\t\t//  xzXZ\r\n\t\t\t\t//   y Y\r\n\t\t\t\t//\r\n\t\t\t\t// X - Positive x direction\r\n\t\t\t\t// x - Negative x direction\r\n\t\t\t\t// Y - Positive y direction\r\n\t\t\t\t// y - Negative y direction\r\n\t\t\t\t// Z - Positive z direction\r\n\t\t\t\t// z - Negative z direction\r\n\r\n\t\t\t\t// positive X\r\n\t\t\t\tcube2DViewPorts[ 0 ].set( vpWidth * 2, vpHeight, vpWidth, vpHeight );\r\n\t\t\t\t// negative X\r\n\t\t\t\tcube2DViewPorts[ 1 ].set( 0, vpHeight, vpWidth, vpHeight );\r\n\t\t\t\t// positive Z\r\n\t\t\t\tcube2DViewPorts[ 2 ].set( vpWidth * 3, vpHeight, vpWidth, vpHeight );\r\n\t\t\t\t// negative Z\r\n\t\t\t\tcube2DViewPorts[ 3 ].set( vpWidth, vpHeight, vpWidth, vpHeight );\r\n\t\t\t\t// positive Y\r\n\t\t\t\tcube2DViewPorts[ 4 ].set( vpWidth * 3, 0, vpWidth, vpHeight );\r\n\t\t\t\t// negative Y\r\n\t\t\t\tcube2DViewPorts[ 5 ].set( vpWidth, 0, vpWidth, vpHeight );\r\n\r\n\t\t\t\t_shadowMapSize.x *= 4.0;\r\n\t\t\t\t_shadowMapSize.y *= 2.0;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tfaceCount = 1;\r\n\t\t\t\tisPointLight = false;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( shadow.map === null ) {\r\n\r\n\t\t\t\tvar pars = { minFilter: THREE.NearestFilter, magFilter: THREE.NearestFilter, format: THREE.RGBAFormat };\r\n\r\n\t\t\t\tshadow.map = new THREE.WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );\r\n\r\n\t\t\t\tshadowCamera.updateProjectionMatrix();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( shadow instanceof THREE.SpotLightShadow ) {\r\n\r\n\t\t\t\tshadow.update( light );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar shadowMap = shadow.map;\r\n\t\t\tvar shadowMatrix = shadow.matrix;\r\n\r\n\t\t\t_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );\r\n\t\t\tshadowCamera.position.copy( _lightPositionWorld );\r\n\r\n\t\t\t_renderer.setRenderTarget( shadowMap );\r\n\t\t\t_renderer.clear();\r\n\r\n\t\t\t// render shadow map for each cube face (if omni-directional) or\r\n\t\t\t// run a single pass if not\r\n\r\n\t\t\tfor ( var face = 0; face < faceCount; face ++ ) {\r\n\r\n\t\t\t\tif ( isPointLight ) {\r\n\r\n\t\t\t\t\t_lookTarget.copy( shadowCamera.position );\r\n\t\t\t\t\t_lookTarget.add( cubeDirections[ face ] );\r\n\t\t\t\t\tshadowCamera.up.copy( cubeUps[ face ] );\r\n\t\t\t\t\tshadowCamera.lookAt( _lookTarget );\r\n\r\n\t\t\t\t\tvar vpDimensions = cube2DViewPorts[ face ];\r\n\t\t\t\t\t_state.viewport( vpDimensions );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t_lookTarget.setFromMatrixPosition( light.target.matrixWorld );\r\n\t\t\t\t\tshadowCamera.lookAt( _lookTarget );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tshadowCamera.updateMatrixWorld();\r\n\t\t\t\tshadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );\r\n\r\n\t\t\t\t// compute shadow matrix\r\n\r\n\t\t\t\tshadowMatrix.set(\r\n\t\t\t\t\t0.5, 0.0, 0.0, 0.5,\r\n\t\t\t\t\t0.0, 0.5, 0.0, 0.5,\r\n\t\t\t\t\t0.0, 0.0, 0.5, 0.5,\r\n\t\t\t\t\t0.0, 0.0, 0.0, 1.0\r\n\t\t\t\t);\r\n\r\n\t\t\t\tshadowMatrix.multiply( shadowCamera.projectionMatrix );\r\n\t\t\t\tshadowMatrix.multiply( shadowCamera.matrixWorldInverse );\r\n\r\n\t\t\t\t// update camera matrices and frustum\r\n\r\n\t\t\t\t_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );\r\n\t\t\t\t_frustum.setFromMatrix( _projScreenMatrix );\r\n\r\n\t\t\t\t// set object matrices & frustum culling\r\n\r\n\t\t\t\t_renderList.length = 0;\r\n\r\n\t\t\t\tprojectObject( scene, camera, shadowCamera );\r\n\r\n\t\t\t\t// render shadow map\r\n\t\t\t\t// render regular objects\r\n\r\n\t\t\t\tfor ( var j = 0, jl = _renderList.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\tvar object = _renderList[ j ];\r\n\t\t\t\t\tvar geometry = _objects.update( object );\r\n\t\t\t\t\tvar material = object.material;\r\n\r\n\t\t\t\t\tif ( material instanceof THREE.MultiMaterial ) {\r\n\r\n\t\t\t\t\t\tvar groups = geometry.groups;\r\n\t\t\t\t\t\tvar materials = material.materials;\r\n\r\n\t\t\t\t\t\tfor ( var k = 0, kl = groups.length; k < kl; k ++ ) {\r\n\r\n\t\t\t\t\t\t\tvar group = groups[ k ];\r\n\t\t\t\t\t\t\tvar groupMaterial = materials[ group.materialIndex ];\r\n\r\n\t\t\t\t\t\t\tif ( groupMaterial.visible === true ) {\r\n\r\n\t\t\t\t\t\t\t\tvar depthMaterial = getDepthMaterial( object, groupMaterial, isPointLight, _lightPositionWorld );\r\n\t\t\t\t\t\t\t\t_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tvar depthMaterial = getDepthMaterial( object, material, isPointLight, _lightPositionWorld );\r\n\t\t\t\t\t\t_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// Restore GL state.\r\n\t\tvar clearColor = _renderer.getClearColor(),\r\n\t\tclearAlpha = _renderer.getClearAlpha();\r\n\t\t_renderer.setClearColor( clearColor, clearAlpha );\r\n\r\n\t\t_state.enable( _gl.BLEND );\r\n\r\n\t\tif ( scope.cullFace === THREE.CullFaceFront ) {\r\n\r\n\t\t\t_gl.cullFace( _gl.BACK );\r\n\r\n\t\t}\r\n\r\n\t\tscope.needsUpdate = false;\r\n\r\n\t};\r\n\r\n\tfunction getDepthMaterial( object, material, isPointLight, lightPositionWorld ) {\r\n\r\n\t\tvar geometry = object.geometry;\r\n\r\n\t\tvar result = null;\r\n\r\n\t\tvar materialVariants = _depthMaterials;\r\n\t\tvar customMaterial = object.customDepthMaterial;\r\n\r\n\t\tif ( isPointLight ) {\r\n\r\n\t\t\tmaterialVariants = _distanceMaterials;\r\n\t\t\tcustomMaterial = object.customDistanceMaterial;\r\n\r\n\t\t}\r\n\r\n\t\tif ( ! customMaterial ) {\r\n\r\n\t\t\tvar useMorphing = geometry.morphTargets !== undefined &&\r\n\t\t\t\t\tgeometry.morphTargets.length > 0 && material.morphTargets;\r\n\r\n\t\t\tvar useSkinning = object instanceof THREE.SkinnedMesh && material.skinning;\r\n\r\n\t\t\tvar variantIndex = 0;\r\n\r\n\t\t\tif ( useMorphing ) variantIndex |= _MorphingFlag;\r\n\t\t\tif ( useSkinning ) variantIndex |= _SkinningFlag;\r\n\r\n\t\t\tresult = materialVariants[ variantIndex ];\r\n\r\n\t\t} else {\r\n\r\n\t\t\tresult = customMaterial;\r\n\r\n\t\t}\r\n\r\n\t\tif ( _renderer.localClippingEnabled &&\r\n\t\t\t material.clipShadows === true &&\r\n\t\t\t\tmaterial.clippingPlanes.length !== 0 ) {\r\n\r\n\t\t\t// in this case we need a unique material instance reflecting the\r\n\t\t\t// appropriate state\r\n\r\n\t\t\tvar keyA = result.uuid, keyB = material.uuid;\r\n\r\n\t\t\tvar materialsForVariant = _materialCache[ keyA ];\r\n\r\n\t\t\tif ( materialsForVariant === undefined ) {\r\n\r\n\t\t\t\tmaterialsForVariant = {};\r\n\t\t\t\t_materialCache[ keyA ] = materialsForVariant;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar cachedMaterial = materialsForVariant[ keyB ];\r\n\r\n\t\t\tif ( cachedMaterial === undefined ) {\r\n\r\n\t\t\t\tcachedMaterial = result.clone();\r\n\t\t\t\tmaterialsForVariant[ keyB ] = cachedMaterial;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tresult = cachedMaterial;\r\n\r\n\t\t}\r\n\r\n\t\tresult.visible = material.visible;\r\n\t\tresult.wireframe = material.wireframe;\r\n\t\tresult.side = material.side;\r\n\t\tresult.clipShadows = material.clipShadows;\r\n\t\tresult.clippingPlanes = material.clippingPlanes;\r\n\t\tresult.wireframeLinewidth = material.wireframeLinewidth;\r\n\t\tresult.linewidth = material.linewidth;\r\n\r\n\t\tif ( isPointLight && result.uniforms.lightPos !== undefined ) {\r\n\r\n\t\t\tresult.uniforms.lightPos.value.copy( lightPositionWorld );\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n\tfunction projectObject( object, camera, shadowCamera ) {\r\n\r\n\t\tif ( object.visible === false ) return;\r\n\r\n\t\tif ( object.layers.test( camera.layers ) && ( object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Points ) ) {\r\n\r\n\t\t\tif ( object.castShadow && ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) ) {\r\n\r\n\t\t\t\tvar material = object.material;\r\n\r\n\t\t\t\tif ( material.visible === true ) {\r\n\r\n\t\t\t\t\tobject.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );\r\n\t\t\t\t\t_renderList.push( object );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar children = object.children;\r\n\r\n\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\r\n\r\n\t\t\tprojectObject( children[ i ], camera, shadowCamera );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/renderers/webgl/WebGLState.js\r\n\r\n/**\r\n* @author mrdoob / http://mrdoob.com/\r\n*/\r\n\r\nTHREE.WebGLState = function ( gl, extensions, paramThreeToGL ) {\r\n\r\n\tvar _this = this;\r\n\r\n\tvar color = new THREE.Vector4();\r\n\r\n\tvar maxVertexAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );\r\n\tvar newAttributes = new Uint8Array( maxVertexAttributes );\r\n\tvar enabledAttributes = new Uint8Array( maxVertexAttributes );\r\n\tvar attributeDivisors = new Uint8Array( maxVertexAttributes );\r\n\r\n\tvar capabilities = {};\r\n\r\n\tvar compressedTextureFormats = null;\r\n\r\n\tvar currentBlending = null;\r\n\tvar currentBlendEquation = null;\r\n\tvar currentBlendSrc = null;\r\n\tvar currentBlendDst = null;\r\n\tvar currentBlendEquationAlpha = null;\r\n\tvar currentBlendSrcAlpha = null;\r\n\tvar currentBlendDstAlpha = null;\r\n\tvar currentPremultipledAlpha = false;\r\n\r\n\tvar currentDepthFunc = null;\r\n\tvar currentDepthWrite = null;\r\n\r\n\tvar currentColorWrite = null;\r\n\r\n\tvar currentStencilWrite = null;\r\n\tvar currentStencilFunc = null;\r\n\tvar currentStencilRef = null;\r\n\tvar currentStencilMask = null;\r\n\tvar currentStencilFail  = null;\r\n\tvar currentStencilZFail = null;\r\n\tvar currentStencilZPass = null;\r\n\r\n\tvar currentFlipSided = null;\r\n\r\n\tvar currentLineWidth = null;\r\n\r\n\tvar currentPolygonOffsetFactor = null;\r\n\tvar currentPolygonOffsetUnits = null;\r\n\r\n\tvar currentScissorTest = null;\r\n\r\n\tvar maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );\r\n\r\n\tvar currentTextureSlot = undefined;\r\n\tvar currentBoundTextures = {};\r\n\r\n\tvar currentClearColor = new THREE.Vector4();\r\n\tvar currentClearDepth = null;\r\n\tvar currentClearStencil = null;\r\n\r\n\tvar currentScissor = new THREE.Vector4();\r\n\tvar currentViewport = new THREE.Vector4();\r\n\r\n\tthis.init = function () {\r\n\r\n\t\tthis.clearColor( 0, 0, 0, 1 );\r\n\t\tthis.clearDepth( 1 );\r\n\t\tthis.clearStencil( 0 );\r\n\r\n\t\tthis.enable( gl.DEPTH_TEST );\r\n\t\tgl.depthFunc( gl.LEQUAL );\r\n\r\n\t\tgl.frontFace( gl.CCW );\r\n\t\tgl.cullFace( gl.BACK );\r\n\t\tthis.enable( gl.CULL_FACE );\r\n\r\n\t\tthis.enable( gl.BLEND );\r\n\t\tgl.blendEquation( gl.FUNC_ADD );\r\n\t\tgl.blendFunc( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA );\r\n\r\n\t};\r\n\r\n\tthis.initAttributes = function () {\r\n\r\n\t\tfor ( var i = 0, l = newAttributes.length; i < l; i ++ ) {\r\n\r\n\t\t\tnewAttributes[ i ] = 0;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.enableAttribute = function ( attribute ) {\r\n\r\n\t\tnewAttributes[ attribute ] = 1;\r\n\r\n\t\tif ( enabledAttributes[ attribute ] === 0 ) {\r\n\r\n\t\t\tgl.enableVertexAttribArray( attribute );\r\n\t\t\tenabledAttributes[ attribute ] = 1;\r\n\r\n\t\t}\r\n\r\n\t\tif ( attributeDivisors[ attribute ] !== 0 ) {\r\n\r\n\t\t\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\r\n\r\n\t\t\textension.vertexAttribDivisorANGLE( attribute, 0 );\r\n\t\t\tattributeDivisors[ attribute ] = 0;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.enableAttributeAndDivisor = function ( attribute, meshPerAttribute, extension ) {\r\n\r\n\t\tnewAttributes[ attribute ] = 1;\r\n\r\n\t\tif ( enabledAttributes[ attribute ] === 0 ) {\r\n\r\n\t\t\tgl.enableVertexAttribArray( attribute );\r\n\t\t\tenabledAttributes[ attribute ] = 1;\r\n\r\n\t\t}\r\n\r\n\t\tif ( attributeDivisors[ attribute ] !== meshPerAttribute ) {\r\n\r\n\t\t\textension.vertexAttribDivisorANGLE( attribute, meshPerAttribute );\r\n\t\t\tattributeDivisors[ attribute ] = meshPerAttribute;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.disableUnusedAttributes = function () {\r\n\r\n\t\tfor ( var i = 0, l = enabledAttributes.length; i < l; i ++ ) {\r\n\r\n\t\t\tif ( enabledAttributes[ i ] !== newAttributes[ i ] ) {\r\n\r\n\t\t\t\tgl.disableVertexAttribArray( i );\r\n\t\t\t\tenabledAttributes[ i ] = 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.enable = function ( id ) {\r\n\r\n\t\tif ( capabilities[ id ] !== true ) {\r\n\r\n\t\t\tgl.enable( id );\r\n\t\t\tcapabilities[ id ] = true;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.disable = function ( id ) {\r\n\r\n\t\tif ( capabilities[ id ] !== false ) {\r\n\r\n\t\t\tgl.disable( id );\r\n\t\t\tcapabilities[ id ] = false;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.getCompressedTextureFormats = function () {\r\n\r\n\t\tif ( compressedTextureFormats === null ) {\r\n\r\n\t\t\tcompressedTextureFormats = [];\r\n\r\n\t\t\tif ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) ||\r\n\t\t\t     extensions.get( 'WEBGL_compressed_texture_s3tc' ) ||\r\n\t\t\t     extensions.get( 'WEBGL_compressed_texture_etc1' ) ) {\r\n\r\n\t\t\t\tvar formats = gl.getParameter( gl.COMPRESSED_TEXTURE_FORMATS );\r\n\r\n\t\t\t\tfor ( var i = 0; i < formats.length; i ++ ) {\r\n\r\n\t\t\t\t\tcompressedTextureFormats.push( formats[ i ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn compressedTextureFormats;\r\n\r\n\t};\r\n\r\n\tthis.setBlending = function ( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {\r\n\r\n\t\tif ( blending === THREE.NoBlending ) {\r\n\r\n\t\t\tthis.disable( gl.BLEND );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.enable( gl.BLEND );\r\n\r\n\t\t}\r\n\r\n\t\tif ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {\r\n\r\n\t\t\tif ( blending === THREE.AdditiveBlending ) {\r\n\r\n\t\t\t\tif ( premultipliedAlpha ) {\r\n\r\n\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\r\n\t\t\t\t\tgl.blendFuncSeparate( gl.ONE, gl.ONE, gl.ONE, gl.ONE );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\r\n\t\t\t\t\tgl.blendFunc( gl.SRC_ALPHA, gl.ONE );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( blending === THREE.SubtractiveBlending ) {\r\n\r\n\t\t\t\tif ( premultipliedAlpha ) {\r\n\r\n\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\r\n\t\t\t\t\tgl.blendFuncSeparate( gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\r\n\t\t\t\t\tgl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( blending === THREE.MultiplyBlending ) {\r\n\r\n\t\t\t\tif ( premultipliedAlpha ) {\r\n\r\n\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\r\n\t\t\t\t\tgl.blendFuncSeparate( gl.ZERO, gl.ZERO, gl.SRC_COLOR, gl.SRC_ALPHA );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\r\n\t\t\t\t\tgl.blendFunc( gl.ZERO, gl.SRC_COLOR );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tif ( premultipliedAlpha ) {\r\n\r\n\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\r\n\t\t\t\t\tgl.blendFuncSeparate( gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\r\n\t\t\t\t\tgl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tcurrentBlending = blending;\r\n\t\t\tcurrentPremultipledAlpha = premultipliedAlpha;\r\n\r\n\t\t}\r\n\r\n\t\tif ( blending === THREE.CustomBlending ) {\r\n\r\n\t\t\tblendEquationAlpha = blendEquationAlpha || blendEquation;\r\n\t\t\tblendSrcAlpha = blendSrcAlpha || blendSrc;\r\n\t\t\tblendDstAlpha = blendDstAlpha || blendDst;\r\n\r\n\t\t\tif ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {\r\n\r\n\t\t\t\tgl.blendEquationSeparate( paramThreeToGL( blendEquation ), paramThreeToGL( blendEquationAlpha ) );\r\n\r\n\t\t\t\tcurrentBlendEquation = blendEquation;\r\n\t\t\t\tcurrentBlendEquationAlpha = blendEquationAlpha;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {\r\n\r\n\t\t\t\tgl.blendFuncSeparate( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ), paramThreeToGL( blendSrcAlpha ), paramThreeToGL( blendDstAlpha ) );\r\n\r\n\t\t\t\tcurrentBlendSrc = blendSrc;\r\n\t\t\t\tcurrentBlendDst = blendDst;\r\n\t\t\t\tcurrentBlendSrcAlpha = blendSrcAlpha;\r\n\t\t\t\tcurrentBlendDstAlpha = blendDstAlpha;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tcurrentBlendEquation = null;\r\n\t\t\tcurrentBlendSrc = null;\r\n\t\t\tcurrentBlendDst = null;\r\n\t\t\tcurrentBlendEquationAlpha = null;\r\n\t\t\tcurrentBlendSrcAlpha = null;\r\n\t\t\tcurrentBlendDstAlpha = null;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.setDepthFunc = function ( depthFunc ) {\r\n\r\n\t\tif ( currentDepthFunc !== depthFunc ) {\r\n\r\n\t\t\tif ( depthFunc ) {\r\n\r\n\t\t\t\tswitch ( depthFunc ) {\r\n\r\n\t\t\t\t\tcase THREE.NeverDepth:\r\n\r\n\t\t\t\t\t\tgl.depthFunc( gl.NEVER );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase THREE.AlwaysDepth:\r\n\r\n\t\t\t\t\t\tgl.depthFunc( gl.ALWAYS );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase THREE.LessDepth:\r\n\r\n\t\t\t\t\t\tgl.depthFunc( gl.LESS );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase THREE.LessEqualDepth:\r\n\r\n\t\t\t\t\t\tgl.depthFunc( gl.LEQUAL );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase THREE.EqualDepth:\r\n\r\n\t\t\t\t\t\tgl.depthFunc( gl.EQUAL );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase THREE.GreaterEqualDepth:\r\n\r\n\t\t\t\t\t\tgl.depthFunc( gl.GEQUAL );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase THREE.GreaterDepth:\r\n\r\n\t\t\t\t\t\tgl.depthFunc( gl.GREATER );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase THREE.NotEqualDepth:\r\n\r\n\t\t\t\t\t\tgl.depthFunc( gl.NOTEQUAL );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tdefault:\r\n\r\n\t\t\t\t\t\tgl.depthFunc( gl.LEQUAL );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tgl.depthFunc( gl.LEQUAL );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tcurrentDepthFunc = depthFunc;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.setDepthTest = function ( depthTest ) {\r\n\r\n\t\tif ( depthTest ) {\r\n\r\n\t\t\tthis.enable( gl.DEPTH_TEST );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.disable( gl.DEPTH_TEST );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.setDepthWrite = function ( depthWrite ) {\r\n\r\n\t\t// TODO: Rename to setDepthMask\r\n\r\n\t\tif ( currentDepthWrite !== depthWrite ) {\r\n\r\n\t\t\tgl.depthMask( depthWrite );\r\n\t\t\tcurrentDepthWrite = depthWrite;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.setColorWrite = function ( colorWrite ) {\r\n\r\n\t\t// TODO: Rename to setColorMask\r\n\r\n\t\tif ( currentColorWrite !== colorWrite ) {\r\n\r\n\t\t\tgl.colorMask( colorWrite, colorWrite, colorWrite, colorWrite );\r\n\t\t\tcurrentColorWrite = colorWrite;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.setStencilFunc = function ( stencilFunc, stencilRef, stencilMask ) {\r\n\r\n\t\tif ( currentStencilFunc !== stencilFunc ||\r\n\t\t\t\t currentStencilRef \t!== stencilRef \t||\r\n\t\t\t\t currentStencilMask !== stencilMask ) {\r\n\r\n\t\t\tgl.stencilFunc( stencilFunc,  stencilRef, stencilMask );\r\n\r\n\t\t\tcurrentStencilFunc = stencilFunc;\r\n\t\t\tcurrentStencilRef  = stencilRef;\r\n\t\t\tcurrentStencilMask = stencilMask;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.setStencilOp = function ( stencilFail, stencilZFail, stencilZPass ) {\r\n\r\n\t\tif ( currentStencilFail\t !== stencilFail \t||\r\n\t\t\t\t currentStencilZFail !== stencilZFail ||\r\n\t\t\t\t currentStencilZPass !== stencilZPass ) {\r\n\r\n\t\t\tgl.stencilOp( stencilFail,  stencilZFail, stencilZPass );\r\n\r\n\t\t\tcurrentStencilFail  = stencilFail;\r\n\t\t\tcurrentStencilZFail = stencilZFail;\r\n\t\t\tcurrentStencilZPass = stencilZPass;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.setStencilTest = function ( stencilTest ) {\r\n\r\n\t\tif ( stencilTest ) {\r\n\r\n\t\t\tthis.enable( gl.STENCIL_TEST );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.disable( gl.STENCIL_TEST );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.setStencilWrite = function ( stencilWrite ) {\r\n\r\n\t\t// TODO: Rename to setStencilMask\r\n\r\n\t\tif ( currentStencilWrite !== stencilWrite ) {\r\n\r\n\t\t\tgl.stencilMask( stencilWrite );\r\n\t\t\tcurrentStencilWrite = stencilWrite;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.setFlipSided = function ( flipSided ) {\r\n\r\n\t\tif ( currentFlipSided !== flipSided ) {\r\n\r\n\t\t\tif ( flipSided ) {\r\n\r\n\t\t\t\tgl.frontFace( gl.CW );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tgl.frontFace( gl.CCW );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tcurrentFlipSided = flipSided;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.setLineWidth = function ( width ) {\r\n\r\n\t\tif ( width !== currentLineWidth ) {\r\n\r\n\t\t\tgl.lineWidth( width );\r\n\r\n\t\t\tcurrentLineWidth = width;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.setPolygonOffset = function ( polygonOffset, factor, units ) {\r\n\r\n\t\tif ( polygonOffset ) {\r\n\r\n\t\t\tthis.enable( gl.POLYGON_OFFSET_FILL );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.disable( gl.POLYGON_OFFSET_FILL );\r\n\r\n\t\t}\r\n\r\n\t\tif ( polygonOffset && ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) ) {\r\n\r\n\t\t\tgl.polygonOffset( factor, units );\r\n\r\n\t\t\tcurrentPolygonOffsetFactor = factor;\r\n\t\t\tcurrentPolygonOffsetUnits = units;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.getScissorTest = function () {\r\n\r\n\t\treturn currentScissorTest;\r\n\r\n\t};\r\n\r\n\tthis.setScissorTest = function ( scissorTest ) {\r\n\r\n\t\tcurrentScissorTest = scissorTest;\r\n\r\n\t\tif ( scissorTest ) {\r\n\r\n\t\t\tthis.enable( gl.SCISSOR_TEST );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.disable( gl.SCISSOR_TEST );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t// texture\r\n\r\n\tthis.activeTexture = function ( webglSlot ) {\r\n\r\n\t\tif ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;\r\n\r\n\t\tif ( currentTextureSlot !== webglSlot ) {\r\n\r\n\t\t\tgl.activeTexture( webglSlot );\r\n\t\t\tcurrentTextureSlot = webglSlot;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.bindTexture = function ( webglType, webglTexture ) {\r\n\r\n\t\tif ( currentTextureSlot === undefined ) {\r\n\r\n\t\t\t_this.activeTexture();\r\n\r\n\t\t}\r\n\r\n\t\tvar boundTexture = currentBoundTextures[ currentTextureSlot ];\r\n\r\n\t\tif ( boundTexture === undefined ) {\r\n\r\n\t\t\tboundTexture = { type: undefined, texture: undefined };\r\n\t\t\tcurrentBoundTextures[ currentTextureSlot ] = boundTexture;\r\n\r\n\t\t}\r\n\r\n\t\tif ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {\r\n\r\n\t\t\tgl.bindTexture( webglType, webglTexture );\r\n\r\n\t\t\tboundTexture.type = webglType;\r\n\t\t\tboundTexture.texture = webglTexture;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.compressedTexImage2D = function () {\r\n\r\n\t\ttry {\r\n\r\n\t\t\tgl.compressedTexImage2D.apply( gl, arguments );\r\n\r\n\t\t} catch ( error ) {\r\n\r\n\t\t\tconsole.error( error );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.texImage2D = function () {\r\n\r\n\t\ttry {\r\n\r\n\t\t\tgl.texImage2D.apply( gl, arguments );\r\n\r\n\t\t} catch ( error ) {\r\n\r\n\t\t\tconsole.error( error );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t// clear values\r\n\r\n\tthis.clearColor = function ( r, g, b, a ) {\r\n\r\n\t\tcolor.set( r, g, b, a );\r\n\r\n\t\tif ( currentClearColor.equals( color ) === false ) {\r\n\r\n\t\t\tgl.clearColor( r, g, b, a );\r\n\t\t\tcurrentClearColor.copy( color );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.clearDepth = function ( depth ) {\r\n\r\n\t\tif ( currentClearDepth !== depth ) {\r\n\r\n\t\t\tgl.clearDepth( depth );\r\n\t\t\tcurrentClearDepth = depth;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.clearStencil = function ( stencil ) {\r\n\r\n\t\tif ( currentClearStencil !== stencil ) {\r\n\r\n\t\t\tgl.clearStencil( stencil );\r\n\t\t\tcurrentClearStencil = stencil;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t//\r\n\r\n\tthis.scissor = function ( scissor ) {\r\n\r\n\t\tif ( currentScissor.equals( scissor ) === false ) {\r\n\r\n\t\t\tgl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );\r\n\t\t\tcurrentScissor.copy( scissor );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.viewport = function ( viewport ) {\r\n\r\n\t\tif ( currentViewport.equals( viewport ) === false ) {\r\n\r\n\t\t\tgl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );\r\n\t\t\tcurrentViewport.copy( viewport );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t//\r\n\r\n\tthis.reset = function () {\r\n\r\n\t\tfor ( var i = 0; i < enabledAttributes.length; i ++ ) {\r\n\r\n\t\t\tif ( enabledAttributes[ i ] === 1 ) {\r\n\r\n\t\t\t\tgl.disableVertexAttribArray( i );\r\n\t\t\t\tenabledAttributes[ i ] = 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tcapabilities = {};\r\n\r\n\t\tcompressedTextureFormats = null;\r\n\r\n\t\tcurrentTextureSlot = undefined;\r\n\t\tcurrentBoundTextures = {};\r\n\r\n\t\tcurrentBlending = null;\r\n\r\n\t\tcurrentColorWrite = null;\r\n\t\tcurrentDepthWrite = null;\r\n\t\tcurrentStencilWrite = null;\r\n\r\n\t\tcurrentFlipSided = null;\r\n\r\n\t};\r\n\r\n};\r\n\r\n// File:src/renderers/webgl/WebGLUniforms.js\r\n\r\n/**\r\n *\r\n * Uniforms of a program.\r\n * Those form a tree structure with a special top-level container for the root,\r\n * which you get by calling 'new WebGLUniforms( gl, program, renderer )'.\r\n *\r\n *\r\n * Properties of inner nodes including the top-level container:\r\n *\r\n * .seq - array of nested uniforms\r\n * .map - nested uniforms by name\r\n *\r\n *\r\n * Methods of all nodes except the top-level container:\r\n *\r\n * .setValue( gl, value, [renderer] )\r\n *\r\n * \t\tuploads a uniform value(s)\r\n *  \tthe 'renderer' parameter is needed for sampler uniforms\r\n *\r\n *\r\n * Static methods of the top-level container (renderer factorizations):\r\n *\r\n * .upload( gl, seq, values, renderer )\r\n *\r\n * \t\tsets uniforms in 'seq' to 'values[id].value'\r\n *\r\n * .seqWithValue( seq, values ) : filteredSeq\r\n *\r\n * \t\tfilters 'seq' entries with corresponding entry in values\r\n *\r\n * .splitDynamic( seq, values ) : filteredSeq\r\n *\r\n * \t\tfilters 'seq' entries with dynamic entry and removes them from 'seq'\r\n *\r\n *\r\n * Methods of the top-level container (renderer factorizations):\r\n *\r\n * .setValue( gl, name, value )\r\n *\r\n * \t\tsets uniform with  name 'name' to 'value'\r\n *\r\n * .set( gl, obj, prop )\r\n *\r\n * \t\tsets uniform from object and property with same name than uniform\r\n *\r\n * .setOptional( gl, obj, prop )\r\n *\r\n * \t\tlike .set for an optional property of the object\r\n *\r\n *\r\n * @author tschw\r\n *\r\n */\r\n\r\nTHREE.WebGLUniforms = ( function() { // scope\r\n\r\n\t// --- Base for inner nodes (including the root) ---\r\n\r\n\tvar UniformContainer = function() {\r\n\r\n\t\t\tthis.seq = [];\r\n\t\t\tthis.map = {};\r\n\r\n\t\t},\r\n\r\n\t// --- Utilities ---\r\n\r\n\t// Array Caches (provide typed arrays for temporary by size)\r\n\r\n\t\tarrayCacheF32 = [],\r\n\t\tarrayCacheI32 = [],\r\n\r\n\t\tuncacheTemporaryArrays = function() {\r\n\r\n\t\t\tarrayCacheF32.length = 0;\r\n\t\t\tarrayCacheI32.length = 0;\r\n\r\n\t\t},\r\n\r\n\t// Flattening for arrays of vectors and matrices\r\n\r\n\t\tflatten = function( array, nBlocks, blockSize ) {\r\n\r\n\t\t\tvar firstElem = array[ 0 ];\r\n\r\n\t\t\tif ( firstElem <= 0 || firstElem > 0 ) return array;\r\n\t\t\t// unoptimized: ! isNaN( firstElem )\r\n\t\t\t// see http://jacksondunstan.com/articles/983\r\n\r\n\t\t\tvar n = nBlocks * blockSize,\r\n\t\t\t\tr = arrayCacheF32[ n ];\r\n\r\n\t\t\tif ( r === undefined ) {\r\n\r\n\t\t\t\tr = new Float32Array( n );\r\n\t\t\t\tarrayCacheF32[ n ] = r;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( nBlocks !== 0 ) {\r\n\r\n\t\t\t\tfirstElem.toArray( r, 0 );\r\n\r\n\t\t\t\tfor ( var i = 1, offset = 0; i !== nBlocks; ++ i ) {\r\n\r\n\t\t\t\t\toffset += blockSize;\r\n\t\t\t\t\tarray[ i ].toArray( r, offset );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn r;\r\n\r\n\t\t},\r\n\r\n\t// Texture unit allocation\r\n\r\n\t\tallocTexUnits = function( renderer, n ) {\r\n\r\n\t\t\tvar r = arrayCacheI32[ n ];\r\n\r\n\t\t\tif ( r === undefined ) {\r\n\r\n\t\t\t\tr = new Int32Array( n );\r\n\t\t\t\tarrayCacheI32[ n ] = r;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var i = 0; i !== n; ++ i )\r\n\t\t\t\tr[ i ] = renderer.allocTextureUnit();\r\n\r\n\t\t\treturn r;\r\n\r\n\t\t},\r\n\r\n\t// --- Setters ---\r\n\r\n\t// Note: Defining these methods externally, because they come in a bunch\r\n\t// and this way their names minify.\r\n\r\n\t\t// Single scalar\r\n\r\n\t\tsetValue1f = function( gl, v ) { gl.uniform1f( this.addr, v ); },\r\n\t\tsetValue1i = function( gl, v ) { gl.uniform1i( this.addr, v ); },\r\n\r\n\t\t// Single float vector (from flat array or THREE.VectorN)\r\n\r\n\t\tsetValue2fv = function( gl, v ) {\r\n\r\n\t\t\tif ( v.x === undefined ) gl.uniform2fv( this.addr, v );\r\n\t\t\telse gl.uniform2f( this.addr, v.x, v.y );\r\n\r\n\t\t},\r\n\r\n\t\tsetValue3fv = function( gl, v ) {\r\n\r\n\t\t\tif ( v.x !== undefined )\r\n\t\t\t\tgl.uniform3f( this.addr, v.x, v.y, v.z );\r\n\t\t\telse if ( v.r !== undefined )\r\n\t\t\t\tgl.uniform3f( this.addr, v.r, v.g, v.b );\r\n\t\t\telse\r\n\t\t\t\tgl.uniform3fv( this.addr, v );\r\n\r\n\t\t},\r\n\r\n\t\tsetValue4fv = function( gl, v ) {\r\n\r\n\t\t\tif ( v.x === undefined ) gl.uniform4fv( this.addr, v );\r\n\t\t\telse gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );\r\n\r\n\t\t},\r\n\r\n\t\t// Single matrix (from flat array or MatrixN)\r\n\r\n\t\tsetValue2fm = function( gl, v ) {\r\n\r\n\t\t\tgl.uniformMatrix2fv( this.addr, false, v.elements || v );\r\n\r\n\t\t},\r\n\r\n\t\tsetValue3fm = function( gl, v ) {\r\n\r\n\t\t\tgl.uniformMatrix3fv( this.addr, false, v.elements || v );\r\n\r\n\t\t},\r\n\r\n\t\tsetValue4fm = function( gl, v ) {\r\n\r\n\t\t\tgl.uniformMatrix4fv( this.addr, false, v.elements || v );\r\n\r\n\t\t},\r\n\r\n\t\t// Single texture (2D / Cube)\r\n\r\n\t\tsetValueT1 = function( gl, v, renderer ) {\r\n\r\n\t\t\tvar unit = renderer.allocTextureUnit();\r\n\t\t\tgl.uniform1i( this.addr, unit );\r\n\t\t\tif ( v ) renderer.setTexture2D( v, unit );\r\n\r\n\t\t},\r\n\r\n\t\tsetValueT6 = function( gl, v, renderer ) {\r\n\r\n\t\t\tvar unit = renderer.allocTextureUnit();\r\n\t\t\tgl.uniform1i( this.addr, unit );\r\n\t\t\tif ( v ) renderer.setTextureCube( v, unit );\r\n\r\n\t\t},\r\n\r\n\t\t// Integer / Boolean vectors or arrays thereof (always flat arrays)\r\n\r\n\t\tsetValue2iv = function( gl, v ) { gl.uniform2iv( this.addr, v ); },\r\n\t\tsetValue3iv = function( gl, v ) { gl.uniform3iv( this.addr, v ); },\r\n\t\tsetValue4iv = function( gl, v ) { gl.uniform4iv( this.addr, v ); },\r\n\r\n\t\t// Helper to pick the right setter for the singular case\r\n\r\n\t\tgetSingularSetter = function( type ) {\r\n\r\n\t\t\tswitch ( type ) {\r\n\r\n\t\t\t\tcase 0x1406: return setValue1f; // FLOAT\r\n\t\t\t\tcase 0x8b50: return setValue2fv; // _VEC2\r\n\t\t\t\tcase 0x8b51: return setValue3fv; // _VEC3\r\n\t\t\t\tcase 0x8b52: return setValue4fv; // _VEC4\r\n\r\n\t\t\t\tcase 0x8b5a: return setValue2fm; // _MAT2\r\n\t\t\t\tcase 0x8b5b: return setValue3fm; // _MAT3\r\n\t\t\t\tcase 0x8b5c: return setValue4fm; // _MAT4\r\n\r\n\t\t\t\tcase 0x8b5e: return setValueT1; // SAMPLER_2D\r\n\t\t\t\tcase 0x8b60: return setValueT6; // SAMPLER_CUBE\r\n\r\n\t\t\t\tcase 0x1404: case 0x8b56: return setValue1i; // INT, BOOL\r\n\t\t\t\tcase 0x8b53: case 0x8b57: return setValue2iv; // _VEC2\r\n\t\t\t\tcase 0x8b54: case 0x8b58: return setValue3iv; // _VEC3\r\n\t\t\t\tcase 0x8b55: case 0x8b59: return setValue4iv; // _VEC4\r\n\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\t// Array of scalars\r\n\r\n\t\tsetValue1fv = function( gl, v ) { gl.uniform1fv( this.addr, v ); },\r\n\t\tsetValue1iv = function( gl, v ) { gl.uniform1iv( this.addr, v ); },\r\n\r\n\t\t// Array of vectors (flat or from THREE classes)\r\n\r\n\t\tsetValueV2a = function( gl, v ) {\r\n\r\n\t\t\tgl.uniform2fv( this.addr, flatten( v, this.size, 2 ) );\r\n\r\n\t\t},\r\n\r\n\t\tsetValueV3a = function( gl, v ) {\r\n\r\n\t\t\tgl.uniform3fv( this.addr, flatten( v, this.size, 3 ) );\r\n\r\n\t\t},\r\n\r\n\t\tsetValueV4a = function( gl, v ) {\r\n\r\n\t\t\tgl.uniform4fv( this.addr, flatten( v, this.size, 4 ) );\r\n\r\n\t\t},\r\n\r\n\t\t// Array of matrices (flat or from THREE clases)\r\n\r\n\t\tsetValueM2a = function( gl, v ) {\r\n\r\n\t\t\tgl.uniformMatrix2fv( this.addr, false, flatten( v, this.size, 4 ) );\r\n\r\n\t\t},\r\n\r\n\t\tsetValueM3a = function( gl, v ) {\r\n\r\n\t\t\tgl.uniformMatrix3fv( this.addr, false, flatten( v, this.size, 9 ) );\r\n\r\n\t\t},\r\n\r\n\t\tsetValueM4a = function( gl, v ) {\r\n\r\n\t\t\tgl.uniformMatrix4fv( this.addr, false, flatten( v, this.size, 16 ) );\r\n\r\n\t\t},\r\n\r\n\t\t// Array of textures (2D / Cube)\r\n\r\n\t\tsetValueT1a = function( gl, v, renderer ) {\r\n\r\n\t\t\tvar n = v.length,\r\n\t\t\t\tunits = allocTexUnits( renderer, n );\r\n\r\n\t\t\tgl.uniform1iv( this.addr, units );\r\n\r\n\t\t\tfor ( var i = 0; i !== n; ++ i ) {\r\n\r\n\t\t\t\tvar tex = v[ i ];\r\n\t\t\t\tif ( tex ) renderer.setTexture2D( tex, units[ i ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\tsetValueT6a = function( gl, v, renderer ) {\r\n\r\n\t\t\tvar n = v.length,\r\n\t\t\t\tunits = allocTexUnits( renderer, n );\r\n\r\n\t\t\tgl.uniform1iv( this.addr, units );\r\n\r\n\t\t\tfor ( var i = 0; i !== n; ++ i ) {\r\n\r\n\t\t\t\tvar tex = v[ i ];\r\n\t\t\t\tif ( tex ) renderer.setTextureCube( tex, units[ i ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\r\n\t\t// Helper to pick the right setter for a pure (bottom-level) array\r\n\r\n\t\tgetPureArraySetter = function( type ) {\r\n\r\n\t\t\tswitch ( type ) {\r\n\r\n\t\t\t\tcase 0x1406: return setValue1fv; // FLOAT\r\n\t\t\t\tcase 0x8b50: return setValueV2a; // _VEC2\r\n\t\t\t\tcase 0x8b51: return setValueV3a; // _VEC3\r\n\t\t\t\tcase 0x8b52: return setValueV4a; // _VEC4\r\n\r\n\t\t\t\tcase 0x8b5a: return setValueM2a; // _MAT2\r\n\t\t\t\tcase 0x8b5b: return setValueM3a; // _MAT3\r\n\t\t\t\tcase 0x8b5c: return setValueM4a; // _MAT4\r\n\r\n\t\t\t\tcase 0x8b5e: return setValueT1a; // SAMPLER_2D\r\n\t\t\t\tcase 0x8b60: return setValueT6a; // SAMPLER_CUBE\r\n\r\n\t\t\t\tcase 0x1404: case 0x8b56: return setValue1iv; // INT, BOOL\r\n\t\t\t\tcase 0x8b53: case 0x8b57: return setValue2iv; // _VEC2\r\n\t\t\t\tcase 0x8b54: case 0x8b58: return setValue3iv; // _VEC3\r\n\t\t\t\tcase 0x8b55: case 0x8b59: return setValue4iv; // _VEC4\r\n\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t// --- Uniform Classes ---\r\n\r\n\t\tSingleUniform = function SingleUniform( id, activeInfo, addr ) {\r\n\r\n\t\t\tthis.id = id;\r\n\t\t\tthis.addr = addr;\r\n\t\t\tthis.setValue = getSingularSetter( activeInfo.type );\r\n\r\n\t\t\t// this.path = activeInfo.name; // DEBUG\r\n\r\n\t\t},\r\n\r\n\t\tPureArrayUniform = function( id, activeInfo, addr ) {\r\n\r\n\t\t\tthis.id = id;\r\n\t\t\tthis.addr = addr;\r\n\t\t\tthis.size = activeInfo.size;\r\n\t\t\tthis.setValue = getPureArraySetter( activeInfo.type );\r\n\r\n\t\t\t// this.path = activeInfo.name; // DEBUG\r\n\r\n\t\t},\r\n\r\n\t\tStructuredUniform = function( id ) {\r\n\r\n\t\t\tthis.id = id;\r\n\r\n\t\t\tUniformContainer.call( this ); // mix-in\r\n\r\n\t\t};\r\n\r\n\tStructuredUniform.prototype.setValue = function( gl, value ) {\r\n\r\n\t\t// Note: Don't need an extra 'renderer' parameter, since samplers\r\n\t\t// are not allowed in structured uniforms.\r\n\r\n\t\tvar seq = this.seq;\r\n\r\n\t\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\r\n\r\n\t\t\tvar u = seq[ i ];\r\n\t\t\tu.setValue( gl, value[ u.id ] );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t// --- Top-level ---\r\n\r\n\t// Parser - builds up the property tree from the path strings\r\n\r\n\tvar RePathPart = /([\\w\\d_]+)(\\])?(\\[|\\.)?/g,\r\n\t\t// extracts\r\n\t\t// \t- the identifier (member name or array index)\r\n\t\t//  - followed by an optional right bracket (found when array index)\r\n\t\t//  - followed by an optional left bracket or dot (type of subscript)\r\n\t\t//\r\n\t\t// Note: These portions can be read in a non-overlapping fashion and\r\n\t\t// allow straightforward parsing of the hierarchy that WebGL encodes\r\n\t\t// in the uniform names.\r\n\r\n\t\taddUniform = function( container, uniformObject ) {\r\n\r\n\t\t\tcontainer.seq.push( uniformObject );\r\n\t\t\tcontainer.map[ uniformObject.id ] = uniformObject;\r\n\r\n\t\t},\r\n\r\n\t\tparseUniform = function( activeInfo, addr, container ) {\r\n\r\n\t\t\tvar path = activeInfo.name,\r\n\t\t\t\tpathLength = path.length;\r\n\r\n\t\t\t// reset RegExp object, because of the early exit of a previous run\r\n\t\t\tRePathPart.lastIndex = 0;\r\n\r\n\t\t\tfor (; ;) {\r\n\r\n\t\t\t\tvar match = RePathPart.exec( path ),\r\n\t\t\t\t\tmatchEnd = RePathPart.lastIndex,\r\n\r\n\t\t\t\t\tid = match[ 1 ],\r\n\t\t\t\t\tidIsIndex = match[ 2 ] === ']',\r\n\t\t\t\t\tsubscript = match[ 3 ];\r\n\r\n\t\t\t\tif ( idIsIndex ) id = id | 0; // convert to integer\r\n\r\n\t\t\t\tif ( subscript === undefined ||\r\n\t\t\t\t\t\tsubscript === '[' && matchEnd + 2 === pathLength ) {\r\n\t\t\t\t\t// bare name or \"pure\" bottom-level array \"[0]\" suffix\r\n\r\n\t\t\t\t\taddUniform( container, subscript === undefined ?\r\n\t\t\t\t\t\t\tnew SingleUniform( id, activeInfo, addr ) :\r\n\t\t\t\t\t\t\tnew PureArrayUniform( id, activeInfo, addr ) );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// step into inner node / create it in case it doesn't exist\r\n\r\n\t\t\t\t\tvar map = container.map,\r\n\t\t\t\t\t\tnext = map[ id ];\r\n\r\n\t\t\t\t\tif ( next === undefined ) {\r\n\r\n\t\t\t\t\t\tnext = new StructuredUniform( id );\r\n\t\t\t\t\t\taddUniform( container, next );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tcontainer = next;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t// Root Container\r\n\r\n\t\tWebGLUniforms = function WebGLUniforms( gl, program, renderer ) {\r\n\r\n\t\t\tUniformContainer.call( this );\r\n\r\n\t\t\tthis.renderer = renderer;\r\n\r\n\t\t\tvar n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );\r\n\r\n\t\t\tfor ( var i = 0; i !== n; ++ i ) {\r\n\r\n\t\t\t\tvar info = gl.getActiveUniform( program, i ),\r\n\t\t\t\t\tpath = info.name,\r\n\t\t\t\t\taddr = gl.getUniformLocation( program, path );\r\n\r\n\t\t\t\tparseUniform( info, addr, this );\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\r\n\tWebGLUniforms.prototype.setValue = function( gl, name, value ) {\r\n\r\n\t\tvar u = this.map[ name ];\r\n\r\n\t\tif ( u !== undefined ) u.setValue( gl, value, this.renderer );\r\n\r\n\t};\r\n\r\n\tWebGLUniforms.prototype.set = function( gl, object, name ) {\r\n\r\n\t\tvar u = this.map[ name ];\r\n\r\n\t\tif ( u !== undefined ) u.setValue( gl, object[ name ], this.renderer );\r\n\r\n\t};\r\n\r\n\tWebGLUniforms.prototype.setOptional = function( gl, object, name ) {\r\n\r\n\t\tvar v = object[ name ];\r\n\r\n\t\tif ( v !== undefined ) this.setValue( gl, name, v );\r\n\r\n\t};\r\n\r\n\r\n\t// Static interface\r\n\r\n\tWebGLUniforms.upload = function( gl, seq, values, renderer ) {\r\n\r\n\t\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\r\n\r\n\t\t\tvar u = seq[ i ],\r\n\t\t\t\tv = values[ u.id ];\r\n\r\n\t\t\tif ( v.needsUpdate !== false ) {\r\n\t\t\t\t// note: always updating when .needsUpdate is undefined\r\n\r\n\t\t\t\tu.setValue( gl, v.value, renderer );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tWebGLUniforms.seqWithValue = function( seq, values ) {\r\n\r\n\t\tvar r = [];\r\n\r\n\t\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\r\n\r\n\t\t\tvar u = seq[ i ];\r\n\t\t\tif ( u.id in values ) r.push( u );\r\n\r\n\t\t}\r\n\r\n\t\treturn r;\r\n\r\n\t};\r\n\r\n\tWebGLUniforms.splitDynamic = function( seq, values ) {\r\n\r\n\t\tvar r = null,\r\n\t\t\tn = seq.length,\r\n\t\t\tw = 0;\r\n\r\n\t\tfor ( var i = 0; i !== n; ++ i ) {\r\n\r\n\t\t\tvar u = seq[ i ],\r\n\t\t\t\tv = values[ u.id ];\r\n\r\n\t\t\tif ( v && v.dynamic === true ) {\r\n\r\n\t\t\t\tif ( r === null ) r = [];\r\n\t\t\t\tr.push( u );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// in-place compact 'seq', removing the matches\r\n\t\t\t\tif ( w < i ) seq[ w ] = u;\r\n\t\t\t\t++ w;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( w < n ) seq.length = w;\r\n\r\n\t\treturn r;\r\n\r\n\t};\r\n\r\n\tWebGLUniforms.evalDynamic = function( seq, values, object, camera ) {\r\n\r\n\t\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\r\n\r\n\t\t\tvar v = values[ seq[ i ].id ],\r\n\t\t\t\tf = v.onUpdateCallback;\r\n\r\n\t\t\tif ( f !== undefined ) f.call( v, object, camera );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\treturn WebGLUniforms;\r\n\r\n} )();\r\n\r\n\r\n// File:src/renderers/webgl/plugins/LensFlarePlugin.js\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.LensFlarePlugin = function ( renderer, flares ) {\r\n\r\n\tvar gl = renderer.context;\r\n\tvar state = renderer.state;\r\n\r\n\tvar vertexBuffer, elementBuffer;\r\n\tvar shader, program, attributes, uniforms;\r\n\r\n\tvar tempTexture, occlusionTexture;\r\n\r\n\tfunction init() {\r\n\r\n\t\tvar vertices = new Float32Array( [\r\n\t\t\t- 1, - 1,  0, 0,\r\n\t\t\t 1, - 1,  1, 0,\r\n\t\t\t 1,  1,  1, 1,\r\n\t\t\t- 1,  1,  0, 1\r\n\t\t] );\r\n\r\n\t\tvar faces = new Uint16Array( [\r\n\t\t\t0, 1, 2,\r\n\t\t\t0, 2, 3\r\n\t\t] );\r\n\r\n\t\t// buffers\r\n\r\n\t\tvertexBuffer     = gl.createBuffer();\r\n\t\telementBuffer    = gl.createBuffer();\r\n\r\n\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\r\n\t\tgl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );\r\n\r\n\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\r\n\t\tgl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );\r\n\r\n\t\t// textures\r\n\r\n\t\ttempTexture      = gl.createTexture();\r\n\t\tocclusionTexture = gl.createTexture();\r\n\r\n\t\tstate.bindTexture( gl.TEXTURE_2D, tempTexture );\r\n\t\tgl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null );\r\n\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );\r\n\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );\r\n\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\r\n\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\r\n\r\n\t\tstate.bindTexture( gl.TEXTURE_2D, occlusionTexture );\r\n\t\tgl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null );\r\n\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );\r\n\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );\r\n\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\r\n\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\r\n\r\n\t\tshader = {\r\n\r\n\t\t\tvertexShader: [\r\n\r\n\t\t\t\t\"uniform lowp int renderType;\",\r\n\r\n\t\t\t\t\"uniform vec3 screenPosition;\",\r\n\t\t\t\t\"uniform vec2 scale;\",\r\n\t\t\t\t\"uniform float rotation;\",\r\n\r\n\t\t\t\t\"uniform sampler2D occlusionMap;\",\r\n\r\n\t\t\t\t\"attribute vec2 position;\",\r\n\t\t\t\t\"attribute vec2 uv;\",\r\n\r\n\t\t\t\t\"varying vec2 vUV;\",\r\n\t\t\t\t\"varying float vVisibility;\",\r\n\r\n\t\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\t\"vUV = uv;\",\r\n\r\n\t\t\t\t\t\"vec2 pos = position;\",\r\n\r\n\t\t\t\t\t\"if ( renderType == 2 ) {\",\r\n\r\n\t\t\t\t\t\t\"vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\",\r\n\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\",\r\n\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\",\r\n\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\",\r\n\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\",\r\n\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\",\r\n\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\",\r\n\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\",\r\n\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\",\r\n\r\n\t\t\t\t\t\t\"vVisibility =        visibility.r / 9.0;\",\r\n\t\t\t\t\t\t\"vVisibility *= 1.0 - visibility.g / 9.0;\",\r\n\t\t\t\t\t\t\"vVisibility *=       visibility.b / 9.0;\",\r\n\t\t\t\t\t\t\"vVisibility *= 1.0 - visibility.a / 9.0;\",\r\n\r\n\t\t\t\t\t\t\"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\",\r\n\t\t\t\t\t\t\"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\",\r\n\r\n\t\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\t\"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\",\r\n\r\n\t\t\t\t\"}\"\r\n\r\n\t\t\t].join( \"\\n\" ),\r\n\r\n\t\t\tfragmentShader: [\r\n\r\n\t\t\t\t\"uniform lowp int renderType;\",\r\n\r\n\t\t\t\t\"uniform sampler2D map;\",\r\n\t\t\t\t\"uniform float opacity;\",\r\n\t\t\t\t\"uniform vec3 color;\",\r\n\r\n\t\t\t\t\"varying vec2 vUV;\",\r\n\t\t\t\t\"varying float vVisibility;\",\r\n\r\n\t\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\t// pink square\r\n\r\n\t\t\t\t\t\"if ( renderType == 0 ) {\",\r\n\r\n\t\t\t\t\t\t\"gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );\",\r\n\r\n\t\t\t\t\t// restore\r\n\r\n\t\t\t\t\t\"} else if ( renderType == 1 ) {\",\r\n\r\n\t\t\t\t\t\t\"gl_FragColor = texture2D( map, vUV );\",\r\n\r\n\t\t\t\t\t// flare\r\n\r\n\t\t\t\t\t\"} else {\",\r\n\r\n\t\t\t\t\t\t\"vec4 texture = texture2D( map, vUV );\",\r\n\t\t\t\t\t\t\"texture.a *= opacity * vVisibility;\",\r\n\t\t\t\t\t\t\"gl_FragColor = texture;\",\r\n\t\t\t\t\t\t\"gl_FragColor.rgb *= color;\",\r\n\r\n\t\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\"}\"\r\n\r\n\t\t\t].join( \"\\n\" )\r\n\r\n\t\t};\r\n\r\n\t\tprogram = createProgram( shader );\r\n\r\n\t\tattributes = {\r\n\t\t\tvertex: gl.getAttribLocation ( program, \"position\" ),\r\n\t\t\tuv:     gl.getAttribLocation ( program, \"uv\" )\r\n\t\t};\r\n\r\n\t\tuniforms = {\r\n\t\t\trenderType:     gl.getUniformLocation( program, \"renderType\" ),\r\n\t\t\tmap:            gl.getUniformLocation( program, \"map\" ),\r\n\t\t\tocclusionMap:   gl.getUniformLocation( program, \"occlusionMap\" ),\r\n\t\t\topacity:        gl.getUniformLocation( program, \"opacity\" ),\r\n\t\t\tcolor:          gl.getUniformLocation( program, \"color\" ),\r\n\t\t\tscale:          gl.getUniformLocation( program, \"scale\" ),\r\n\t\t\trotation:       gl.getUniformLocation( program, \"rotation\" ),\r\n\t\t\tscreenPosition: gl.getUniformLocation( program, \"screenPosition\" )\r\n\t\t};\r\n\r\n\t}\r\n\r\n\t/*\r\n\t * Render lens flares\r\n\t * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,\r\n\t *         reads these back and calculates occlusion.\r\n\t */\r\n\r\n\tthis.render = function ( scene, camera, viewport ) {\r\n\r\n\t\tif ( flares.length === 0 ) return;\r\n\r\n\t\tvar tempPosition = new THREE.Vector3();\r\n\r\n\t\tvar invAspect = viewport.w / viewport.z,\r\n\t\t\thalfViewportWidth = viewport.z * 0.5,\r\n\t\t\thalfViewportHeight = viewport.w * 0.5;\r\n\r\n\t\tvar size = 16 / viewport.w,\r\n\t\t\tscale = new THREE.Vector2( size * invAspect, size );\r\n\r\n\t\tvar screenPosition = new THREE.Vector3( 1, 1, 0 ),\r\n\t\t\tscreenPositionPixels = new THREE.Vector2( 1, 1 );\r\n\r\n\t\tvar validArea = new THREE.Box2();\r\n\r\n\t\tvalidArea.min.set( 0, 0 );\r\n\t\tvalidArea.max.set( viewport.z - 16, viewport.w - 16 );\r\n\r\n\t\tif ( program === undefined ) {\r\n\r\n\t\t\tinit();\r\n\r\n\t\t}\r\n\r\n\t\tgl.useProgram( program );\r\n\r\n\t\tstate.initAttributes();\r\n\t\tstate.enableAttribute( attributes.vertex );\r\n\t\tstate.enableAttribute( attributes.uv );\r\n\t\tstate.disableUnusedAttributes();\r\n\r\n\t\t// loop through all lens flares to update their occlusion and positions\r\n\t\t// setup gl and common used attribs/uniforms\r\n\r\n\t\tgl.uniform1i( uniforms.occlusionMap, 0 );\r\n\t\tgl.uniform1i( uniforms.map, 1 );\r\n\r\n\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\r\n\t\tgl.vertexAttribPointer( attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0 );\r\n\t\tgl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );\r\n\r\n\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\r\n\r\n\t\tstate.disable( gl.CULL_FACE );\r\n\t\tstate.setDepthWrite( false );\r\n\r\n\t\tfor ( var i = 0, l = flares.length; i < l; i ++ ) {\r\n\r\n\t\t\tsize = 16 / viewport.w;\r\n\t\t\tscale.set( size * invAspect, size );\r\n\r\n\t\t\t// calc object screen position\r\n\r\n\t\t\tvar flare = flares[ i ];\r\n\r\n\t\t\ttempPosition.set( flare.matrixWorld.elements[ 12 ], flare.matrixWorld.elements[ 13 ], flare.matrixWorld.elements[ 14 ] );\r\n\r\n\t\t\ttempPosition.applyMatrix4( camera.matrixWorldInverse );\r\n\t\t\ttempPosition.applyProjection( camera.projectionMatrix );\r\n\r\n\t\t\t// setup arrays for gl programs\r\n\r\n\t\t\tscreenPosition.copy( tempPosition );\r\n\r\n\t\t\t// horizontal and vertical coordinate of the lower left corner of the pixels to copy\r\n\r\n\t\t\tscreenPositionPixels.x = viewport.x + ( screenPosition.x * halfViewportWidth ) + halfViewportWidth - 8;\r\n\t\t\tscreenPositionPixels.y = viewport.y + ( screenPosition.y * halfViewportHeight ) + halfViewportHeight - 8;\r\n\r\n\t\t\t// screen cull\r\n\r\n\t\t\tif ( validArea.containsPoint( screenPositionPixels ) === true ) {\r\n\r\n\t\t\t\t// save current RGB to temp texture\r\n\r\n\t\t\t\tstate.activeTexture( gl.TEXTURE0 );\r\n\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, null );\r\n\t\t\t\tstate.activeTexture( gl.TEXTURE1 );\r\n\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, tempTexture );\r\n\t\t\t\tgl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );\r\n\r\n\r\n\t\t\t\t// render pink quad\r\n\r\n\t\t\t\tgl.uniform1i( uniforms.renderType, 0 );\r\n\t\t\t\tgl.uniform2f( uniforms.scale, scale.x, scale.y );\r\n\t\t\t\tgl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );\r\n\r\n\t\t\t\tstate.disable( gl.BLEND );\r\n\t\t\t\tstate.enable( gl.DEPTH_TEST );\r\n\r\n\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\r\n\r\n\r\n\t\t\t\t// copy result to occlusionMap\r\n\r\n\t\t\t\tstate.activeTexture( gl.TEXTURE0 );\r\n\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, occlusionTexture );\r\n\t\t\t\tgl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );\r\n\r\n\r\n\t\t\t\t// restore graphics\r\n\r\n\t\t\t\tgl.uniform1i( uniforms.renderType, 1 );\r\n\t\t\t\tstate.disable( gl.DEPTH_TEST );\r\n\r\n\t\t\t\tstate.activeTexture( gl.TEXTURE1 );\r\n\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, tempTexture );\r\n\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\r\n\r\n\r\n\t\t\t\t// update object positions\r\n\r\n\t\t\t\tflare.positionScreen.copy( screenPosition );\r\n\r\n\t\t\t\tif ( flare.customUpdateCallback ) {\r\n\r\n\t\t\t\t\tflare.customUpdateCallback( flare );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tflare.updateLensFlares();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// render flares\r\n\r\n\t\t\t\tgl.uniform1i( uniforms.renderType, 2 );\r\n\t\t\t\tstate.enable( gl.BLEND );\r\n\r\n\t\t\t\tfor ( var j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\tvar sprite = flare.lensFlares[ j ];\r\n\r\n\t\t\t\t\tif ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {\r\n\r\n\t\t\t\t\t\tscreenPosition.x = sprite.x;\r\n\t\t\t\t\t\tscreenPosition.y = sprite.y;\r\n\t\t\t\t\t\tscreenPosition.z = sprite.z;\r\n\r\n\t\t\t\t\t\tsize = sprite.size * sprite.scale / viewport.w;\r\n\r\n\t\t\t\t\t\tscale.x = size * invAspect;\r\n\t\t\t\t\t\tscale.y = size;\r\n\r\n\t\t\t\t\t\tgl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );\r\n\t\t\t\t\t\tgl.uniform2f( uniforms.scale, scale.x, scale.y );\r\n\t\t\t\t\t\tgl.uniform1f( uniforms.rotation, sprite.rotation );\r\n\r\n\t\t\t\t\t\tgl.uniform1f( uniforms.opacity, sprite.opacity );\r\n\t\t\t\t\t\tgl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );\r\n\r\n\t\t\t\t\t\tstate.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );\r\n\t\t\t\t\t\trenderer.setTexture2D( sprite.texture, 1 );\r\n\r\n\t\t\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// restore gl\r\n\r\n\t\tstate.enable( gl.CULL_FACE );\r\n\t\tstate.enable( gl.DEPTH_TEST );\r\n\t\tstate.setDepthWrite( true );\r\n\r\n\t\trenderer.resetGLState();\r\n\r\n\t};\r\n\r\n\tfunction createProgram ( shader ) {\r\n\r\n\t\tvar program = gl.createProgram();\r\n\r\n\t\tvar fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );\r\n\t\tvar vertexShader = gl.createShader( gl.VERTEX_SHADER );\r\n\r\n\t\tvar prefix = \"precision \" + renderer.getPrecision() + \" float;\\n\";\r\n\r\n\t\tgl.shaderSource( fragmentShader, prefix + shader.fragmentShader );\r\n\t\tgl.shaderSource( vertexShader, prefix + shader.vertexShader );\r\n\r\n\t\tgl.compileShader( fragmentShader );\r\n\t\tgl.compileShader( vertexShader );\r\n\r\n\t\tgl.attachShader( program, fragmentShader );\r\n\t\tgl.attachShader( program, vertexShader );\r\n\r\n\t\tgl.linkProgram( program );\r\n\r\n\t\treturn program;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/renderers/webgl/plugins/SpritePlugin.js\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.SpritePlugin = function ( renderer, sprites ) {\r\n\r\n\tvar gl = renderer.context;\r\n\tvar state = renderer.state;\r\n\r\n\tvar vertexBuffer, elementBuffer;\r\n\tvar program, attributes, uniforms;\r\n\r\n\tvar texture;\r\n\r\n\t// decompose matrixWorld\r\n\r\n\tvar spritePosition = new THREE.Vector3();\r\n\tvar spriteRotation = new THREE.Quaternion();\r\n\tvar spriteScale = new THREE.Vector3();\r\n\r\n\tfunction init() {\r\n\r\n\t\tvar vertices = new Float32Array( [\r\n\t\t\t- 0.5, - 0.5,  0, 0,\r\n\t\t\t  0.5, - 0.5,  1, 0,\r\n\t\t\t  0.5,   0.5,  1, 1,\r\n\t\t\t- 0.5,   0.5,  0, 1\r\n\t\t] );\r\n\r\n\t\tvar faces = new Uint16Array( [\r\n\t\t\t0, 1, 2,\r\n\t\t\t0, 2, 3\r\n\t\t] );\r\n\r\n\t\tvertexBuffer  = gl.createBuffer();\r\n\t\telementBuffer = gl.createBuffer();\r\n\r\n\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\r\n\t\tgl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );\r\n\r\n\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\r\n\t\tgl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );\r\n\r\n\t\tprogram = createProgram();\r\n\r\n\t\tattributes = {\r\n\t\t\tposition:\t\t\tgl.getAttribLocation ( program, 'position' ),\r\n\t\t\tuv:\t\t\t\t\tgl.getAttribLocation ( program, 'uv' )\r\n\t\t};\r\n\r\n\t\tuniforms = {\r\n\t\t\tuvOffset:\t\t\tgl.getUniformLocation( program, 'uvOffset' ),\r\n\t\t\tuvScale:\t\t\tgl.getUniformLocation( program, 'uvScale' ),\r\n\r\n\t\t\trotation:\t\t\tgl.getUniformLocation( program, 'rotation' ),\r\n\t\t\tscale:\t\t\t\tgl.getUniformLocation( program, 'scale' ),\r\n\r\n\t\t\tcolor:\t\t\t\tgl.getUniformLocation( program, 'color' ),\r\n\t\t\tmap:\t\t\t\tgl.getUniformLocation( program, 'map' ),\r\n\t\t\topacity:\t\t\tgl.getUniformLocation( program, 'opacity' ),\r\n\r\n\t\t\tmodelViewMatrix: \tgl.getUniformLocation( program, 'modelViewMatrix' ),\r\n\t\t\tprojectionMatrix:\tgl.getUniformLocation( program, 'projectionMatrix' ),\r\n\r\n\t\t\tfogType:\t\t\tgl.getUniformLocation( program, 'fogType' ),\r\n\t\t\tfogDensity:\t\t\tgl.getUniformLocation( program, 'fogDensity' ),\r\n\t\t\tfogNear:\t\t\tgl.getUniformLocation( program, 'fogNear' ),\r\n\t\t\tfogFar:\t\t\t\tgl.getUniformLocation( program, 'fogFar' ),\r\n\t\t\tfogColor:\t\t\tgl.getUniformLocation( program, 'fogColor' ),\r\n\r\n\t\t\talphaTest:\t\t\tgl.getUniformLocation( program, 'alphaTest' )\r\n\t\t};\r\n\r\n\t\tvar canvas = document.createElement( 'canvas' );\r\n\t\tcanvas.width = 8;\r\n\t\tcanvas.height = 8;\r\n\r\n\t\tvar context = canvas.getContext( '2d' );\r\n\t\tcontext.fillStyle = 'white';\r\n\t\tcontext.fillRect( 0, 0, 8, 8 );\r\n\r\n\t\ttexture = new THREE.Texture( canvas );\r\n\t\ttexture.needsUpdate = true;\r\n\r\n\t}\r\n\r\n\tthis.render = function ( scene, camera ) {\r\n\r\n\t\tif ( sprites.length === 0 ) return;\r\n\r\n\t\t// setup gl\r\n\r\n\t\tif ( program === undefined ) {\r\n\r\n\t\t\tinit();\r\n\r\n\t\t}\r\n\r\n\t\tgl.useProgram( program );\r\n\r\n\t\tstate.initAttributes();\r\n\t\tstate.enableAttribute( attributes.position );\r\n\t\tstate.enableAttribute( attributes.uv );\r\n\t\tstate.disableUnusedAttributes();\r\n\r\n\t\tstate.disable( gl.CULL_FACE );\r\n\t\tstate.enable( gl.BLEND );\r\n\r\n\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\r\n\t\tgl.vertexAttribPointer( attributes.position, 2, gl.FLOAT, false, 2 * 8, 0 );\r\n\t\tgl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );\r\n\r\n\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\r\n\r\n\t\tgl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );\r\n\r\n\t\tstate.activeTexture( gl.TEXTURE0 );\r\n\t\tgl.uniform1i( uniforms.map, 0 );\r\n\r\n\t\tvar oldFogType = 0;\r\n\t\tvar sceneFogType = 0;\r\n\t\tvar fog = scene.fog;\r\n\r\n\t\tif ( fog ) {\r\n\r\n\t\t\tgl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );\r\n\r\n\t\t\tif ( fog instanceof THREE.Fog ) {\r\n\r\n\t\t\t\tgl.uniform1f( uniforms.fogNear, fog.near );\r\n\t\t\t\tgl.uniform1f( uniforms.fogFar, fog.far );\r\n\r\n\t\t\t\tgl.uniform1i( uniforms.fogType, 1 );\r\n\t\t\t\toldFogType = 1;\r\n\t\t\t\tsceneFogType = 1;\r\n\r\n\t\t\t} else if ( fog instanceof THREE.FogExp2 ) {\r\n\r\n\t\t\t\tgl.uniform1f( uniforms.fogDensity, fog.density );\r\n\r\n\t\t\t\tgl.uniform1i( uniforms.fogType, 2 );\r\n\t\t\t\toldFogType = 2;\r\n\t\t\t\tsceneFogType = 2;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tgl.uniform1i( uniforms.fogType, 0 );\r\n\t\t\toldFogType = 0;\r\n\t\t\tsceneFogType = 0;\r\n\r\n\t\t}\r\n\r\n\r\n\t\t// update positions and sort\r\n\r\n\t\tfor ( var i = 0, l = sprites.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar sprite = sprites[ i ];\r\n\r\n\t\t\tsprite.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );\r\n\t\t\tsprite.z = - sprite.modelViewMatrix.elements[ 14 ];\r\n\r\n\t\t}\r\n\r\n\t\tsprites.sort( painterSortStable );\r\n\r\n\t\t// render all sprites\r\n\r\n\t\tvar scale = [];\r\n\r\n\t\tfor ( var i = 0, l = sprites.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar sprite = sprites[ i ];\r\n\t\t\tvar material = sprite.material;\r\n\r\n\t\t\tgl.uniform1f( uniforms.alphaTest, material.alphaTest );\r\n\t\t\tgl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements );\r\n\r\n\t\t\tsprite.matrixWorld.decompose( spritePosition, spriteRotation, spriteScale );\r\n\r\n\t\t\tscale[ 0 ] = spriteScale.x;\r\n\t\t\tscale[ 1 ] = spriteScale.y;\r\n\r\n\t\t\tvar fogType = 0;\r\n\r\n\t\t\tif ( scene.fog && material.fog ) {\r\n\r\n\t\t\t\tfogType = sceneFogType;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( oldFogType !== fogType ) {\r\n\r\n\t\t\t\tgl.uniform1i( uniforms.fogType, fogType );\r\n\t\t\t\toldFogType = fogType;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( material.map !== null ) {\r\n\r\n\t\t\t\tgl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );\r\n\t\t\t\tgl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tgl.uniform2f( uniforms.uvOffset, 0, 0 );\r\n\t\t\t\tgl.uniform2f( uniforms.uvScale, 1, 1 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgl.uniform1f( uniforms.opacity, material.opacity );\r\n\t\t\tgl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );\r\n\r\n\t\t\tgl.uniform1f( uniforms.rotation, material.rotation );\r\n\t\t\tgl.uniform2fv( uniforms.scale, scale );\r\n\r\n\t\t\tstate.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );\r\n\t\t\tstate.setDepthTest( material.depthTest );\r\n\t\t\tstate.setDepthWrite( material.depthWrite );\r\n\r\n\t\t\tif ( material.map ) {\r\n\r\n\t\t\t\trenderer.setTexture2D( material.map, 0 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\trenderer.setTexture2D( texture, 0 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\r\n\r\n\t\t}\r\n\r\n\t\t// restore gl\r\n\r\n\t\tstate.enable( gl.CULL_FACE );\r\n\r\n\t\trenderer.resetGLState();\r\n\r\n\t};\r\n\r\n\tfunction createProgram () {\r\n\r\n\t\tvar program = gl.createProgram();\r\n\r\n\t\tvar vertexShader = gl.createShader( gl.VERTEX_SHADER );\r\n\t\tvar fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );\r\n\r\n\t\tgl.shaderSource( vertexShader, [\r\n\r\n\t\t\t'precision ' + renderer.getPrecision() + ' float;',\r\n\r\n\t\t\t'uniform mat4 modelViewMatrix;',\r\n\t\t\t'uniform mat4 projectionMatrix;',\r\n\t\t\t'uniform float rotation;',\r\n\t\t\t'uniform vec2 scale;',\r\n\t\t\t'uniform vec2 uvOffset;',\r\n\t\t\t'uniform vec2 uvScale;',\r\n\r\n\t\t\t'attribute vec2 position;',\r\n\t\t\t'attribute vec2 uv;',\r\n\r\n\t\t\t'varying vec2 vUV;',\r\n\r\n\t\t\t'void main() {',\r\n\r\n\t\t\t\t'vUV = uvOffset + uv * uvScale;',\r\n\r\n\t\t\t\t'vec2 alignedPosition = position * scale;',\r\n\r\n\t\t\t\t'vec2 rotatedPosition;',\r\n\t\t\t\t'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',\r\n\t\t\t\t'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',\r\n\r\n\t\t\t\t'vec4 finalPosition;',\r\n\r\n\t\t\t\t'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',\r\n\t\t\t\t'finalPosition.xy += rotatedPosition;',\r\n\t\t\t\t'finalPosition = projectionMatrix * finalPosition;',\r\n\r\n\t\t\t\t'gl_Position = finalPosition;',\r\n\r\n\t\t\t'}'\r\n\r\n\t\t].join( '\\n' ) );\r\n\r\n\t\tgl.shaderSource( fragmentShader, [\r\n\r\n\t\t\t'precision ' + renderer.getPrecision() + ' float;',\r\n\r\n\t\t\t'uniform vec3 color;',\r\n\t\t\t'uniform sampler2D map;',\r\n\t\t\t'uniform float opacity;',\r\n\r\n\t\t\t'uniform int fogType;',\r\n\t\t\t'uniform vec3 fogColor;',\r\n\t\t\t'uniform float fogDensity;',\r\n\t\t\t'uniform float fogNear;',\r\n\t\t\t'uniform float fogFar;',\r\n\t\t\t'uniform float alphaTest;',\r\n\r\n\t\t\t'varying vec2 vUV;',\r\n\r\n\t\t\t'void main() {',\r\n\r\n\t\t\t\t'vec4 texture = texture2D( map, vUV );',\r\n\r\n\t\t\t\t'if ( texture.a < alphaTest ) discard;',\r\n\r\n\t\t\t\t'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',\r\n\r\n\t\t\t\t'if ( fogType > 0 ) {',\r\n\r\n\t\t\t\t\t'float depth = gl_FragCoord.z / gl_FragCoord.w;',\r\n\t\t\t\t\t'float fogFactor = 0.0;',\r\n\r\n\t\t\t\t\t'if ( fogType == 1 ) {',\r\n\r\n\t\t\t\t\t\t'fogFactor = smoothstep( fogNear, fogFar, depth );',\r\n\r\n\t\t\t\t\t'} else {',\r\n\r\n\t\t\t\t\t\t'const float LOG2 = 1.442695;',\r\n\t\t\t\t\t\t'fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',\r\n\t\t\t\t\t\t'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',\r\n\r\n\t\t\t\t\t'}',\r\n\r\n\t\t\t\t\t'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',\r\n\r\n\t\t\t\t'}',\r\n\r\n\t\t\t'}'\r\n\r\n\t\t].join( '\\n' ) );\r\n\r\n\t\tgl.compileShader( vertexShader );\r\n\t\tgl.compileShader( fragmentShader );\r\n\r\n\t\tgl.attachShader( program, vertexShader );\r\n\t\tgl.attachShader( program, fragmentShader );\r\n\r\n\t\tgl.linkProgram( program );\r\n\r\n\t\treturn program;\r\n\r\n\t}\r\n\r\n\tfunction painterSortStable ( a, b ) {\r\n\t\t\r\n\t\tif ( a.renderOrder !== b.renderOrder ) {\r\n\r\n\t\t\treturn a.renderOrder - b.renderOrder;\r\n\r\n\t\t} else if ( a.z !== b.z ) {\r\n\r\n\t\t\treturn b.z - a.z;\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn b.id - a.id;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/Three.Legacy.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nObject.defineProperties( THREE.Box2.prototype, {\r\n\tempty: {\r\n\t\tvalue: function () {\r\n\t\t\tconsole.warn( 'THREE.Box2: .empty() has been renamed to .isEmpty().' );\r\n\t\t\treturn this.isEmpty();\r\n\t\t}\r\n\t},\r\n\tisIntersectionBox: {\r\n\t\tvalue: function ( box ) {\r\n\t\t\tconsole.warn( 'THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().' );\r\n\t\t\treturn this.intersectsBox( box );\r\n\t\t}\r\n\t}\r\n} );\r\n\r\nObject.defineProperties( THREE.Box3.prototype, {\r\n\tempty: {\r\n\t\tvalue: function () {\r\n\t\t\tconsole.warn( 'THREE.Box3: .empty() has been renamed to .isEmpty().' );\r\n\t\t\treturn this.isEmpty();\r\n\t\t}\r\n\t},\r\n\tisIntersectionBox: {\r\n\t\tvalue: function ( box ) {\r\n\t\t\tconsole.warn( 'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().' );\r\n\t\t\treturn this.intersectsBox( box );\r\n\t\t}\r\n\t},\r\n\tisIntersectionSphere: {\r\n\t\tvalue: function ( sphere ) {\r\n\t\t\tconsole.warn( 'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().' );\r\n\t\t\treturn this.intersectsSphere( sphere );\r\n\t\t}\r\n\t}\r\n} );\r\n\r\nObject.defineProperties( THREE.Matrix3.prototype, {\r\n\tmultiplyVector3: {\r\n\t\tvalue: function ( vector ) {\r\n\t\t\tconsole.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );\r\n\t\t\treturn vector.applyMatrix3( this );\r\n\t\t}\r\n\t},\r\n\tmultiplyVector3Array: {\r\n\t\tvalue: function ( a ) {\r\n\t\t\tconsole.warn( 'THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );\r\n\t\t\treturn this.applyToVector3Array( a );\r\n\t\t}\r\n\t}\r\n} );\r\n\r\nObject.defineProperties( THREE.Matrix4.prototype, {\r\n\textractPosition: {\r\n\t\tvalue: function ( m ) {\r\n\t\t\tconsole.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );\r\n\t\t\treturn this.copyPosition( m );\r\n\t\t}\r\n\t},\r\n\tsetRotationFromQuaternion: {\r\n\t\tvalue: function ( q ) {\r\n\t\t\tconsole.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );\r\n\t\t\treturn this.makeRotationFromQuaternion( q );\r\n\t\t}\r\n\t},\r\n\tmultiplyVector3: {\r\n\t\tvalue: function ( vector ) {\r\n\t\t\tconsole.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.' );\r\n\t\t\treturn vector.applyProjection( this );\r\n\t\t}\r\n\t},\r\n\tmultiplyVector4: {\r\n\t\tvalue: function ( vector ) {\r\n\t\t\tconsole.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\r\n\t\t\treturn vector.applyMatrix4( this );\r\n\t\t}\r\n\t},\r\n\tmultiplyVector3Array: {\r\n\t\tvalue: function ( a ) {\r\n\t\t\tconsole.warn( 'THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );\r\n\t\t\treturn this.applyToVector3Array( a );\r\n\t\t}\r\n\t},\r\n\trotateAxis: {\r\n\t\tvalue: function ( v ) {\r\n\t\t\tconsole.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );\r\n\t\t\tv.transformDirection( this );\r\n\t\t}\r\n\t},\r\n\tcrossVector: {\r\n\t\tvalue: function ( vector ) {\r\n\t\t\tconsole.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\r\n\t\t\treturn vector.applyMatrix4( this );\r\n\t\t}\r\n\t},\r\n\ttranslate: {\r\n\t\tvalue: function ( v ) {\r\n\t\t\tconsole.error( 'THREE.Matrix4: .translate() has been removed.' );\r\n\t\t}\r\n\t},\r\n\trotateX: {\r\n\t\tvalue: function ( angle ) {\r\n\t\t\tconsole.error( 'THREE.Matrix4: .rotateX() has been removed.' );\r\n\t\t}\r\n\t},\r\n\trotateY: {\r\n\t\tvalue: function ( angle ) {\r\n\t\t\tconsole.error( 'THREE.Matrix4: .rotateY() has been removed.' );\r\n\t\t}\r\n\t},\r\n\trotateZ: {\r\n\t\tvalue: function ( angle ) {\r\n\t\t\tconsole.error( 'THREE.Matrix4: .rotateZ() has been removed.' );\r\n\t\t}\r\n\t},\r\n\trotateByAxis: {\r\n\t\tvalue: function ( axis, angle ) {\r\n\t\t\tconsole.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );\r\n\t\t}\r\n\t}\r\n} );\r\n\r\nObject.defineProperties( THREE.Plane.prototype, {\r\n\tisIntersectionLine: {\r\n\t\tvalue: function ( line ) {\r\n\t\t\tconsole.warn( 'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().' );\r\n\t\t\treturn this.intersectsLine( line );\r\n\t\t}\r\n\t}\r\n} );\r\n\r\nObject.defineProperties( THREE.Quaternion.prototype, {\r\n\tmultiplyVector3: {\r\n\t\tvalue: function ( vector ) {\r\n\t\t\tconsole.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );\r\n\t\t\treturn vector.applyQuaternion( this );\r\n\t\t}\r\n\t}\r\n} );\r\n\r\nObject.defineProperties( THREE.Ray.prototype, {\r\n\tisIntersectionBox: {\r\n\t\tvalue: function ( box ) {\r\n\t\t\tconsole.warn( 'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().' );\r\n\t\t\treturn this.intersectsBox( box );\r\n\t\t}\r\n\t},\r\n\tisIntersectionPlane: {\r\n\t\tvalue: function ( plane ) {\r\n\t\t\tconsole.warn( 'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().' );\r\n\t\t\treturn this.intersectsPlane( plane );\r\n\t\t}\r\n\t},\r\n\tisIntersectionSphere: {\r\n\t\tvalue: function ( sphere ) {\r\n\t\t\tconsole.warn( 'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().' );\r\n\t\t\treturn this.intersectsSphere( sphere );\r\n\t\t}\r\n\t}\r\n} );\r\n\r\nObject.defineProperties( THREE.Vector3.prototype, {\r\n\tsetEulerFromRotationMatrix: {\r\n\t\tvalue: function () {\r\n\t\t\tconsole.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );\r\n\t\t}\r\n\t},\r\n\tsetEulerFromQuaternion: {\r\n\t\tvalue: function () {\r\n\t\t\tconsole.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );\r\n\t\t}\r\n\t},\r\n\tgetPositionFromMatrix: {\r\n\t\tvalue: function ( m ) {\r\n\t\t\tconsole.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );\r\n\t\t\treturn this.setFromMatrixPosition( m );\r\n\t\t}\r\n\t},\r\n\tgetScaleFromMatrix: {\r\n\t\tvalue: function ( m ) {\r\n\t\t\tconsole.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );\r\n\t\t\treturn this.setFromMatrixScale( m );\r\n\t\t}\r\n\t},\r\n\tgetColumnFromMatrix: {\r\n\t\tvalue: function ( index, matrix ) {\r\n\t\t\tconsole.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );\r\n\t\t\treturn this.setFromMatrixColumn( index, matrix );\r\n\t\t}\r\n\t}\r\n} );\r\n\r\n//\r\n\r\nTHREE.Face4 = function ( a, b, c, d, normal, color, materialIndex ) {\r\n\r\n\tconsole.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' );\r\n\treturn new THREE.Face3( a, b, c, normal, color, materialIndex );\r\n\r\n};\r\n\r\nTHREE.Vertex = function ( x, y, z ) {\r\n\r\n\tconsole.warn( 'THREE.Vertex has been removed. Use THREE.Vector3 instead.' );\r\n\treturn new THREE.Vector3( x, y, z );\r\n\r\n};\r\n\r\n//\r\n\r\nObject.defineProperties( THREE.Object3D.prototype, {\r\n\teulerOrder: {\r\n\t\tget: function () {\r\n\t\t\tconsole.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );\r\n\t\t\treturn this.rotation.order;\r\n\t\t},\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );\r\n\t\t\tthis.rotation.order = value;\r\n\t\t}\r\n\t},\r\n\tgetChildByName: {\r\n\t\tvalue: function ( name ) {\r\n\t\t\tconsole.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );\r\n\t\t\treturn this.getObjectByName( name );\r\n\t\t}\r\n\t},\r\n\trenderDepth: {\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );\r\n\t\t}\r\n\t},\r\n\ttranslate: {\r\n\t\tvalue: function ( distance, axis ) {\r\n\t\t\tconsole.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );\r\n\t\t\treturn this.translateOnAxis( axis, distance );\r\n\t\t}\r\n\t},\r\n\tuseQuaternion: {\r\n\t\tget: function () {\r\n\t\t\tconsole.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );\r\n\t\t},\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );\r\n\t\t}\r\n\t}\r\n} );\r\n\r\n//\r\n\r\nObject.defineProperties( THREE, {\r\n\tPointCloud: {\r\n\t\tvalue: function ( geometry, material ) {\r\n\t\t\tconsole.warn( 'THREE.PointCloud has been renamed to THREE.Points.' );\r\n\t\t\treturn new THREE.Points( geometry, material );\r\n\t\t}\r\n\t},\r\n\tParticleSystem: {\r\n\t\tvalue: function ( geometry, material ) {\r\n\t\t\tconsole.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' );\r\n\t\t\treturn new THREE.Points( geometry, material );\r\n\t\t}\r\n\t}\r\n} );\r\n\r\n//\r\n\r\nObject.defineProperties( THREE.Light.prototype, {\r\n\tonlyShadow: {\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.Light: .onlyShadow has been removed.' );\r\n\t\t}\r\n\t},\r\n\tshadowCameraFov: {\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.' );\r\n\t\t\tthis.shadow.camera.fov = value;\r\n\t\t}\r\n\t},\r\n\tshadowCameraLeft: {\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.' );\r\n\t\t\tthis.shadow.camera.left = value;\r\n\t\t}\r\n\t},\r\n\tshadowCameraRight: {\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraRight is now .shadow.camera.right.' );\r\n\t\t\tthis.shadow.camera.right = value;\r\n\t\t}\r\n\t},\r\n\tshadowCameraTop: {\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraTop is now .shadow.camera.top.' );\r\n\t\t\tthis.shadow.camera.top = value;\r\n\t\t}\r\n\t},\r\n\tshadowCameraBottom: {\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.' );\r\n\t\t\tthis.shadow.camera.bottom = value;\r\n\t\t}\r\n\t},\r\n\tshadowCameraNear: {\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraNear is now .shadow.camera.near.' );\r\n\t\t\tthis.shadow.camera.near = value;\r\n\t\t}\r\n\t},\r\n\tshadowCameraFar: {\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraFar is now .shadow.camera.far.' );\r\n\t\t\tthis.shadow.camera.far = value;\r\n\t\t}\r\n\t},\r\n\tshadowCameraVisible: {\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.' );\r\n\t\t}\r\n\t},\r\n\tshadowBias: {\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.Light: .shadowBias is now .shadow.bias.' );\r\n\t\t\tthis.shadow.bias = value;\r\n\t\t}\r\n\t},\r\n\tshadowDarkness: {\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.Light: .shadowDarkness has been removed.' );\r\n\t\t}\r\n\t},\r\n\tshadowMapWidth: {\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.' );\r\n\t\t\tthis.shadow.mapSize.width = value;\r\n\t\t}\r\n\t},\r\n\tshadowMapHeight: {\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.' );\r\n\t\t\tthis.shadow.mapSize.height = value;\r\n\t\t}\r\n\t}\r\n} );\r\n\r\n//\r\n\r\nObject.defineProperties( THREE.BufferAttribute.prototype, {\r\n\tlength: {\r\n\t\tget: function () {\r\n\t\t\tconsole.warn( 'THREE.BufferAttribute: .length has been deprecated. Please use .count.' );\r\n\t\t\treturn this.array.length;\r\n\t\t}\r\n\t}\r\n} );\r\n\r\nObject.defineProperties( THREE.BufferGeometry.prototype, {\r\n\tdrawcalls: {\r\n\t\tget: function () {\r\n\t\t\tconsole.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );\r\n\t\t\treturn this.groups;\r\n\t\t}\r\n\t},\r\n\toffsets: {\r\n\t\tget: function () {\r\n\t\t\tconsole.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );\r\n\t\t\treturn this.groups;\r\n\t\t}\r\n\t},\r\n\taddIndex: {\r\n\t\tvalue: function ( index ) {\r\n\t\t\tconsole.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );\r\n\t\t\tthis.setIndex( index );\r\n\t\t}\r\n\t},\r\n\taddDrawCall: {\r\n\t\tvalue: function ( start, count, indexOffset ) {\r\n\t\t\tif ( indexOffset !== undefined ) {\r\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );\r\n\t\t\t}\r\n\t\t\tconsole.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );\r\n\t\t\tthis.addGroup( start, count );\r\n\t\t}\r\n\t},\r\n\tclearDrawCalls: {\r\n\t\tvalue: function () {\r\n\t\t\tconsole.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );\r\n\t\t\tthis.clearGroups();\r\n\t\t}\r\n\t},\r\n\tcomputeTangents: {\r\n\t\tvalue: function () {\r\n\t\t\tconsole.warn( 'THREE.BufferGeometry: .computeTangents() has been removed.' );\r\n\t\t}\r\n\t},\r\n\tcomputeOffsets: {\r\n\t\tvalue: function () {\r\n\t\t\tconsole.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.' );\r\n\t\t}\r\n\t}\r\n} );\r\n\r\n//\r\n\r\nObject.defineProperties( THREE.Material.prototype, {\r\n\twrapAround: {\r\n\t\tget: function () {\r\n\t\t\tconsole.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );\r\n\t\t},\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );\r\n\t\t}\r\n\t},\r\n\twrapRGB: {\r\n\t\tget: function () {\r\n\t\t\tconsole.warn( 'THREE.' + this.type + ': .wrapRGB has been removed.' );\r\n\t\t\treturn new THREE.Color();\r\n\t\t}\r\n\t}\r\n} );\r\n\r\nObject.defineProperties( THREE, {\r\n\tPointCloudMaterial: {\r\n\t\tvalue: function ( parameters ) {\r\n\t\t\tconsole.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' );\r\n\t\t\treturn new THREE.PointsMaterial( parameters );\r\n\t\t}\r\n\t},\r\n\tParticleBasicMaterial: {\r\n\t\tvalue: function ( parameters ) {\r\n\t\t\tconsole.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' );\r\n\t\t\treturn new THREE.PointsMaterial( parameters );\r\n\t\t}\r\n\t},\r\n\tParticleSystemMaterial:{\r\n\t\tvalue: function ( parameters ) {\r\n\t\t\tconsole.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' );\r\n\t\t\treturn new THREE.PointsMaterial( parameters );\r\n\t\t}\r\n\t}\r\n} );\r\n\r\nObject.defineProperties( THREE.MeshPhongMaterial.prototype, {\r\n\tmetal: {\r\n\t\tget: function () {\r\n\t\t\tconsole.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.' );\r\n\t\t\treturn false;\r\n\t\t},\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead' );\r\n\t\t}\r\n\t}\r\n} );\r\n\r\nObject.defineProperties( THREE.ShaderMaterial.prototype, {\r\n\tderivatives: {\r\n\t\tget: function () {\r\n\t\t\tconsole.warn( 'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );\r\n\t\t\treturn this.extensions.derivatives;\r\n\t\t},\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );\r\n\t\t\tthis.extensions.derivatives = value;\r\n\t\t}\r\n\t}\r\n} );\r\n\r\n//\r\n\r\nObject.defineProperties( THREE.WebGLRenderer.prototype, {\r\n\tsupportsFloatTextures: {\r\n\t\tvalue: function () {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \\'OES_texture_float\\' ).' );\r\n\t\t\treturn this.extensions.get( 'OES_texture_float' );\r\n\t\t}\r\n\t},\r\n\tsupportsHalfFloatTextures: {\r\n\t\tvalue: function () {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \\'OES_texture_half_float\\' ).' );\r\n\t\t\treturn this.extensions.get( 'OES_texture_half_float' );\r\n\t\t}\r\n\t},\r\n\tsupportsStandardDerivatives: {\r\n\t\tvalue: function () {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \\'OES_standard_derivatives\\' ).' );\r\n\t\t\treturn this.extensions.get( 'OES_standard_derivatives' );\r\n\t\t}\r\n\t},\r\n\tsupportsCompressedTextureS3TC: {\r\n\t\tvalue: function () {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \\'WEBGL_compressed_texture_s3tc\\' ).' );\r\n\t\t\treturn this.extensions.get( 'WEBGL_compressed_texture_s3tc' );\r\n\t\t}\r\n\t},\r\n\tsupportsCompressedTexturePVRTC: {\r\n\t\tvalue: function () {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \\'WEBGL_compressed_texture_pvrtc\\' ).' );\r\n\t\t\treturn this.extensions.get( 'WEBGL_compressed_texture_pvrtc' );\r\n\t\t}\r\n\t},\r\n\tsupportsBlendMinMax: {\r\n\t\tvalue: function () {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \\'EXT_blend_minmax\\' ).' );\r\n\t\t\treturn this.extensions.get( 'EXT_blend_minmax' );\r\n\t\t}\r\n\t},\r\n\tsupportsVertexTextures: {\r\n\t\tvalue: function () {\r\n\t\t\treturn this.capabilities.vertexTextures;\r\n\t\t}\r\n\t},\r\n\tsupportsInstancedArrays: {\r\n\t\tvalue: function () {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \\'ANGLE_instanced_arrays\\' ).' );\r\n\t\t\treturn this.extensions.get( 'ANGLE_instanced_arrays' );\r\n\t\t}\r\n\t},\r\n\tenableScissorTest: {\r\n\t\tvalue: function ( boolean ) {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().' );\r\n\t\t\tthis.setScissorTest( boolean );\r\n\t\t}\r\n\t},\r\n\tinitMaterial: {\r\n\t\tvalue: function () {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );\r\n\t\t}\r\n\t},\r\n\taddPrePlugin: {\r\n\t\tvalue: function () {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );\r\n\t\t}\r\n\t},\r\n\taddPostPlugin: {\r\n\t\tvalue: function () {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );\r\n\t\t}\r\n\t},\r\n\tupdateShadowMap: {\r\n\t\tvalue: function () {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );\r\n\t\t}\r\n\t},\r\n\tshadowMapEnabled: {\r\n\t\tget: function () {\r\n\t\t\treturn this.shadowMap.enabled;\r\n\t\t},\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );\r\n\t\t\tthis.shadowMap.enabled = value;\r\n\t\t}\r\n\t},\r\n\tshadowMapType: {\r\n\t\tget: function () {\r\n\t\t\treturn this.shadowMap.type;\r\n\t\t},\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );\r\n\t\t\tthis.shadowMap.type = value;\r\n\t\t}\r\n\t},\r\n\tshadowMapCullFace: {\r\n\t\tget: function () {\r\n\t\t\treturn this.shadowMap.cullFace;\r\n\t\t},\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.' );\r\n\t\t\tthis.shadowMap.cullFace = value;\r\n\t\t}\r\n\t}\r\n} );\r\n\r\n//\r\n\r\nObject.defineProperties( THREE.WebGLRenderTarget.prototype, {\r\n\twrapS: {\r\n\t\tget: function () {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );\r\n\t\t\treturn this.texture.wrapS;\r\n\t\t},\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );\r\n\t\t\tthis.texture.wrapS = value;\r\n\t\t}\r\n\t},\r\n\twrapT: {\r\n\t\tget: function () {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );\r\n\t\t\treturn this.texture.wrapT;\r\n\t\t},\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );\r\n\t\t\tthis.texture.wrapT = value;\r\n\t\t}\r\n\t},\r\n\tmagFilter: {\r\n\t\tget: function () {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );\r\n\t\t\treturn this.texture.magFilter;\r\n\t\t},\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );\r\n\t\t\tthis.texture.magFilter = value;\r\n\t\t}\r\n\t},\r\n\tminFilter: {\r\n\t\tget: function () {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );\r\n\t\t\treturn this.texture.minFilter;\r\n\t\t},\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );\r\n\t\t\tthis.texture.minFilter = value;\r\n\t\t}\r\n\t},\r\n\tanisotropy: {\r\n\t\tget: function () {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );\r\n\t\t\treturn this.texture.anisotropy;\r\n\t\t},\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );\r\n\t\t\tthis.texture.anisotropy = value;\r\n\t\t}\r\n\t},\r\n\toffset: {\r\n\t\tget: function () {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );\r\n\t\t\treturn this.texture.offset;\r\n\t\t},\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );\r\n\t\t\tthis.texture.offset = value;\r\n\t\t}\r\n\t},\r\n\trepeat: {\r\n\t\tget: function () {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );\r\n\t\t\treturn this.texture.repeat;\r\n\t\t},\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );\r\n\t\t\tthis.texture.repeat = value;\r\n\t\t}\r\n\t},\r\n\tformat: {\r\n\t\tget: function () {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );\r\n\t\t\treturn this.texture.format;\r\n\t\t},\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );\r\n\t\t\tthis.texture.format = value;\r\n\t\t}\r\n\t},\r\n\ttype: {\r\n\t\tget: function () {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );\r\n\t\t\treturn this.texture.type;\r\n\t\t},\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );\r\n\t\t\tthis.texture.type = value;\r\n\t\t}\r\n\t},\r\n\tgenerateMipmaps: {\r\n\t\tget: function () {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );\r\n\t\t\treturn this.texture.generateMipmaps;\r\n\t\t},\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );\r\n\t\t\tthis.texture.generateMipmaps = value;\r\n\t\t}\r\n\t}\r\n} );\r\n\r\n//\r\n\r\nObject.defineProperties( THREE.Audio.prototype, {\r\n\tload: {\r\n\t\tvalue: function ( file ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.Audio: .load has been deprecated. Please use THREE.AudioLoader.' );\r\n\r\n\t\t\tvar scope = this;\r\n\r\n\t\t\tvar audioLoader = new THREE.AudioLoader();\r\n\r\n\t\t\taudioLoader.load( file, function ( buffer ) {\r\n\r\n\t\t\t\tscope.setBuffer( buffer );\r\n\r\n\t\t\t} );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\t}\r\n} );\r\n\r\n//\r\n\r\nTHREE.GeometryUtils = {\r\n\r\n\tmerge: function ( geometry1, geometry2, materialIndexOffset ) {\r\n\r\n\t\tconsole.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );\r\n\r\n\t\tvar matrix;\r\n\r\n\t\tif ( geometry2 instanceof THREE.Mesh ) {\r\n\r\n\t\t\tgeometry2.matrixAutoUpdate && geometry2.updateMatrix();\r\n\r\n\t\t\tmatrix = geometry2.matrix;\r\n\t\t\tgeometry2 = geometry2.geometry;\r\n\r\n\t\t}\r\n\r\n\t\tgeometry1.merge( geometry2, matrix, materialIndexOffset );\r\n\r\n\t},\r\n\r\n\tcenter: function ( geometry ) {\r\n\r\n\t\tconsole.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );\r\n\t\treturn geometry.center();\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.ImageUtils = {\r\n\r\n\tcrossOrigin: undefined,\r\n\r\n\tloadTexture: function ( url, mapping, onLoad, onError ) {\r\n\r\n\t\tconsole.warn( 'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.' );\r\n\r\n\t\tvar loader = new THREE.TextureLoader();\r\n\t\tloader.setCrossOrigin( this.crossOrigin );\r\n\r\n\t\tvar texture = loader.load( url, onLoad, undefined, onError );\r\n\r\n\t\tif ( mapping ) texture.mapping = mapping;\r\n\r\n\t\treturn texture;\r\n\r\n\t},\r\n\r\n\tloadTextureCube: function ( urls, mapping, onLoad, onError ) {\r\n\r\n\t\tconsole.warn( 'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.' );\r\n\r\n\t\tvar loader = new THREE.CubeTextureLoader();\r\n\t\tloader.setCrossOrigin( this.crossOrigin );\r\n\r\n\t\tvar texture = loader.load( urls, onLoad, undefined, onError );\r\n\r\n\t\tif ( mapping ) texture.mapping = mapping;\r\n\r\n\t\treturn texture;\r\n\r\n\t},\r\n\r\n\tloadCompressedTexture: function () {\r\n\r\n\t\tconsole.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' );\r\n\r\n\t},\r\n\r\n\tloadCompressedTextureCube: function () {\r\n\r\n\t\tconsole.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' );\r\n\r\n\t}\r\n\r\n};\r\n\r\n//\r\n\r\nTHREE.Projector = function () {\r\n\r\n\tconsole.error( 'THREE.Projector has been moved to /examples/js/renderers/Projector.js.' );\r\n\r\n\tthis.projectVector = function ( vector, camera ) {\r\n\r\n\t\tconsole.warn( 'THREE.Projector: .projectVector() is now vector.project().' );\r\n\t\tvector.project( camera );\r\n\r\n\t};\r\n\r\n\tthis.unprojectVector = function ( vector, camera ) {\r\n\r\n\t\tconsole.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );\r\n\t\tvector.unproject( camera );\r\n\r\n\t};\r\n\r\n\tthis.pickingRay = function ( vector, camera ) {\r\n\r\n\t\tconsole.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );\r\n\r\n\t};\r\n\r\n};\r\n\r\n//\r\n\r\nTHREE.CanvasRenderer = function () {\r\n\r\n\tconsole.error( 'THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js' );\r\n\r\n\tthis.domElement = document.createElement( 'canvas' );\r\n\tthis.clear = function () {};\r\n\tthis.render = function () {};\r\n\tthis.setClearColor = function () {};\r\n\tthis.setSize = function () {};\r\n\r\n};\r\n\r\n//\r\n\r\nTHREE.MeshFaceMaterial = THREE.MultiMaterial;\r\n\r\n//\r\n\r\nObject.defineProperties( THREE.LOD.prototype, {\r\n\tobjects: {\r\n\t\tget: function () {\r\n\r\n\t\t\tconsole.warn( 'THREE.LOD: .objects has been renamed to .levels.' );\r\n\t\t\treturn this.levels;\r\n\r\n\t\t}\r\n\t}\r\n} );\r\n\r\n// File:src/extras/CurveUtils.js\r\n\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n */\r\n\r\nTHREE.CurveUtils = {\r\n\r\n\ttangentQuadraticBezier: function ( t, p0, p1, p2 ) {\r\n\r\n\t\treturn 2 * ( 1 - t ) * ( p1 - p0 ) + 2 * t * ( p2 - p1 );\r\n\r\n\t},\r\n\r\n\t// Puay Bing, thanks for helping with this derivative!\r\n\r\n\ttangentCubicBezier: function ( t, p0, p1, p2, p3 ) {\r\n\r\n\t\treturn - 3 * p0 * ( 1 - t ) * ( 1 - t )  +\r\n\t\t\t3 * p1 * ( 1 - t ) * ( 1 - t ) - 6 * t * p1 * ( 1 - t ) +\r\n\t\t\t6 * t *  p2 * ( 1 - t ) - 3 * t * t * p2 +\r\n\t\t\t3 * t * t * p3;\r\n\r\n\t},\r\n\r\n\ttangentSpline: function ( t, p0, p1, p2, p3 ) {\r\n\r\n\t\t// To check if my formulas are correct\r\n\r\n\t\tvar h00 = 6 * t * t - 6 * t; \t// derived from 2t^3  3t^2 + 1\r\n\t\tvar h10 = 3 * t * t - 4 * t + 1; // t^3  2t^2 + t\r\n\t\tvar h01 = - 6 * t * t + 6 * t; \t//  2t3 + 3t2\r\n\t\tvar h11 = 3 * t * t - 2 * t;\t// t3  t2\r\n\r\n\t\treturn h00 + h10 + h01 + h11;\r\n\r\n\t},\r\n\r\n\t// Catmull-Rom\r\n\r\n\tinterpolate: function( p0, p1, p2, p3, t ) {\r\n\r\n\t\tvar v0 = ( p2 - p0 ) * 0.5;\r\n\t\tvar v1 = ( p3 - p1 ) * 0.5;\r\n\t\tvar t2 = t * t;\r\n\t\tvar t3 = t * t2;\r\n\t\treturn ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/extras/SceneUtils.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.SceneUtils = {\r\n\r\n\tcreateMultiMaterialObject: function ( geometry, materials ) {\r\n\r\n\t\tvar group = new THREE.Group();\r\n\r\n\t\tfor ( var i = 0, l = materials.length; i < l; i ++ ) {\r\n\r\n\t\t\tgroup.add( new THREE.Mesh( geometry, materials[ i ] ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn group;\r\n\r\n\t},\r\n\r\n\tdetach: function ( child, parent, scene ) {\r\n\r\n\t\tchild.applyMatrix( parent.matrixWorld );\r\n\t\tparent.remove( child );\r\n\t\tscene.add( child );\r\n\r\n\t},\r\n\r\n\tattach: function ( child, scene, parent ) {\r\n\r\n\t\tvar matrixWorldInverse = new THREE.Matrix4();\r\n\t\tmatrixWorldInverse.getInverse( parent.matrixWorld );\r\n\t\tchild.applyMatrix( matrixWorldInverse );\r\n\r\n\t\tscene.remove( child );\r\n\t\tparent.add( child );\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/extras/ShapeUtils.js\r\n\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n */\r\n\r\nTHREE.ShapeUtils = {\r\n\r\n\t// calculate area of the contour polygon\r\n\r\n\tarea: function ( contour ) {\r\n\r\n\t\tvar n = contour.length;\r\n\t\tvar a = 0.0;\r\n\r\n\t\tfor ( var p = n - 1, q = 0; q < n; p = q ++ ) {\r\n\r\n\t\t\ta += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;\r\n\r\n\t\t}\r\n\r\n\t\treturn a * 0.5;\r\n\r\n\t},\r\n\r\n\ttriangulate: ( function () {\r\n\r\n\t\t/**\r\n\t\t * This code is a quick port of code written in C++ which was submitted to\r\n\t\t * flipcode.com by John W. Ratcliff  // July 22, 2000\r\n\t\t * See original code and more information here:\r\n\t\t * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml\r\n\t\t *\r\n\t\t * ported to actionscript by Zevan Rosser\r\n\t\t * www.actionsnippet.com\r\n\t\t *\r\n\t\t * ported to javascript by Joshua Koo\r\n\t\t * http://www.lab4games.net/zz85/blog\r\n\t\t *\r\n\t\t */\r\n\r\n\t\tfunction snip( contour, u, v, w, n, verts ) {\r\n\r\n\t\t\tvar p;\r\n\t\t\tvar ax, ay, bx, by;\r\n\t\t\tvar cx, cy, px, py;\r\n\r\n\t\t\tax = contour[ verts[ u ] ].x;\r\n\t\t\tay = contour[ verts[ u ] ].y;\r\n\r\n\t\t\tbx = contour[ verts[ v ] ].x;\r\n\t\t\tby = contour[ verts[ v ] ].y;\r\n\r\n\t\t\tcx = contour[ verts[ w ] ].x;\r\n\t\t\tcy = contour[ verts[ w ] ].y;\r\n\r\n\t\t\tif ( Number.EPSILON > ( ( ( bx - ax ) * ( cy - ay ) ) - ( ( by - ay ) * ( cx - ax ) ) ) ) return false;\r\n\r\n\t\t\tvar aX, aY, bX, bY, cX, cY;\r\n\t\t\tvar apx, apy, bpx, bpy, cpx, cpy;\r\n\t\t\tvar cCROSSap, bCROSScp, aCROSSbp;\r\n\r\n\t\t\taX = cx - bx;  aY = cy - by;\r\n\t\t\tbX = ax - cx;  bY = ay - cy;\r\n\t\t\tcX = bx - ax;  cY = by - ay;\r\n\r\n\t\t\tfor ( p = 0; p < n; p ++ ) {\r\n\r\n\t\t\t\tpx = contour[ verts[ p ] ].x;\r\n\t\t\t\tpy = contour[ verts[ p ] ].y;\r\n\r\n\t\t\t\tif ( ( ( px === ax ) && ( py === ay ) ) ||\r\n\t\t\t\t\t ( ( px === bx ) && ( py === by ) ) ||\r\n\t\t\t\t\t ( ( px === cx ) && ( py === cy ) ) )\tcontinue;\r\n\r\n\t\t\t\tapx = px - ax;  apy = py - ay;\r\n\t\t\t\tbpx = px - bx;  bpy = py - by;\r\n\t\t\t\tcpx = px - cx;  cpy = py - cy;\r\n\r\n\t\t\t\t// see if p is inside triangle abc\r\n\r\n\t\t\t\taCROSSbp = aX * bpy - aY * bpx;\r\n\t\t\t\tcCROSSap = cX * apy - cY * apx;\r\n\t\t\t\tbCROSScp = bX * cpy - bY * cpx;\r\n\r\n\t\t\t\tif ( ( aCROSSbp >= - Number.EPSILON ) && ( bCROSScp >= - Number.EPSILON ) && ( cCROSSap >= - Number.EPSILON ) ) return false;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\r\n\t\t// takes in an contour array and returns\r\n\r\n\t\treturn function ( contour, indices ) {\r\n\r\n\t\t\tvar n = contour.length;\r\n\r\n\t\t\tif ( n < 3 ) return null;\r\n\r\n\t\t\tvar result = [],\r\n\t\t\t\tverts = [],\r\n\t\t\t\tvertIndices = [];\r\n\r\n\t\t\t/* we want a counter-clockwise polygon in verts */\r\n\r\n\t\t\tvar u, v, w;\r\n\r\n\t\t\tif ( THREE.ShapeUtils.area( contour ) > 0.0 ) {\r\n\r\n\t\t\t\tfor ( v = 0; v < n; v ++ ) verts[ v ] = v;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tfor ( v = 0; v < n; v ++ ) verts[ v ] = ( n - 1 ) - v;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar nv = n;\r\n\r\n\t\t\t/*  remove nv - 2 vertices, creating 1 triangle every time */\r\n\r\n\t\t\tvar count = 2 * nv;   /* error detection */\r\n\r\n\t\t\tfor ( v = nv - 1; nv > 2; ) {\r\n\r\n\t\t\t\t/* if we loop, it is probably a non-simple polygon */\r\n\r\n\t\t\t\tif ( ( count -- ) <= 0 ) {\r\n\r\n\t\t\t\t\t//** Triangulate: ERROR - probable bad polygon!\r\n\r\n\t\t\t\t\t//throw ( \"Warning, unable to triangulate polygon!\" );\r\n\t\t\t\t\t//return null;\r\n\t\t\t\t\t// Sometimes warning is fine, especially polygons are triangulated in reverse.\r\n\t\t\t\t\tconsole.warn( 'THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()' );\r\n\r\n\t\t\t\t\tif ( indices ) return vertIndices;\r\n\t\t\t\t\treturn result;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t/* three consecutive vertices in current polygon, <u,v,w> */\r\n\r\n\t\t\t\tu = v; \t \tif ( nv <= u ) u = 0;     /* previous */\r\n\t\t\t\tv = u + 1;  if ( nv <= v ) v = 0;     /* new v    */\r\n\t\t\t\tw = v + 1;  if ( nv <= w ) w = 0;     /* next     */\r\n\r\n\t\t\t\tif ( snip( contour, u, v, w, nv, verts ) ) {\r\n\r\n\t\t\t\t\tvar a, b, c, s, t;\r\n\r\n\t\t\t\t\t/* true names of the vertices */\r\n\r\n\t\t\t\t\ta = verts[ u ];\r\n\t\t\t\t\tb = verts[ v ];\r\n\t\t\t\t\tc = verts[ w ];\r\n\r\n\t\t\t\t\t/* output Triangle */\r\n\r\n\t\t\t\t\tresult.push( [ contour[ a ],\r\n\t\t\t\t\t\tcontour[ b ],\r\n\t\t\t\t\t\tcontour[ c ] ] );\r\n\r\n\r\n\t\t\t\t\tvertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );\r\n\r\n\t\t\t\t\t/* remove v from the remaining polygon */\r\n\r\n\t\t\t\t\tfor ( s = v, t = v + 1; t < nv; s ++, t ++ ) {\r\n\r\n\t\t\t\t\t\tverts[ s ] = verts[ t ];\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tnv --;\r\n\r\n\t\t\t\t\t/* reset error detection counter */\r\n\r\n\t\t\t\t\tcount = 2 * nv;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( indices ) return vertIndices;\r\n\t\t\treturn result;\r\n\r\n\t\t}\r\n\r\n\t} )(),\r\n\r\n\ttriangulateShape: function ( contour, holes ) {\r\n\r\n\t\tfunction point_in_segment_2D_colin( inSegPt1, inSegPt2, inOtherPt ) {\r\n\r\n\t\t\t// inOtherPt needs to be collinear to the inSegment\r\n\t\t\tif ( inSegPt1.x !== inSegPt2.x ) {\r\n\r\n\t\t\t\tif ( inSegPt1.x < inSegPt2.x ) {\r\n\r\n\t\t\t\t\treturn\t( ( inSegPt1.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt2.x ) );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\treturn\t( ( inSegPt2.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt1.x ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tif ( inSegPt1.y < inSegPt2.y ) {\r\n\r\n\t\t\t\t\treturn\t( ( inSegPt1.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt2.y ) );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\treturn\t( ( inSegPt2.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt1.y ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction intersect_segments_2D( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs ) {\r\n\r\n\t\t\tvar seg1dx = inSeg1Pt2.x - inSeg1Pt1.x,   seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;\r\n\t\t\tvar seg2dx = inSeg2Pt2.x - inSeg2Pt1.x,   seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;\r\n\r\n\t\t\tvar seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;\r\n\t\t\tvar seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;\r\n\r\n\t\t\tvar limit\t\t= seg1dy * seg2dx - seg1dx * seg2dy;\r\n\t\t\tvar perpSeg1\t= seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;\r\n\r\n\t\t\tif ( Math.abs( limit ) > Number.EPSILON ) {\r\n\r\n\t\t\t\t// not parallel\r\n\r\n\t\t\t\tvar perpSeg2;\r\n\t\t\t\tif ( limit > 0 ) {\r\n\r\n\t\t\t\t\tif ( ( perpSeg1 < 0 ) || ( perpSeg1 > limit ) ) \t\treturn [];\r\n\t\t\t\t\tperpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;\r\n\t\t\t\t\tif ( ( perpSeg2 < 0 ) || ( perpSeg2 > limit ) ) \t\treturn [];\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tif ( ( perpSeg1 > 0 ) || ( perpSeg1 < limit ) ) \t\treturn [];\r\n\t\t\t\t\tperpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;\r\n\t\t\t\t\tif ( ( perpSeg2 > 0 ) || ( perpSeg2 < limit ) ) \t\treturn [];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// i.e. to reduce rounding errors\r\n\t\t\t\t// intersection at endpoint of segment#1?\r\n\t\t\t\tif ( perpSeg2 === 0 ) {\r\n\r\n\t\t\t\t\tif ( ( inExcludeAdjacentSegs ) &&\r\n\t\t\t\t\t\t ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )\t\treturn [];\r\n\t\t\t\t\treturn [ inSeg1Pt1 ];\r\n\r\n\t\t\t\t}\r\n\t\t\t\tif ( perpSeg2 === limit ) {\r\n\r\n\t\t\t\t\tif ( ( inExcludeAdjacentSegs ) &&\r\n\t\t\t\t\t\t ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )\t\treturn [];\r\n\t\t\t\t\treturn [ inSeg1Pt2 ];\r\n\r\n\t\t\t\t}\r\n\t\t\t\t// intersection at endpoint of segment#2?\r\n\t\t\t\tif ( perpSeg1 === 0 )\t\treturn [ inSeg2Pt1 ];\r\n\t\t\t\tif ( perpSeg1 === limit )\treturn [ inSeg2Pt2 ];\r\n\r\n\t\t\t\t// return real intersection point\r\n\t\t\t\tvar factorSeg1 = perpSeg2 / limit;\r\n\t\t\t\treturn\t[ { x: inSeg1Pt1.x + factorSeg1 * seg1dx,\r\n\t\t\t\t\t\t\ty: inSeg1Pt1.y + factorSeg1 * seg1dy } ];\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// parallel or collinear\r\n\t\t\t\tif ( ( perpSeg1 !== 0 ) ||\r\n\t\t\t\t\t ( seg2dy * seg1seg2dx !== seg2dx * seg1seg2dy ) ) \t\t\treturn [];\r\n\r\n\t\t\t\t// they are collinear or degenerate\r\n\t\t\t\tvar seg1Pt = ( ( seg1dx === 0 ) && ( seg1dy === 0 ) );\t// segment1 is just a point?\r\n\t\t\t\tvar seg2Pt = ( ( seg2dx === 0 ) && ( seg2dy === 0 ) );\t// segment2 is just a point?\r\n\t\t\t\t// both segments are points\r\n\t\t\t\tif ( seg1Pt && seg2Pt ) {\r\n\r\n\t\t\t\t\tif ( ( inSeg1Pt1.x !== inSeg2Pt1.x ) ||\r\n\t\t\t\t\t\t ( inSeg1Pt1.y !== inSeg2Pt1.y ) )\t\treturn [];\t// they are distinct  points\r\n\t\t\t\t\treturn [ inSeg1Pt1 ];                 \t\t\t\t\t\t// they are the same point\r\n\r\n\t\t\t\t}\r\n\t\t\t\t// segment#1  is a single point\r\n\t\t\t\tif ( seg1Pt ) {\r\n\r\n\t\t\t\t\tif ( ! point_in_segment_2D_colin( inSeg2Pt1, inSeg2Pt2, inSeg1Pt1 ) )\t\treturn [];\t\t// but not in segment#2\r\n\t\t\t\t\treturn [ inSeg1Pt1 ];\r\n\r\n\t\t\t\t}\r\n\t\t\t\t// segment#2  is a single point\r\n\t\t\t\tif ( seg2Pt ) {\r\n\r\n\t\t\t\t\tif ( ! point_in_segment_2D_colin( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1 ) )\t\treturn [];\t\t// but not in segment#1\r\n\t\t\t\t\treturn [ inSeg2Pt1 ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// they are collinear segments, which might overlap\r\n\t\t\t\tvar seg1min, seg1max, seg1minVal, seg1maxVal;\r\n\t\t\t\tvar seg2min, seg2max, seg2minVal, seg2maxVal;\r\n\t\t\t\tif ( seg1dx !== 0 ) {\r\n\r\n\t\t\t\t\t// the segments are NOT on a vertical line\r\n\t\t\t\t\tif ( inSeg1Pt1.x < inSeg1Pt2.x ) {\r\n\r\n\t\t\t\t\t\tseg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.x;\r\n\t\t\t\t\t\tseg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.x;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tseg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.x;\r\n\t\t\t\t\t\tseg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.x;\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ( inSeg2Pt1.x < inSeg2Pt2.x ) {\r\n\r\n\t\t\t\t\t\tseg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.x;\r\n\t\t\t\t\t\tseg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.x;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tseg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.x;\r\n\t\t\t\t\t\tseg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.x;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// the segments are on a vertical line\r\n\t\t\t\t\tif ( inSeg1Pt1.y < inSeg1Pt2.y ) {\r\n\r\n\t\t\t\t\t\tseg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.y;\r\n\t\t\t\t\t\tseg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.y;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tseg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.y;\r\n\t\t\t\t\t\tseg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.y;\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ( inSeg2Pt1.y < inSeg2Pt2.y ) {\r\n\r\n\t\t\t\t\t\tseg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.y;\r\n\t\t\t\t\t\tseg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.y;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tseg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.y;\r\n\t\t\t\t\t\tseg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.y;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\t\t\t\tif ( seg1minVal <= seg2minVal ) {\r\n\r\n\t\t\t\t\tif ( seg1maxVal <  seg2minVal )\treturn [];\r\n\t\t\t\t\tif ( seg1maxVal === seg2minVal )\t{\r\n\r\n\t\t\t\t\t\tif ( inExcludeAdjacentSegs )\t\treturn [];\r\n\t\t\t\t\t\treturn [ seg2min ];\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ( seg1maxVal <= seg2maxVal )\treturn [ seg2min, seg1max ];\r\n\t\t\t\t\treturn\t[ seg2min, seg2max ];\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tif ( seg1minVal >  seg2maxVal )\treturn [];\r\n\t\t\t\t\tif ( seg1minVal === seg2maxVal )\t{\r\n\r\n\t\t\t\t\t\tif ( inExcludeAdjacentSegs )\t\treturn [];\r\n\t\t\t\t\t\treturn [ seg1min ];\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ( seg1maxVal <= seg2maxVal )\treturn [ seg1min, seg1max ];\r\n\t\t\t\t\treturn\t[ seg1min, seg2max ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction isPointInsideAngle( inVertex, inLegFromPt, inLegToPt, inOtherPt ) {\r\n\r\n\t\t\t// The order of legs is important\r\n\r\n\t\t\t// translation of all points, so that Vertex is at (0,0)\r\n\t\t\tvar legFromPtX\t= inLegFromPt.x - inVertex.x,  legFromPtY\t= inLegFromPt.y - inVertex.y;\r\n\t\t\tvar legToPtX\t= inLegToPt.x\t- inVertex.x,  legToPtY\t\t= inLegToPt.y\t- inVertex.y;\r\n\t\t\tvar otherPtX\t= inOtherPt.x\t- inVertex.x,  otherPtY\t\t= inOtherPt.y\t- inVertex.y;\r\n\r\n\t\t\t// main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.\r\n\t\t\tvar from2toAngle\t= legFromPtX * legToPtY - legFromPtY * legToPtX;\r\n\t\t\tvar from2otherAngle\t= legFromPtX * otherPtY - legFromPtY * otherPtX;\r\n\r\n\t\t\tif ( Math.abs( from2toAngle ) > Number.EPSILON ) {\r\n\r\n\t\t\t\t// angle != 180 deg.\r\n\r\n\t\t\t\tvar other2toAngle\t\t= otherPtX * legToPtY - otherPtY * legToPtX;\r\n\t\t\t\t// console.log( \"from2to: \" + from2toAngle + \", from2other: \" + from2otherAngle + \", other2to: \" + other2toAngle );\r\n\r\n\t\t\t\tif ( from2toAngle > 0 ) {\r\n\r\n\t\t\t\t\t// main angle < 180 deg.\r\n\t\t\t\t\treturn\t( ( from2otherAngle >= 0 ) && ( other2toAngle >= 0 ) );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// main angle > 180 deg.\r\n\t\t\t\t\treturn\t( ( from2otherAngle >= 0 ) || ( other2toAngle >= 0 ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// angle == 180 deg.\r\n\t\t\t\t// console.log( \"from2to: 180 deg., from2other: \" + from2otherAngle  );\r\n\t\t\t\treturn\t( from2otherAngle > 0 );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\r\n\t\tfunction removeHoles( contour, holes ) {\r\n\r\n\t\t\tvar shape = contour.concat(); // work on this shape\r\n\t\t\tvar hole;\r\n\r\n\t\t\tfunction isCutLineInsideAngles( inShapeIdx, inHoleIdx ) {\r\n\r\n\t\t\t\t// Check if hole point lies within angle around shape point\r\n\t\t\t\tvar lastShapeIdx = shape.length - 1;\r\n\r\n\t\t\t\tvar prevShapeIdx = inShapeIdx - 1;\r\n\t\t\t\tif ( prevShapeIdx < 0 )\t\t\tprevShapeIdx = lastShapeIdx;\r\n\r\n\t\t\t\tvar nextShapeIdx = inShapeIdx + 1;\r\n\t\t\t\tif ( nextShapeIdx > lastShapeIdx )\tnextShapeIdx = 0;\r\n\r\n\t\t\t\tvar insideAngle = isPointInsideAngle( shape[ inShapeIdx ], shape[ prevShapeIdx ], shape[ nextShapeIdx ], hole[ inHoleIdx ] );\r\n\t\t\t\tif ( ! insideAngle ) {\r\n\r\n\t\t\t\t\t// console.log( \"Vertex (Shape): \" + inShapeIdx + \", Point: \" + hole[inHoleIdx].x + \"/\" + hole[inHoleIdx].y );\r\n\t\t\t\t\treturn\tfalse;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Check if shape point lies within angle around hole point\r\n\t\t\t\tvar lastHoleIdx = hole.length - 1;\r\n\r\n\t\t\t\tvar prevHoleIdx = inHoleIdx - 1;\r\n\t\t\t\tif ( prevHoleIdx < 0 )\t\t\tprevHoleIdx = lastHoleIdx;\r\n\r\n\t\t\t\tvar nextHoleIdx = inHoleIdx + 1;\r\n\t\t\t\tif ( nextHoleIdx > lastHoleIdx )\tnextHoleIdx = 0;\r\n\r\n\t\t\t\tinsideAngle = isPointInsideAngle( hole[ inHoleIdx ], hole[ prevHoleIdx ], hole[ nextHoleIdx ], shape[ inShapeIdx ] );\r\n\t\t\t\tif ( ! insideAngle ) {\r\n\r\n\t\t\t\t\t// console.log( \"Vertex (Hole): \" + inHoleIdx + \", Point: \" + shape[inShapeIdx].x + \"/\" + shape[inShapeIdx].y );\r\n\t\t\t\t\treturn\tfalse;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn\ttrue;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction intersectsShapeEdge( inShapePt, inHolePt ) {\r\n\r\n\t\t\t\t// checks for intersections with shape edges\r\n\t\t\t\tvar sIdx, nextIdx, intersection;\r\n\t\t\t\tfor ( sIdx = 0; sIdx < shape.length; sIdx ++ ) {\r\n\r\n\t\t\t\t\tnextIdx = sIdx + 1; nextIdx %= shape.length;\r\n\t\t\t\t\tintersection = intersect_segments_2D( inShapePt, inHolePt, shape[ sIdx ], shape[ nextIdx ], true );\r\n\t\t\t\t\tif ( intersection.length > 0 )\t\treturn\ttrue;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn\tfalse;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar indepHoles = [];\r\n\r\n\t\t\tfunction intersectsHoleEdge( inShapePt, inHolePt ) {\r\n\r\n\t\t\t\t// checks for intersections with hole edges\r\n\t\t\t\tvar ihIdx, chkHole,\r\n\t\t\t\t\thIdx, nextIdx, intersection;\r\n\t\t\t\tfor ( ihIdx = 0; ihIdx < indepHoles.length; ihIdx ++ ) {\r\n\r\n\t\t\t\t\tchkHole = holes[ indepHoles[ ihIdx ]];\r\n\t\t\t\t\tfor ( hIdx = 0; hIdx < chkHole.length; hIdx ++ ) {\r\n\r\n\t\t\t\t\t\tnextIdx = hIdx + 1; nextIdx %= chkHole.length;\r\n\t\t\t\t\t\tintersection = intersect_segments_2D( inShapePt, inHolePt, chkHole[ hIdx ], chkHole[ nextIdx ], true );\r\n\t\t\t\t\t\tif ( intersection.length > 0 )\t\treturn\ttrue;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\t\t\t\treturn\tfalse;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar holeIndex, shapeIndex,\r\n\t\t\t\tshapePt, holePt,\r\n\t\t\t\tholeIdx, cutKey, failedCuts = [],\r\n\t\t\t\ttmpShape1, tmpShape2,\r\n\t\t\t\ttmpHole1, tmpHole2;\r\n\r\n\t\t\tfor ( var h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n\t\t\t\tindepHoles.push( h );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar minShapeIndex = 0;\r\n\t\t\tvar counter = indepHoles.length * 2;\r\n\t\t\twhile ( indepHoles.length > 0 ) {\r\n\r\n\t\t\t\tcounter --;\r\n\t\t\t\tif ( counter < 0 ) {\r\n\r\n\t\t\t\t\tconsole.log( \"Infinite Loop! Holes left:\" + indepHoles.length + \", Probably Hole outside Shape!\" );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// search for shape-vertex and hole-vertex,\r\n\t\t\t\t// which can be connected without intersections\r\n\t\t\t\tfor ( shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex ++ ) {\r\n\r\n\t\t\t\t\tshapePt = shape[ shapeIndex ];\r\n\t\t\t\t\tholeIndex\t= - 1;\r\n\r\n\t\t\t\t\t// search for hole which can be reached without intersections\r\n\t\t\t\t\tfor ( var h = 0; h < indepHoles.length; h ++ ) {\r\n\r\n\t\t\t\t\t\tholeIdx = indepHoles[ h ];\r\n\r\n\t\t\t\t\t\t// prevent multiple checks\r\n\t\t\t\t\t\tcutKey = shapePt.x + \":\" + shapePt.y + \":\" + holeIdx;\r\n\t\t\t\t\t\tif ( failedCuts[ cutKey ] !== undefined )\t\t\tcontinue;\r\n\r\n\t\t\t\t\t\thole = holes[ holeIdx ];\r\n\t\t\t\t\t\tfor ( var h2 = 0; h2 < hole.length; h2 ++ ) {\r\n\r\n\t\t\t\t\t\t\tholePt = hole[ h2 ];\r\n\t\t\t\t\t\t\tif ( ! isCutLineInsideAngles( shapeIndex, h2 ) )\t\tcontinue;\r\n\t\t\t\t\t\t\tif ( intersectsShapeEdge( shapePt, holePt ) )\t\tcontinue;\r\n\t\t\t\t\t\t\tif ( intersectsHoleEdge( shapePt, holePt ) )\t\tcontinue;\r\n\r\n\t\t\t\t\t\t\tholeIndex = h2;\r\n\t\t\t\t\t\t\tindepHoles.splice( h, 1 );\r\n\r\n\t\t\t\t\t\t\ttmpShape1 = shape.slice( 0, shapeIndex + 1 );\r\n\t\t\t\t\t\t\ttmpShape2 = shape.slice( shapeIndex );\r\n\t\t\t\t\t\t\ttmpHole1 = hole.slice( holeIndex );\r\n\t\t\t\t\t\t\ttmpHole2 = hole.slice( 0, holeIndex + 1 );\r\n\r\n\t\t\t\t\t\t\tshape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );\r\n\r\n\t\t\t\t\t\t\tminShapeIndex = shapeIndex;\r\n\r\n\t\t\t\t\t\t\t// Debug only, to show the selected cuts\r\n\t\t\t\t\t\t\t// glob_CutLines.push( [ shapePt, holePt ] );\r\n\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif ( holeIndex >= 0 )\tbreak;\t\t// hole-vertex found\r\n\r\n\t\t\t\t\t\tfailedCuts[ cutKey ] = true;\t\t\t// remember failure\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ( holeIndex >= 0 )\tbreak;\t\t// hole-vertex found\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shape; \t\t\t/* shape with no holes */\r\n\r\n\t\t}\r\n\r\n\r\n\t\tvar i, il, f, face,\r\n\t\t\tkey, index,\r\n\t\t\tallPointsMap = {};\r\n\r\n\t\t// To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.\r\n\r\n\t\tvar allpoints = contour.concat();\r\n\r\n\t\tfor ( var h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n\t\t\tArray.prototype.push.apply( allpoints, holes[ h ] );\r\n\r\n\t\t}\r\n\r\n\t\t//console.log( \"allpoints\",allpoints, allpoints.length );\r\n\r\n\t\t// prepare all points map\r\n\r\n\t\tfor ( i = 0, il = allpoints.length; i < il; i ++ ) {\r\n\r\n\t\t\tkey = allpoints[ i ].x + \":\" + allpoints[ i ].y;\r\n\r\n\t\t\tif ( allPointsMap[ key ] !== undefined ) {\r\n\r\n\t\t\t\tconsole.warn( \"THREE.Shape: Duplicate point\", key );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tallPointsMap[ key ] = i;\r\n\r\n\t\t}\r\n\r\n\t\t// remove holes by cutting paths to holes and adding them to the shape\r\n\t\tvar shapeWithoutHoles = removeHoles( contour, holes );\r\n\r\n\t\tvar triangles = THREE.ShapeUtils.triangulate( shapeWithoutHoles, false ); // True returns indices for points of spooled shape\r\n\t\t//console.log( \"triangles\",triangles, triangles.length );\r\n\r\n\t\t// check all face vertices against all points map\r\n\r\n\t\tfor ( i = 0, il = triangles.length; i < il; i ++ ) {\r\n\r\n\t\t\tface = triangles[ i ];\r\n\r\n\t\t\tfor ( f = 0; f < 3; f ++ ) {\r\n\r\n\t\t\t\tkey = face[ f ].x + \":\" + face[ f ].y;\r\n\r\n\t\t\t\tindex = allPointsMap[ key ];\r\n\r\n\t\t\t\tif ( index !== undefined ) {\r\n\r\n\t\t\t\t\tface[ f ] = index;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn triangles.concat();\r\n\r\n\t},\r\n\r\n\tisClockWise: function ( pts ) {\r\n\r\n\t\treturn THREE.ShapeUtils.area( pts ) < 0;\r\n\r\n\t},\r\n\r\n\t// Bezier Curves formulas obtained from\r\n\t// http://en.wikipedia.org/wiki/B%C3%A9zier_curve\r\n\r\n\t// Quad Bezier Functions\r\n\r\n\tb2: ( function () {\r\n\r\n\t\tfunction b2p0( t, p ) {\r\n\r\n\t\t\tvar k = 1 - t;\r\n\t\t\treturn k * k * p;\r\n\r\n\t\t}\r\n\r\n\t\tfunction b2p1( t, p ) {\r\n\r\n\t\t\treturn 2 * ( 1 - t ) * t * p;\r\n\r\n\t\t}\r\n\r\n\t\tfunction b2p2( t, p ) {\r\n\r\n\t\t\treturn t * t * p;\r\n\r\n\t\t}\r\n\r\n\t\treturn function ( t, p0, p1, p2 ) {\r\n\r\n\t\t\treturn b2p0( t, p0 ) + b2p1( t, p1 ) + b2p2( t, p2 );\r\n\r\n\t\t};\r\n\r\n\t} )(),\r\n\r\n\t// Cubic Bezier Functions\r\n\r\n\tb3: ( function () {\r\n\r\n\t\tfunction b3p0( t, p ) {\r\n\r\n\t\t\tvar k = 1 - t;\r\n\t\t\treturn k * k * k * p;\r\n\r\n\t\t}\r\n\r\n\t\tfunction b3p1( t, p ) {\r\n\r\n\t\t\tvar k = 1 - t;\r\n\t\t\treturn 3 * k * k * t * p;\r\n\r\n\t\t}\r\n\r\n\t\tfunction b3p2( t, p ) {\r\n\r\n\t\t\tvar k = 1 - t;\r\n\t\t\treturn 3 * k * t * t * p;\r\n\r\n\t\t}\r\n\r\n\t\tfunction b3p3( t, p ) {\r\n\r\n\t\t\treturn t * t * t * p;\r\n\r\n\t\t}\r\n\r\n\t\treturn function ( t, p0, p1, p2, p3 ) {\r\n\r\n\t\t\treturn b3p0( t, p0 ) + b3p1( t, p1 ) + b3p2( t, p2 ) + b3p3( t, p3 );\r\n\r\n\t\t};\r\n\r\n\t} )()\r\n\r\n};\r\n\r\n// File:src/extras/core/Curve.js\r\n\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * Extensible curve object\r\n *\r\n * Some common of Curve methods\r\n * .getPoint(t), getTangent(t)\r\n * .getPointAt(u), getTagentAt(u)\r\n * .getPoints(), .getSpacedPoints()\r\n * .getLength()\r\n * .updateArcLengths()\r\n *\r\n * This following classes subclasses THREE.Curve:\r\n *\r\n * -- 2d classes --\r\n * THREE.LineCurve\r\n * THREE.QuadraticBezierCurve\r\n * THREE.CubicBezierCurve\r\n * THREE.SplineCurve\r\n * THREE.ArcCurve\r\n * THREE.EllipseCurve\r\n *\r\n * -- 3d classes --\r\n * THREE.LineCurve3\r\n * THREE.QuadraticBezierCurve3\r\n * THREE.CubicBezierCurve3\r\n * THREE.SplineCurve3\r\n *\r\n * A series of curves can be represented as a THREE.CurvePath\r\n *\r\n **/\r\n\r\n/**************************************************************\r\n *\tAbstract Curve base class\r\n **************************************************************/\r\n\r\nTHREE.Curve = function () {\r\n\r\n};\r\n\r\nTHREE.Curve.prototype = {\r\n\r\n\tconstructor: THREE.Curve,\r\n\r\n\t// Virtual base class method to overwrite and implement in subclasses\r\n\t//\t- t [0 .. 1]\r\n\r\n\tgetPoint: function ( t ) {\r\n\r\n\t\tconsole.warn( \"THREE.Curve: Warning, getPoint() not implemented!\" );\r\n\t\treturn null;\r\n\r\n\t},\r\n\r\n\t// Get point at relative position in curve according to arc length\r\n\t// - u [0 .. 1]\r\n\r\n\tgetPointAt: function ( u ) {\r\n\r\n\t\tvar t = this.getUtoTmapping( u );\r\n\t\treturn this.getPoint( t );\r\n\r\n\t},\r\n\r\n\t// Get sequence of points using getPoint( t )\r\n\r\n\tgetPoints: function ( divisions ) {\r\n\r\n\t\tif ( ! divisions ) divisions = 5;\r\n\r\n\t\tvar d, pts = [];\r\n\r\n\t\tfor ( d = 0; d <= divisions; d ++ ) {\r\n\r\n\t\t\tpts.push( this.getPoint( d / divisions ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn pts;\r\n\r\n\t},\r\n\r\n\t// Get sequence of points using getPointAt( u )\r\n\r\n\tgetSpacedPoints: function ( divisions ) {\r\n\r\n\t\tif ( ! divisions ) divisions = 5;\r\n\r\n\t\tvar d, pts = [];\r\n\r\n\t\tfor ( d = 0; d <= divisions; d ++ ) {\r\n\r\n\t\t\tpts.push( this.getPointAt( d / divisions ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn pts;\r\n\r\n\t},\r\n\r\n\t// Get total curve arc length\r\n\r\n\tgetLength: function () {\r\n\r\n\t\tvar lengths = this.getLengths();\r\n\t\treturn lengths[ lengths.length - 1 ];\r\n\r\n\t},\r\n\r\n\t// Get list of cumulative segment lengths\r\n\r\n\tgetLengths: function ( divisions ) {\r\n\r\n\t\tif ( ! divisions ) divisions = ( this.__arcLengthDivisions ) ? ( this.__arcLengthDivisions ) : 200;\r\n\r\n\t\tif ( this.cacheArcLengths\r\n\t\t\t&& ( this.cacheArcLengths.length === divisions + 1 )\r\n\t\t\t&& ! this.needsUpdate ) {\r\n\r\n\t\t\t//console.log( \"cached\", this.cacheArcLengths );\r\n\t\t\treturn this.cacheArcLengths;\r\n\r\n\t\t}\r\n\r\n\t\tthis.needsUpdate = false;\r\n\r\n\t\tvar cache = [];\r\n\t\tvar current, last = this.getPoint( 0 );\r\n\t\tvar p, sum = 0;\r\n\r\n\t\tcache.push( 0 );\r\n\r\n\t\tfor ( p = 1; p <= divisions; p ++ ) {\r\n\r\n\t\t\tcurrent = this.getPoint ( p / divisions );\r\n\t\t\tsum += current.distanceTo( last );\r\n\t\t\tcache.push( sum );\r\n\t\t\tlast = current;\r\n\r\n\t\t}\r\n\r\n\t\tthis.cacheArcLengths = cache;\r\n\r\n\t\treturn cache; // { sums: cache, sum:sum }; Sum is in the last element.\r\n\r\n\t},\r\n\r\n\tupdateArcLengths: function() {\r\n\r\n\t\tthis.needsUpdate = true;\r\n\t\tthis.getLengths();\r\n\r\n\t},\r\n\r\n\t// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant\r\n\r\n\tgetUtoTmapping: function ( u, distance ) {\r\n\r\n\t\tvar arcLengths = this.getLengths();\r\n\r\n\t\tvar i = 0, il = arcLengths.length;\r\n\r\n\t\tvar targetArcLength; // The targeted u distance value to get\r\n\r\n\t\tif ( distance ) {\r\n\r\n\t\t\ttargetArcLength = distance;\r\n\r\n\t\t} else {\r\n\r\n\t\t\ttargetArcLength = u * arcLengths[ il - 1 ];\r\n\r\n\t\t}\r\n\r\n\t\t//var time = Date.now();\r\n\r\n\t\t// binary search for the index with largest value smaller than target u distance\r\n\r\n\t\tvar low = 0, high = il - 1, comparison;\r\n\r\n\t\twhile ( low <= high ) {\r\n\r\n\t\t\ti = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats\r\n\r\n\t\t\tcomparison = arcLengths[ i ] - targetArcLength;\r\n\r\n\t\t\tif ( comparison < 0 ) {\r\n\r\n\t\t\t\tlow = i + 1;\r\n\r\n\t\t\t} else if ( comparison > 0 ) {\r\n\r\n\t\t\t\thigh = i - 1;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\thigh = i;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t\t// DONE\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\ti = high;\r\n\r\n\t\t//console.log('b' , i, low, high, Date.now()- time);\r\n\r\n\t\tif ( arcLengths[ i ] === targetArcLength ) {\r\n\r\n\t\t\tvar t = i / ( il - 1 );\r\n\t\t\treturn t;\r\n\r\n\t\t}\r\n\r\n\t\t// we could get finer grain at lengths, or use simple interpolation between two points\r\n\r\n\t\tvar lengthBefore = arcLengths[ i ];\r\n\t\tvar lengthAfter = arcLengths[ i + 1 ];\r\n\r\n\t\tvar segmentLength = lengthAfter - lengthBefore;\r\n\r\n\t\t// determine where we are between the 'before' and 'after' points\r\n\r\n\t\tvar segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;\r\n\r\n\t\t// add that fractional amount to t\r\n\r\n\t\tvar t = ( i + segmentFraction ) / ( il - 1 );\r\n\r\n\t\treturn t;\r\n\r\n\t},\r\n\r\n\t// Returns a unit vector tangent at t\r\n\t// In case any sub curve does not implement its tangent derivation,\r\n\t// 2 points a small delta apart will be used to find its gradient\r\n\t// which seems to give a reasonable approximation\r\n\r\n\tgetTangent: function( t ) {\r\n\r\n\t\tvar delta = 0.0001;\r\n\t\tvar t1 = t - delta;\r\n\t\tvar t2 = t + delta;\r\n\r\n\t\t// Capping in case of danger\r\n\r\n\t\tif ( t1 < 0 ) t1 = 0;\r\n\t\tif ( t2 > 1 ) t2 = 1;\r\n\r\n\t\tvar pt1 = this.getPoint( t1 );\r\n\t\tvar pt2 = this.getPoint( t2 );\r\n\r\n\t\tvar vec = pt2.clone().sub( pt1 );\r\n\t\treturn vec.normalize();\r\n\r\n\t},\r\n\r\n\tgetTangentAt: function ( u ) {\r\n\r\n\t\tvar t = this.getUtoTmapping( u );\r\n\t\treturn this.getTangent( t );\r\n\r\n\t}\r\n\r\n};\r\n\r\n// TODO: Transformation for Curves?\r\n\r\n/**************************************************************\r\n *\t3D Curves\r\n **************************************************************/\r\n\r\n// A Factory method for creating new curve subclasses\r\n\r\nTHREE.Curve.create = function ( constructor, getPointFunc ) {\r\n\r\n\tconstructor.prototype = Object.create( THREE.Curve.prototype );\r\n\tconstructor.prototype.constructor = constructor;\r\n\tconstructor.prototype.getPoint = getPointFunc;\r\n\r\n\treturn constructor;\r\n\r\n};\r\n\r\n// File:src/extras/core/CurvePath.js\r\n\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n *\r\n **/\r\n\r\n/**************************************************************\r\n *\tCurved Path - a curve path is simply a array of connected\r\n *  curves, but retains the api of a curve\r\n **************************************************************/\r\n\r\nTHREE.CurvePath = function () {\r\n\r\n\tthis.curves = [];\r\n\r\n\tthis.autoClose = false; // Automatically closes the path\r\n\r\n};\r\n\r\nTHREE.CurvePath.prototype = Object.create( THREE.Curve.prototype );\r\nTHREE.CurvePath.prototype.constructor = THREE.CurvePath;\r\n\r\nTHREE.CurvePath.prototype.add = function ( curve ) {\r\n\r\n\tthis.curves.push( curve );\r\n\r\n};\r\n\r\n/*\r\nTHREE.CurvePath.prototype.checkConnection = function() {\r\n\t// TODO\r\n\t// If the ending of curve is not connected to the starting\r\n\t// or the next curve, then, this is not a real path\r\n};\r\n*/\r\n\r\nTHREE.CurvePath.prototype.closePath = function() {\r\n\r\n\t// TODO Test\r\n\t// and verify for vector3 (needs to implement equals)\r\n\t// Add a line curve if start and end of lines are not connected\r\n\tvar startPoint = this.curves[ 0 ].getPoint( 0 );\r\n\tvar endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );\r\n\r\n\tif ( ! startPoint.equals( endPoint ) ) {\r\n\r\n\t\tthis.curves.push( new THREE.LineCurve( endPoint, startPoint ) );\r\n\r\n\t}\r\n\r\n};\r\n\r\n// To get accurate point with reference to\r\n// entire path distance at time t,\r\n// following has to be done:\r\n\r\n// 1. Length of each sub path have to be known\r\n// 2. Locate and identify type of curve\r\n// 3. Get t for the curve\r\n// 4. Return curve.getPointAt(t')\r\n\r\nTHREE.CurvePath.prototype.getPoint = function( t ) {\r\n\r\n\tvar d = t * this.getLength();\r\n\tvar curveLengths = this.getCurveLengths();\r\n\tvar i = 0;\r\n\r\n\t// To think about boundaries points.\r\n\r\n\twhile ( i < curveLengths.length ) {\r\n\r\n\t\tif ( curveLengths[ i ] >= d ) {\r\n\r\n\t\t\tvar diff = curveLengths[ i ] - d;\r\n\t\t\tvar curve = this.curves[ i ];\r\n\r\n\t\t\tvar u = 1 - diff / curve.getLength();\r\n\r\n\t\t\treturn curve.getPointAt( u );\r\n\r\n\t\t}\r\n\r\n\t\ti ++;\r\n\r\n\t}\r\n\r\n\treturn null;\r\n\r\n\t// loop where sum != 0, sum > d , sum+1 <d\r\n\r\n};\r\n\r\n/*\r\nTHREE.CurvePath.prototype.getTangent = function( t ) {\r\n};\r\n*/\r\n\r\n// We cannot use the default THREE.Curve getPoint() with getLength() because in\r\n// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath\r\n// getPoint() depends on getLength\r\n\r\nTHREE.CurvePath.prototype.getLength = function() {\r\n\r\n\tvar lens = this.getCurveLengths();\r\n\treturn lens[ lens.length - 1 ];\r\n\r\n};\r\n\r\n// Compute lengths and cache them\r\n// We cannot overwrite getLengths() because UtoT mapping uses it.\r\n\r\nTHREE.CurvePath.prototype.getCurveLengths = function() {\r\n\r\n\t// We use cache values if curves and cache array are same length\r\n\r\n\tif ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {\r\n\r\n\t\treturn this.cacheLengths;\r\n\r\n\t}\r\n\r\n\t// Get length of sub-curve\r\n\t// Push sums into cached array\r\n\r\n\tvar lengths = [], sums = 0;\r\n\r\n\tfor ( var i = 0, l = this.curves.length; i < l; i ++ ) {\r\n\r\n\t\tsums += this.curves[ i ].getLength();\r\n\t\tlengths.push( sums );\r\n\r\n\t}\r\n\r\n\tthis.cacheLengths = lengths;\r\n\r\n\treturn lengths;\r\n\r\n};\r\n\r\n\r\n\r\n/**************************************************************\r\n *\tCreate Geometries Helpers\r\n **************************************************************/\r\n\r\n/// Generate geometry from path points (for Line or Points objects)\r\n\r\nTHREE.CurvePath.prototype.createPointsGeometry = function( divisions ) {\r\n\r\n\tvar pts = this.getPoints( divisions );\r\n\treturn this.createGeometry( pts );\r\n\r\n};\r\n\r\n// Generate geometry from equidistant sampling along the path\r\n\r\nTHREE.CurvePath.prototype.createSpacedPointsGeometry = function( divisions ) {\r\n\r\n\tvar pts = this.getSpacedPoints( divisions );\r\n\treturn this.createGeometry( pts );\r\n\r\n};\r\n\r\nTHREE.CurvePath.prototype.createGeometry = function( points ) {\r\n\r\n\tvar geometry = new THREE.Geometry();\r\n\r\n\tfor ( var i = 0, l = points.length; i < l; i ++ ) {\r\n\r\n\t\tvar point = points[ i ];\r\n\t\tgeometry.vertices.push( new THREE.Vector3( point.x, point.y, point.z || 0 ) );\r\n\r\n\t}\r\n\r\n\treturn geometry;\r\n\r\n};\r\n\r\n// File:src/extras/core/Font.js\r\n\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Font = function ( data ) {\r\n\r\n\tthis.data = data;\r\n\r\n};\r\n\r\nTHREE.Font.prototype = {\r\n\r\n\tconstructor: THREE.Font,\r\n\r\n\tgenerateShapes: function ( text, size, divisions ) {\r\n\r\n\t\tfunction createPaths( text ) {\r\n\r\n\t\t\tvar chars = String( text ).split( '' );\r\n\t\t\tvar scale = size / data.resolution;\r\n\t\t\tvar offset = 0;\r\n\r\n\t\t\tvar paths = [];\r\n\r\n\t\t\tfor ( var i = 0; i < chars.length; i ++ ) {\r\n\r\n\t\t\t\tvar ret = createPath( chars[ i ], scale, offset );\r\n\t\t\t\toffset += ret.offset;\r\n\r\n\t\t\t\tpaths.push( ret.path );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn paths;\r\n\r\n\t\t}\r\n\r\n\t\tfunction createPath( c, scale, offset ) {\r\n\r\n\t\t\tvar glyph = data.glyphs[ c ] || data.glyphs[ '?' ];\r\n\r\n\t\t\tif ( ! glyph ) return;\r\n\r\n\t\t\tvar path = new THREE.Path();\r\n\r\n\t\t\tvar pts = [], b2 = THREE.ShapeUtils.b2, b3 = THREE.ShapeUtils.b3;\r\n\t\t\tvar x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2, laste;\r\n\r\n\t\t\tif ( glyph.o ) {\r\n\r\n\t\t\t\tvar outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );\r\n\r\n\t\t\t\tfor ( var i = 0, l = outline.length; i < l; ) {\r\n\r\n\t\t\t\t\tvar action = outline[ i ++ ];\r\n\r\n\t\t\t\t\tswitch ( action ) {\r\n\r\n\t\t\t\t\t\tcase 'm': // moveTo\r\n\r\n\t\t\t\t\t\t\tx = outline[ i ++ ] * scale + offset;\r\n\t\t\t\t\t\t\ty = outline[ i ++ ] * scale;\r\n\r\n\t\t\t\t\t\t\tpath.moveTo( x, y );\r\n\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 'l': // lineTo\r\n\r\n\t\t\t\t\t\t\tx = outline[ i ++ ] * scale + offset;\r\n\t\t\t\t\t\t\ty = outline[ i ++ ] * scale;\r\n\r\n\t\t\t\t\t\t\tpath.lineTo( x, y );\r\n\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 'q': // quadraticCurveTo\r\n\r\n\t\t\t\t\t\t\tcpx  = outline[ i ++ ] * scale + offset;\r\n\t\t\t\t\t\t\tcpy  = outline[ i ++ ] * scale;\r\n\t\t\t\t\t\t\tcpx1 = outline[ i ++ ] * scale + offset;\r\n\t\t\t\t\t\t\tcpy1 = outline[ i ++ ] * scale;\r\n\r\n\t\t\t\t\t\t\tpath.quadraticCurveTo( cpx1, cpy1, cpx, cpy );\r\n\r\n\t\t\t\t\t\t\tlaste = pts[ pts.length - 1 ];\r\n\r\n\t\t\t\t\t\t\tif ( laste ) {\r\n\r\n\t\t\t\t\t\t\t\tcpx0 = laste.x;\r\n\t\t\t\t\t\t\t\tcpy0 = laste.y;\r\n\r\n\t\t\t\t\t\t\t\tfor ( var i2 = 1; i2 <= divisions; i2 ++ ) {\r\n\r\n\t\t\t\t\t\t\t\t\tvar t = i2 / divisions;\r\n\t\t\t\t\t\t\t\t\tb2( t, cpx0, cpx1, cpx );\r\n\t\t\t\t\t\t\t\t\tb2( t, cpy0, cpy1, cpy );\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 'b': // bezierCurveTo\r\n\r\n\t\t\t\t\t\t\tcpx  = outline[ i ++ ] * scale + offset;\r\n\t\t\t\t\t\t\tcpy  = outline[ i ++ ] * scale;\r\n\t\t\t\t\t\t\tcpx1 = outline[ i ++ ] * scale + offset;\r\n\t\t\t\t\t\t\tcpy1 = outline[ i ++ ] * scale;\r\n\t\t\t\t\t\t\tcpx2 = outline[ i ++ ] * scale + offset;\r\n\t\t\t\t\t\t\tcpy2 = outline[ i ++ ] * scale;\r\n\r\n\t\t\t\t\t\t\tpath.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );\r\n\r\n\t\t\t\t\t\t\tlaste = pts[ pts.length - 1 ];\r\n\r\n\t\t\t\t\t\t\tif ( laste ) {\r\n\r\n\t\t\t\t\t\t\t\tcpx0 = laste.x;\r\n\t\t\t\t\t\t\t\tcpy0 = laste.y;\r\n\r\n\t\t\t\t\t\t\t\tfor ( var i2 = 1; i2 <= divisions; i2 ++ ) {\r\n\r\n\t\t\t\t\t\t\t\t\tvar t = i2 / divisions;\r\n\t\t\t\t\t\t\t\t\tb3( t, cpx0, cpx1, cpx2, cpx );\r\n\t\t\t\t\t\t\t\t\tb3( t, cpy0, cpy1, cpy2, cpy );\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn { offset: glyph.ha * scale, path: path };\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tif ( size === undefined ) size = 100;\r\n\t\tif ( divisions === undefined ) divisions = 4;\r\n\r\n\t\tvar data = this.data;\r\n\r\n\t\tvar paths = createPaths( text );\r\n\t\tvar shapes = [];\r\n\r\n\t\tfor ( var p = 0, pl = paths.length; p < pl; p ++ ) {\r\n\r\n\t\t\tArray.prototype.push.apply( shapes, paths[ p ].toShapes() );\r\n\r\n\t\t}\r\n\r\n\t\treturn shapes;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/extras/core/Path.js\r\n\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * Creates free form 2d path using series of points, lines or curves.\r\n *\r\n **/\r\n\r\nTHREE.Path = function ( points ) {\r\n\r\n\tTHREE.CurvePath.call( this );\r\n\r\n\tthis.actions = [];\r\n\r\n\tif ( points ) {\r\n\r\n\t\tthis.fromPoints( points );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.Path.prototype = Object.create( THREE.CurvePath.prototype );\r\nTHREE.Path.prototype.constructor = THREE.Path;\r\n\r\n// TODO Clean up PATH API\r\n\r\n// Create path using straight lines to connect all points\r\n// - vectors: array of Vector2\r\n\r\nTHREE.Path.prototype.fromPoints = function ( vectors ) {\r\n\r\n\tthis.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );\r\n\r\n\tfor ( var i = 1, l = vectors.length; i < l; i ++ ) {\r\n\r\n\t\tthis.lineTo( vectors[ i ].x, vectors[ i ].y );\r\n\r\n\t}\r\n\r\n};\r\n\r\n// startPath() endPath()?\r\n\r\nTHREE.Path.prototype.moveTo = function ( x, y ) {\r\n\r\n\tthis.actions.push( { action: 'moveTo', args: [ x, y ] } );\r\n\r\n};\r\n\r\nTHREE.Path.prototype.lineTo = function ( x, y ) {\r\n\r\n\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\r\n\r\n\tvar x0 = lastargs[ lastargs.length - 2 ];\r\n\tvar y0 = lastargs[ lastargs.length - 1 ];\r\n\r\n\tvar curve = new THREE.LineCurve( new THREE.Vector2( x0, y0 ), new THREE.Vector2( x, y ) );\r\n\tthis.curves.push( curve );\r\n\r\n\tthis.actions.push( { action: 'lineTo', args: [ x, y ] } );\r\n\r\n};\r\n\r\nTHREE.Path.prototype.quadraticCurveTo = function( aCPx, aCPy, aX, aY ) {\r\n\r\n\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\r\n\r\n\tvar x0 = lastargs[ lastargs.length - 2 ];\r\n\tvar y0 = lastargs[ lastargs.length - 1 ];\r\n\r\n\tvar curve = new THREE.QuadraticBezierCurve(\r\n\t\tnew THREE.Vector2( x0, y0 ),\r\n\t\tnew THREE.Vector2( aCPx, aCPy ),\r\n\t\tnew THREE.Vector2( aX, aY )\r\n\t);\r\n\r\n\tthis.curves.push( curve );\r\n\r\n\tthis.actions.push( { action: 'quadraticCurveTo', args: [ aCPx, aCPy, aX, aY ] } );\r\n\r\n};\r\n\r\nTHREE.Path.prototype.bezierCurveTo = function( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {\r\n\r\n\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\r\n\r\n\tvar x0 = lastargs[ lastargs.length - 2 ];\r\n\tvar y0 = lastargs[ lastargs.length - 1 ];\r\n\r\n\tvar curve = new THREE.CubicBezierCurve(\r\n\t\tnew THREE.Vector2( x0, y0 ),\r\n\t\tnew THREE.Vector2( aCP1x, aCP1y ),\r\n\t\tnew THREE.Vector2( aCP2x, aCP2y ),\r\n\t\tnew THREE.Vector2( aX, aY )\r\n\t);\r\n\r\n\tthis.curves.push( curve );\r\n\r\n\tthis.actions.push( { action: 'bezierCurveTo', args: [ aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ] } );\r\n\r\n};\r\n\r\nTHREE.Path.prototype.splineThru = function( pts /*Array of Vector*/ ) {\r\n\r\n\tvar args = Array.prototype.slice.call( arguments );\r\n\r\n\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\r\n\r\n\tvar x0 = lastargs[ lastargs.length - 2 ];\r\n\tvar y0 = lastargs[ lastargs.length - 1 ];\r\n\r\n\tvar npts = [ new THREE.Vector2( x0, y0 ) ];\r\n\tArray.prototype.push.apply( npts, pts );\r\n\r\n\tvar curve = new THREE.SplineCurve( npts );\r\n\tthis.curves.push( curve );\r\n\r\n\tthis.actions.push( { action: 'splineThru', args: args } );\r\n\r\n};\r\n\r\n// FUTURE: Change the API or follow canvas API?\r\n\r\nTHREE.Path.prototype.arc = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\r\n\r\n\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\r\n\tvar x0 = lastargs[ lastargs.length - 2 ];\r\n\tvar y0 = lastargs[ lastargs.length - 1 ];\r\n\r\n\tthis.absarc( aX + x0, aY + y0, aRadius,\r\n\t\taStartAngle, aEndAngle, aClockwise );\r\n\r\n };\r\n\r\n THREE.Path.prototype.absarc = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\r\n\r\n\tthis.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\r\n\r\n };\r\n\r\nTHREE.Path.prototype.ellipse = function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\r\n\r\n\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\r\n\tvar x0 = lastargs[ lastargs.length - 2 ];\r\n\tvar y0 = lastargs[ lastargs.length - 1 ];\r\n\r\n\tthis.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\r\n\r\n };\r\n\r\n\r\nTHREE.Path.prototype.absellipse = function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\r\n\r\n\tvar args = [\r\n\t\taX, aY,\r\n\t\txRadius, yRadius,\r\n\t\taStartAngle, aEndAngle,\r\n\t\taClockwise,\r\n\t\taRotation || 0 // aRotation is optional.\r\n\t];\r\n\r\n\tvar curve = new THREE.EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\r\n\tthis.curves.push( curve );\r\n\r\n\tvar lastPoint = curve.getPoint( 1 );\r\n\targs.push( lastPoint.x );\r\n\targs.push( lastPoint.y );\r\n\r\n\tthis.actions.push( { action: 'ellipse', args: args } );\r\n\r\n };\r\n\r\nTHREE.Path.prototype.getSpacedPoints = function ( divisions ) {\r\n\r\n\tif ( ! divisions ) divisions = 40;\r\n\r\n\tvar points = [];\r\n\r\n\tfor ( var i = 0; i < divisions; i ++ ) {\r\n\r\n\t\tpoints.push( this.getPoint( i / divisions ) );\r\n\r\n\t\t//if ( !this.getPoint( i / divisions ) ) throw \"DIE\";\r\n\r\n\t}\r\n\r\n\tif ( this.autoClose ) {\r\n\r\n\t\tpoints.push( points[ 0 ] );\r\n\r\n\t}\r\n\r\n\treturn points;\r\n\r\n};\r\n\r\n/* Return an array of vectors based on contour of the path */\r\n\r\nTHREE.Path.prototype.getPoints = function( divisions ) {\r\n\r\n\tdivisions = divisions || 12;\r\n\r\n\tvar b2 = THREE.ShapeUtils.b2;\r\n\tvar b3 = THREE.ShapeUtils.b3;\r\n\r\n\tvar points = [];\r\n\r\n\tvar cpx, cpy, cpx2, cpy2, cpx1, cpy1, cpx0, cpy0,\r\n\t\tlaste, tx, ty;\r\n\r\n\tfor ( var i = 0, l = this.actions.length; i < l; i ++ ) {\r\n\r\n\t\tvar item = this.actions[ i ];\r\n\r\n\t\tvar action = item.action;\r\n\t\tvar args = item.args;\r\n\r\n\t\tswitch ( action ) {\r\n\r\n\t\tcase 'moveTo':\r\n\r\n\t\t\tpoints.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );\r\n\r\n\t\t\tbreak;\r\n\r\n\t\tcase 'lineTo':\r\n\r\n\t\t\tpoints.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );\r\n\r\n\t\t\tbreak;\r\n\r\n\t\tcase 'quadraticCurveTo':\r\n\r\n\t\t\tcpx  = args[ 2 ];\r\n\t\t\tcpy  = args[ 3 ];\r\n\r\n\t\t\tcpx1 = args[ 0 ];\r\n\t\t\tcpy1 = args[ 1 ];\r\n\r\n\t\t\tif ( points.length > 0 ) {\r\n\r\n\t\t\t\tlaste = points[ points.length - 1 ];\r\n\r\n\t\t\t\tcpx0 = laste.x;\r\n\t\t\t\tcpy0 = laste.y;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tlaste = this.actions[ i - 1 ].args;\r\n\r\n\t\t\t\tcpx0 = laste[ laste.length - 2 ];\r\n\t\t\t\tcpy0 = laste[ laste.length - 1 ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var j = 1; j <= divisions; j ++ ) {\r\n\r\n\t\t\t\tvar t = j / divisions;\r\n\r\n\t\t\t\ttx = b2( t, cpx0, cpx1, cpx );\r\n\t\t\t\tty = b2( t, cpy0, cpy1, cpy );\r\n\r\n\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tbreak;\r\n\r\n\t\tcase 'bezierCurveTo':\r\n\r\n\t\t\tcpx  = args[ 4 ];\r\n\t\t\tcpy  = args[ 5 ];\r\n\r\n\t\t\tcpx1 = args[ 0 ];\r\n\t\t\tcpy1 = args[ 1 ];\r\n\r\n\t\t\tcpx2 = args[ 2 ];\r\n\t\t\tcpy2 = args[ 3 ];\r\n\r\n\t\t\tif ( points.length > 0 ) {\r\n\r\n\t\t\t\tlaste = points[ points.length - 1 ];\r\n\r\n\t\t\t\tcpx0 = laste.x;\r\n\t\t\t\tcpy0 = laste.y;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tlaste = this.actions[ i - 1 ].args;\r\n\r\n\t\t\t\tcpx0 = laste[ laste.length - 2 ];\r\n\t\t\t\tcpy0 = laste[ laste.length - 1 ];\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t\tfor ( var j = 1; j <= divisions; j ++ ) {\r\n\r\n\t\t\t\tvar t = j / divisions;\r\n\r\n\t\t\t\ttx = b3( t, cpx0, cpx1, cpx2, cpx );\r\n\t\t\t\tty = b3( t, cpy0, cpy1, cpy2, cpy );\r\n\r\n\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tbreak;\r\n\r\n\t\tcase 'splineThru':\r\n\r\n\t\t\tlaste = this.actions[ i - 1 ].args;\r\n\r\n\t\t\tvar last = new THREE.Vector2( laste[ laste.length - 2 ], laste[ laste.length - 1 ] );\r\n\t\t\tvar spts = [ last ];\r\n\r\n\t\t\tvar n = divisions * args[ 0 ].length;\r\n\r\n\t\t\tspts = spts.concat( args[ 0 ] );\r\n\r\n\t\t\tvar spline = new THREE.SplineCurve( spts );\r\n\r\n\t\t\tfor ( var j = 1; j <= n; j ++ ) {\r\n\r\n\t\t\t\tpoints.push( spline.getPointAt( j / n ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tbreak;\r\n\r\n\t\tcase 'arc':\r\n\r\n\t\t\tvar aX = args[ 0 ], aY = args[ 1 ],\r\n\t\t\t\taRadius = args[ 2 ],\r\n\t\t\t\taStartAngle = args[ 3 ], aEndAngle = args[ 4 ],\r\n\t\t\t\taClockwise = !! args[ 5 ];\r\n\r\n\t\t\tvar deltaAngle = aEndAngle - aStartAngle;\r\n\t\t\tvar angle;\r\n\t\t\tvar tdivisions = divisions * 2;\r\n\r\n\t\t\tfor ( var j = 1; j <= tdivisions; j ++ ) {\r\n\r\n\t\t\t\tvar t = j / tdivisions;\r\n\r\n\t\t\t\tif ( ! aClockwise ) {\r\n\r\n\t\t\t\t\tt = 1 - t;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tangle = aStartAngle + t * deltaAngle;\r\n\r\n\t\t\t\ttx = aX + aRadius * Math.cos( angle );\r\n\t\t\t\tty = aY + aRadius * Math.sin( angle );\r\n\r\n\t\t\t\t//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);\r\n\r\n\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t//console.log(points);\r\n\r\n\t\t\tbreak;\r\n\r\n\t\tcase 'ellipse':\r\n\r\n\t\t\tvar aX = args[ 0 ], aY = args[ 1 ],\r\n\t\t\t\txRadius = args[ 2 ],\r\n\t\t\t\tyRadius = args[ 3 ],\r\n\t\t\t\taStartAngle = args[ 4 ], aEndAngle = args[ 5 ],\r\n\t\t\t\taClockwise = !! args[ 6 ],\r\n\t\t\t\taRotation = args[ 7 ];\r\n\r\n\r\n\t\t\tvar deltaAngle = aEndAngle - aStartAngle;\r\n\t\t\tvar angle;\r\n\t\t\tvar tdivisions = divisions * 2;\r\n\r\n\t\t\tvar cos, sin;\r\n\t\t\tif ( aRotation !== 0 ) {\r\n\r\n\t\t\t\tcos = Math.cos( aRotation );\r\n\t\t\t\tsin = Math.sin( aRotation );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var j = 1; j <= tdivisions; j ++ ) {\r\n\r\n\t\t\t\tvar t = j / tdivisions;\r\n\r\n\t\t\t\tif ( ! aClockwise ) {\r\n\r\n\t\t\t\t\tt = 1 - t;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tangle = aStartAngle + t * deltaAngle;\r\n\r\n\t\t\t\ttx = aX + xRadius * Math.cos( angle );\r\n\t\t\t\tty = aY + yRadius * Math.sin( angle );\r\n\r\n\t\t\t\tif ( aRotation !== 0 ) {\r\n\r\n\t\t\t\t\tvar x = tx, y = ty;\r\n\r\n\t\t\t\t\t// Rotate the point about the center of the ellipse.\r\n\t\t\t\t\ttx = ( x - aX ) * cos - ( y - aY ) * sin + aX;\r\n\t\t\t\t\tty = ( x - aX ) * sin + ( y - aY ) * cos + aY;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);\r\n\r\n\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t//console.log(points);\r\n\r\n\t\t\tbreak;\r\n\r\n\t\t} // end switch\r\n\r\n\t}\r\n\r\n\r\n\r\n\t// Normalize to remove the closing point by default.\r\n\tvar lastPoint = points[ points.length - 1 ];\r\n\tif ( Math.abs( lastPoint.x - points[ 0 ].x ) < Number.EPSILON &&\r\n\t\t\t Math.abs( lastPoint.y - points[ 0 ].y ) < Number.EPSILON )\r\n\t\tpoints.splice( points.length - 1, 1 );\r\n\r\n\tif ( this.autoClose ) {\r\n\r\n\t\tpoints.push( points[ 0 ] );\r\n\r\n\t}\r\n\r\n\treturn points;\r\n\r\n};\r\n\r\n//\r\n// Breaks path into shapes\r\n//\r\n//\tAssumptions (if parameter isCCW==true the opposite holds):\r\n//\t- solid shapes are defined clockwise (CW)\r\n//\t- holes are defined counterclockwise (CCW)\r\n//\r\n//\tIf parameter noHoles==true:\r\n//  - all subPaths are regarded as solid shapes\r\n//  - definition order CW/CCW has no relevance\r\n//\r\n\r\nTHREE.Path.prototype.toShapes = function( isCCW, noHoles ) {\r\n\r\n\tfunction extractSubpaths( inActions ) {\r\n\r\n\t\tvar subPaths = [], lastPath = new THREE.Path();\r\n\r\n\t\tfor ( var i = 0, l = inActions.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar item = inActions[ i ];\r\n\r\n\t\t\tvar args = item.args;\r\n\t\t\tvar action = item.action;\r\n\r\n\t\t\tif ( action === 'moveTo' ) {\r\n\r\n\t\t\t\tif ( lastPath.actions.length !== 0 ) {\r\n\r\n\t\t\t\t\tsubPaths.push( lastPath );\r\n\t\t\t\t\tlastPath = new THREE.Path();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tlastPath[ action ].apply( lastPath, args );\r\n\r\n\t\t}\r\n\r\n\t\tif ( lastPath.actions.length !== 0 ) {\r\n\r\n\t\t\tsubPaths.push( lastPath );\r\n\r\n\t\t}\r\n\r\n\t\t// console.log(subPaths);\r\n\r\n\t\treturn\tsubPaths;\r\n\r\n\t}\r\n\r\n\tfunction toShapesNoHoles( inSubpaths ) {\r\n\r\n\t\tvar shapes = [];\r\n\r\n\t\tfor ( var i = 0, l = inSubpaths.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar tmpPath = inSubpaths[ i ];\r\n\r\n\t\t\tvar tmpShape = new THREE.Shape();\r\n\t\t\ttmpShape.actions = tmpPath.actions;\r\n\t\t\ttmpShape.curves = tmpPath.curves;\r\n\r\n\t\t\tshapes.push( tmpShape );\r\n\r\n\t\t}\r\n\r\n\t\t//console.log(\"shape\", shapes);\r\n\r\n\t\treturn shapes;\r\n\r\n\t}\r\n\r\n\tfunction isPointInsidePolygon( inPt, inPolygon ) {\r\n\r\n\t\tvar polyLen = inPolygon.length;\r\n\r\n\t\t// inPt on polygon contour => immediate success    or\r\n\t\t// toggling of inside/outside at every single! intersection point of an edge\r\n\t\t//  with the horizontal line through inPt, left of inPt\r\n\t\t//  not counting lowerY endpoints of edges and whole edges on that line\r\n\t\tvar inside = false;\r\n\t\tfor ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {\r\n\r\n\t\t\tvar edgeLowPt  = inPolygon[ p ];\r\n\t\t\tvar edgeHighPt = inPolygon[ q ];\r\n\r\n\t\t\tvar edgeDx = edgeHighPt.x - edgeLowPt.x;\r\n\t\t\tvar edgeDy = edgeHighPt.y - edgeLowPt.y;\r\n\r\n\t\t\tif ( Math.abs( edgeDy ) > Number.EPSILON ) {\r\n\r\n\t\t\t\t// not parallel\r\n\t\t\t\tif ( edgeDy < 0 ) {\r\n\r\n\t\t\t\t\tedgeLowPt  = inPolygon[ q ]; edgeDx = - edgeDx;\r\n\t\t\t\t\tedgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;\r\n\r\n\t\t\t\t}\r\n\t\t\t\tif ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) \t\tcontinue;\r\n\r\n\t\t\t\tif ( inPt.y === edgeLowPt.y ) {\r\n\r\n\t\t\t\t\tif ( inPt.x === edgeLowPt.x )\t\treturn\ttrue;\t\t// inPt is on contour ?\r\n\t\t\t\t\t// continue;\t\t\t\t// no intersection or edgeLowPt => doesn't count !!!\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tvar perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );\r\n\t\t\t\t\tif ( perpEdge === 0 )\t\t\t\treturn\ttrue;\t\t// inPt is on contour ?\r\n\t\t\t\t\tif ( perpEdge < 0 ) \t\t\t\tcontinue;\r\n\t\t\t\t\tinside = ! inside;\t\t// true intersection left of inPt\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// parallel or collinear\r\n\t\t\t\tif ( inPt.y !== edgeLowPt.y ) \t\tcontinue;\t\t\t// parallel\r\n\t\t\t\t// edge lies on the same horizontal line as inPt\r\n\t\t\t\tif ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||\r\n\t\t\t\t\t ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )\t\treturn\ttrue;\t// inPt: Point on contour !\r\n\t\t\t\t// continue;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn\tinside;\r\n\r\n\t}\r\n\r\n\tvar isClockWise = THREE.ShapeUtils.isClockWise;\r\n\r\n\tvar subPaths = extractSubpaths( this.actions );\r\n\tif ( subPaths.length === 0 ) return [];\r\n\r\n\tif ( noHoles === true )\treturn\ttoShapesNoHoles( subPaths );\r\n\r\n\r\n\tvar solid, tmpPath, tmpShape, shapes = [];\r\n\r\n\tif ( subPaths.length === 1 ) {\r\n\r\n\t\ttmpPath = subPaths[ 0 ];\r\n\t\ttmpShape = new THREE.Shape();\r\n\t\ttmpShape.actions = tmpPath.actions;\r\n\t\ttmpShape.curves = tmpPath.curves;\r\n\t\tshapes.push( tmpShape );\r\n\t\treturn shapes;\r\n\r\n\t}\r\n\r\n\tvar holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );\r\n\tholesFirst = isCCW ? ! holesFirst : holesFirst;\r\n\r\n\t// console.log(\"Holes first\", holesFirst);\r\n\r\n\tvar betterShapeHoles = [];\r\n\tvar newShapes = [];\r\n\tvar newShapeHoles = [];\r\n\tvar mainIdx = 0;\r\n\tvar tmpPoints;\r\n\r\n\tnewShapes[ mainIdx ] = undefined;\r\n\tnewShapeHoles[ mainIdx ] = [];\r\n\r\n\tfor ( var i = 0, l = subPaths.length; i < l; i ++ ) {\r\n\r\n\t\ttmpPath = subPaths[ i ];\r\n\t\ttmpPoints = tmpPath.getPoints();\r\n\t\tsolid = isClockWise( tmpPoints );\r\n\t\tsolid = isCCW ? ! solid : solid;\r\n\r\n\t\tif ( solid ) {\r\n\r\n\t\t\tif ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )\tmainIdx ++;\r\n\r\n\t\t\tnewShapes[ mainIdx ] = { s: new THREE.Shape(), p: tmpPoints };\r\n\t\t\tnewShapes[ mainIdx ].s.actions = tmpPath.actions;\r\n\t\t\tnewShapes[ mainIdx ].s.curves = tmpPath.curves;\r\n\r\n\t\t\tif ( holesFirst )\tmainIdx ++;\r\n\t\t\tnewShapeHoles[ mainIdx ] = [];\r\n\r\n\t\t\t//console.log('cw', i);\r\n\r\n\t\t} else {\r\n\r\n\t\t\tnewShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );\r\n\r\n\t\t\t//console.log('ccw', i);\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// only Holes? -> probably all Shapes with wrong orientation\r\n\tif ( ! newShapes[ 0 ] )\treturn\ttoShapesNoHoles( subPaths );\r\n\r\n\r\n\tif ( newShapes.length > 1 ) {\r\n\r\n\t\tvar ambiguous = false;\r\n\t\tvar toChange = [];\r\n\r\n\t\tfor ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\r\n\r\n\t\t\tbetterShapeHoles[ sIdx ] = [];\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\r\n\r\n\t\t\tvar sho = newShapeHoles[ sIdx ];\r\n\r\n\t\t\tfor ( var hIdx = 0; hIdx < sho.length; hIdx ++ ) {\r\n\r\n\t\t\t\tvar ho = sho[ hIdx ];\r\n\t\t\t\tvar hole_unassigned = true;\r\n\r\n\t\t\t\tfor ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {\r\n\r\n\t\t\t\t\tif ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {\r\n\r\n\t\t\t\t\t\tif ( sIdx !== s2Idx )\ttoChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );\r\n\t\t\t\t\t\tif ( hole_unassigned ) {\r\n\r\n\t\t\t\t\t\t\thole_unassigned = false;\r\n\t\t\t\t\t\t\tbetterShapeHoles[ s2Idx ].push( ho );\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tambiguous = true;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\t\t\t\tif ( hole_unassigned ) {\r\n\r\n\t\t\t\t\tbetterShapeHoles[ sIdx ].push( ho );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t\t// console.log(\"ambiguous: \", ambiguous);\r\n\t\tif ( toChange.length > 0 ) {\r\n\r\n\t\t\t// console.log(\"to change: \", toChange);\r\n\t\t\tif ( ! ambiguous )\tnewShapeHoles = betterShapeHoles;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tvar tmpHoles;\r\n\r\n\tfor ( var i = 0, il = newShapes.length; i < il; i ++ ) {\r\n\r\n\t\ttmpShape = newShapes[ i ].s;\r\n\t\tshapes.push( tmpShape );\r\n\t\ttmpHoles = newShapeHoles[ i ];\r\n\r\n\t\tfor ( var j = 0, jl = tmpHoles.length; j < jl; j ++ ) {\r\n\r\n\t\t\ttmpShape.holes.push( tmpHoles[ j ].h );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t//console.log(\"shape\", shapes);\r\n\r\n\treturn shapes;\r\n\r\n};\r\n\r\n// File:src/extras/core/Shape.js\r\n\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * Defines a 2d shape plane using paths.\r\n **/\r\n\r\n// STEP 1 Create a path.\r\n// STEP 2 Turn path into shape.\r\n// STEP 3 ExtrudeGeometry takes in Shape/Shapes\r\n// STEP 3a - Extract points from each shape, turn to vertices\r\n// STEP 3b - Triangulate each shape, add faces.\r\n\r\nTHREE.Shape = function () {\r\n\r\n\tTHREE.Path.apply( this, arguments );\r\n\r\n\tthis.holes = [];\r\n\r\n};\r\n\r\nTHREE.Shape.prototype = Object.create( THREE.Path.prototype );\r\nTHREE.Shape.prototype.constructor = THREE.Shape;\r\n\r\n// Convenience method to return ExtrudeGeometry\r\n\r\nTHREE.Shape.prototype.extrude = function ( options ) {\r\n\r\n\treturn new THREE.ExtrudeGeometry( this, options );\r\n\r\n};\r\n\r\n// Convenience method to return ShapeGeometry\r\n\r\nTHREE.Shape.prototype.makeGeometry = function ( options ) {\r\n\r\n\treturn new THREE.ShapeGeometry( this, options );\r\n\r\n};\r\n\r\n// Get points of holes\r\n\r\nTHREE.Shape.prototype.getPointsHoles = function ( divisions ) {\r\n\r\n\tvar holesPts = [];\r\n\r\n\tfor ( var i = 0, l = this.holes.length; i < l; i ++ ) {\r\n\r\n\t\tholesPts[ i ] = this.holes[ i ].getPoints( divisions );\r\n\r\n\t}\r\n\r\n\treturn holesPts;\r\n\r\n};\r\n\r\n\r\n// Get points of shape and holes (keypoints based on segments parameter)\r\n\r\nTHREE.Shape.prototype.extractAllPoints = function ( divisions ) {\r\n\r\n\treturn {\r\n\r\n\t\tshape: this.getPoints( divisions ),\r\n\t\tholes: this.getPointsHoles( divisions )\r\n\r\n\t};\r\n\r\n};\r\n\r\nTHREE.Shape.prototype.extractPoints = function ( divisions ) {\r\n\r\n\treturn this.extractAllPoints( divisions );\r\n\r\n};\r\n\r\n// File:src/extras/curves/LineCurve.js\r\n\r\n/**************************************************************\r\n *\tLine\r\n **************************************************************/\r\n\r\nTHREE.LineCurve = function ( v1, v2 ) {\r\n\r\n\tthis.v1 = v1;\r\n\tthis.v2 = v2;\r\n\r\n};\r\n\r\nTHREE.LineCurve.prototype = Object.create( THREE.Curve.prototype );\r\nTHREE.LineCurve.prototype.constructor = THREE.LineCurve;\r\n\r\nTHREE.LineCurve.prototype.getPoint = function ( t ) {\r\n\r\n\tvar point = this.v2.clone().sub( this.v1 );\r\n\tpoint.multiplyScalar( t ).add( this.v1 );\r\n\r\n\treturn point;\r\n\r\n};\r\n\r\n// Line curve is linear, so we can overwrite default getPointAt\r\n\r\nTHREE.LineCurve.prototype.getPointAt = function ( u ) {\r\n\r\n\treturn this.getPoint( u );\r\n\r\n};\r\n\r\nTHREE.LineCurve.prototype.getTangent = function( t ) {\r\n\r\n\tvar tangent = this.v2.clone().sub( this.v1 );\r\n\r\n\treturn tangent.normalize();\r\n\r\n};\r\n\r\n// File:src/extras/curves/QuadraticBezierCurve.js\r\n\r\n/**************************************************************\r\n *\tQuadratic Bezier curve\r\n **************************************************************/\r\n\r\n\r\nTHREE.QuadraticBezierCurve = function ( v0, v1, v2 ) {\r\n\r\n\tthis.v0 = v0;\r\n\tthis.v1 = v1;\r\n\tthis.v2 = v2;\r\n\r\n};\r\n\r\nTHREE.QuadraticBezierCurve.prototype = Object.create( THREE.Curve.prototype );\r\nTHREE.QuadraticBezierCurve.prototype.constructor = THREE.QuadraticBezierCurve;\r\n\r\n\r\nTHREE.QuadraticBezierCurve.prototype.getPoint = function ( t ) {\r\n\r\n\tvar b2 = THREE.ShapeUtils.b2;\r\n\r\n\treturn new THREE.Vector2(\r\n\t\tb2( t, this.v0.x, this.v1.x, this.v2.x ),\r\n\t\tb2( t, this.v0.y, this.v1.y, this.v2.y )\r\n\t);\r\n\r\n};\r\n\r\n\r\nTHREE.QuadraticBezierCurve.prototype.getTangent = function( t ) {\r\n\r\n\tvar tangentQuadraticBezier = THREE.CurveUtils.tangentQuadraticBezier;\r\n\r\n\treturn new THREE.Vector2(\r\n\t\ttangentQuadraticBezier( t, this.v0.x, this.v1.x, this.v2.x ),\r\n\t\ttangentQuadraticBezier( t, this.v0.y, this.v1.y, this.v2.y )\r\n\t).normalize();\r\n\r\n};\r\n\r\n// File:src/extras/curves/CubicBezierCurve.js\r\n\r\n/**************************************************************\r\n *\tCubic Bezier curve\r\n **************************************************************/\r\n\r\nTHREE.CubicBezierCurve = function ( v0, v1, v2, v3 ) {\r\n\r\n\tthis.v0 = v0;\r\n\tthis.v1 = v1;\r\n\tthis.v2 = v2;\r\n\tthis.v3 = v3;\r\n\r\n};\r\n\r\nTHREE.CubicBezierCurve.prototype = Object.create( THREE.Curve.prototype );\r\nTHREE.CubicBezierCurve.prototype.constructor = THREE.CubicBezierCurve;\r\n\r\nTHREE.CubicBezierCurve.prototype.getPoint = function ( t ) {\r\n\r\n\tvar b3 = THREE.ShapeUtils.b3;\r\n\r\n\treturn new THREE.Vector2( \r\n\t\tb3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),\r\n\t\tb3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y )\r\n\t);\r\n\r\n};\r\n\r\nTHREE.CubicBezierCurve.prototype.getTangent = function( t ) {\r\n\r\n\tvar tangentCubicBezier = THREE.CurveUtils.tangentCubicBezier;\r\n\r\n\treturn new THREE.Vector2( \r\n\t\ttangentCubicBezier( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),\r\n\t\ttangentCubicBezier( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y )\r\n\t).normalize();\r\n\r\n};\r\n\r\n// File:src/extras/curves/SplineCurve.js\r\n\r\n/**************************************************************\r\n *\tSpline curve\r\n **************************************************************/\r\n\r\nTHREE.SplineCurve = function ( points /* array of Vector2 */ ) {\r\n\r\n\tthis.points = ( points == undefined ) ? [] : points;\r\n\r\n};\r\n\r\nTHREE.SplineCurve.prototype = Object.create( THREE.Curve.prototype );\r\nTHREE.SplineCurve.prototype.constructor = THREE.SplineCurve;\r\n\r\nTHREE.SplineCurve.prototype.getPoint = function ( t ) {\r\n\r\n\tvar points = this.points;\r\n\tvar point = ( points.length - 1 ) * t;\r\n\r\n\tvar intPoint = Math.floor( point );\r\n\tvar weight = point - intPoint;\r\n\r\n\tvar point0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];\r\n\tvar point1 = points[ intPoint ];\r\n\tvar point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];\r\n\tvar point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];\r\n\r\n\tvar interpolate = THREE.CurveUtils.interpolate;\r\n\r\n\treturn new THREE.Vector2(\r\n\t\tinterpolate( point0.x, point1.x, point2.x, point3.x, weight ),\r\n\t\tinterpolate( point0.y, point1.y, point2.y, point3.y, weight )\r\n\t);\r\n\r\n};\r\n\r\n// File:src/extras/curves/EllipseCurve.js\r\n\r\n/**************************************************************\r\n *\tEllipse curve\r\n **************************************************************/\r\n\r\nTHREE.EllipseCurve = function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\r\n\r\n\tthis.aX = aX;\r\n\tthis.aY = aY;\r\n\r\n\tthis.xRadius = xRadius;\r\n\tthis.yRadius = yRadius;\r\n\r\n\tthis.aStartAngle = aStartAngle;\r\n\tthis.aEndAngle = aEndAngle;\r\n\r\n\tthis.aClockwise = aClockwise;\r\n\t\r\n\tthis.aRotation = aRotation || 0;\r\n\r\n};\r\n\r\nTHREE.EllipseCurve.prototype = Object.create( THREE.Curve.prototype );\r\nTHREE.EllipseCurve.prototype.constructor = THREE.EllipseCurve;\r\n\r\nTHREE.EllipseCurve.prototype.getPoint = function ( t ) {\r\n\r\n\tvar deltaAngle = this.aEndAngle - this.aStartAngle;\r\n\r\n\tif ( deltaAngle < 0 ) deltaAngle += Math.PI * 2;\r\n\tif ( deltaAngle > Math.PI * 2 ) deltaAngle -= Math.PI * 2;\r\n\r\n\tvar angle;\r\n\r\n\tif ( this.aClockwise === true ) {\r\n\r\n\t\tangle = this.aEndAngle + ( 1 - t ) * ( Math.PI * 2 - deltaAngle );\r\n\r\n\t} else {\r\n\r\n\t\tangle = this.aStartAngle + t * deltaAngle;\r\n\r\n\t}\r\n\t\r\n\tvar x = this.aX + this.xRadius * Math.cos( angle );\r\n\tvar y = this.aY + this.yRadius * Math.sin( angle );\r\n\r\n\tif ( this.aRotation !== 0 ) {\r\n\r\n\t\tvar cos = Math.cos( this.aRotation );\r\n\t\tvar sin = Math.sin( this.aRotation );\r\n\r\n\t\tvar tx = x, ty = y;\r\n\r\n\t\t// Rotate the point about the center of the ellipse.\r\n\t\tx = ( tx - this.aX ) * cos - ( ty - this.aY ) * sin + this.aX;\r\n\t\ty = ( tx - this.aX ) * sin + ( ty - this.aY ) * cos + this.aY;\r\n\r\n\t}\r\n\r\n\treturn new THREE.Vector2( x, y );\r\n\r\n};\r\n\r\n// File:src/extras/curves/ArcCurve.js\r\n\r\n/**************************************************************\r\n *\tArc curve\r\n **************************************************************/\r\n\r\nTHREE.ArcCurve = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\r\n\r\n\tTHREE.EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\r\n\r\n};\r\n\r\nTHREE.ArcCurve.prototype = Object.create( THREE.EllipseCurve.prototype );\r\nTHREE.ArcCurve.prototype.constructor = THREE.ArcCurve;\r\n\r\n// File:src/extras/curves/LineCurve3.js\r\n\r\n/**************************************************************\r\n *\tLine3D\r\n **************************************************************/\r\n\r\nTHREE.LineCurve3 = THREE.Curve.create(\r\n\r\n\tfunction ( v1, v2 ) {\r\n\r\n\t\tthis.v1 = v1;\r\n\t\tthis.v2 = v2;\r\n\r\n\t},\r\n\r\n\tfunction ( t ) {\r\n\r\n\t\tvar vector = new THREE.Vector3();\r\n\r\n\t\tvector.subVectors( this.v2, this.v1 ); // diff\r\n\t\tvector.multiplyScalar( t );\r\n\t\tvector.add( this.v1 );\r\n\r\n\t\treturn vector;\r\n\r\n\t}\r\n\r\n);\r\n\r\n// File:src/extras/curves/QuadraticBezierCurve3.js\r\n\r\n/**************************************************************\r\n *\tQuadratic Bezier 3D curve\r\n **************************************************************/\r\n\r\nTHREE.QuadraticBezierCurve3 = THREE.Curve.create(\r\n\r\n\tfunction ( v0, v1, v2 ) {\r\n\r\n\t\tthis.v0 = v0;\r\n\t\tthis.v1 = v1;\r\n\t\tthis.v2 = v2;\r\n\r\n\t},\r\n\r\n\tfunction ( t ) {\r\n\r\n\t\tvar b2 = THREE.ShapeUtils.b2;\t\t\r\n\r\n\t\treturn new THREE.Vector3(\r\n\t\t\tb2( t, this.v0.x, this.v1.x, this.v2.x ),\r\n\t\t\tb2( t, this.v0.y, this.v1.y, this.v2.y ),\r\n\t\t\tb2( t, this.v0.z, this.v1.z, this.v2.z )\r\n\t\t);\r\n\r\n\t}\r\n\r\n);\r\n\r\n// File:src/extras/curves/CubicBezierCurve3.js\r\n\r\n/**************************************************************\r\n *\tCubic Bezier 3D curve\r\n **************************************************************/\r\n\r\nTHREE.CubicBezierCurve3 = THREE.Curve.create(\r\n\r\n\tfunction ( v0, v1, v2, v3 ) {\r\n\r\n\t\tthis.v0 = v0;\r\n\t\tthis.v1 = v1;\r\n\t\tthis.v2 = v2;\r\n\t\tthis.v3 = v3;\r\n\r\n\t},\r\n\r\n\tfunction ( t ) {\r\n\r\n\t\tvar b3 = THREE.ShapeUtils.b3;\r\n\r\n\t\treturn new THREE.Vector3(\r\n\t\t\tb3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),\r\n\t\t\tb3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y ),\r\n\t\t\tb3( t, this.v0.z, this.v1.z, this.v2.z, this.v3.z )\r\n\t\t);\r\n\r\n\t}\r\n\r\n);\r\n\r\n// File:src/extras/curves/SplineCurve3.js\r\n\r\n/**************************************************************\r\n *\tSpline 3D curve\r\n **************************************************************/\r\n\r\n\r\nTHREE.SplineCurve3 = THREE.Curve.create(\r\n\r\n\tfunction ( points /* array of Vector3 */ ) {\r\n\r\n\t\tconsole.warn( 'THREE.SplineCurve3 will be deprecated. Please use THREE.CatmullRomCurve3' );\r\n\t\tthis.points = ( points == undefined ) ? [] : points;\r\n\r\n\t},\r\n\r\n\tfunction ( t ) {\r\n\r\n\t\tvar points = this.points;\r\n\t\tvar point = ( points.length - 1 ) * t;\r\n\r\n\t\tvar intPoint = Math.floor( point );\r\n\t\tvar weight = point - intPoint;\r\n\r\n\t\tvar point0 = points[ intPoint == 0 ? intPoint : intPoint - 1 ];\r\n\t\tvar point1 = points[ intPoint ];\r\n\t\tvar point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];\r\n\t\tvar point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];\r\n\r\n\t\tvar interpolate = THREE.CurveUtils.interpolate;\r\n\r\n\t\treturn new THREE.Vector3(\r\n\t\t\tinterpolate( point0.x, point1.x, point2.x, point3.x, weight ),\r\n\t\t\tinterpolate( point0.y, point1.y, point2.y, point3.y, weight ),\r\n\t\t\tinterpolate( point0.z, point1.z, point2.z, point3.z, weight )\r\n\t\t);\r\n\r\n\t}\r\n\r\n);\r\n\r\n// File:src/extras/curves/CatmullRomCurve3.js\r\n\r\n/**\r\n * @author zz85 https://github.com/zz85\r\n *\r\n * Centripetal CatmullRom Curve - which is useful for avoiding\r\n * cusps and self-intersections in non-uniform catmull rom curves.\r\n * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf\r\n *\r\n * curve.type accepts centripetal(default), chordal and catmullrom\r\n * curve.tension is used for catmullrom which defaults to 0.5\r\n */\r\n\r\nTHREE.CatmullRomCurve3 = ( function() {\r\n\r\n\tvar\r\n\t\ttmp = new THREE.Vector3(),\r\n\t\tpx = new CubicPoly(),\r\n\t\tpy = new CubicPoly(),\r\n\t\tpz = new CubicPoly();\r\n\r\n\t/*\r\n\tBased on an optimized c++ solution in\r\n\t - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/\r\n\t - http://ideone.com/NoEbVM\r\n\r\n\tThis CubicPoly class could be used for reusing some variables and calculations,\r\n\tbut for three.js curve use, it could be possible inlined and flatten into a single function call\r\n\twhich can be placed in CurveUtils.\r\n\t*/\r\n\r\n\tfunction CubicPoly() {\r\n\r\n\t}\r\n\r\n\t/*\r\n\t * Compute coefficients for a cubic polynomial\r\n\t *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3\r\n\t * such that\r\n\t *   p(0) = x0, p(1) = x1\r\n\t *  and\r\n\t *   p'(0) = t0, p'(1) = t1.\r\n\t */\r\n\tCubicPoly.prototype.init = function( x0, x1, t0, t1 ) {\r\n\r\n\t\tthis.c0 = x0;\r\n\t\tthis.c1 = t0;\r\n\t\tthis.c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;\r\n\t\tthis.c3 = 2 * x0 - 2 * x1 + t0 + t1;\r\n\r\n\t};\r\n\r\n\tCubicPoly.prototype.initNonuniformCatmullRom = function( x0, x1, x2, x3, dt0, dt1, dt2 ) {\r\n\r\n\t\t// compute tangents when parameterized in [t1,t2]\r\n\t\tvar t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;\r\n\t\tvar t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;\r\n\r\n\t\t// rescale tangents for parametrization in [0,1]\r\n\t\tt1 *= dt1;\r\n\t\tt2 *= dt1;\r\n\r\n\t\t// initCubicPoly\r\n\t\tthis.init( x1, x2, t1, t2 );\r\n\r\n\t};\r\n\r\n\t// standard Catmull-Rom spline: interpolate between x1 and x2 with previous/following points x1/x4\r\n\tCubicPoly.prototype.initCatmullRom = function( x0, x1, x2, x3, tension ) {\r\n\r\n\t\tthis.init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );\r\n\r\n\t};\r\n\r\n\tCubicPoly.prototype.calc = function( t ) {\r\n\r\n\t\tvar t2 = t * t;\r\n\t\tvar t3 = t2 * t;\r\n\t\treturn this.c0 + this.c1 * t + this.c2 * t2 + this.c3 * t3;\r\n\r\n\t};\r\n\r\n\t// Subclass Three.js curve\r\n\treturn THREE.Curve.create(\r\n\r\n\t\tfunction ( p /* array of Vector3 */ ) {\r\n\r\n\t\t\tthis.points = p || [];\r\n\t\t\tthis.closed = false;\r\n\r\n\t\t},\r\n\r\n\t\tfunction ( t ) {\r\n\r\n\t\t\tvar points = this.points,\r\n\t\t\t\tpoint, intPoint, weight, l;\r\n\r\n\t\t\tl = points.length;\r\n\r\n\t\t\tif ( l < 2 ) console.log( 'duh, you need at least 2 points' );\r\n\r\n\t\t\tpoint = ( l - ( this.closed ? 0 : 1 ) ) * t;\r\n\t\t\tintPoint = Math.floor( point );\r\n\t\t\tweight = point - intPoint;\r\n\r\n\t\t\tif ( this.closed ) {\r\n\r\n\t\t\t\tintPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;\r\n\r\n\t\t\t} else if ( weight === 0 && intPoint === l - 1 ) {\r\n\r\n\t\t\t\tintPoint = l - 2;\r\n\t\t\t\tweight = 1;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar p0, p1, p2, p3; // 4 points\r\n\r\n\t\t\tif ( this.closed || intPoint > 0 ) {\r\n\r\n\t\t\t\tp0 = points[ ( intPoint - 1 ) % l ];\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// extrapolate first point\r\n\t\t\t\ttmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );\r\n\t\t\t\tp0 = tmp;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tp1 = points[ intPoint % l ];\r\n\t\t\tp2 = points[ ( intPoint + 1 ) % l ];\r\n\r\n\t\t\tif ( this.closed || intPoint + 2 < l ) {\r\n\r\n\t\t\t\tp3 = points[ ( intPoint + 2 ) % l ];\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// extrapolate last point\r\n\t\t\t\ttmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );\r\n\t\t\t\tp3 = tmp;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( this.type === undefined || this.type === 'centripetal' || this.type === 'chordal' ) {\r\n\r\n\t\t\t\t// init Centripetal / Chordal Catmull-Rom\r\n\t\t\t\tvar pow = this.type === 'chordal' ? 0.5 : 0.25;\r\n\t\t\t\tvar dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );\r\n\t\t\t\tvar dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );\r\n\t\t\t\tvar dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );\r\n\r\n\t\t\t\t// safety check for repeated points\r\n\t\t\t\tif ( dt1 < 1e-4 ) dt1 = 1.0;\r\n\t\t\t\tif ( dt0 < 1e-4 ) dt0 = dt1;\r\n\t\t\t\tif ( dt2 < 1e-4 ) dt2 = dt1;\r\n\r\n\t\t\t\tpx.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );\r\n\t\t\t\tpy.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );\r\n\t\t\t\tpz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );\r\n\r\n\t\t\t} else if ( this.type === 'catmullrom' ) {\r\n\r\n\t\t\t\tvar tension = this.tension !== undefined ? this.tension : 0.5;\r\n\t\t\t\tpx.initCatmullRom( p0.x, p1.x, p2.x, p3.x, tension );\r\n\t\t\t\tpy.initCatmullRom( p0.y, p1.y, p2.y, p3.y, tension );\r\n\t\t\t\tpz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, tension );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar v = new THREE.Vector3(\r\n\t\t\t\tpx.calc( weight ),\r\n\t\t\t\tpy.calc( weight ),\r\n\t\t\t\tpz.calc( weight )\r\n\t\t\t);\r\n\r\n\t\t\treturn v;\r\n\r\n\t\t}\r\n\r\n\t);\r\n\r\n} )();\r\n\r\n// File:src/extras/curves/ClosedSplineCurve3.js\r\n\r\n/**************************************************************\r\n *\tClosed Spline 3D curve\r\n **************************************************************/\r\n\r\n\r\nTHREE.ClosedSplineCurve3 = function ( points ) {\r\n\r\n\tconsole.warn( 'THREE.ClosedSplineCurve3 has been deprecated. Please use THREE.CatmullRomCurve3.' );\r\n\r\n\tTHREE.CatmullRomCurve3.call( this, points );\r\n\tthis.type = 'catmullrom';\r\n\tthis.closed = true;\r\n\r\n};\r\n\r\nTHREE.ClosedSplineCurve3.prototype = Object.create( THREE.CatmullRomCurve3.prototype );\r\n\r\n// File:src/extras/geometries/BoxGeometry.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as\r\n */\r\n\r\nTHREE.BoxGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tthis.type = 'BoxGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\twidth: width,\r\n\t\theight: height,\r\n\t\tdepth: depth,\r\n\t\twidthSegments: widthSegments,\r\n\t\theightSegments: heightSegments,\r\n\t\tdepthSegments: depthSegments\r\n\t};\r\n\r\n\tthis.fromBufferGeometry( new THREE.BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) );\r\n\tthis.mergeVertices();\r\n\r\n};\r\n\r\nTHREE.BoxGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.BoxGeometry.prototype.constructor = THREE.BoxGeometry;\r\n\r\nTHREE.CubeGeometry = THREE.BoxGeometry;\r\n\r\n// File:src/extras/geometries/BoxBufferGeometry.js\r\n\r\n/**\r\n * @author Mugen87 / https://github.com/Mugen87\r\n */\r\n\r\nTHREE.BoxBufferGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {\r\n\r\n\tTHREE.BufferGeometry.call( this );\r\n\r\n\tthis.type = 'BoxBufferGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\twidth: width,\r\n\t\theight: height,\r\n\t\tdepth: depth,\r\n\t\twidthSegments: widthSegments,\r\n\t\theightSegments: heightSegments,\r\n\t\tdepthSegments: depthSegments\r\n\t};\r\n\r\n\tvar scope = this;\r\n\r\n\t// segments\r\n\twidthSegments = Math.floor( widthSegments ) || 1;\r\n\theightSegments = Math.floor( heightSegments ) || 1;\r\n\tdepthSegments = Math.floor( depthSegments ) || 1;\r\n\r\n\t// these are used to calculate buffer length\r\n\tvar vertexCount = calculateVertexCount( widthSegments, heightSegments, depthSegments );\r\n\tvar indexCount = ( vertexCount / 4 ) * 6;\r\n\r\n\t// buffers\r\n\tvar indices = new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount );\r\n\tvar vertices = new Float32Array( vertexCount * 3 );\r\n\tvar normals = new Float32Array( vertexCount * 3 );\r\n\tvar uvs = new Float32Array( vertexCount * 2 );\r\n\r\n\t// offset variables\r\n\tvar vertexBufferOffset = 0;\r\n\tvar uvBufferOffset = 0;\r\n\tvar indexBufferOffset = 0;\r\n\tvar numberOfVertices = 0;\r\n\r\n\t// group variables\r\n\tvar groupStart = 0;\r\n\r\n\t// build each side of the box geometry\r\n\tbuildPlane( 'z', 'y', 'x', - 1, - 1, depth, height,   width,  depthSegments, heightSegments, 0 ); // px\r\n\tbuildPlane( 'z', 'y', 'x',   1, - 1, depth, height, - width,  depthSegments, heightSegments, 1 ); // nx\r\n\tbuildPlane( 'x', 'z', 'y',   1,   1, width, depth,    height, widthSegments, depthSegments,  2 ); // py\r\n\tbuildPlane( 'x', 'z', 'y',   1, - 1, width, depth,  - height, widthSegments, depthSegments,  3 ); // ny\r\n\tbuildPlane( 'x', 'y', 'z',   1, - 1, width, height,   depth,  widthSegments, heightSegments, 4 ); // pz\r\n\tbuildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth,  widthSegments, heightSegments, 5 ); // nz\r\n\r\n\t// build geometry\r\n\tthis.setIndex( new THREE.BufferAttribute( indices, 1 ) );\r\n\tthis.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\r\n\tthis.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );\r\n\tthis.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );\r\n\r\n\t// helper functions\r\n\r\n\tfunction calculateVertexCount ( w, h, d ) {\r\n\r\n\t\tvar segments = 0;\r\n\r\n\t\t// calculate the amount of segments for each side\r\n\t\tsegments += w * h * 2; // xy\r\n\t\tsegments += w * d * 2; // xz\r\n\t\tsegments += d * h * 2; // zy\r\n\r\n\t\treturn segments * 4; // four vertices per segments\r\n\r\n\t}\r\n\r\n\tfunction buildPlane ( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {\r\n\r\n\t\tvar segmentWidth\t= width / gridX;\r\n\t\tvar segmentHeight = height / gridY;\r\n\r\n\t\tvar widthHalf = width / 2;\r\n\t\tvar heightHalf = height / 2;\r\n\t\tvar depthHalf = depth / 2;\r\n\r\n\t\tvar gridX1 = gridX + 1;\r\n\t\tvar gridY1 = gridY + 1;\r\n\r\n\t\tvar vertexCounter = 0;\r\n\t\tvar groupCount = 0;\r\n\r\n\t\tvar vector = new THREE.Vector3();\r\n\r\n\t\t// generate vertices, normals and uvs\r\n\r\n\t\tfor ( var iy = 0; iy < gridY1; iy ++ ) {\r\n\r\n\t\t\tvar y = iy * segmentHeight - heightHalf;\r\n\r\n\t\t\tfor ( var ix = 0; ix < gridX1; ix ++ ) {\r\n\r\n\t\t\t\tvar x = ix * segmentWidth - widthHalf;\r\n\r\n\t\t\t\t// set values to correct vector component\r\n\t\t\t\tvector[ u ] = x * udir;\r\n\t\t\t\tvector[ v ] = y * vdir;\r\n\t\t\t\tvector[ w ] = depthHalf;\r\n\r\n\t\t\t\t// now apply vector to vertex buffer\r\n\t\t\t\tvertices[ vertexBufferOffset ] = vector.x;\r\n\t\t\t\tvertices[ vertexBufferOffset + 1 ] = vector.y;\r\n\t\t\t\tvertices[ vertexBufferOffset + 2 ] = vector.z;\r\n\r\n\t\t\t\t// set values to correct vector component\r\n\t\t\t\tvector[ u ] = 0;\r\n\t\t\t\tvector[ v ] = 0;\r\n\t\t\t\tvector[ w ] = depth > 0 ? 1 : - 1;\r\n\r\n\t\t\t\t// now apply vector to normal buffer\r\n\t\t\t\tnormals[ vertexBufferOffset ] = vector.x;\r\n\t\t\t\tnormals[ vertexBufferOffset + 1 ] = vector.y;\r\n\t\t\t\tnormals[ vertexBufferOffset + 2 ] = vector.z;\r\n\r\n\t\t\t\t// uvs\r\n\t\t\t\tuvs[ uvBufferOffset ] = ix / gridX;\r\n\t\t\t\tuvs[ uvBufferOffset + 1 ] = 1 - ( iy / gridY );\r\n\r\n\t\t\t\t// update offsets and counters\r\n\t\t\t\tvertexBufferOffset += 3;\r\n\t\t\t\tuvBufferOffset += 2;\r\n\t\t\t\tvertexCounter += 1;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// 1. you need three indices to draw a single face\r\n\t\t// 2. a single segment consists of two faces\r\n\t\t// 3. so we need to generate six (2*3) indices per segment\r\n\r\n\t\tfor ( iy = 0; iy < gridY; iy ++ ) {\r\n\r\n\t\t\tfor ( ix = 0; ix < gridX; ix ++ ) {\r\n\r\n\t\t\t\t// indices\r\n\t\t\t\tvar a = numberOfVertices + ix + gridX1 * iy;\r\n\t\t\t\tvar b = numberOfVertices + ix + gridX1 * ( iy + 1 );\r\n\t\t\t\tvar c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );\r\n\t\t\t\tvar d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;\r\n\r\n\t\t\t\t// face one\r\n\t\t\t\tindices[ indexBufferOffset ] = a;\r\n\t\t\t\tindices[ indexBufferOffset + 1 ] = b;\r\n\t\t\t\tindices[ indexBufferOffset + 2 ] = d;\r\n\r\n\t\t\t\t// face two\r\n\t\t\t\tindices[ indexBufferOffset + 3 ] = b;\r\n\t\t\t\tindices[ indexBufferOffset + 4 ] = c;\r\n\t\t\t\tindices[ indexBufferOffset + 5 ] = d;\r\n\r\n\t\t\t\t// update offsets and counters\r\n\t\t\t\tindexBufferOffset += 6;\r\n\t\t\t\tgroupCount += 6;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// add a group to the geometry. this will ensure multi material support\r\n\t\tscope.addGroup( groupStart, groupCount, materialIndex );\r\n\r\n\t\t// calculate new start value for groups\r\n\t\tgroupStart += groupCount;\r\n\r\n\t\t// update total number of vertices\r\n\t\tnumberOfVertices += vertexCounter;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.BoxBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\nTHREE.BoxBufferGeometry.prototype.constructor = THREE.BoxBufferGeometry;\r\n\r\n// File:src/extras/geometries/CircleGeometry.js\r\n\r\n/**\r\n * @author hughes\r\n */\r\n\r\nTHREE.CircleGeometry = function ( radius, segments, thetaStart, thetaLength ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tthis.type = 'CircleGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tradius: radius,\r\n\t\tsegments: segments,\r\n\t\tthetaStart: thetaStart,\r\n\t\tthetaLength: thetaLength\r\n\t};\r\n\r\n\tthis.fromBufferGeometry( new THREE.CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) );\r\n\r\n};\r\n\r\nTHREE.CircleGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.CircleGeometry.prototype.constructor = THREE.CircleGeometry;\r\n\r\n// File:src/extras/geometries/CircleBufferGeometry.js\r\n\r\n/**\r\n * @author benaadams / https://twitter.com/ben_a_adams\r\n */\r\n\r\nTHREE.CircleBufferGeometry = function ( radius, segments, thetaStart, thetaLength ) {\r\n\r\n\tTHREE.BufferGeometry.call( this );\r\n\r\n\tthis.type = 'CircleBufferGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tradius: radius,\r\n\t\tsegments: segments,\r\n\t\tthetaStart: thetaStart,\r\n\t\tthetaLength: thetaLength\r\n\t};\r\n\r\n\tradius = radius || 50;\r\n\tsegments = segments !== undefined ? Math.max( 3, segments ) : 8;\r\n\r\n\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\r\n\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\r\n\r\n\tvar vertices = segments + 2;\r\n\r\n\tvar positions = new Float32Array( vertices * 3 );\r\n\tvar normals = new Float32Array( vertices * 3 );\r\n\tvar uvs = new Float32Array( vertices * 2 );\r\n\r\n\t// center data is already zero, but need to set a few extras\r\n\tnormals[ 2 ] = 1.0;\r\n\tuvs[ 0 ] = 0.5;\r\n\tuvs[ 1 ] = 0.5;\r\n\r\n\tfor ( var s = 0, i = 3, ii = 2 ; s <= segments; s ++, i += 3, ii += 2 ) {\r\n\r\n\t\tvar segment = thetaStart + s / segments * thetaLength;\r\n\r\n\t\tpositions[ i ] = radius * Math.cos( segment );\r\n\t\tpositions[ i + 1 ] = radius * Math.sin( segment );\r\n\r\n\t\tnormals[ i + 2 ] = 1; // normal z\r\n\r\n\t\tuvs[ ii ] = ( positions[ i ] / radius + 1 ) / 2;\r\n\t\tuvs[ ii + 1 ] = ( positions[ i + 1 ] / radius + 1 ) / 2;\r\n\r\n\t}\r\n\r\n\tvar indices = [];\r\n\r\n\tfor ( var i = 1; i <= segments; i ++ ) {\r\n\r\n\t\tindices.push( i, i + 1, 0 );\r\n\r\n\t}\r\n\r\n\tthis.setIndex( new THREE.BufferAttribute( new Uint16Array( indices ), 1 ) );\r\n\tthis.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );\r\n\tthis.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );\r\n\tthis.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );\r\n\r\n\tthis.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\r\n\r\n};\r\n\r\nTHREE.CircleBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\nTHREE.CircleBufferGeometry.prototype.constructor = THREE.CircleBufferGeometry;\r\n\r\n// File:src/extras/geometries/CylinderBufferGeometry.js\r\n\r\n/**\r\n * @author Mugen87 / https://github.com/Mugen87\r\n */\r\n\r\nTHREE.CylinderBufferGeometry = function( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\r\n\r\n\tTHREE.BufferGeometry.call( this );\r\n\r\n\tthis.type = 'CylinderBufferGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tradiusTop: radiusTop,\r\n\t\tradiusBottom: radiusBottom,\r\n\t\theight: height,\r\n\t\tradialSegments: radialSegments,\r\n\t\theightSegments: heightSegments,\r\n\t\topenEnded: openEnded,\r\n\t\tthetaStart: thetaStart,\r\n\t\tthetaLength: thetaLength\r\n\t};\r\n\r\n\tvar scope = this;\r\n\r\n\tradiusTop = radiusTop !== undefined ? radiusTop : 20;\r\n\tradiusBottom = radiusBottom !== undefined ? radiusBottom : 20;\r\n\theight = height !== undefined ? height : 100;\r\n\r\n\tradialSegments = Math.floor( radialSegments ) || 8;\r\n\theightSegments = Math.floor( heightSegments ) || 1;\r\n\r\n\topenEnded = openEnded !== undefined ? openEnded : false;\r\n\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\r\n\tthetaLength = thetaLength !== undefined ? thetaLength : 2 * Math.PI;\r\n\r\n\t// used to calculate buffer length\r\n\r\n\tvar vertexCount = calculateVertexCount();\r\n\tvar indexCount = calculateIndexCount();\r\n\r\n\t// buffers\r\n\r\n\tvar indices = new THREE.BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ), 1 );\r\n\tvar vertices = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\r\n\tvar normals = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\r\n\tvar uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\r\n\r\n\t// helper variables\r\n\r\n\tvar index = 0, indexOffset = 0, indexArray = [], halfHeight = height / 2;\r\n\r\n\t// group variables\r\n\tvar groupStart = 0;\r\n\r\n\t// generate geometry\r\n\r\n\tgenerateTorso();\r\n\r\n\tif ( openEnded === false ) {\r\n\r\n\t\tif ( radiusTop > 0 ) generateCap( true );\r\n\t\tif ( radiusBottom > 0 ) generateCap( false );\r\n\r\n\t}\r\n\r\n\t// build geometry\r\n\r\n\tthis.setIndex( indices );\r\n\tthis.addAttribute( 'position', vertices );\r\n\tthis.addAttribute( 'normal', normals );\r\n\tthis.addAttribute( 'uv', uvs );\r\n\r\n\t// helper functions\r\n\r\n\tfunction calculateVertexCount() {\r\n\r\n\t\tvar count = ( radialSegments + 1 ) * ( heightSegments + 1 );\r\n\r\n\t\tif ( openEnded === false ) {\r\n\r\n\t\t\tcount += ( ( radialSegments + 1 ) * 2 ) + ( radialSegments * 2 );\r\n\r\n\t\t}\r\n\r\n\t\treturn count;\r\n\r\n\t}\r\n\r\n\tfunction calculateIndexCount() {\r\n\r\n\t\tvar count = radialSegments * heightSegments * 2 * 3;\r\n\r\n\t\tif ( openEnded === false ) {\r\n\r\n\t\t\tcount += radialSegments * 2 * 3;\r\n\r\n\t\t}\r\n\r\n\t\treturn count;\r\n\r\n\t}\r\n\r\n\tfunction generateTorso() {\r\n\r\n\t\tvar x, y;\r\n\t\tvar normal = new THREE.Vector3();\r\n\t\tvar vertex = new THREE.Vector3();\r\n\r\n\t\tvar groupCount = 0;\r\n\r\n\t\t// this will be used to calculate the normal\r\n\t\tvar tanTheta = ( radiusBottom - radiusTop ) / height;\r\n\r\n\t\t// generate vertices, normals and uvs\r\n\r\n\t\tfor ( y = 0; y <= heightSegments; y ++ ) {\r\n\r\n\t\t\tvar indexRow = [];\r\n\r\n\t\t\tvar v = y / heightSegments;\r\n\r\n\t\t\t// calculate the radius of the current row\r\n\t\t\tvar radius = v * ( radiusBottom - radiusTop ) + radiusTop;\r\n\r\n\t\t\tfor ( x = 0; x <= radialSegments; x ++ ) {\r\n\r\n\t\t\t\tvar u = x / radialSegments;\r\n\r\n\t\t\t\t// vertex\r\n\t\t\t\tvertex.x = radius * Math.sin( u * thetaLength + thetaStart );\r\n\t\t\t\tvertex.y = - v * height + halfHeight;\r\n\t\t\t\tvertex.z = radius * Math.cos( u * thetaLength + thetaStart );\r\n\t\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\r\n\r\n\t\t\t\t// normal\r\n\t\t\t\tnormal.copy( vertex );\r\n\r\n\t\t\t\t// handle special case if radiusTop/radiusBottom is zero\r\n\t\t\t\tif ( ( radiusTop === 0 && y === 0 ) || ( radiusBottom === 0 && y === heightSegments ) ) {\r\n\r\n\t\t\t\t\tnormal.x = Math.sin( u * thetaLength + thetaStart );\r\n\t\t\t\t\tnormal.z = Math.cos( u * thetaLength + thetaStart );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tnormal.setY( Math.sqrt( normal.x * normal.x + normal.z * normal.z ) * tanTheta ).normalize();\r\n\t\t\t\tnormals.setXYZ( index, normal.x, normal.y, normal.z );\r\n\r\n\t\t\t\t// uv\r\n\t\t\t\tuvs.setXY( index, u, 1 - v );\r\n\r\n\t\t\t\t// save index of vertex in respective row\r\n\t\t\t\tindexRow.push( index );\r\n\r\n\t\t\t\t// increase index\r\n\t\t\t\tindex ++;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// now save vertices of the row in our index array\r\n\t\t\tindexArray.push( indexRow );\r\n\r\n\t\t}\r\n\r\n\t\t// generate indices\r\n\r\n\t\tfor ( x = 0; x < radialSegments; x ++ ) {\r\n\r\n\t\t\tfor ( y = 0; y < heightSegments; y ++ ) {\r\n\r\n\t\t\t\t// we use the index array to access the correct indices\r\n\t\t\t\tvar i1 = indexArray[ y ][ x ];\r\n\t\t\t\tvar i2 = indexArray[ y + 1 ][ x ];\r\n\t\t\t\tvar i3 = indexArray[ y + 1 ][ x + 1 ];\r\n\t\t\t\tvar i4 = indexArray[ y ][ x + 1 ];\r\n\r\n\t\t\t\t// face one\r\n\t\t\t\tindices.setX( indexOffset, i1 ); indexOffset ++;\r\n\t\t\t\tindices.setX( indexOffset, i2 ); indexOffset ++;\r\n\t\t\t\tindices.setX( indexOffset, i4 ); indexOffset ++;\r\n\r\n\t\t\t\t// face two\r\n\t\t\t\tindices.setX( indexOffset, i2 ); indexOffset ++;\r\n\t\t\t\tindices.setX( indexOffset, i3 ); indexOffset ++;\r\n\t\t\t\tindices.setX( indexOffset, i4 ); indexOffset ++;\r\n\r\n\t\t\t\t// update counters\r\n\t\t\t\tgroupCount += 6;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// add a group to the geometry. this will ensure multi material support\r\n\t\tscope.addGroup( groupStart, groupCount, 0 );\r\n\r\n\t\t// calculate new start value for groups\r\n\t\tgroupStart += groupCount;\r\n\r\n\t}\r\n\r\n\tfunction generateCap( top ) {\r\n\r\n\t\tvar x, centerIndexStart, centerIndexEnd;\r\n\t\tvar uv = new THREE.Vector2();\r\n\t\tvar vertex = new THREE.Vector3();\r\n\r\n\t\tvar groupCount = 0;\r\n\r\n\t\tvar radius = ( top === true ) ? radiusTop : radiusBottom;\r\n\t\tvar sign = ( top === true ) ? 1 : - 1;\r\n\r\n\t\t// save the index of the first center vertex\r\n\t\tcenterIndexStart = index;\r\n\r\n\t\t// first we generate the center vertex data of the cap.\r\n\t\t// because the geometry needs one set of uvs per face,\r\n\t\t// we must generate a center vertex per face/segment\r\n\r\n\t\tfor ( x = 1; x <= radialSegments; x ++ ) {\r\n\r\n\t\t\t// vertex\r\n\t\t\tvertices.setXYZ( index, 0, halfHeight * sign, 0 );\r\n\r\n\t\t\t// normal\r\n\t\t\tnormals.setXYZ( index, 0, sign, 0 );\r\n\r\n\t\t\t// uv\r\n\t\t\tif ( top === true ) {\r\n\r\n\t\t\t\tuv.x = x / radialSegments;\r\n\t\t\t\tuv.y = 0;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tuv.x = ( x - 1 ) / radialSegments;\r\n\t\t\t\tuv.y = 1;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tuvs.setXY( index, uv.x, uv.y );\r\n\r\n\t\t\t// increase index\r\n\t\t\tindex ++;\r\n\r\n\t\t}\r\n\r\n\t\t// save the index of the last center vertex\r\n\t\tcenterIndexEnd = index;\r\n\r\n\t\t// now we generate the surrounding vertices, normals and uvs\r\n\r\n\t\tfor ( x = 0; x <= radialSegments; x ++ ) {\r\n\r\n\t\t\tvar u = x / radialSegments;\r\n\r\n\t\t\t// vertex\r\n\t\t\tvertex.x = radius * Math.sin( u * thetaLength + thetaStart );\r\n\t\t\tvertex.y = halfHeight * sign;\r\n\t\t\tvertex.z = radius * Math.cos( u * thetaLength + thetaStart );\r\n\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\r\n\r\n\t\t\t// normal\r\n\t\t\tnormals.setXYZ( index, 0, sign, 0 );\r\n\r\n\t\t\t// uv\r\n\t\t\tuvs.setXY( index, u, ( top === true ) ? 1 : 0 );\r\n\r\n\t\t\t// increase index\r\n\t\t\tindex ++;\r\n\r\n\t\t}\r\n\r\n\t\t// generate indices\r\n\r\n\t\tfor ( x = 0; x < radialSegments; x ++ ) {\r\n\r\n\t\t\tvar c = centerIndexStart + x;\r\n\t\t\tvar i = centerIndexEnd + x;\r\n\r\n\t\t\tif ( top === true ) {\r\n\r\n\t\t\t\t// face top\r\n\t\t\t\tindices.setX( indexOffset, i ); indexOffset ++;\r\n\t\t\t\tindices.setX( indexOffset, i + 1 ); indexOffset ++;\r\n\t\t\t\tindices.setX( indexOffset, c ); indexOffset ++;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// face bottom\r\n\t\t\t\tindices.setX( indexOffset, i + 1 ); indexOffset ++;\r\n\t\t\t\tindices.setX( indexOffset, i ); indexOffset ++;\r\n\t\t\t\tindices.setX( indexOffset, c ); indexOffset ++;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// update counters\r\n\t\t\tgroupCount += 3;\r\n\r\n\t\t}\r\n\r\n\t\t// add a group to the geometry. this will ensure multi material support\r\n\t\tscope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );\r\n\r\n\t\t// calculate new start value for groups\r\n\t\tgroupStart += groupCount;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.CylinderBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\nTHREE.CylinderBufferGeometry.prototype.constructor = THREE.CylinderBufferGeometry;\r\n\r\n// File:src/extras/geometries/CylinderGeometry.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.CylinderGeometry = function ( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tthis.type = 'CylinderGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tradiusTop: radiusTop,\r\n\t\tradiusBottom: radiusBottom,\r\n\t\theight: height,\r\n\t\tradialSegments: radialSegments,\r\n\t\theightSegments: heightSegments,\r\n\t\topenEnded: openEnded,\r\n\t\tthetaStart: thetaStart,\r\n\t\tthetaLength: thetaLength\r\n\t};\r\n\r\n\tthis.fromBufferGeometry( new THREE.CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) );\r\n\tthis.mergeVertices();\r\n\r\n};\r\n\r\nTHREE.CylinderGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.CylinderGeometry.prototype.constructor = THREE.CylinderGeometry;\r\n\r\n// File:src/extras/geometries/EdgesGeometry.js\r\n\r\n/**\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\n\r\nTHREE.EdgesGeometry = function ( geometry, thresholdAngle ) {\r\n\r\n\tTHREE.BufferGeometry.call( this );\r\n\r\n\tthresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;\r\n\r\n\tvar thresholdDot = Math.cos( THREE.Math.DEG2RAD * thresholdAngle );\r\n\r\n\tvar edge = [ 0, 0 ], hash = {};\r\n\r\n\tfunction sortFunction( a, b ) {\r\n\r\n\t\treturn a - b;\r\n\r\n\t}\r\n\r\n\tvar keys = [ 'a', 'b', 'c' ];\r\n\r\n\tvar geometry2;\r\n\r\n\tif ( geometry instanceof THREE.BufferGeometry ) {\r\n\r\n\t\tgeometry2 = new THREE.Geometry();\r\n\t\tgeometry2.fromBufferGeometry( geometry );\r\n\r\n\t} else {\r\n\r\n\t\tgeometry2 = geometry.clone();\r\n\r\n\t}\r\n\r\n\tgeometry2.mergeVertices();\r\n\tgeometry2.computeFaceNormals();\r\n\r\n\tvar vertices = geometry2.vertices;\r\n\tvar faces = geometry2.faces;\r\n\r\n\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\r\n\t\tvar face = faces[ i ];\r\n\r\n\t\tfor ( var j = 0; j < 3; j ++ ) {\r\n\r\n\t\t\tedge[ 0 ] = face[ keys[ j ] ];\r\n\t\t\tedge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];\r\n\t\t\tedge.sort( sortFunction );\r\n\r\n\t\t\tvar key = edge.toString();\r\n\r\n\t\t\tif ( hash[ key ] === undefined ) {\r\n\r\n\t\t\t\thash[ key ] = { vert1: edge[ 0 ], vert2: edge[ 1 ], face1: i, face2: undefined };\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\thash[ key ].face2 = i;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tvar coords = [];\r\n\r\n\tfor ( var key in hash ) {\r\n\r\n\t\tvar h = hash[ key ];\r\n\r\n\t\tif ( h.face2 === undefined || faces[ h.face1 ].normal.dot( faces[ h.face2 ].normal ) <= thresholdDot ) {\r\n\r\n\t\t\tvar vertex = vertices[ h.vert1 ];\r\n\t\t\tcoords.push( vertex.x );\r\n\t\t\tcoords.push( vertex.y );\r\n\t\t\tcoords.push( vertex.z );\r\n\r\n\t\t\tvertex = vertices[ h.vert2 ];\r\n\t\t\tcoords.push( vertex.x );\r\n\t\t\tcoords.push( vertex.y );\r\n\t\t\tcoords.push( vertex.z );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tthis.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array( coords ), 3 ) );\r\n\r\n};\r\n\r\nTHREE.EdgesGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\nTHREE.EdgesGeometry.prototype.constructor = THREE.EdgesGeometry;\r\n\r\n// File:src/extras/geometries/ExtrudeGeometry.js\r\n\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n *\r\n * Creates extruded geometry from a path shape.\r\n *\r\n * parameters = {\r\n *\r\n *  curveSegments: <int>, // number of points on the curves\r\n *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too\r\n *  amount: <int>, // Depth to extrude the shape\r\n *\r\n *  bevelEnabled: <bool>, // turn on bevel\r\n *  bevelThickness: <float>, // how deep into the original shape bevel goes\r\n *  bevelSize: <float>, // how far from shape outline is bevel\r\n *  bevelSegments: <int>, // number of bevel layers\r\n *\r\n *  extrudePath: <THREE.CurvePath> // 3d spline path to extrude shape along. (creates Frames if .frames aren't defined)\r\n *  frames: <THREE.TubeGeometry.FrenetFrames> // containing arrays of tangents, normals, binormals\r\n *\r\n *  uvGenerator: <Object> // object that provides UV generator functions\r\n *\r\n * }\r\n **/\r\n\r\nTHREE.ExtrudeGeometry = function ( shapes, options ) {\r\n\r\n\tif ( typeof( shapes ) === \"undefined\" ) {\r\n\r\n\t\tshapes = [];\r\n\t\treturn;\r\n\r\n\t}\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tthis.type = 'ExtrudeGeometry';\r\n\r\n\tshapes = Array.isArray( shapes ) ? shapes : [ shapes ];\r\n\r\n\tthis.addShapeList( shapes, options );\r\n\r\n\tthis.computeFaceNormals();\r\n\r\n\t// can't really use automatic vertex normals\r\n\t// as then front and back sides get smoothed too\r\n\t// should do separate smoothing just for sides\r\n\r\n\t//this.computeVertexNormals();\r\n\r\n\t//console.log( \"took\", ( Date.now() - startTime ) );\r\n\r\n};\r\n\r\nTHREE.ExtrudeGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.ExtrudeGeometry.prototype.constructor = THREE.ExtrudeGeometry;\r\n\r\nTHREE.ExtrudeGeometry.prototype.addShapeList = function ( shapes, options ) {\r\n\r\n\tvar sl = shapes.length;\r\n\r\n\tfor ( var s = 0; s < sl; s ++ ) {\r\n\r\n\t\tvar shape = shapes[ s ];\r\n\t\tthis.addShape( shape, options );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.ExtrudeGeometry.prototype.addShape = function ( shape, options ) {\r\n\r\n\tvar amount = options.amount !== undefined ? options.amount : 100;\r\n\r\n\tvar bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10\r\n\tvar bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8\r\n\tvar bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;\r\n\r\n\tvar bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false\r\n\r\n\tvar curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\r\n\r\n\tvar steps = options.steps !== undefined ? options.steps : 1;\r\n\r\n\tvar extrudePath = options.extrudePath;\r\n\tvar extrudePts, extrudeByPath = false;\r\n\r\n\t// Use default WorldUVGenerator if no UV generators are specified.\r\n\tvar uvgen = options.UVGenerator !== undefined ? options.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator;\r\n\r\n\tvar splineTube, binormal, normal, position2;\r\n\tif ( extrudePath ) {\r\n\r\n\t\textrudePts = extrudePath.getSpacedPoints( steps );\r\n\r\n\t\textrudeByPath = true;\r\n\t\tbevelEnabled = false; // bevels not supported for path extrusion\r\n\r\n\t\t// SETUP TNB variables\r\n\r\n\t\t// Reuse TNB from TubeGeomtry for now.\r\n\t\t// TODO1 - have a .isClosed in spline?\r\n\r\n\t\tsplineTube = options.frames !== undefined ? options.frames : new THREE.TubeGeometry.FrenetFrames( extrudePath, steps, false );\r\n\r\n\t\t// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);\r\n\r\n\t\tbinormal = new THREE.Vector3();\r\n\t\tnormal = new THREE.Vector3();\r\n\t\tposition2 = new THREE.Vector3();\r\n\r\n\t}\r\n\r\n\t// Safeguards if bevels are not enabled\r\n\r\n\tif ( ! bevelEnabled ) {\r\n\r\n\t\tbevelSegments = 0;\r\n\t\tbevelThickness = 0;\r\n\t\tbevelSize = 0;\r\n\r\n\t}\r\n\r\n\t// Variables initialization\r\n\r\n\tvar ahole, h, hl; // looping of holes\r\n\tvar scope = this;\r\n\r\n\tvar shapesOffset = this.vertices.length;\r\n\r\n\tvar shapePoints = shape.extractPoints( curveSegments );\r\n\r\n\tvar vertices = shapePoints.shape;\r\n\tvar holes = shapePoints.holes;\r\n\r\n\tvar reverse = ! THREE.ShapeUtils.isClockWise( vertices );\r\n\r\n\tif ( reverse ) {\r\n\r\n\t\tvertices = vertices.reverse();\r\n\r\n\t\t// Maybe we should also check if holes are in the opposite direction, just to be safe ...\r\n\r\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n\t\t\tahole = holes[ h ];\r\n\r\n\t\t\tif ( THREE.ShapeUtils.isClockWise( ahole ) ) {\r\n\r\n\t\t\t\tholes[ h ] = ahole.reverse();\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!\r\n\r\n\t}\r\n\r\n\r\n\tvar faces = THREE.ShapeUtils.triangulateShape( vertices, holes );\r\n\r\n\t/* Vertices */\r\n\r\n\tvar contour = vertices; // vertices has all points but contour has only points of circumference\r\n\r\n\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n\t\tahole = holes[ h ];\r\n\r\n\t\tvertices = vertices.concat( ahole );\r\n\r\n\t}\r\n\r\n\r\n\tfunction scalePt2 ( pt, vec, size ) {\r\n\r\n\t\tif ( ! vec ) console.error( \"THREE.ExtrudeGeometry: vec does not exist\" );\r\n\r\n\t\treturn vec.clone().multiplyScalar( size ).add( pt );\r\n\r\n\t}\r\n\r\n\tvar b, bs, t, z,\r\n\t\tvert, vlen = vertices.length,\r\n\t\tface, flen = faces.length;\r\n\r\n\r\n\t// Find directions for point movement\r\n\r\n\r\n\tfunction getBevelVec( inPt, inPrev, inNext ) {\r\n\r\n\t\t// computes for inPt the corresponding point inPt' on a new contour\r\n\t\t//   shifted by 1 unit (length of normalized vector) to the left\r\n\t\t// if we walk along contour clockwise, this new contour is outside the old one\r\n\t\t//\r\n\t\t// inPt' is the intersection of the two lines parallel to the two\r\n\t\t//  adjacent edges of inPt at a distance of 1 unit on the left side.\r\n\r\n\t\tvar v_trans_x, v_trans_y, shrink_by = 1;\t\t// resulting translation vector for inPt\r\n\r\n\t\t// good reading for geometry algorithms (here: line-line intersection)\r\n\t\t// http://geomalgorithms.com/a05-_intersect-1.html\r\n\r\n\t\tvar v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;\r\n\t\tvar v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;\r\n\r\n\t\tvar v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );\r\n\r\n\t\t// check for collinear edges\r\n\t\tvar collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );\r\n\r\n\t\tif ( Math.abs( collinear0 ) > Number.EPSILON ) {\r\n\r\n\t\t\t// not collinear\r\n\r\n\t\t\t// length of vectors for normalizing\r\n\r\n\t\t\tvar v_prev_len = Math.sqrt( v_prev_lensq );\r\n\t\t\tvar v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );\r\n\r\n\t\t\t// shift adjacent points by unit vectors to the left\r\n\r\n\t\t\tvar ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );\r\n\t\t\tvar ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );\r\n\r\n\t\t\tvar ptNextShift_x = ( inNext.x - v_next_y / v_next_len );\r\n\t\t\tvar ptNextShift_y = ( inNext.y + v_next_x / v_next_len );\r\n\r\n\t\t\t// scaling factor for v_prev to intersection point\r\n\r\n\t\t\tvar sf = (  ( ptNextShift_x - ptPrevShift_x ) * v_next_y -\r\n\t\t\t\t\t\t( ptNextShift_y - ptPrevShift_y ) * v_next_x    ) /\r\n\t\t\t\t\t  ( v_prev_x * v_next_y - v_prev_y * v_next_x );\r\n\r\n\t\t\t// vector from inPt to intersection point\r\n\r\n\t\t\tv_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );\r\n\t\t\tv_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );\r\n\r\n\t\t\t// Don't normalize!, otherwise sharp corners become ugly\r\n\t\t\t//  but prevent crazy spikes\r\n\t\t\tvar v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );\r\n\t\t\tif ( v_trans_lensq <= 2 ) {\r\n\r\n\t\t\t\treturn\tnew THREE.Vector2( v_trans_x, v_trans_y );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tshrink_by = Math.sqrt( v_trans_lensq / 2 );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// handle special case of collinear edges\r\n\r\n\t\t\tvar direction_eq = false;\t\t// assumes: opposite\r\n\t\t\tif ( v_prev_x > Number.EPSILON ) {\r\n\r\n\t\t\t\tif ( v_next_x > Number.EPSILON ) {\r\n\r\n\t\t\t\t\tdirection_eq = true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tif ( v_prev_x < - Number.EPSILON ) {\r\n\r\n\t\t\t\t\tif ( v_next_x < - Number.EPSILON ) {\r\n\r\n\t\t\t\t\t\tdirection_eq = true;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tif ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {\r\n\r\n\t\t\t\t\t\tdirection_eq = true;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( direction_eq ) {\r\n\r\n\t\t\t\t// console.log(\"Warning: lines are a straight sequence\");\r\n\t\t\t\tv_trans_x = - v_prev_y;\r\n\t\t\t\tv_trans_y =  v_prev_x;\r\n\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// console.log(\"Warning: lines are a straight spike\");\r\n\t\t\t\tv_trans_x = v_prev_x;\r\n\t\t\t\tv_trans_y = v_prev_y;\r\n\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq / 2 );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn\tnew THREE.Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );\r\n\r\n\t}\r\n\r\n\r\n\tvar contourMovements = [];\r\n\r\n\tfor ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\r\n\r\n\t\tif ( j === il ) j = 0;\r\n\t\tif ( k === il ) k = 0;\r\n\r\n\t\t//  (j)---(i)---(k)\r\n\t\t// console.log('i,j,k', i, j , k)\r\n\r\n\t\tcontourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );\r\n\r\n\t}\r\n\r\n\tvar holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();\r\n\r\n\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n\t\tahole = holes[ h ];\r\n\r\n\t\toneHoleMovements = [];\r\n\r\n\t\tfor ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\r\n\r\n\t\t\tif ( j === il ) j = 0;\r\n\t\t\tif ( k === il ) k = 0;\r\n\r\n\t\t\t//  (j)---(i)---(k)\r\n\t\t\toneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );\r\n\r\n\t\t}\r\n\r\n\t\tholesMovements.push( oneHoleMovements );\r\n\t\tverticesMovements = verticesMovements.concat( oneHoleMovements );\r\n\r\n\t}\r\n\r\n\r\n\t// Loop bevelSegments, 1 for the front, 1 for the back\r\n\r\n\tfor ( b = 0; b < bevelSegments; b ++ ) {\r\n\r\n\t\t//for ( b = bevelSegments; b > 0; b -- ) {\r\n\r\n\t\tt = b / bevelSegments;\r\n\t\tz = bevelThickness * ( 1 - t );\r\n\r\n\t\t//z = bevelThickness * t;\r\n\t\tbs = bevelSize * ( Math.sin ( t * Math.PI / 2 ) ); // curved\r\n\t\t//bs = bevelSize * t; // linear\r\n\r\n\t\t// contract shape\r\n\r\n\t\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\r\n\r\n\t\t\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\r\n\r\n\t\t\tv( vert.x, vert.y,  - z );\r\n\r\n\t\t}\r\n\r\n\t\t// expand holes\r\n\r\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n\t\t\tahole = holes[ h ];\r\n\t\t\toneHoleMovements = holesMovements[ h ];\r\n\r\n\t\t\tfor ( i = 0, il = ahole.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\r\n\r\n\t\t\t\tv( vert.x, vert.y,  - z );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tbs = bevelSize;\r\n\r\n\t// Back facing vertices\r\n\r\n\tfor ( i = 0; i < vlen; i ++ ) {\r\n\r\n\t\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\r\n\r\n\t\tif ( ! extrudeByPath ) {\r\n\r\n\t\t\tv( vert.x, vert.y, 0 );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );\r\n\r\n\t\t\tnormal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );\r\n\t\t\tbinormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );\r\n\r\n\t\t\tposition2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );\r\n\r\n\t\t\tv( position2.x, position2.y, position2.z );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// Add stepped vertices...\r\n\t// Including front facing vertices\r\n\r\n\tvar s;\r\n\r\n\tfor ( s = 1; s <= steps; s ++ ) {\r\n\r\n\t\tfor ( i = 0; i < vlen; i ++ ) {\r\n\r\n\t\t\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\r\n\r\n\t\t\tif ( ! extrudeByPath ) {\r\n\r\n\t\t\t\tv( vert.x, vert.y, amount / steps * s );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );\r\n\r\n\t\t\t\tnormal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );\r\n\t\t\t\tbinormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );\r\n\r\n\t\t\t\tposition2.copy( extrudePts[ s ] ).add( normal ).add( binormal );\r\n\r\n\t\t\t\tv( position2.x, position2.y, position2.z );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\r\n\t// Add bevel segments planes\r\n\r\n\t//for ( b = 1; b <= bevelSegments; b ++ ) {\r\n\tfor ( b = bevelSegments - 1; b >= 0; b -- ) {\r\n\r\n\t\tt = b / bevelSegments;\r\n\t\tz = bevelThickness * ( 1 - t );\r\n\t\t//bs = bevelSize * ( 1-Math.sin ( ( 1 - t ) * Math.PI/2 ) );\r\n\t\tbs = bevelSize * Math.sin ( t * Math.PI / 2 );\r\n\r\n\t\t// contract shape\r\n\r\n\t\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\r\n\r\n\t\t\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\r\n\t\t\tv( vert.x, vert.y,  amount + z );\r\n\r\n\t\t}\r\n\r\n\t\t// expand holes\r\n\r\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n\t\t\tahole = holes[ h ];\r\n\t\t\toneHoleMovements = holesMovements[ h ];\r\n\r\n\t\t\tfor ( i = 0, il = ahole.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\r\n\r\n\t\t\t\tif ( ! extrudeByPath ) {\r\n\r\n\t\t\t\t\tv( vert.x, vert.y,  amount + z );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tv( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/* Faces */\r\n\r\n\t// Top and bottom faces\r\n\r\n\tbuildLidFaces();\r\n\r\n\t// Sides faces\r\n\r\n\tbuildSideFaces();\r\n\r\n\r\n\t/////  Internal functions\r\n\r\n\tfunction buildLidFaces() {\r\n\r\n\t\tif ( bevelEnabled ) {\r\n\r\n\t\t\tvar layer = 0; // steps + 1\r\n\t\t\tvar offset = vlen * layer;\r\n\r\n\t\t\t// Bottom faces\r\n\r\n\t\t\tfor ( i = 0; i < flen; i ++ ) {\r\n\r\n\t\t\t\tface = faces[ i ];\r\n\t\t\t\tf3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tlayer = steps + bevelSegments * 2;\r\n\t\t\toffset = vlen * layer;\r\n\r\n\t\t\t// Top faces\r\n\r\n\t\t\tfor ( i = 0; i < flen; i ++ ) {\r\n\r\n\t\t\t\tface = faces[ i ];\r\n\t\t\t\tf3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// Bottom faces\r\n\r\n\t\t\tfor ( i = 0; i < flen; i ++ ) {\r\n\r\n\t\t\t\tface = faces[ i ];\r\n\t\t\t\tf3( face[ 2 ], face[ 1 ], face[ 0 ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Top faces\r\n\r\n\t\t\tfor ( i = 0; i < flen; i ++ ) {\r\n\r\n\t\t\t\tface = faces[ i ];\r\n\t\t\t\tf3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// Create faces for the z-sides of the shape\r\n\r\n\tfunction buildSideFaces() {\r\n\r\n\t\tvar layeroffset = 0;\r\n\t\tsidewalls( contour, layeroffset );\r\n\t\tlayeroffset += contour.length;\r\n\r\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n\t\t\tahole = holes[ h ];\r\n\t\t\tsidewalls( ahole, layeroffset );\r\n\r\n\t\t\t//, true\r\n\t\t\tlayeroffset += ahole.length;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction sidewalls( contour, layeroffset ) {\r\n\r\n\t\tvar j, k;\r\n\t\ti = contour.length;\r\n\r\n\t\twhile ( -- i >= 0 ) {\r\n\r\n\t\t\tj = i;\r\n\t\t\tk = i - 1;\r\n\t\t\tif ( k < 0 ) k = contour.length - 1;\r\n\r\n\t\t\t//console.log('b', i,j, i-1, k,vertices.length);\r\n\r\n\t\t\tvar s = 0, sl = steps  + bevelSegments * 2;\r\n\r\n\t\t\tfor ( s = 0; s < sl; s ++ ) {\r\n\r\n\t\t\t\tvar slen1 = vlen * s;\r\n\t\t\t\tvar slen2 = vlen * ( s + 1 );\r\n\r\n\t\t\t\tvar a = layeroffset + j + slen1,\r\n\t\t\t\t\tb = layeroffset + k + slen1,\r\n\t\t\t\t\tc = layeroffset + k + slen2,\r\n\t\t\t\t\td = layeroffset + j + slen2;\r\n\r\n\t\t\t\tf4( a, b, c, d, contour, s, sl, j, k );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\r\n\tfunction v( x, y, z ) {\r\n\r\n\t\tscope.vertices.push( new THREE.Vector3( x, y, z ) );\r\n\r\n\t}\r\n\r\n\tfunction f3( a, b, c ) {\r\n\r\n\t\ta += shapesOffset;\r\n\t\tb += shapesOffset;\r\n\t\tc += shapesOffset;\r\n\r\n\t\tscope.faces.push( new THREE.Face3( a, b, c, null, null, 0 ) );\r\n\r\n\t\tvar uvs = uvgen.generateTopUV( scope, a, b, c );\r\n\r\n\t\tscope.faceVertexUvs[ 0 ].push( uvs );\r\n\r\n\t}\r\n\r\n\tfunction f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {\r\n\r\n\t\ta += shapesOffset;\r\n\t\tb += shapesOffset;\r\n\t\tc += shapesOffset;\r\n\t\td += shapesOffset;\r\n\r\n\t\tscope.faces.push( new THREE.Face3( a, b, d, null, null, 1 ) );\r\n\t\tscope.faces.push( new THREE.Face3( b, c, d, null, null, 1 ) );\r\n\r\n\t\tvar uvs = uvgen.generateSideWallUV( scope, a, b, c, d );\r\n\r\n\t\tscope.faceVertexUvs[ 0 ].push( [ uvs[ 0 ], uvs[ 1 ], uvs[ 3 ] ] );\r\n\t\tscope.faceVertexUvs[ 0 ].push( [ uvs[ 1 ], uvs[ 2 ], uvs[ 3 ] ] );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.ExtrudeGeometry.WorldUVGenerator = {\r\n\r\n\tgenerateTopUV: function ( geometry, indexA, indexB, indexC ) {\r\n\r\n\t\tvar vertices = geometry.vertices;\r\n\r\n\t\tvar a = vertices[ indexA ];\r\n\t\tvar b = vertices[ indexB ];\r\n\t\tvar c = vertices[ indexC ];\r\n\r\n\t\treturn [\r\n\t\t\tnew THREE.Vector2( a.x, a.y ),\r\n\t\t\tnew THREE.Vector2( b.x, b.y ),\r\n\t\t\tnew THREE.Vector2( c.x, c.y )\r\n\t\t];\r\n\r\n\t},\r\n\r\n\tgenerateSideWallUV: function ( geometry, indexA, indexB, indexC, indexD ) {\r\n\r\n\t\tvar vertices = geometry.vertices;\r\n\r\n\t\tvar a = vertices[ indexA ];\r\n\t\tvar b = vertices[ indexB ];\r\n\t\tvar c = vertices[ indexC ];\r\n\t\tvar d = vertices[ indexD ];\r\n\r\n\t\tif ( Math.abs( a.y - b.y ) < 0.01 ) {\r\n\r\n\t\t\treturn [\r\n\t\t\t\tnew THREE.Vector2( a.x, 1 - a.z ),\r\n\t\t\t\tnew THREE.Vector2( b.x, 1 - b.z ),\r\n\t\t\t\tnew THREE.Vector2( c.x, 1 - c.z ),\r\n\t\t\t\tnew THREE.Vector2( d.x, 1 - d.z )\r\n\t\t\t];\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn [\r\n\t\t\t\tnew THREE.Vector2( a.y, 1 - a.z ),\r\n\t\t\t\tnew THREE.Vector2( b.y, 1 - b.z ),\r\n\t\t\t\tnew THREE.Vector2( c.y, 1 - c.z ),\r\n\t\t\t\tnew THREE.Vector2( d.y, 1 - d.z )\r\n\t\t\t];\r\n\r\n\t\t}\r\n\r\n\t}\r\n};\r\n\r\n// File:src/extras/geometries/ShapeGeometry.js\r\n\r\n/**\r\n * @author jonobr1 / http://jonobr1.com\r\n *\r\n * Creates a one-sided polygonal geometry from a path shape. Similar to\r\n * ExtrudeGeometry.\r\n *\r\n * parameters = {\r\n *\r\n *\tcurveSegments: <int>, // number of points on the curves. NOT USED AT THE MOMENT.\r\n *\r\n *\tmaterial: <int> // material index for front and back faces\r\n *\tuvGenerator: <Object> // object that provides UV generator functions\r\n *\r\n * }\r\n **/\r\n\r\nTHREE.ShapeGeometry = function ( shapes, options ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tthis.type = 'ShapeGeometry';\r\n\r\n\tif ( Array.isArray( shapes ) === false ) shapes = [ shapes ];\r\n\r\n\tthis.addShapeList( shapes, options );\r\n\r\n\tthis.computeFaceNormals();\r\n\r\n};\r\n\r\nTHREE.ShapeGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.ShapeGeometry.prototype.constructor = THREE.ShapeGeometry;\r\n\r\n/**\r\n * Add an array of shapes to THREE.ShapeGeometry.\r\n */\r\nTHREE.ShapeGeometry.prototype.addShapeList = function ( shapes, options ) {\r\n\r\n\tfor ( var i = 0, l = shapes.length; i < l; i ++ ) {\r\n\r\n\t\tthis.addShape( shapes[ i ], options );\r\n\r\n\t}\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\n/**\r\n * Adds a shape to THREE.ShapeGeometry, based on THREE.ExtrudeGeometry.\r\n */\r\nTHREE.ShapeGeometry.prototype.addShape = function ( shape, options ) {\r\n\r\n\tif ( options === undefined ) options = {};\r\n\tvar curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\r\n\r\n\tvar material = options.material;\r\n\tvar uvgen = options.UVGenerator === undefined ? THREE.ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;\r\n\r\n\t//\r\n\r\n\tvar i, l, hole;\r\n\r\n\tvar shapesOffset = this.vertices.length;\r\n\tvar shapePoints = shape.extractPoints( curveSegments );\r\n\r\n\tvar vertices = shapePoints.shape;\r\n\tvar holes = shapePoints.holes;\r\n\r\n\tvar reverse = ! THREE.ShapeUtils.isClockWise( vertices );\r\n\r\n\tif ( reverse ) {\r\n\r\n\t\tvertices = vertices.reverse();\r\n\r\n\t\t// Maybe we should also check if holes are in the opposite direction, just to be safe...\r\n\r\n\t\tfor ( i = 0, l = holes.length; i < l; i ++ ) {\r\n\r\n\t\t\thole = holes[ i ];\r\n\r\n\t\t\tif ( THREE.ShapeUtils.isClockWise( hole ) ) {\r\n\r\n\t\t\t\tholes[ i ] = hole.reverse();\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treverse = false;\r\n\r\n\t}\r\n\r\n\tvar faces = THREE.ShapeUtils.triangulateShape( vertices, holes );\r\n\r\n\t// Vertices\r\n\r\n\tfor ( i = 0, l = holes.length; i < l; i ++ ) {\r\n\r\n\t\thole = holes[ i ];\r\n\t\tvertices = vertices.concat( hole );\r\n\r\n\t}\r\n\r\n\t//\r\n\r\n\tvar vert, vlen = vertices.length;\r\n\tvar face, flen = faces.length;\r\n\r\n\tfor ( i = 0; i < vlen; i ++ ) {\r\n\r\n\t\tvert = vertices[ i ];\r\n\r\n\t\tthis.vertices.push( new THREE.Vector3( vert.x, vert.y, 0 ) );\r\n\r\n\t}\r\n\r\n\tfor ( i = 0; i < flen; i ++ ) {\r\n\r\n\t\tface = faces[ i ];\r\n\r\n\t\tvar a = face[ 0 ] + shapesOffset;\r\n\t\tvar b = face[ 1 ] + shapesOffset;\r\n\t\tvar c = face[ 2 ] + shapesOffset;\r\n\r\n\t\tthis.faces.push( new THREE.Face3( a, b, c, null, null, material ) );\r\n\t\tthis.faceVertexUvs[ 0 ].push( uvgen.generateTopUV( this, a, b, c ) );\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/extras/geometries/LatheBufferGeometry.js\r\n\r\n/**\r\n * @author Mugen87 / https://github.com/Mugen87\r\n */\r\n\r\n // points - to create a closed torus, one must use a set of points\r\n //    like so: [ a, b, c, d, a ], see first is the same as last.\r\n // segments - the number of circumference segments to create\r\n // phiStart - the starting radian\r\n // phiLength - the radian (0 to 2PI) range of the lathed section\r\n //    2PI is a closed lathe, less than 2PI is a portion.\r\n\r\nTHREE.LatheBufferGeometry = function ( points, segments, phiStart, phiLength ) {\r\n\r\n\tTHREE.BufferGeometry.call( this );\r\n\r\n\tthis.type = 'LatheBufferGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tpoints: points,\r\n\t\tsegments: segments,\r\n\t\tphiStart: phiStart,\r\n\t\tphiLength: phiLength\r\n\t};\r\n\r\n\tsegments = Math.floor( segments ) || 12;\r\n\tphiStart = phiStart || 0;\r\n\tphiLength = phiLength || Math.PI * 2;\r\n\r\n\t// clamp phiLength so it's in range of [ 0, 2PI ]\r\n\tphiLength = THREE.Math.clamp( phiLength, 0, Math.PI * 2 );\r\n\r\n\t// these are used to calculate buffer length\r\n\tvar vertexCount = ( segments + 1 ) * points.length;\r\n\tvar indexCount = segments * points.length * 2 * 3;\r\n\r\n\t// buffers\r\n\tvar indices = new THREE.BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );\r\n\tvar vertices = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\r\n\tvar uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\r\n\r\n\t// helper variables\r\n\tvar index = 0, indexOffset = 0, base;\r\n\tvar inversePointLength = 1.0 / ( points.length - 1 );\r\n\tvar inverseSegments = 1.0 / segments;\r\n\tvar vertex = new THREE.Vector3();\r\n\tvar uv = new THREE.Vector2();\r\n\tvar i, j;\r\n\r\n\t// generate vertices and uvs\r\n\r\n\tfor ( i = 0; i <= segments; i ++ ) {\r\n\r\n\t\tvar phi = phiStart + i * inverseSegments * phiLength;\r\n\r\n\t\tvar sin = Math.sin( phi );\r\n\t\tvar cos = Math.cos( phi );\r\n\r\n\t\tfor ( j = 0; j <= ( points.length - 1 ); j ++ ) {\r\n\r\n\t\t\t// vertex\r\n\t\t\tvertex.x = points[ j ].x * sin;\r\n\t\t\tvertex.y = points[ j ].y;\r\n\t\t\tvertex.z = points[ j ].x * cos;\r\n\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\r\n\r\n\t\t\t// uv\r\n\t\t\tuv.x = i / segments;\r\n\t\t\tuv.y = j / ( points.length - 1 );\r\n\t\t\tuvs.setXY( index, uv.x, uv.y );\r\n\r\n\t\t\t// increase index\r\n\t\t\tindex ++;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// generate indices\r\n\r\n\tfor ( i = 0; i < segments; i ++ ) {\r\n\r\n\t\tfor ( j = 0; j < ( points.length - 1 ); j ++ ) {\r\n\r\n\t\t\tbase = j + i * points.length;\r\n\r\n\t\t\t// indices\r\n\t\t\tvar a = base;\r\n\t\t\tvar b = base + points.length;\r\n\t\t\tvar c = base + points.length + 1;\r\n\t\t\tvar d = base + 1;\r\n\r\n\t\t\t// face one\r\n\t\t\tindices.setX( indexOffset, a ); indexOffset++;\r\n\t\t\tindices.setX( indexOffset, b ); indexOffset++;\r\n\t\t\tindices.setX( indexOffset, d ); indexOffset++;\r\n\r\n\t\t\t// face two\r\n\t\t\tindices.setX( indexOffset, b ); indexOffset++;\r\n\t\t\tindices.setX( indexOffset, c ); indexOffset++;\r\n\t\t\tindices.setX( indexOffset, d ); indexOffset++;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// build geometry\r\n\r\n\tthis.setIndex( indices );\r\n\tthis.addAttribute( 'position', vertices );\r\n\tthis.addAttribute( 'uv', uvs );\r\n\r\n\t// generate normals\r\n\r\n\tthis.computeVertexNormals();\r\n\r\n\t// if the geometry is closed, we need to average the normals along the seam.\r\n\t// because the corresponding vertices are identical (but still have different UVs).\r\n\r\n\tif( phiLength === Math.PI * 2 ) {\r\n\r\n\t\tvar normals = this.attributes.normal.array;\r\n\t\tvar n1 = new THREE.Vector3();\r\n\t\tvar n2 = new THREE.Vector3();\r\n\t\tvar n = new THREE.Vector3();\r\n\r\n\t\t// this is the buffer offset for the last line of vertices\r\n\t\tbase = segments * points.length * 3;\r\n\r\n\t\tfor( i = 0, j = 0; i < points.length; i ++, j += 3 ) {\r\n\r\n\t\t\t// select the normal of the vertex in the first line\r\n\t\t\tn1.x = normals[ j + 0 ];\r\n\t\t\tn1.y = normals[ j + 1 ];\r\n\t\t\tn1.z = normals[ j + 2 ];\r\n\r\n\t\t\t// select the normal of the vertex in the last line\r\n\t\t\tn2.x = normals[ base + j + 0 ];\r\n\t\t\tn2.y = normals[ base + j + 1 ];\r\n\t\t\tn2.z = normals[ base + j + 2 ];\r\n\r\n\t\t\t// average normals\r\n\t\t\tn.addVectors( n1, n2 ).normalize();\r\n\r\n\t\t\t// assign the new values to both normals\r\n\t\t\tnormals[ j + 0 ] = normals[ base + j + 0 ] = n.x;\r\n\t\t\tnormals[ j + 1 ] = normals[ base + j + 1 ] = n.y;\r\n\t\t\tnormals[ j + 2 ] = normals[ base + j + 2 ] = n.z;\r\n\r\n\t\t} // next row\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.LatheBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\nTHREE.LatheBufferGeometry.prototype.constructor = THREE.LatheBufferGeometry;\r\n\r\n// File:src/extras/geometries/LatheGeometry.js\r\n\r\n/**\r\n * @author astrodud / http://astrodud.isgreat.org/\r\n * @author zz85 / https://github.com/zz85\r\n * @author bhouston / http://clara.io\r\n */\r\n\r\n// points - to create a closed torus, one must use a set of points\r\n//    like so: [ a, b, c, d, a ], see first is the same as last.\r\n// segments - the number of circumference segments to create\r\n// phiStart - the starting radian\r\n// phiLength - the radian (0 to 2PI) range of the lathed section\r\n//    2PI is a closed lathe, less than 2PI is a portion.\r\n\r\nTHREE.LatheGeometry = function ( points, segments, phiStart, phiLength ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tthis.type = 'LatheGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tpoints: points,\r\n\t\tsegments: segments,\r\n\t\tphiStart: phiStart,\r\n\t\tphiLength: phiLength\r\n\t};\r\n\r\n\tthis.fromBufferGeometry( new THREE.LatheBufferGeometry( points, segments, phiStart, phiLength ) );\r\n\tthis.mergeVertices();\r\n\r\n};\r\n\r\nTHREE.LatheGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.LatheGeometry.prototype.constructor = THREE.LatheGeometry;\r\n\r\n// File:src/extras/geometries/PlaneGeometry.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as\r\n */\r\n\r\nTHREE.PlaneGeometry = function ( width, height, widthSegments, heightSegments ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tthis.type = 'PlaneGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\twidth: width,\r\n\t\theight: height,\r\n\t\twidthSegments: widthSegments,\r\n\t\theightSegments: heightSegments\r\n\t};\r\n\r\n\tthis.fromBufferGeometry( new THREE.PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );\r\n\r\n};\r\n\r\nTHREE.PlaneGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.PlaneGeometry.prototype.constructor = THREE.PlaneGeometry;\r\n\r\n// File:src/extras/geometries/PlaneBufferGeometry.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as\r\n */\r\n\r\nTHREE.PlaneBufferGeometry = function ( width, height, widthSegments, heightSegments ) {\r\n\r\n\tTHREE.BufferGeometry.call( this );\r\n\r\n\tthis.type = 'PlaneBufferGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\twidth: width,\r\n\t\theight: height,\r\n\t\twidthSegments: widthSegments,\r\n\t\theightSegments: heightSegments\r\n\t};\r\n\r\n\tvar width_half = width / 2;\r\n\tvar height_half = height / 2;\r\n\r\n\tvar gridX = Math.floor( widthSegments ) || 1;\r\n\tvar gridY = Math.floor( heightSegments ) || 1;\r\n\r\n\tvar gridX1 = gridX + 1;\r\n\tvar gridY1 = gridY + 1;\r\n\r\n\tvar segment_width = width / gridX;\r\n\tvar segment_height = height / gridY;\r\n\r\n\tvar vertices = new Float32Array( gridX1 * gridY1 * 3 );\r\n\tvar normals = new Float32Array( gridX1 * gridY1 * 3 );\r\n\tvar uvs = new Float32Array( gridX1 * gridY1 * 2 );\r\n\r\n\tvar offset = 0;\r\n\tvar offset2 = 0;\r\n\r\n\tfor ( var iy = 0; iy < gridY1; iy ++ ) {\r\n\r\n\t\tvar y = iy * segment_height - height_half;\r\n\r\n\t\tfor ( var ix = 0; ix < gridX1; ix ++ ) {\r\n\r\n\t\t\tvar x = ix * segment_width - width_half;\r\n\r\n\t\t\tvertices[ offset ] = x;\r\n\t\t\tvertices[ offset + 1 ] = - y;\r\n\r\n\t\t\tnormals[ offset + 2 ] = 1;\r\n\r\n\t\t\tuvs[ offset2 ] = ix / gridX;\r\n\t\t\tuvs[ offset2 + 1 ] = 1 - ( iy / gridY );\r\n\r\n\t\t\toffset += 3;\r\n\t\t\toffset2 += 2;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\toffset = 0;\r\n\r\n\tvar indices = new ( ( vertices.length / 3 ) > 65535 ? Uint32Array : Uint16Array )( gridX * gridY * 6 );\r\n\r\n\tfor ( var iy = 0; iy < gridY; iy ++ ) {\r\n\r\n\t\tfor ( var ix = 0; ix < gridX; ix ++ ) {\r\n\r\n\t\t\tvar a = ix + gridX1 * iy;\r\n\t\t\tvar b = ix + gridX1 * ( iy + 1 );\r\n\t\t\tvar c = ( ix + 1 ) + gridX1 * ( iy + 1 );\r\n\t\t\tvar d = ( ix + 1 ) + gridX1 * iy;\r\n\r\n\t\t\tindices[ offset ] = a;\r\n\t\t\tindices[ offset + 1 ] = b;\r\n\t\t\tindices[ offset + 2 ] = d;\r\n\r\n\t\t\tindices[ offset + 3 ] = b;\r\n\t\t\tindices[ offset + 4 ] = c;\r\n\t\t\tindices[ offset + 5 ] = d;\r\n\r\n\t\t\toffset += 6;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tthis.setIndex( new THREE.BufferAttribute( indices, 1 ) );\r\n\tthis.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\r\n\tthis.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );\r\n\tthis.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );\r\n\r\n};\r\n\r\nTHREE.PlaneBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\nTHREE.PlaneBufferGeometry.prototype.constructor = THREE.PlaneBufferGeometry;\r\n\r\n// File:src/extras/geometries/RingBufferGeometry.js\r\n\r\n/**\r\n * @author Mugen87 / https://github.com/Mugen87\r\n */\r\n\r\nTHREE.RingBufferGeometry = function ( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {\r\n\r\n\tTHREE.BufferGeometry.call( this );\r\n\r\n\tthis.type = 'RingBufferGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tinnerRadius: innerRadius,\r\n\t\touterRadius: outerRadius,\r\n\t\tthetaSegments: thetaSegments,\r\n\t\tphiSegments: phiSegments,\r\n\t\tthetaStart: thetaStart,\r\n\t\tthetaLength: thetaLength\r\n\t};\r\n\r\n\tinnerRadius = innerRadius || 20;\r\n\touterRadius = outerRadius || 50;\r\n\r\n\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\r\n\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\r\n\r\n\tthetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;\r\n\tphiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 1;\r\n\r\n\t// these are used to calculate buffer length\r\n\tvar vertexCount = ( thetaSegments + 1 ) * ( phiSegments + 1 );\r\n\tvar indexCount = thetaSegments * phiSegments * 2 * 3;\r\n\r\n\t// buffers\r\n\tvar indices = new THREE.BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );\r\n\tvar vertices = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\r\n\tvar normals = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\r\n\tvar uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\r\n\r\n\t// some helper variables\r\n\tvar index = 0, indexOffset = 0, segment;\r\n\tvar radius = innerRadius;\r\n\tvar radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );\r\n\tvar vertex = new THREE.Vector3();\r\n\tvar uv = new THREE.Vector2();\r\n\tvar j, i;\r\n\r\n\t// generate vertices, normals and uvs\r\n\r\n\t// values are generate from the inside of the ring to the outside\r\n\r\n\tfor ( j = 0; j <= phiSegments; j ++ ) {\r\n\r\n\t\tfor ( i = 0; i <= thetaSegments; i ++ ) {\r\n\r\n\t\t\tsegment = thetaStart + i / thetaSegments * thetaLength;\r\n\r\n\t\t\t// vertex\r\n\t\t\tvertex.x = radius * Math.cos( segment );\r\n\t\t\tvertex.y = radius * Math.sin( segment );\r\n\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\r\n\r\n\t\t\t// normal\r\n\t\t\tnormals.setXYZ( index, 0, 0, 1 );\r\n\r\n\t\t\t// uv\r\n\t\t\tuv.x = ( vertex.x / outerRadius + 1 ) / 2;\r\n\t\t\tuv.y = ( vertex.y / outerRadius + 1 ) / 2;\r\n\t\t\tuvs.setXY( index, uv.x, uv.y );\r\n\r\n\t\t\t// increase index\r\n\t\t\tindex++;\r\n\r\n\t\t}\r\n\r\n\t\t// increase the radius for next row of vertices\r\n\t\tradius += radiusStep;\r\n\r\n\t}\r\n\r\n\t// generate indices\r\n\r\n\tfor ( j = 0; j < phiSegments; j ++ ) {\r\n\r\n\t\tvar thetaSegmentLevel = j * ( thetaSegments + 1 );\r\n\r\n\t\tfor ( i = 0; i < thetaSegments; i ++ ) {\r\n\r\n\t\t\tsegment = i + thetaSegmentLevel;\r\n\r\n\t\t\t// indices\r\n\t\t\tvar a = segment;\r\n\t\t\tvar b = segment + thetaSegments + 1;\r\n\t\t\tvar c = segment + thetaSegments + 2;\r\n\t\t\tvar d = segment + 1;\r\n\r\n\t\t\t// face one\r\n\t\t\tindices.setX( indexOffset, a ); indexOffset++;\r\n\t\t\tindices.setX( indexOffset, b ); indexOffset++;\r\n\t\t\tindices.setX( indexOffset, c ); indexOffset++;\r\n\r\n\t\t\t// face two\r\n\t\t\tindices.setX( indexOffset, a ); indexOffset++;\r\n\t\t\tindices.setX( indexOffset, c ); indexOffset++;\r\n\t\t\tindices.setX( indexOffset, d ); indexOffset++;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// build geometry\r\n\r\n\tthis.setIndex( indices );\r\n\tthis.addAttribute( 'position', vertices );\r\n\tthis.addAttribute( 'normal', normals );\r\n\tthis.addAttribute( 'uv', uvs );\r\n\r\n};\r\n\r\nTHREE.RingBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\nTHREE.RingBufferGeometry.prototype.constructor = THREE.RingBufferGeometry;\r\n\r\n// File:src/extras/geometries/RingGeometry.js\r\n\r\n/**\r\n * @author Kaleb Murphy\r\n */\r\n\r\nTHREE.RingGeometry = function ( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tthis.type = 'RingGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tinnerRadius: innerRadius,\r\n\t\touterRadius: outerRadius,\r\n\t\tthetaSegments: thetaSegments,\r\n\t\tphiSegments: phiSegments,\r\n\t\tthetaStart: thetaStart,\r\n\t\tthetaLength: thetaLength\r\n\t};\r\n\r\n\tthis.fromBufferGeometry( new THREE.RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) );\r\n\r\n};\r\n\r\nTHREE.RingGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.RingGeometry.prototype.constructor = THREE.RingGeometry;\r\n\r\n// File:src/extras/geometries/SphereGeometry.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.SphereGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tthis.type = 'SphereGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tradius: radius,\r\n\t\twidthSegments: widthSegments,\r\n\t\theightSegments: heightSegments,\r\n\t\tphiStart: phiStart,\r\n\t\tphiLength: phiLength,\r\n\t\tthetaStart: thetaStart,\r\n\t\tthetaLength: thetaLength\r\n\t};\r\n\r\n\tthis.fromBufferGeometry( new THREE.SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );\r\n\r\n};\r\n\r\nTHREE.SphereGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.SphereGeometry.prototype.constructor = THREE.SphereGeometry;\r\n\r\n// File:src/extras/geometries/SphereBufferGeometry.js\r\n\r\n/**\r\n * @author benaadams / https://twitter.com/ben_a_adams\r\n * based on THREE.SphereGeometry\r\n */\r\n\r\nTHREE.SphereBufferGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {\r\n\r\n\tTHREE.BufferGeometry.call( this );\r\n\r\n\tthis.type = 'SphereBufferGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tradius: radius,\r\n\t\twidthSegments: widthSegments,\r\n\t\theightSegments: heightSegments,\r\n\t\tphiStart: phiStart,\r\n\t\tphiLength: phiLength,\r\n\t\tthetaStart: thetaStart,\r\n\t\tthetaLength: thetaLength\r\n\t};\r\n\r\n\tradius = radius || 50;\r\n\r\n\twidthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );\r\n\theightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );\r\n\r\n\tphiStart = phiStart !== undefined ? phiStart : 0;\r\n\tphiLength = phiLength !== undefined ? phiLength : Math.PI * 2;\r\n\r\n\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\r\n\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI;\r\n\r\n\tvar thetaEnd = thetaStart + thetaLength;\r\n\r\n\tvar vertexCount = ( ( widthSegments + 1 ) * ( heightSegments + 1 ) );\r\n\r\n\tvar positions = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\r\n\tvar normals = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\r\n\tvar uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\r\n\r\n\tvar index = 0, vertices = [], normal = new THREE.Vector3();\r\n\r\n\tfor ( var y = 0; y <= heightSegments; y ++ ) {\r\n\r\n\t\tvar verticesRow = [];\r\n\r\n\t\tvar v = y / heightSegments;\r\n\r\n\t\tfor ( var x = 0; x <= widthSegments; x ++ ) {\r\n\r\n\t\t\tvar u = x / widthSegments;\r\n\r\n\t\t\tvar px = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\r\n\t\t\tvar py = radius * Math.cos( thetaStart + v * thetaLength );\r\n\t\t\tvar pz = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\r\n\r\n\t\t\tnormal.set( px, py, pz ).normalize();\r\n\r\n\t\t\tpositions.setXYZ( index, px, py, pz );\r\n\t\t\tnormals.setXYZ( index, normal.x, normal.y, normal.z );\r\n\t\t\tuvs.setXY( index, u, 1 - v );\r\n\r\n\t\t\tverticesRow.push( index );\r\n\r\n\t\t\tindex ++;\r\n\r\n\t\t}\r\n\r\n\t\tvertices.push( verticesRow );\r\n\r\n\t}\r\n\r\n\tvar indices = [];\r\n\r\n\tfor ( var y = 0; y < heightSegments; y ++ ) {\r\n\r\n\t\tfor ( var x = 0; x < widthSegments; x ++ ) {\r\n\r\n\t\t\tvar v1 = vertices[ y ][ x + 1 ];\r\n\t\t\tvar v2 = vertices[ y ][ x ];\r\n\t\t\tvar v3 = vertices[ y + 1 ][ x ];\r\n\t\t\tvar v4 = vertices[ y + 1 ][ x + 1 ];\r\n\r\n\t\t\tif ( y !== 0 || thetaStart > 0 ) indices.push( v1, v2, v4 );\r\n\t\t\tif ( y !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( v2, v3, v4 );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tthis.setIndex( new ( positions.count > 65535 ? THREE.Uint32Attribute : THREE.Uint16Attribute )( indices, 1 ) );\r\n\tthis.addAttribute( 'position', positions );\r\n\tthis.addAttribute( 'normal', normals );\r\n\tthis.addAttribute( 'uv', uvs );\r\n\r\n\tthis.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\r\n\r\n};\r\n\r\nTHREE.SphereBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\nTHREE.SphereBufferGeometry.prototype.constructor = THREE.SphereBufferGeometry;\r\n\r\n// File:src/extras/geometries/TextGeometry.js\r\n\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * Text = 3D Text\r\n *\r\n * parameters = {\r\n *  font: <THREE.Font>, // font\r\n *\r\n *  size: <float>, // size of the text\r\n *  height: <float>, // thickness to extrude text\r\n *  curveSegments: <int>, // number of points on the curves\r\n *\r\n *  bevelEnabled: <bool>, // turn on bevel\r\n *  bevelThickness: <float>, // how deep into text bevel goes\r\n *  bevelSize: <float> // how far from text outline is bevel\r\n * }\r\n */\r\n\r\nTHREE.TextGeometry = function ( text, parameters ) {\r\n\r\n\tparameters = parameters || {};\r\n\r\n\tvar font = parameters.font;\r\n\r\n\tif ( font instanceof THREE.Font === false ) {\r\n\r\n\t\tconsole.error( 'THREE.TextGeometry: font parameter is not an instance of THREE.Font.' );\r\n\t\treturn new THREE.Geometry();\r\n\r\n\t}\r\n\r\n\tvar shapes = font.generateShapes( text, parameters.size, parameters.curveSegments );\r\n\r\n\t// translate parameters to ExtrudeGeometry API\r\n\r\n\tparameters.amount = parameters.height !== undefined ? parameters.height : 50;\r\n\r\n\t// defaults\r\n\r\n\tif ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;\r\n\tif ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;\r\n\tif ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;\r\n\r\n\tTHREE.ExtrudeGeometry.call( this, shapes, parameters );\r\n\r\n\tthis.type = 'TextGeometry';\r\n\r\n};\r\n\r\nTHREE.TextGeometry.prototype = Object.create( THREE.ExtrudeGeometry.prototype );\r\nTHREE.TextGeometry.prototype.constructor = THREE.TextGeometry;\r\n\r\n// File:src/extras/geometries/TorusBufferGeometry.js\r\n\r\n/**\r\n * @author Mugen87 / https://github.com/Mugen87\r\n */\r\n\r\nTHREE.TorusBufferGeometry = function ( radius, tube, radialSegments, tubularSegments, arc ) {\r\n\r\n\tTHREE.BufferGeometry.call( this );\r\n\r\n\tthis.type = 'TorusBufferGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tradius: radius,\r\n\t\ttube: tube,\r\n\t\tradialSegments: radialSegments,\r\n\t\ttubularSegments: tubularSegments,\r\n\t\tarc: arc\r\n\t};\r\n\r\n\tradius = radius || 100;\r\n\ttube = tube || 40;\r\n\tradialSegments = Math.floor( radialSegments ) || 8;\r\n\ttubularSegments = Math.floor( tubularSegments ) || 6;\r\n\tarc = arc || Math.PI * 2;\r\n\r\n\t// used to calculate buffer length\r\n\tvar vertexCount = ( ( radialSegments + 1 ) * ( tubularSegments + 1 ) );\r\n\tvar indexCount = radialSegments * tubularSegments * 2 * 3;\r\n\r\n\t// buffers\r\n\tvar indices = new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount );\r\n\tvar vertices = new Float32Array( vertexCount * 3 );\r\n\tvar normals = new Float32Array( vertexCount * 3 );\r\n\tvar uvs = new Float32Array( vertexCount * 2 );\r\n\r\n\t// offset variables\r\n\tvar vertexBufferOffset = 0;\r\n\tvar uvBufferOffset = 0;\r\n\tvar indexBufferOffset = 0;\r\n\r\n\t// helper variables\r\n\tvar center = new THREE.Vector3();\r\n\tvar vertex = new THREE.Vector3();\r\n\tvar normal = new THREE.Vector3();\r\n\r\n\tvar j, i;\r\n\r\n\t// generate vertices, normals and uvs\r\n\r\n\tfor ( j = 0; j <= radialSegments; j ++ ) {\r\n\r\n\t\tfor ( i = 0; i <= tubularSegments; i ++ ) {\r\n\r\n\t\t\tvar u = i / tubularSegments * arc;\r\n\t\t\tvar v = j / radialSegments * Math.PI * 2;\r\n\r\n\t\t\t// vertex\r\n\t\t\tvertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );\r\n\t\t\tvertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );\r\n\t\t\tvertex.z = tube * Math.sin( v );\r\n\r\n\t\t\tvertices[ vertexBufferOffset ] = vertex.x;\r\n\t\t\tvertices[ vertexBufferOffset + 1 ] = vertex.y;\r\n\t\t\tvertices[ vertexBufferOffset + 2 ] = vertex.z;\r\n\r\n\t\t\t// this vector is used to calculate the normal\r\n\t\t\tcenter.x = radius * Math.cos( u );\r\n\t\t\tcenter.y = radius * Math.sin( u );\r\n\r\n\t\t\t// normal\r\n\t\t\tnormal.subVectors( vertex, center ).normalize();\r\n\r\n\t\t\tnormals[ vertexBufferOffset ] = normal.x;\r\n\t\t\tnormals[ vertexBufferOffset + 1 ] = normal.y;\r\n\t\t\tnormals[ vertexBufferOffset + 2 ] = normal.z;\r\n\r\n\t\t\t// uv\r\n\t\t\tuvs[ uvBufferOffset ] = i / tubularSegments;\r\n\t\t\tuvs[ uvBufferOffset + 1 ] = j / radialSegments;\r\n\r\n\t\t\t// update offsets\r\n\t\t\tvertexBufferOffset += 3;\r\n\t\t\tuvBufferOffset += 2;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// generate indices\r\n\r\n\tfor ( j = 1; j <= radialSegments; j ++ ) {\r\n\r\n\t\tfor ( i = 1; i <= tubularSegments; i ++ ) {\r\n\r\n\t\t\t// indices\r\n\t\t\tvar a = ( tubularSegments + 1 ) * j + i - 1;\r\n\t\t\tvar b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;\r\n\t\t\tvar c = ( tubularSegments + 1 ) * ( j - 1 ) + i;\r\n\t\t\tvar d = ( tubularSegments + 1 ) * j + i;\r\n\r\n\t\t\t// face one\r\n\t\t\tindices[ indexBufferOffset ] = a;\r\n\t\t\tindices[ indexBufferOffset + 1 ] = b;\r\n\t\t\tindices[ indexBufferOffset + 2 ] = d;\r\n\r\n\t\t\t// face two\r\n\t\t\tindices[ indexBufferOffset + 3 ] = b;\r\n\t\t\tindices[ indexBufferOffset + 4 ] = c;\r\n\t\t\tindices[ indexBufferOffset + 5 ] = d;\r\n\r\n\t\t\t// update offset\r\n\t\t\tindexBufferOffset += 6;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// build geometry\r\n\tthis.setIndex( new THREE.BufferAttribute( indices, 1 ) );\r\n\tthis.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\r\n\tthis.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );\r\n\tthis.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );\r\n\r\n};\r\n\r\nTHREE.TorusBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\nTHREE.TorusBufferGeometry.prototype.constructor = THREE.TorusBufferGeometry;\r\n\r\n// File:src/extras/geometries/TorusGeometry.js\r\n\r\n/**\r\n * @author oosmoxiecode\r\n * @author mrdoob / http://mrdoob.com/\r\n * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888\r\n */\r\n\r\nTHREE.TorusGeometry = function ( radius, tube, radialSegments, tubularSegments, arc ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tthis.type = 'TorusGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tradius: radius,\r\n\t\ttube: tube,\r\n\t\tradialSegments: radialSegments,\r\n\t\ttubularSegments: tubularSegments,\r\n\t\tarc: arc\r\n\t};\r\n\r\n\tthis.fromBufferGeometry( new THREE.TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) );\r\n\r\n};\r\n\r\nTHREE.TorusGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.TorusGeometry.prototype.constructor = THREE.TorusGeometry;\r\n\r\n// File:src/extras/geometries/TorusKnotBufferGeometry.js\r\n\r\n/**\r\n * @author Mugen87 / https://github.com/Mugen87\r\n *\r\n * see: http://www.blackpawn.com/texts/pqtorus/\r\n */\r\nTHREE.TorusKnotBufferGeometry = function ( radius, tube, tubularSegments, radialSegments, p, q ) {\r\n\r\n\tTHREE.BufferGeometry.call( this );\r\n\r\n\tthis.type = 'TorusKnotBufferGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tradius: radius,\r\n\t\ttube: tube,\r\n\t\ttubularSegments: tubularSegments,\r\n\t\tradialSegments: radialSegments,\r\n\t\tp: p,\r\n\t\tq: q\r\n\t};\r\n\r\n\tradius = radius || 100;\r\n\ttube = tube || 40;\r\n\ttubularSegments = Math.floor( tubularSegments ) || 64;\r\n\tradialSegments = Math.floor( radialSegments ) || 8;\r\n\tp = p || 2;\r\n\tq = q || 3;\r\n\r\n\t// used to calculate buffer length\r\n\tvar vertexCount = ( ( radialSegments + 1 ) * ( tubularSegments + 1 ) );\r\n\tvar indexCount = radialSegments * tubularSegments * 2 * 3;\r\n\r\n\t// buffers\r\n\tvar indices = new THREE.BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );\r\n\tvar vertices = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\r\n\tvar normals = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\r\n\tvar uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\r\n\r\n\t// helper variables\r\n\tvar i, j, index = 0, indexOffset = 0;\r\n\r\n\tvar vertex = new THREE.Vector3();\r\n\tvar normal = new THREE.Vector3();\r\n\tvar uv = new THREE.Vector2();\r\n\r\n\tvar P1 = new THREE.Vector3();\r\n\tvar P2 = new THREE.Vector3();\r\n\r\n\tvar B = new THREE.Vector3();\r\n\tvar T = new THREE.Vector3();\r\n\tvar N = new THREE.Vector3();\r\n\r\n\t// generate vertices, normals and uvs\r\n\r\n\tfor ( i = 0; i <= tubularSegments; ++ i ) {\r\n\r\n\t\t// the radian \"u\" is used to calculate the position on the torus curve of the current tubular segement\r\n\r\n\t\tvar u = i / tubularSegments * p * Math.PI * 2;\r\n\r\n\t\t// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.\r\n\t\t// these points are used to create a special \"coordinate space\", which is necessary to calculate the correct vertex positions\r\n\r\n\t\tcalculatePositionOnCurve( u, p, q, radius, P1 );\r\n\t\tcalculatePositionOnCurve( u + 0.01, p, q, radius, P2 );\r\n\r\n\t\t// calculate orthonormal basis\r\n\r\n\t\tT.subVectors( P2, P1 );\r\n\t\tN.addVectors( P2, P1 );\r\n\t\tB.crossVectors( T, N );\r\n\t\tN.crossVectors( B, T );\r\n\r\n\t\t// normalize B, N. T can be ignored, we don't use it\r\n\r\n\t\tB.normalize();\r\n\t\tN.normalize();\r\n\r\n\t\tfor ( j = 0; j <= radialSegments; ++ j ) {\r\n\r\n\t\t\t// now calculate the vertices. they are nothing more than an extrusion of the torus curve.\r\n\t\t\t// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.\r\n\r\n\t\t\tvar v = j / radialSegments * Math.PI * 2;\r\n\t\t\tvar cx = - tube * Math.cos( v );\r\n\t\t\tvar cy = tube * Math.sin( v );\r\n\r\n\t\t\t// now calculate the final vertex position.\r\n\t\t\t// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve\r\n\r\n\t\t\tvertex.x = P1.x + ( cx * N.x + cy * B.x );\r\n\t\t\tvertex.y = P1.y + ( cx * N.y + cy * B.y );\r\n\t\t\tvertex.z = P1.z + ( cx * N.z + cy * B.z );\r\n\r\n\t\t\t// vertex\r\n\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\r\n\r\n\t\t\t// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)\r\n\t\t\tnormal.subVectors( vertex, P1 ).normalize();\r\n\t\t\tnormals.setXYZ( index, normal.x, normal.y, normal.z );\r\n\r\n\t\t\t// uv\r\n\t\t\tuv.x = i / tubularSegments;\r\n\t\t\tuv.y = j / radialSegments;\r\n\t\t\tuvs.setXY( index, uv.x, uv.y );\r\n\r\n\t\t\t// increase index\r\n\t\t\tindex ++;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// generate indices\r\n\r\n\tfor ( j = 1; j <= tubularSegments; j ++ ) {\r\n\r\n\t\tfor ( i = 1; i <= radialSegments; i ++ ) {\r\n\r\n\t\t\t// indices\r\n\t\t\tvar a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );\r\n\t\t\tvar b = ( radialSegments + 1 ) * j + ( i - 1 );\r\n\t\t\tvar c = ( radialSegments + 1 ) * j + i;\r\n\t\t\tvar d = ( radialSegments + 1 ) * ( j - 1 ) + i;\r\n\r\n\t\t\t// face one\r\n\t\t\tindices.setX( indexOffset, a ); indexOffset++;\r\n\t\t\tindices.setX( indexOffset, b ); indexOffset++;\r\n\t\t\tindices.setX( indexOffset, d ); indexOffset++;\r\n\r\n\t\t\t// face two\r\n\t\t\tindices.setX( indexOffset, b ); indexOffset++;\r\n\t\t\tindices.setX( indexOffset, c ); indexOffset++;\r\n\t\t\tindices.setX( indexOffset, d ); indexOffset++;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// build geometry\r\n\r\n\tthis.setIndex( indices );\r\n\tthis.addAttribute( 'position', vertices );\r\n\tthis.addAttribute( 'normal', normals );\r\n\tthis.addAttribute( 'uv', uvs );\r\n\r\n\t// this function calculates the current position on the torus curve\r\n\r\n\tfunction calculatePositionOnCurve( u, p, q, radius, position ) {\r\n\r\n\t\tvar cu = Math.cos( u );\r\n\t\tvar su = Math.sin( u );\r\n\t\tvar quOverP = q / p * u;\r\n\t\tvar cs = Math.cos( quOverP );\r\n\r\n\t\tposition.x = radius * ( 2 + cs ) * 0.5 * cu;\r\n\t\tposition.y = radius * ( 2 + cs ) * su * 0.5;\r\n\t\tposition.z = radius * Math.sin( quOverP ) * 0.5;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.TorusKnotBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\nTHREE.TorusKnotBufferGeometry.prototype.constructor = THREE.TorusKnotBufferGeometry;\r\n\r\n// File:src/extras/geometries/TorusKnotGeometry.js\r\n\r\n/**\r\n * @author oosmoxiecode\r\n */\r\n\r\nTHREE.TorusKnotGeometry = function ( radius, tube, tubularSegments, radialSegments, p, q, heightScale ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tthis.type = 'TorusKnotGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tradius: radius,\r\n\t\ttube: tube,\r\n\t\ttubularSegments: tubularSegments,\r\n\t\tradialSegments: radialSegments,\r\n\t\tp: p,\r\n\t\tq: q\r\n\t};\r\n\r\n\tif( heightScale !== undefined ) console.warn( 'THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.' );\r\n\r\n\tthis.fromBufferGeometry( new THREE.TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) );\r\n\tthis.mergeVertices();\r\n\r\n};\r\n\r\nTHREE.TorusKnotGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.TorusKnotGeometry.prototype.constructor = THREE.TorusKnotGeometry;\r\n\r\n// File:src/extras/geometries/TubeGeometry.js\r\n\r\n/**\r\n * @author WestLangley / https://github.com/WestLangley\r\n * @author zz85 / https://github.com/zz85\r\n * @author miningold / https://github.com/miningold\r\n * @author jonobr1 / https://github.com/jonobr1\r\n *\r\n * Modified from the TorusKnotGeometry by @oosmoxiecode\r\n *\r\n * Creates a tube which extrudes along a 3d spline\r\n *\r\n * Uses parallel transport frames as described in\r\n * http://www.cs.indiana.edu/pub/techreports/TR425.pdf\r\n */\r\n\r\nTHREE.TubeGeometry = function ( path, segments, radius, radialSegments, closed, taper ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tthis.type = 'TubeGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tpath: path,\r\n\t\tsegments: segments,\r\n\t\tradius: radius,\r\n\t\tradialSegments: radialSegments,\r\n\t\tclosed: closed,\r\n\t\ttaper: taper\r\n\t};\r\n\r\n\tsegments = segments || 64;\r\n\tradius = radius || 1;\r\n\tradialSegments = radialSegments || 8;\r\n\tclosed = closed || false;\r\n\ttaper = taper || THREE.TubeGeometry.NoTaper;\r\n\r\n\tvar grid = [];\r\n\r\n\tvar scope = this,\r\n\r\n\t\ttangent,\r\n\t\tnormal,\r\n\t\tbinormal,\r\n\r\n\t\tnumpoints = segments + 1,\r\n\r\n\t\tu, v, r,\r\n\r\n\t\tcx, cy,\r\n\t\tpos, pos2 = new THREE.Vector3(),\r\n\t\ti, j,\r\n\t\tip, jp,\r\n\t\ta, b, c, d,\r\n\t\tuva, uvb, uvc, uvd;\r\n\r\n\tvar frames = new THREE.TubeGeometry.FrenetFrames( path, segments, closed ),\r\n\t\ttangents = frames.tangents,\r\n\t\tnormals = frames.normals,\r\n\t\tbinormals = frames.binormals;\r\n\r\n\t// proxy internals\r\n\tthis.tangents = tangents;\r\n\tthis.normals = normals;\r\n\tthis.binormals = binormals;\r\n\r\n\tfunction vert( x, y, z ) {\r\n\r\n\t\treturn scope.vertices.push( new THREE.Vector3( x, y, z ) ) - 1;\r\n\r\n\t}\r\n\r\n\t// construct the grid\r\n\r\n\tfor ( i = 0; i < numpoints; i ++ ) {\r\n\r\n\t\tgrid[ i ] = [];\r\n\r\n\t\tu = i / ( numpoints - 1 );\r\n\r\n\t\tpos = path.getPointAt( u );\r\n\r\n\t\ttangent = tangents[ i ];\r\n\t\tnormal = normals[ i ];\r\n\t\tbinormal = binormals[ i ];\r\n\r\n\t\tr = radius * taper( u );\r\n\r\n\t\tfor ( j = 0; j < radialSegments; j ++ ) {\r\n\r\n\t\t\tv = j / radialSegments * 2 * Math.PI;\r\n\r\n\t\t\tcx = - r * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.\r\n\t\t\tcy = r * Math.sin( v );\r\n\r\n\t\t\tpos2.copy( pos );\r\n\t\t\tpos2.x += cx * normal.x + cy * binormal.x;\r\n\t\t\tpos2.y += cx * normal.y + cy * binormal.y;\r\n\t\t\tpos2.z += cx * normal.z + cy * binormal.z;\r\n\r\n\t\t\tgrid[ i ][ j ] = vert( pos2.x, pos2.y, pos2.z );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\r\n\t// construct the mesh\r\n\r\n\tfor ( i = 0; i < segments; i ++ ) {\r\n\r\n\t\tfor ( j = 0; j < radialSegments; j ++ ) {\r\n\r\n\t\t\tip = ( closed ) ? ( i + 1 ) % segments : i + 1;\r\n\t\t\tjp = ( j + 1 ) % radialSegments;\r\n\r\n\t\t\ta = grid[ i ][ j ];\t\t// *** NOT NECESSARILY PLANAR ! ***\r\n\t\t\tb = grid[ ip ][ j ];\r\n\t\t\tc = grid[ ip ][ jp ];\r\n\t\t\td = grid[ i ][ jp ];\r\n\r\n\t\t\tuva = new THREE.Vector2( i / segments, j / radialSegments );\r\n\t\t\tuvb = new THREE.Vector2( ( i + 1 ) / segments, j / radialSegments );\r\n\t\t\tuvc = new THREE.Vector2( ( i + 1 ) / segments, ( j + 1 ) / radialSegments );\r\n\t\t\tuvd = new THREE.Vector2( i / segments, ( j + 1 ) / radialSegments );\r\n\r\n\t\t\tthis.faces.push( new THREE.Face3( a, b, d ) );\r\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );\r\n\r\n\t\t\tthis.faces.push( new THREE.Face3( b, c, d ) );\r\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tthis.computeFaceNormals();\r\n\tthis.computeVertexNormals();\r\n\r\n};\r\n\r\nTHREE.TubeGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.TubeGeometry.prototype.constructor = THREE.TubeGeometry;\r\n\r\nTHREE.TubeGeometry.NoTaper = function ( u ) {\r\n\r\n\treturn 1;\r\n\r\n};\r\n\r\nTHREE.TubeGeometry.SinusoidalTaper = function ( u ) {\r\n\r\n\treturn Math.sin( Math.PI * u );\r\n\r\n};\r\n\r\n// For computing of Frenet frames, exposing the tangents, normals and binormals the spline\r\nTHREE.TubeGeometry.FrenetFrames = function ( path, segments, closed ) {\r\n\r\n\tvar\tnormal = new THREE.Vector3(),\r\n\r\n\t\ttangents = [],\r\n\t\tnormals = [],\r\n\t\tbinormals = [],\r\n\r\n\t\tvec = new THREE.Vector3(),\r\n\t\tmat = new THREE.Matrix4(),\r\n\r\n\t\tnumpoints = segments + 1,\r\n\t\ttheta,\r\n\t\tsmallest,\r\n\r\n\t\ttx, ty, tz,\r\n\t\ti, u;\r\n\r\n\r\n\t// expose internals\r\n\tthis.tangents = tangents;\r\n\tthis.normals = normals;\r\n\tthis.binormals = binormals;\r\n\r\n\t// compute the tangent vectors for each segment on the path\r\n\r\n\tfor ( i = 0; i < numpoints; i ++ ) {\r\n\r\n\t\tu = i / ( numpoints - 1 );\r\n\r\n\t\ttangents[ i ] = path.getTangentAt( u );\r\n\t\ttangents[ i ].normalize();\r\n\r\n\t}\r\n\r\n\tinitialNormal3();\r\n\r\n\t/*\r\n\tfunction initialNormal1(lastBinormal) {\r\n\t\t// fixed start binormal. Has dangers of 0 vectors\r\n\t\tnormals[ 0 ] = new THREE.Vector3();\r\n\t\tbinormals[ 0 ] = new THREE.Vector3();\r\n\t\tif (lastBinormal===undefined) lastBinormal = new THREE.Vector3( 0, 0, 1 );\r\n\t\tnormals[ 0 ].crossVectors( lastBinormal, tangents[ 0 ] ).normalize();\r\n\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();\r\n\t}\r\n\r\n\tfunction initialNormal2() {\r\n\r\n\t\t// This uses the Frenet-Serret formula for deriving binormal\r\n\t\tvar t2 = path.getTangentAt( epsilon );\r\n\r\n\t\tnormals[ 0 ] = new THREE.Vector3().subVectors( t2, tangents[ 0 ] ).normalize();\r\n\t\tbinormals[ 0 ] = new THREE.Vector3().crossVectors( tangents[ 0 ], normals[ 0 ] );\r\n\r\n\t\tnormals[ 0 ].crossVectors( binormals[ 0 ], tangents[ 0 ] ).normalize(); // last binormal x tangent\r\n\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();\r\n\r\n\t}\r\n\t*/\r\n\r\n\tfunction initialNormal3() {\r\n\r\n\t\t// select an initial normal vector perpendicular to the first tangent vector,\r\n\t\t// and in the direction of the smallest tangent xyz component\r\n\r\n\t\tnormals[ 0 ] = new THREE.Vector3();\r\n\t\tbinormals[ 0 ] = new THREE.Vector3();\r\n\t\tsmallest = Number.MAX_VALUE;\r\n\t\ttx = Math.abs( tangents[ 0 ].x );\r\n\t\tty = Math.abs( tangents[ 0 ].y );\r\n\t\ttz = Math.abs( tangents[ 0 ].z );\r\n\r\n\t\tif ( tx <= smallest ) {\r\n\r\n\t\t\tsmallest = tx;\r\n\t\t\tnormal.set( 1, 0, 0 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( ty <= smallest ) {\r\n\r\n\t\t\tsmallest = ty;\r\n\t\t\tnormal.set( 0, 1, 0 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( tz <= smallest ) {\r\n\r\n\t\t\tnormal.set( 0, 0, 1 );\r\n\r\n\t\t}\r\n\r\n\t\tvec.crossVectors( tangents[ 0 ], normal ).normalize();\r\n\r\n\t\tnormals[ 0 ].crossVectors( tangents[ 0 ], vec );\r\n\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );\r\n\r\n\t}\r\n\r\n\r\n\t// compute the slowly-varying normal and binormal vectors for each segment on the path\r\n\r\n\tfor ( i = 1; i < numpoints; i ++ ) {\r\n\r\n\t\tnormals[ i ] = normals[ i - 1 ].clone();\r\n\r\n\t\tbinormals[ i ] = binormals[ i - 1 ].clone();\r\n\r\n\t\tvec.crossVectors( tangents[ i - 1 ], tangents[ i ] );\r\n\r\n\t\tif ( vec.length() > Number.EPSILON ) {\r\n\r\n\t\t\tvec.normalize();\r\n\r\n\t\t\ttheta = Math.acos( THREE.Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors\r\n\r\n\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );\r\n\r\n\t\t}\r\n\r\n\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\r\n\r\n\t}\r\n\r\n\r\n\t// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\r\n\r\n\tif ( closed ) {\r\n\r\n\t\ttheta = Math.acos( THREE.Math.clamp( normals[ 0 ].dot( normals[ numpoints - 1 ] ), - 1, 1 ) );\r\n\t\ttheta /= ( numpoints - 1 );\r\n\r\n\t\tif ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ numpoints - 1 ] ) ) > 0 ) {\r\n\r\n\t\t\ttheta = - theta;\r\n\r\n\t\t}\r\n\r\n\t\tfor ( i = 1; i < numpoints; i ++ ) {\r\n\r\n\t\t\t// twist a little...\r\n\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );\r\n\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/extras/geometries/PolyhedronGeometry.js\r\n\r\n/**\r\n * @author clockworkgeek / https://github.com/clockworkgeek\r\n * @author timothypratley / https://github.com/timothypratley\r\n * @author WestLangley / http://github.com/WestLangley\r\n*/\r\n\r\nTHREE.PolyhedronGeometry = function ( vertices, indices, radius, detail ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tthis.type = 'PolyhedronGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tvertices: vertices,\r\n\t\tindices: indices,\r\n\t\tradius: radius,\r\n\t\tdetail: detail\r\n\t};\r\n\r\n\tradius = radius || 1;\r\n\tdetail = detail || 0;\r\n\r\n\tvar that = this;\r\n\r\n\tfor ( var i = 0, l = vertices.length; i < l; i += 3 ) {\r\n\r\n\t\tprepare( new THREE.Vector3( vertices[ i ], vertices[ i + 1 ], vertices[ i + 2 ] ) );\r\n\r\n\t}\r\n\r\n\tvar p = this.vertices;\r\n\r\n\tvar faces = [];\r\n\r\n\tfor ( var i = 0, j = 0, l = indices.length; i < l; i += 3, j ++ ) {\r\n\r\n\t\tvar v1 = p[ indices[ i ] ];\r\n\t\tvar v2 = p[ indices[ i + 1 ] ];\r\n\t\tvar v3 = p[ indices[ i + 2 ] ];\r\n\r\n\t\tfaces[ j ] = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ], undefined, j );\r\n\r\n\t}\r\n\r\n\tvar centroid = new THREE.Vector3();\r\n\r\n\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\r\n\t\tsubdivide( faces[ i ], detail );\r\n\r\n\t}\r\n\r\n\r\n\t// Handle case when face straddles the seam\r\n\r\n\tfor ( var i = 0, l = this.faceVertexUvs[ 0 ].length; i < l; i ++ ) {\r\n\r\n\t\tvar uvs = this.faceVertexUvs[ 0 ][ i ];\r\n\r\n\t\tvar x0 = uvs[ 0 ].x;\r\n\t\tvar x1 = uvs[ 1 ].x;\r\n\t\tvar x2 = uvs[ 2 ].x;\r\n\r\n\t\tvar max = Math.max( x0, x1, x2 );\r\n\t\tvar min = Math.min( x0, x1, x2 );\r\n\r\n\t\tif ( max > 0.9 && min < 0.1 ) {\r\n\r\n\t\t\t// 0.9 is somewhat arbitrary\r\n\r\n\t\t\tif ( x0 < 0.2 ) uvs[ 0 ].x += 1;\r\n\t\t\tif ( x1 < 0.2 ) uvs[ 1 ].x += 1;\r\n\t\t\tif ( x2 < 0.2 ) uvs[ 2 ].x += 1;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\r\n\t// Apply radius\r\n\r\n\tfor ( var i = 0, l = this.vertices.length; i < l; i ++ ) {\r\n\r\n\t\tthis.vertices[ i ].multiplyScalar( radius );\r\n\r\n\t}\r\n\r\n\r\n\t// Merge vertices\r\n\r\n\tthis.mergeVertices();\r\n\r\n\tthis.computeFaceNormals();\r\n\r\n\tthis.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\r\n\r\n\r\n\t// Project vector onto sphere's surface\r\n\r\n\tfunction prepare( vector ) {\r\n\r\n\t\tvar vertex = vector.normalize().clone();\r\n\t\tvertex.index = that.vertices.push( vertex ) - 1;\r\n\r\n\t\t// Texture coords are equivalent to map coords, calculate angle and convert to fraction of a circle.\r\n\r\n\t\tvar u = azimuth( vector ) / 2 / Math.PI + 0.5;\r\n\t\tvar v = inclination( vector ) / Math.PI + 0.5;\r\n\t\tvertex.uv = new THREE.Vector2( u, 1 - v );\r\n\r\n\t\treturn vertex;\r\n\r\n\t}\r\n\r\n\r\n\t// Approximate a curved face with recursively sub-divided triangles.\r\n\r\n\tfunction make( v1, v2, v3, materialIndex ) {\r\n\r\n\t\tvar face = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ], undefined, materialIndex );\r\n\t\tthat.faces.push( face );\r\n\r\n\t\tcentroid.copy( v1 ).add( v2 ).add( v3 ).divideScalar( 3 );\r\n\r\n\t\tvar azi = azimuth( centroid );\r\n\r\n\t\tthat.faceVertexUvs[ 0 ].push( [\r\n\t\t\tcorrectUV( v1.uv, v1, azi ),\r\n\t\t\tcorrectUV( v2.uv, v2, azi ),\r\n\t\t\tcorrectUV( v3.uv, v3, azi )\r\n\t\t] );\r\n\r\n\t}\r\n\r\n\r\n\t// Analytically subdivide a face to the required detail level.\r\n\r\n\tfunction subdivide( face, detail ) {\r\n\r\n\t\tvar cols = Math.pow( 2, detail );\r\n\t\tvar a = prepare( that.vertices[ face.a ] );\r\n\t\tvar b = prepare( that.vertices[ face.b ] );\r\n\t\tvar c = prepare( that.vertices[ face.c ] );\r\n\t\tvar v = [];\r\n\r\n\t\tvar materialIndex = face.materialIndex;\r\n\r\n\t\t// Construct all of the vertices for this subdivision.\r\n\r\n\t\tfor ( var i = 0 ; i <= cols; i ++ ) {\r\n\r\n\t\t\tv[ i ] = [];\r\n\r\n\t\t\tvar aj = prepare( a.clone().lerp( c, i / cols ) );\r\n\t\t\tvar bj = prepare( b.clone().lerp( c, i / cols ) );\r\n\t\t\tvar rows = cols - i;\r\n\r\n\t\t\tfor ( var j = 0; j <= rows; j ++ ) {\r\n\r\n\t\t\t\tif ( j === 0 && i === cols ) {\r\n\r\n\t\t\t\t\tv[ i ][ j ] = aj;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tv[ i ][ j ] = prepare( aj.clone().lerp( bj, j / rows ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// Construct all of the faces.\r\n\r\n\t\tfor ( var i = 0; i < cols ; i ++ ) {\r\n\r\n\t\t\tfor ( var j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {\r\n\r\n\t\t\t\tvar k = Math.floor( j / 2 );\r\n\r\n\t\t\t\tif ( j % 2 === 0 ) {\r\n\r\n\t\t\t\t\tmake(\r\n\t\t\t\t\t\tv[ i ][ k + 1 ],\r\n\t\t\t\t\t\tv[ i + 1 ][ k ],\r\n\t\t\t\t\t\tv[ i ][ k ],\r\n\t\t\t\t\t\tmaterialIndex\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tmake(\r\n\t\t\t\t\t\tv[ i ][ k + 1 ],\r\n\t\t\t\t\t\tv[ i + 1 ][ k + 1 ],\r\n\t\t\t\t\t\tv[ i + 1 ][ k ],\r\n\t\t\t\t\t\tmaterialIndex\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\r\n\t// Angle around the Y axis, counter-clockwise when looking from above.\r\n\r\n\tfunction azimuth( vector ) {\r\n\r\n\t\treturn Math.atan2( vector.z, - vector.x );\r\n\r\n\t}\r\n\r\n\r\n\t// Angle above the XZ plane.\r\n\r\n\tfunction inclination( vector ) {\r\n\r\n\t\treturn Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );\r\n\r\n\t}\r\n\r\n\r\n\t// Texture fixing helper. Spheres have some odd behaviours.\r\n\r\n\tfunction correctUV( uv, vector, azimuth ) {\r\n\r\n\t\tif ( ( azimuth < 0 ) && ( uv.x === 1 ) ) uv = new THREE.Vector2( uv.x - 1, uv.y );\r\n\t\tif ( ( vector.x === 0 ) && ( vector.z === 0 ) ) uv = new THREE.Vector2( azimuth / 2 / Math.PI + 0.5, uv.y );\r\n\t\treturn uv.clone();\r\n\r\n\t}\r\n\r\n\r\n};\r\n\r\nTHREE.PolyhedronGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.PolyhedronGeometry.prototype.constructor = THREE.PolyhedronGeometry;\r\n\r\n// File:src/extras/geometries/DodecahedronGeometry.js\r\n\r\n/**\r\n * @author Abe Pazos / https://hamoid.com\r\n */\r\n\r\nTHREE.DodecahedronGeometry = function ( radius, detail ) {\r\n\r\n\tvar t = ( 1 + Math.sqrt( 5 ) ) / 2;\r\n\tvar r = 1 / t;\r\n\r\n\tvar vertices = [\r\n\r\n\t\t// (1, 1, 1)\r\n\t\t- 1, - 1, - 1,    - 1, - 1,  1,\r\n\t\t- 1,  1, - 1,    - 1,  1,  1,\r\n\t\t 1, - 1, - 1,     1, - 1,  1,\r\n\t\t 1,  1, - 1,     1,  1,  1,\r\n\r\n\t\t// (0, 1/, )\r\n\t\t 0, - r, - t,     0, - r,  t,\r\n\t\t 0,  r, - t,     0,  r,  t,\r\n\r\n\t\t// (1/, , 0)\r\n\t\t- r, - t,  0,    - r,  t,  0,\r\n\t\t r, - t,  0,     r,  t,  0,\r\n\r\n\t\t// (, 0, 1/)\r\n\t\t- t,  0, - r,     t,  0, - r,\r\n\t\t- t,  0,  r,     t,  0,  r\r\n\t];\r\n\r\n\tvar indices = [\r\n\t\t 3, 11,  7,      3,  7, 15,      3, 15, 13,\r\n\t\t 7, 19, 17,      7, 17,  6,      7,  6, 15,\r\n\t\t17,  4,  8,     17,  8, 10,     17, 10,  6,\r\n\t\t 8,  0, 16,      8, 16,  2,      8,  2, 10,\r\n\t\t 0, 12,  1,      0,  1, 18,      0, 18, 16,\r\n\t\t 6, 10,  2,      6,  2, 13,      6, 13, 15,\r\n\t\t 2, 16, 18,      2, 18,  3,      2,  3, 13,\r\n\t\t18,  1,  9,     18,  9, 11,     18, 11,  3,\r\n\t\t 4, 14, 12,      4, 12,  0,      4,  0,  8,\r\n\t\t11,  9,  5,     11,  5, 19,     11, 19,  7,\r\n\t\t19,  5, 14,     19, 14,  4,     19,  4, 17,\r\n\t\t 1, 12, 14,      1, 14,  5,      1,  5,  9\r\n\t];\r\n\r\n\tTHREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );\r\n\r\n\tthis.type = 'DodecahedronGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tradius: radius,\r\n\t\tdetail: detail\r\n\t};\r\n\r\n};\r\n\r\nTHREE.DodecahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );\r\nTHREE.DodecahedronGeometry.prototype.constructor = THREE.DodecahedronGeometry;\r\n\r\n// File:src/extras/geometries/IcosahedronGeometry.js\r\n\r\n/**\r\n * @author timothypratley / https://github.com/timothypratley\r\n */\r\n\r\nTHREE.IcosahedronGeometry = function ( radius, detail ) {\r\n\r\n\tvar t = ( 1 + Math.sqrt( 5 ) ) / 2;\r\n\r\n\tvar vertices = [\r\n\t\t- 1,  t,  0,    1,  t,  0,   - 1, - t,  0,    1, - t,  0,\r\n\t\t 0, - 1,  t,    0,  1,  t,    0, - 1, - t,    0,  1, - t,\r\n\t\t t,  0, - 1,    t,  0,  1,   - t,  0, - 1,   - t,  0,  1\r\n\t];\r\n\r\n\tvar indices = [\r\n\t\t 0, 11,  5,    0,  5,  1,    0,  1,  7,    0,  7, 10,    0, 10, 11,\r\n\t\t 1,  5,  9,    5, 11,  4,   11, 10,  2,   10,  7,  6,    7,  1,  8,\r\n\t\t 3,  9,  4,    3,  4,  2,    3,  2,  6,    3,  6,  8,    3,  8,  9,\r\n\t\t 4,  9,  5,    2,  4, 11,    6,  2, 10,    8,  6,  7,    9,  8,  1\r\n\t];\r\n\r\n\tTHREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );\r\n\r\n\tthis.type = 'IcosahedronGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tradius: radius,\r\n\t\tdetail: detail\r\n\t};\r\n\r\n};\r\n\r\nTHREE.IcosahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );\r\nTHREE.IcosahedronGeometry.prototype.constructor = THREE.IcosahedronGeometry;\r\n\r\n// File:src/extras/geometries/OctahedronGeometry.js\r\n\r\n/**\r\n * @author timothypratley / https://github.com/timothypratley\r\n */\r\n\r\nTHREE.OctahedronGeometry = function ( radius, detail ) {\r\n\r\n\tvar vertices = [\r\n\t\t1, 0, 0,   - 1, 0, 0,    0, 1, 0,    0, - 1, 0,    0, 0, 1,    0, 0, - 1\r\n\t];\r\n\r\n\tvar indices = [\r\n\t\t0, 2, 4,    0, 4, 3,    0, 3, 5,    0, 5, 2,    1, 2, 5,    1, 5, 3,    1, 3, 4,    1, 4, 2\r\n\t];\r\n\r\n\tTHREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );\r\n\r\n\tthis.type = 'OctahedronGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tradius: radius,\r\n\t\tdetail: detail\r\n\t};\r\n\r\n};\r\n\r\nTHREE.OctahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );\r\nTHREE.OctahedronGeometry.prototype.constructor = THREE.OctahedronGeometry;\r\n\r\n// File:src/extras/geometries/TetrahedronGeometry.js\r\n\r\n/**\r\n * @author timothypratley / https://github.com/timothypratley\r\n */\r\n\r\nTHREE.TetrahedronGeometry = function ( radius, detail ) {\r\n\r\n\tvar vertices = [\r\n\t\t 1,  1,  1,   - 1, - 1,  1,   - 1,  1, - 1,    1, - 1, - 1\r\n\t];\r\n\r\n\tvar indices = [\r\n\t\t 2,  1,  0,    0,  3,  2,    1,  3,  0,    2,  3,  1\r\n\t];\r\n\r\n\tTHREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );\r\n\r\n\tthis.type = 'TetrahedronGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tradius: radius,\r\n\t\tdetail: detail\r\n\t};\r\n\r\n};\r\n\r\nTHREE.TetrahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );\r\nTHREE.TetrahedronGeometry.prototype.constructor = THREE.TetrahedronGeometry;\r\n\r\n// File:src/extras/geometries/ParametricGeometry.js\r\n\r\n/**\r\n * @author zz85 / https://github.com/zz85\r\n * Parametric Surfaces Geometry\r\n * based on the brilliant article by @prideout http://prideout.net/blog/?p=44\r\n *\r\n * new THREE.ParametricGeometry( parametricFunction, uSegments, ySegements );\r\n *\r\n */\r\n\r\nTHREE.ParametricGeometry = function ( func, slices, stacks ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tthis.type = 'ParametricGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tfunc: func,\r\n\t\tslices: slices,\r\n\t\tstacks: stacks\r\n\t};\r\n\r\n\tvar verts = this.vertices;\r\n\tvar faces = this.faces;\r\n\tvar uvs = this.faceVertexUvs[ 0 ];\r\n\r\n\tvar i, j, p;\r\n\tvar u, v;\r\n\r\n\tvar sliceCount = slices + 1;\r\n\r\n\tfor ( i = 0; i <= stacks; i ++ ) {\r\n\r\n\t\tv = i / stacks;\r\n\r\n\t\tfor ( j = 0; j <= slices; j ++ ) {\r\n\r\n\t\t\tu = j / slices;\r\n\r\n\t\t\tp = func( u, v );\r\n\t\t\tverts.push( p );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tvar a, b, c, d;\r\n\tvar uva, uvb, uvc, uvd;\r\n\r\n\tfor ( i = 0; i < stacks; i ++ ) {\r\n\r\n\t\tfor ( j = 0; j < slices; j ++ ) {\r\n\r\n\t\t\ta = i * sliceCount + j;\r\n\t\t\tb = i * sliceCount + j + 1;\r\n\t\t\tc = ( i + 1 ) * sliceCount + j + 1;\r\n\t\t\td = ( i + 1 ) * sliceCount + j;\r\n\r\n\t\t\tuva = new THREE.Vector2( j / slices, i / stacks );\r\n\t\t\tuvb = new THREE.Vector2( ( j + 1 ) / slices, i / stacks );\r\n\t\t\tuvc = new THREE.Vector2( ( j + 1 ) / slices, ( i + 1 ) / stacks );\r\n\t\t\tuvd = new THREE.Vector2( j / slices, ( i + 1 ) / stacks );\r\n\r\n\t\t\tfaces.push( new THREE.Face3( a, b, d ) );\r\n\t\t\tuvs.push( [ uva, uvb, uvd ] );\r\n\r\n\t\t\tfaces.push( new THREE.Face3( b, c, d ) );\r\n\t\t\tuvs.push( [ uvb.clone(), uvc, uvd.clone() ] );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// console.log(this);\r\n\r\n\t// magic bullet\r\n\t// var diff = this.mergeVertices();\r\n\t// console.log('removed ', diff, ' vertices by merging');\r\n\r\n\tthis.computeFaceNormals();\r\n\tthis.computeVertexNormals();\r\n\r\n};\r\n\r\nTHREE.ParametricGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.ParametricGeometry.prototype.constructor = THREE.ParametricGeometry;\r\n\r\n// File:src/extras/geometries/WireframeGeometry.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.WireframeGeometry = function ( geometry ) {\r\n\r\n\tTHREE.BufferGeometry.call( this );\r\n\r\n\tvar edge = [ 0, 0 ], hash = {};\r\n\r\n\tfunction sortFunction( a, b ) {\r\n\r\n\t\treturn a - b;\r\n\r\n\t}\r\n\r\n\tvar keys = [ 'a', 'b', 'c' ];\r\n\r\n\tif ( geometry instanceof THREE.Geometry ) {\r\n\r\n\t\tvar vertices = geometry.vertices;\r\n\t\tvar faces = geometry.faces;\r\n\t\tvar numEdges = 0;\r\n\r\n\t\t// allocate maximal size\r\n\t\tvar edges = new Uint32Array( 6 * faces.length );\r\n\r\n\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar face = faces[ i ];\r\n\r\n\t\t\tfor ( var j = 0; j < 3; j ++ ) {\r\n\r\n\t\t\t\tedge[ 0 ] = face[ keys[ j ] ];\r\n\t\t\t\tedge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];\r\n\t\t\t\tedge.sort( sortFunction );\r\n\r\n\t\t\t\tvar key = edge.toString();\r\n\r\n\t\t\t\tif ( hash[ key ] === undefined ) {\r\n\r\n\t\t\t\t\tedges[ 2 * numEdges ] = edge[ 0 ];\r\n\t\t\t\t\tedges[ 2 * numEdges + 1 ] = edge[ 1 ];\r\n\t\t\t\t\thash[ key ] = true;\r\n\t\t\t\t\tnumEdges ++;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar coords = new Float32Array( numEdges * 2 * 3 );\r\n\r\n\t\tfor ( var i = 0, l = numEdges; i < l; i ++ ) {\r\n\r\n\t\t\tfor ( var j = 0; j < 2; j ++ ) {\r\n\r\n\t\t\t\tvar vertex = vertices[ edges [ 2 * i + j ] ];\r\n\r\n\t\t\t\tvar index = 6 * i + 3 * j;\r\n\t\t\t\tcoords[ index + 0 ] = vertex.x;\r\n\t\t\t\tcoords[ index + 1 ] = vertex.y;\r\n\t\t\t\tcoords[ index + 2 ] = vertex.z;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );\r\n\r\n\t} else if ( geometry instanceof THREE.BufferGeometry ) {\r\n\r\n\t\tif ( geometry.index !== null ) {\r\n\r\n\t\t\t// Indexed BufferGeometry\r\n\r\n\t\t\tvar indices = geometry.index.array;\r\n\t\t\tvar vertices = geometry.attributes.position;\r\n\t\t\tvar groups = geometry.groups;\r\n\t\t\tvar numEdges = 0;\r\n\r\n\t\t\tif ( groups.length === 0 ) {\r\n\r\n\t\t\t\tgeometry.addGroup( 0, indices.length );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// allocate maximal size\r\n\t\t\tvar edges = new Uint32Array( 2 * indices.length );\r\n\r\n\t\t\tfor ( var o = 0, ol = groups.length; o < ol; ++ o ) {\r\n\r\n\t\t\t\tvar group = groups[ o ];\r\n\r\n\t\t\t\tvar start = group.start;\r\n\t\t\t\tvar count = group.count;\r\n\r\n\t\t\t\tfor ( var i = start, il = start + count; i < il; i += 3 ) {\r\n\r\n\t\t\t\t\tfor ( var j = 0; j < 3; j ++ ) {\r\n\r\n\t\t\t\t\t\tedge[ 0 ] = indices[ i + j ];\r\n\t\t\t\t\t\tedge[ 1 ] = indices[ i + ( j + 1 ) % 3 ];\r\n\t\t\t\t\t\tedge.sort( sortFunction );\r\n\r\n\t\t\t\t\t\tvar key = edge.toString();\r\n\r\n\t\t\t\t\t\tif ( hash[ key ] === undefined ) {\r\n\r\n\t\t\t\t\t\t\tedges[ 2 * numEdges ] = edge[ 0 ];\r\n\t\t\t\t\t\t\tedges[ 2 * numEdges + 1 ] = edge[ 1 ];\r\n\t\t\t\t\t\t\thash[ key ] = true;\r\n\t\t\t\t\t\t\tnumEdges ++;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar coords = new Float32Array( numEdges * 2 * 3 );\r\n\r\n\t\t\tfor ( var i = 0, l = numEdges; i < l; i ++ ) {\r\n\r\n\t\t\t\tfor ( var j = 0; j < 2; j ++ ) {\r\n\r\n\t\t\t\t\tvar index = 6 * i + 3 * j;\r\n\t\t\t\t\tvar index2 = edges[ 2 * i + j ];\r\n\r\n\t\t\t\t\tcoords[ index + 0 ] = vertices.getX( index2 );\r\n\t\t\t\t\tcoords[ index + 1 ] = vertices.getY( index2 );\r\n\t\t\t\t\tcoords[ index + 2 ] = vertices.getZ( index2 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// non-indexed BufferGeometry\r\n\r\n\t\t\tvar vertices = geometry.attributes.position.array;\r\n\t\t\tvar numEdges = vertices.length / 3;\r\n\t\t\tvar numTris = numEdges / 3;\r\n\r\n\t\t\tvar coords = new Float32Array( numEdges * 2 * 3 );\r\n\r\n\t\t\tfor ( var i = 0, l = numTris; i < l; i ++ ) {\r\n\r\n\t\t\t\tfor ( var j = 0; j < 3; j ++ ) {\r\n\r\n\t\t\t\t\tvar index = 18 * i + 6 * j;\r\n\r\n\t\t\t\t\tvar index1 = 9 * i + 3 * j;\r\n\t\t\t\t\tcoords[ index + 0 ] = vertices[ index1 ];\r\n\t\t\t\t\tcoords[ index + 1 ] = vertices[ index1 + 1 ];\r\n\t\t\t\t\tcoords[ index + 2 ] = vertices[ index1 + 2 ];\r\n\r\n\t\t\t\t\tvar index2 = 9 * i + 3 * ( ( j + 1 ) % 3 );\r\n\t\t\t\t\tcoords[ index + 3 ] = vertices[ index2 ];\r\n\t\t\t\t\tcoords[ index + 4 ] = vertices[ index2 + 1 ];\r\n\t\t\t\t\tcoords[ index + 5 ] = vertices[ index2 + 2 ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.WireframeGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\nTHREE.WireframeGeometry.prototype.constructor = THREE.WireframeGeometry;\r\n\r\n// File:src/extras/helpers/AxisHelper.js\r\n\r\n/**\r\n * @author sroucheray / http://sroucheray.org/\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.AxisHelper = function ( size ) {\r\n\r\n\tsize = size || 1;\r\n\r\n\tvar vertices = new Float32Array( [\r\n\t\t0, 0, 0,  size, 0, 0,\r\n\t\t0, 0, 0,  0, size, 0,\r\n\t\t0, 0, 0,  0, 0, size\r\n\t] );\r\n\r\n\tvar colors = new Float32Array( [\r\n\t\t1, 0, 0,  1, 0.6, 0,\r\n\t\t0, 1, 0,  0.6, 1, 0,\r\n\t\t0, 0, 1,  0, 0.6, 1\r\n\t] );\r\n\r\n\tvar geometry = new THREE.BufferGeometry();\r\n\tgeometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\r\n\tgeometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );\r\n\r\n\tvar material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );\r\n\r\n\tTHREE.LineSegments.call( this, geometry, material );\r\n\r\n};\r\n\r\nTHREE.AxisHelper.prototype = Object.create( THREE.LineSegments.prototype );\r\nTHREE.AxisHelper.prototype.constructor = THREE.AxisHelper;\r\n\r\n// File:src/extras/helpers/ArrowHelper.js\r\n\r\n/**\r\n * @author WestLangley / http://github.com/WestLangley\r\n * @author zz85 / http://github.com/zz85\r\n * @author bhouston / http://clara.io\r\n *\r\n * Creates an arrow for visualizing directions\r\n *\r\n * Parameters:\r\n *  dir - Vector3\r\n *  origin - Vector3\r\n *  length - Number\r\n *  color - color in hex value\r\n *  headLength - Number\r\n *  headWidth - Number\r\n */\r\n\r\nTHREE.ArrowHelper = ( function () {\r\n\r\n\tvar lineGeometry = new THREE.Geometry();\r\n\tlineGeometry.vertices.push( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 1, 0 ) );\r\n\r\n\tvar coneGeometry = new THREE.CylinderGeometry( 0, 0.5, 1, 5, 1 );\r\n\tconeGeometry.translate( 0, - 0.5, 0 );\r\n\r\n\treturn function ArrowHelper( dir, origin, length, color, headLength, headWidth ) {\r\n\r\n\t\t// dir is assumed to be normalized\r\n\r\n\t\tTHREE.Object3D.call( this );\r\n\r\n\t\tif ( color === undefined ) color = 0xffff00;\r\n\t\tif ( length === undefined ) length = 1;\r\n\t\tif ( headLength === undefined ) headLength = 0.2 * length;\r\n\t\tif ( headWidth === undefined ) headWidth = 0.2 * headLength;\r\n\r\n\t\tthis.position.copy( origin );\r\n\t\t\r\n\t\tthis.line = new THREE.Line( lineGeometry, new THREE.LineBasicMaterial( { color: color } ) );\r\n\t\tthis.line.matrixAutoUpdate = false;\r\n\t\tthis.add( this.line );\r\n\r\n\t\tthis.cone = new THREE.Mesh( coneGeometry, new THREE.MeshBasicMaterial( { color: color } ) );\r\n\t\tthis.cone.matrixAutoUpdate = false;\r\n\t\tthis.add( this.cone );\r\n\r\n\t\tthis.setDirection( dir );\r\n\t\tthis.setLength( length, headLength, headWidth );\r\n\r\n\t}\r\n\r\n}() );\r\n\r\nTHREE.ArrowHelper.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.ArrowHelper.prototype.constructor = THREE.ArrowHelper;\r\n\r\nTHREE.ArrowHelper.prototype.setDirection = ( function () {\r\n\r\n\tvar axis = new THREE.Vector3();\r\n\tvar radians;\r\n\r\n\treturn function setDirection( dir ) {\r\n\r\n\t\t// dir is assumed to be normalized\r\n\r\n\t\tif ( dir.y > 0.99999 ) {\r\n\r\n\t\t\tthis.quaternion.set( 0, 0, 0, 1 );\r\n\r\n\t\t} else if ( dir.y < - 0.99999 ) {\r\n\r\n\t\t\tthis.quaternion.set( 1, 0, 0, 0 );\r\n\r\n\t\t} else {\r\n\r\n\t\t\taxis.set( dir.z, 0, - dir.x ).normalize();\r\n\r\n\t\t\tradians = Math.acos( dir.y );\r\n\r\n\t\t\tthis.quaternion.setFromAxisAngle( axis, radians );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n}() );\r\n\r\nTHREE.ArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {\r\n\r\n\tif ( headLength === undefined ) headLength = 0.2 * length;\r\n\tif ( headWidth === undefined ) headWidth = 0.2 * headLength;\r\n\r\n\tthis.line.scale.set( 1, Math.max( 0, length - headLength ), 1 );\r\n\tthis.line.updateMatrix();\r\n\r\n\tthis.cone.scale.set( headWidth, headLength, headWidth );\r\n\tthis.cone.position.y = length;\r\n\tthis.cone.updateMatrix();\r\n\r\n};\r\n\r\nTHREE.ArrowHelper.prototype.setColor = function ( color ) {\r\n\r\n\tthis.line.material.color.set( color );\r\n\tthis.cone.material.color.set( color );\r\n\r\n};\r\n\r\n// File:src/extras/helpers/BoxHelper.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.BoxHelper = function ( object ) {\r\n\r\n\tvar indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );\r\n\tvar positions = new Float32Array( 8 * 3 );\r\n\r\n\tvar geometry = new THREE.BufferGeometry();\r\n\tgeometry.setIndex( new THREE.BufferAttribute( indices, 1 ) );\r\n\tgeometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );\r\n\r\n\tTHREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: 0xffff00 } ) );\r\n\r\n\tif ( object !== undefined ) {\r\n\r\n\t\tthis.update( object );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.BoxHelper.prototype = Object.create( THREE.LineSegments.prototype );\r\nTHREE.BoxHelper.prototype.constructor = THREE.BoxHelper;\r\n\r\nTHREE.BoxHelper.prototype.update = ( function () {\r\n\r\n\tvar box = new THREE.Box3();\r\n\r\n\treturn function ( object ) {\r\n\r\n\t\tif ( object instanceof THREE.Box3 ) {\r\n\r\n\t\t\tbox.copy( object );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tbox.setFromObject( object );\r\n\r\n\t\t}\r\n\r\n\t\tif ( box.isEmpty() ) return;\r\n\r\n\t\tvar min = box.min;\r\n\t\tvar max = box.max;\r\n\r\n\t\t/*\r\n\t\t  5____4\r\n\t\t1/___0/|\r\n\t\t| 6__|_7\r\n\t\t2/___3/\r\n\r\n\t\t0: max.x, max.y, max.z\r\n\t\t1: min.x, max.y, max.z\r\n\t\t2: min.x, min.y, max.z\r\n\t\t3: max.x, min.y, max.z\r\n\t\t4: max.x, max.y, min.z\r\n\t\t5: min.x, max.y, min.z\r\n\t\t6: min.x, min.y, min.z\r\n\t\t7: max.x, min.y, min.z\r\n\t\t*/\r\n\r\n\t\tvar position = this.geometry.attributes.position;\r\n\t\tvar array = position.array;\r\n\r\n\t\tarray[  0 ] = max.x; array[  1 ] = max.y; array[  2 ] = max.z;\r\n\t\tarray[  3 ] = min.x; array[  4 ] = max.y; array[  5 ] = max.z;\r\n\t\tarray[  6 ] = min.x; array[  7 ] = min.y; array[  8 ] = max.z;\r\n\t\tarray[  9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;\r\n\t\tarray[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;\r\n\t\tarray[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;\r\n\t\tarray[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;\r\n\t\tarray[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;\r\n\r\n\t\tposition.needsUpdate = true;\r\n\r\n\t\tthis.geometry.computeBoundingSphere();\r\n\r\n\t};\r\n\r\n} )();\r\n\r\n// File:src/extras/helpers/BoundingBoxHelper.js\r\n\r\n/**\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\n\r\n// a helper to show the world-axis-aligned bounding box for an object\r\n\r\nTHREE.BoundingBoxHelper = function ( object, hex ) {\r\n\r\n\tvar color = ( hex !== undefined ) ? hex : 0x888888;\r\n\r\n\tthis.object = object;\r\n\r\n\tthis.box = new THREE.Box3();\r\n\r\n\tTHREE.Mesh.call( this, new THREE.BoxGeometry( 1, 1, 1 ), new THREE.MeshBasicMaterial( { color: color, wireframe: true } ) );\r\n\r\n};\r\n\r\nTHREE.BoundingBoxHelper.prototype = Object.create( THREE.Mesh.prototype );\r\nTHREE.BoundingBoxHelper.prototype.constructor = THREE.BoundingBoxHelper;\r\n\r\nTHREE.BoundingBoxHelper.prototype.update = function () {\r\n\r\n\tthis.box.setFromObject( this.object );\r\n\r\n\tthis.box.size( this.scale );\r\n\r\n\tthis.box.center( this.position );\r\n\r\n};\r\n\r\n// File:src/extras/helpers/CameraHelper.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n *\t- shows frustum, line of sight and up of the camera\r\n *\t- suitable for fast updates\r\n * \t- based on frustum visualization in lightgl.js shadowmap example\r\n *\t\thttp://evanw.github.com/lightgl.js/tests/shadowmap.html\r\n */\r\n\r\nTHREE.CameraHelper = function ( camera ) {\r\n\r\n\tvar geometry = new THREE.Geometry();\r\n\tvar material = new THREE.LineBasicMaterial( { color: 0xffffff, vertexColors: THREE.FaceColors } );\r\n\r\n\tvar pointMap = {};\r\n\r\n\t// colors\r\n\r\n\tvar hexFrustum = 0xffaa00;\r\n\tvar hexCone = 0xff0000;\r\n\tvar hexUp = 0x00aaff;\r\n\tvar hexTarget = 0xffffff;\r\n\tvar hexCross = 0x333333;\r\n\r\n\t// near\r\n\r\n\taddLine( \"n1\", \"n2\", hexFrustum );\r\n\taddLine( \"n2\", \"n4\", hexFrustum );\r\n\taddLine( \"n4\", \"n3\", hexFrustum );\r\n\taddLine( \"n3\", \"n1\", hexFrustum );\r\n\r\n\t// far\r\n\r\n\taddLine( \"f1\", \"f2\", hexFrustum );\r\n\taddLine( \"f2\", \"f4\", hexFrustum );\r\n\taddLine( \"f4\", \"f3\", hexFrustum );\r\n\taddLine( \"f3\", \"f1\", hexFrustum );\r\n\r\n\t// sides\r\n\r\n\taddLine( \"n1\", \"f1\", hexFrustum );\r\n\taddLine( \"n2\", \"f2\", hexFrustum );\r\n\taddLine( \"n3\", \"f3\", hexFrustum );\r\n\taddLine( \"n4\", \"f4\", hexFrustum );\r\n\r\n\t// cone\r\n\r\n\taddLine( \"p\", \"n1\", hexCone );\r\n\taddLine( \"p\", \"n2\", hexCone );\r\n\taddLine( \"p\", \"n3\", hexCone );\r\n\taddLine( \"p\", \"n4\", hexCone );\r\n\r\n\t// up\r\n\r\n\taddLine( \"u1\", \"u2\", hexUp );\r\n\taddLine( \"u2\", \"u3\", hexUp );\r\n\taddLine( \"u3\", \"u1\", hexUp );\r\n\r\n\t// target\r\n\r\n\taddLine( \"c\", \"t\", hexTarget );\r\n\taddLine( \"p\", \"c\", hexCross );\r\n\r\n\t// cross\r\n\r\n\taddLine( \"cn1\", \"cn2\", hexCross );\r\n\taddLine( \"cn3\", \"cn4\", hexCross );\r\n\r\n\taddLine( \"cf1\", \"cf2\", hexCross );\r\n\taddLine( \"cf3\", \"cf4\", hexCross );\r\n\r\n\tfunction addLine( a, b, hex ) {\r\n\r\n\t\taddPoint( a, hex );\r\n\t\taddPoint( b, hex );\r\n\r\n\t}\r\n\r\n\tfunction addPoint( id, hex ) {\r\n\r\n\t\tgeometry.vertices.push( new THREE.Vector3() );\r\n\t\tgeometry.colors.push( new THREE.Color( hex ) );\r\n\r\n\t\tif ( pointMap[ id ] === undefined ) {\r\n\r\n\t\t\tpointMap[ id ] = [];\r\n\r\n\t\t}\r\n\r\n\t\tpointMap[ id ].push( geometry.vertices.length - 1 );\r\n\r\n\t}\r\n\r\n\tTHREE.LineSegments.call( this, geometry, material );\r\n\r\n\tthis.camera = camera;\r\n\tthis.camera.updateProjectionMatrix();\r\n\r\n\tthis.matrix = camera.matrixWorld;\r\n\tthis.matrixAutoUpdate = false;\r\n\r\n\tthis.pointMap = pointMap;\r\n\r\n\tthis.update();\r\n\r\n};\r\n\r\nTHREE.CameraHelper.prototype = Object.create( THREE.LineSegments.prototype );\r\nTHREE.CameraHelper.prototype.constructor = THREE.CameraHelper;\r\n\r\nTHREE.CameraHelper.prototype.update = function () {\r\n\r\n\tvar geometry, pointMap;\r\n\r\n\tvar vector = new THREE.Vector3();\r\n\tvar camera = new THREE.Camera();\r\n\r\n\tfunction setPoint( point, x, y, z ) {\r\n\r\n\t\tvector.set( x, y, z ).unproject( camera );\r\n\r\n\t\tvar points = pointMap[ point ];\r\n\r\n\t\tif ( points !== undefined ) {\r\n\r\n\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tgeometry.vertices[ points[ i ] ].copy( vector );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn function () {\r\n\r\n\t\tgeometry = this.geometry;\r\n\t\tpointMap = this.pointMap;\r\n\r\n\t\tvar w = 1, h = 1;\r\n\r\n\t\t// we need just camera projection matrix\r\n\t\t// world matrix must be identity\r\n\r\n\t\tcamera.projectionMatrix.copy( this.camera.projectionMatrix );\r\n\r\n\t\t// center / target\r\n\r\n\t\tsetPoint( \"c\", 0, 0, - 1 );\r\n\t\tsetPoint( \"t\", 0, 0,  1 );\r\n\r\n\t\t// near\r\n\r\n\t\tsetPoint( \"n1\", - w, - h, - 1 );\r\n\t\tsetPoint( \"n2\",   w, - h, - 1 );\r\n\t\tsetPoint( \"n3\", - w,   h, - 1 );\r\n\t\tsetPoint( \"n4\",   w,   h, - 1 );\r\n\r\n\t\t// far\r\n\r\n\t\tsetPoint( \"f1\", - w, - h, 1 );\r\n\t\tsetPoint( \"f2\",   w, - h, 1 );\r\n\t\tsetPoint( \"f3\", - w,   h, 1 );\r\n\t\tsetPoint( \"f4\",   w,   h, 1 );\r\n\r\n\t\t// up\r\n\r\n\t\tsetPoint( \"u1\",   w * 0.7, h * 1.1, - 1 );\r\n\t\tsetPoint( \"u2\", - w * 0.7, h * 1.1, - 1 );\r\n\t\tsetPoint( \"u3\",         0, h * 2,   - 1 );\r\n\r\n\t\t// cross\r\n\r\n\t\tsetPoint( \"cf1\", - w,   0, 1 );\r\n\t\tsetPoint( \"cf2\",   w,   0, 1 );\r\n\t\tsetPoint( \"cf3\",   0, - h, 1 );\r\n\t\tsetPoint( \"cf4\",   0,   h, 1 );\r\n\r\n\t\tsetPoint( \"cn1\", - w,   0, - 1 );\r\n\t\tsetPoint( \"cn2\",   w,   0, - 1 );\r\n\t\tsetPoint( \"cn3\",   0, - h, - 1 );\r\n\t\tsetPoint( \"cn4\",   0,   h, - 1 );\r\n\r\n\t\tgeometry.verticesNeedUpdate = true;\r\n\r\n\t};\r\n\r\n}();\r\n\r\n// File:src/extras/helpers/DirectionalLightHelper.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\n\r\nTHREE.DirectionalLightHelper = function ( light, size ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.light = light;\r\n\tthis.light.updateMatrixWorld();\r\n\r\n\tthis.matrix = light.matrixWorld;\r\n\tthis.matrixAutoUpdate = false;\r\n\r\n\tsize = size || 1;\r\n\r\n\tvar geometry = new THREE.Geometry();\r\n\tgeometry.vertices.push(\r\n\t\tnew THREE.Vector3( - size,   size, 0 ),\r\n\t\tnew THREE.Vector3(   size,   size, 0 ),\r\n\t\tnew THREE.Vector3(   size, - size, 0 ),\r\n\t\tnew THREE.Vector3( - size, - size, 0 ),\r\n\t\tnew THREE.Vector3( - size,   size, 0 )\r\n\t);\r\n\r\n\tvar material = new THREE.LineBasicMaterial( { fog: false } );\r\n\tmaterial.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\r\n\tthis.lightPlane = new THREE.Line( geometry, material );\r\n\tthis.add( this.lightPlane );\r\n\r\n\tgeometry = new THREE.Geometry();\r\n\tgeometry.vertices.push(\r\n\t\tnew THREE.Vector3(),\r\n\t\tnew THREE.Vector3()\r\n\t);\r\n\r\n\tmaterial = new THREE.LineBasicMaterial( { fog: false } );\r\n\tmaterial.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\r\n\tthis.targetLine = new THREE.Line( geometry, material );\r\n\tthis.add( this.targetLine );\r\n\r\n\tthis.update();\r\n\r\n};\r\n\r\nTHREE.DirectionalLightHelper.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.DirectionalLightHelper.prototype.constructor = THREE.DirectionalLightHelper;\r\n\r\nTHREE.DirectionalLightHelper.prototype.dispose = function () {\r\n\r\n\tthis.lightPlane.geometry.dispose();\r\n\tthis.lightPlane.material.dispose();\r\n\tthis.targetLine.geometry.dispose();\r\n\tthis.targetLine.material.dispose();\r\n\r\n};\r\n\r\nTHREE.DirectionalLightHelper.prototype.update = function () {\r\n\r\n\tvar v1 = new THREE.Vector3();\r\n\tvar v2 = new THREE.Vector3();\r\n\tvar v3 = new THREE.Vector3();\r\n\r\n\treturn function () {\r\n\r\n\t\tv1.setFromMatrixPosition( this.light.matrixWorld );\r\n\t\tv2.setFromMatrixPosition( this.light.target.matrixWorld );\r\n\t\tv3.subVectors( v2, v1 );\r\n\r\n\t\tthis.lightPlane.lookAt( v3 );\r\n\t\tthis.lightPlane.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\r\n\t\tthis.targetLine.geometry.vertices[ 1 ].copy( v3 );\r\n\t\tthis.targetLine.geometry.verticesNeedUpdate = true;\r\n\t\tthis.targetLine.material.color.copy( this.lightPlane.material.color );\r\n\r\n\t};\r\n\r\n}();\r\n\r\n// File:src/extras/helpers/EdgesHelper.js\r\n\r\n/**\r\n * @author WestLangley / http://github.com/WestLangley\r\n * @param object THREE.Mesh whose geometry will be used\r\n * @param hex line color\r\n * @param thresholdAngle the minimum angle (in degrees),\r\n * between the face normals of adjacent faces,\r\n * that is required to render an edge. A value of 10 means\r\n * an edge is only rendered if the angle is at least 10 degrees.\r\n */\r\n\r\nTHREE.EdgesHelper = function ( object, hex, thresholdAngle ) {\r\n\r\n\tvar color = ( hex !== undefined ) ? hex : 0xffffff;\r\n\r\n\tTHREE.LineSegments.call( this, new THREE.EdgesGeometry( object.geometry, thresholdAngle ), new THREE.LineBasicMaterial( { color: color } ) );\r\n\r\n\tthis.matrix = object.matrixWorld;\r\n\tthis.matrixAutoUpdate = false;\r\n\r\n};\r\n\r\nTHREE.EdgesHelper.prototype = Object.create( THREE.LineSegments.prototype );\r\nTHREE.EdgesHelper.prototype.constructor = THREE.EdgesHelper;\r\n\r\n// File:src/extras/helpers/FaceNormalsHelper.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n*/\r\n\r\nTHREE.FaceNormalsHelper = function ( object, size, hex, linewidth ) {\r\n\r\n\t// FaceNormalsHelper only supports THREE.Geometry\r\n\r\n\tthis.object = object;\r\n\r\n\tthis.size = ( size !== undefined ) ? size : 1;\r\n\r\n\tvar color = ( hex !== undefined ) ? hex : 0xffff00;\r\n\r\n\tvar width = ( linewidth !== undefined ) ? linewidth : 1;\r\n\r\n\t//\r\n\r\n\tvar nNormals = 0;\r\n\r\n\tvar objGeometry = this.object.geometry;\r\n\r\n\tif ( objGeometry instanceof THREE.Geometry ) {\r\n\r\n\t\tnNormals = objGeometry.faces.length;\r\n\r\n\t} else {\r\n\r\n\t\tconsole.warn( 'THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.' );\r\n\r\n\t}\r\n\r\n\t//\r\n\r\n\tvar geometry = new THREE.BufferGeometry();\r\n\r\n\tvar positions = new THREE.Float32Attribute( nNormals * 2 * 3, 3 );\r\n\r\n\tgeometry.addAttribute( 'position', positions );\r\n\r\n\tTHREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ) );\r\n\r\n\t//\r\n\r\n\tthis.matrixAutoUpdate = false;\r\n\tthis.update();\r\n\r\n};\r\n\r\nTHREE.FaceNormalsHelper.prototype = Object.create( THREE.LineSegments.prototype );\r\nTHREE.FaceNormalsHelper.prototype.constructor = THREE.FaceNormalsHelper;\r\n\r\nTHREE.FaceNormalsHelper.prototype.update = ( function () {\r\n\r\n\tvar v1 = new THREE.Vector3();\r\n\tvar v2 = new THREE.Vector3();\r\n\tvar normalMatrix = new THREE.Matrix3();\r\n\r\n\treturn function update() {\r\n\r\n\t\tthis.object.updateMatrixWorld( true );\r\n\r\n\t\tnormalMatrix.getNormalMatrix( this.object.matrixWorld );\r\n\r\n\t\tvar matrixWorld = this.object.matrixWorld;\r\n\r\n\t\tvar position = this.geometry.attributes.position;\r\n\r\n\t\t//\r\n\r\n\t\tvar objGeometry = this.object.geometry;\r\n\r\n\t\tvar vertices = objGeometry.vertices;\r\n\r\n\t\tvar faces = objGeometry.faces;\r\n\r\n\t\tvar idx = 0;\r\n\r\n\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar face = faces[ i ];\r\n\r\n\t\t\tvar normal = face.normal;\r\n\r\n\t\t\tv1.copy( vertices[ face.a ] )\r\n\t\t\t\t.add( vertices[ face.b ] )\r\n\t\t\t\t.add( vertices[ face.c ] )\r\n\t\t\t\t.divideScalar( 3 )\r\n\t\t\t\t.applyMatrix4( matrixWorld );\r\n\r\n\t\t\tv2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\r\n\r\n\t\t\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\r\n\r\n\t\t\tidx = idx + 1;\r\n\r\n\t\t\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\r\n\r\n\t\t\tidx = idx + 1;\r\n\r\n\t\t}\r\n\r\n\t\tposition.needsUpdate = true;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n}() );\r\n\r\n// File:src/extras/helpers/GridHelper.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.GridHelper = function ( size, step ) {\r\n\r\n\tvar geometry = new THREE.Geometry();\r\n\tvar material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );\r\n\r\n\tthis.color1 = new THREE.Color( 0x444444 );\r\n\tthis.color2 = new THREE.Color( 0x888888 );\r\n\r\n\tfor ( var i = - size; i <= size; i += step ) {\r\n\r\n\t\tgeometry.vertices.push(\r\n\t\t\tnew THREE.Vector3( - size, 0, i ), new THREE.Vector3( size, 0, i ),\r\n\t\t\tnew THREE.Vector3( i, 0, - size ), new THREE.Vector3( i, 0, size )\r\n\t\t);\r\n\r\n\t\tvar color = i === 0 ? this.color1 : this.color2;\r\n\r\n\t\tgeometry.colors.push( color, color, color, color );\r\n\r\n\t}\r\n\r\n\tTHREE.LineSegments.call( this, geometry, material );\r\n\r\n};\r\n\r\nTHREE.GridHelper.prototype = Object.create( THREE.LineSegments.prototype );\r\nTHREE.GridHelper.prototype.constructor = THREE.GridHelper;\r\n\r\nTHREE.GridHelper.prototype.setColors = function( colorCenterLine, colorGrid ) {\r\n\r\n\tthis.color1.set( colorCenterLine );\r\n\tthis.color2.set( colorGrid );\r\n\r\n\tthis.geometry.colorsNeedUpdate = true;\r\n\r\n};\r\n\r\n// File:src/extras/helpers/HemisphereLightHelper.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.HemisphereLightHelper = function ( light, sphereSize ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.light = light;\r\n\tthis.light.updateMatrixWorld();\r\n\r\n\tthis.matrix = light.matrixWorld;\r\n\tthis.matrixAutoUpdate = false;\r\n\r\n\tthis.colors = [ new THREE.Color(), new THREE.Color() ];\r\n\r\n\tvar geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );\r\n\tgeometry.rotateX( - Math.PI / 2 );\r\n\r\n\tfor ( var i = 0, il = 8; i < il; i ++ ) {\r\n\r\n\t\tgeometry.faces[ i ].color = this.colors[ i < 4 ? 0 : 1 ];\r\n\r\n\t}\r\n\r\n\tvar material = new THREE.MeshBasicMaterial( { vertexColors: THREE.FaceColors, wireframe: true } );\r\n\r\n\tthis.lightSphere = new THREE.Mesh( geometry, material );\r\n\tthis.add( this.lightSphere );\r\n\r\n\tthis.update();\r\n\r\n};\r\n\r\nTHREE.HemisphereLightHelper.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.HemisphereLightHelper.prototype.constructor = THREE.HemisphereLightHelper;\r\n\r\nTHREE.HemisphereLightHelper.prototype.dispose = function () {\r\n\r\n\tthis.lightSphere.geometry.dispose();\r\n\tthis.lightSphere.material.dispose();\r\n\r\n};\r\n\r\nTHREE.HemisphereLightHelper.prototype.update = function () {\r\n\r\n\tvar vector = new THREE.Vector3();\r\n\r\n\treturn function () {\r\n\r\n\t\tthis.colors[ 0 ].copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\t\tthis.colors[ 1 ].copy( this.light.groundColor ).multiplyScalar( this.light.intensity );\r\n\r\n\t\tthis.lightSphere.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );\r\n\t\tthis.lightSphere.geometry.colorsNeedUpdate = true;\r\n\r\n\t}\r\n\r\n}();\r\n\r\n// File:src/extras/helpers/PointLightHelper.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.PointLightHelper = function ( light, sphereSize ) {\r\n\r\n\tthis.light = light;\r\n\tthis.light.updateMatrixWorld();\r\n\r\n\tvar geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );\r\n\tvar material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );\r\n\tmaterial.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\r\n\tTHREE.Mesh.call( this, geometry, material );\r\n\r\n\tthis.matrix = this.light.matrixWorld;\r\n\tthis.matrixAutoUpdate = false;\r\n\r\n\t/*\r\n\tvar distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );\r\n\tvar distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );\r\n\r\n\tthis.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );\r\n\tthis.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );\r\n\r\n\tvar d = light.distance;\r\n\r\n\tif ( d === 0.0 ) {\r\n\r\n\t\tthis.lightDistance.visible = false;\r\n\r\n\t} else {\r\n\r\n\t\tthis.lightDistance.scale.set( d, d, d );\r\n\r\n\t}\r\n\r\n\tthis.add( this.lightDistance );\r\n\t*/\r\n\r\n};\r\n\r\nTHREE.PointLightHelper.prototype = Object.create( THREE.Mesh.prototype );\r\nTHREE.PointLightHelper.prototype.constructor = THREE.PointLightHelper;\r\n\r\nTHREE.PointLightHelper.prototype.dispose = function () {\r\n\r\n\tthis.geometry.dispose();\r\n\tthis.material.dispose();\r\n\r\n};\r\n\r\nTHREE.PointLightHelper.prototype.update = function () {\r\n\r\n\tthis.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\r\n\t/*\r\n\tvar d = this.light.distance;\r\n\r\n\tif ( d === 0.0 ) {\r\n\r\n\t\tthis.lightDistance.visible = false;\r\n\r\n\t} else {\r\n\r\n\t\tthis.lightDistance.visible = true;\r\n\t\tthis.lightDistance.scale.set( d, d, d );\r\n\r\n\t}\r\n\t*/\r\n\r\n};\r\n\r\n// File:src/extras/helpers/SkeletonHelper.js\r\n\r\n/**\r\n * @author Sean Griffin / http://twitter.com/sgrif\r\n * @author Michael Guerrero / http://realitymeltdown.com\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author ikerr / http://verold.com\r\n */\r\n\r\nTHREE.SkeletonHelper = function ( object ) {\r\n\r\n\tthis.bones = this.getBoneList( object );\r\n\r\n\tvar geometry = new THREE.Geometry();\r\n\r\n\tfor ( var i = 0; i < this.bones.length; i ++ ) {\r\n\r\n\t\tvar bone = this.bones[ i ];\r\n\r\n\t\tif ( bone.parent instanceof THREE.Bone ) {\r\n\r\n\t\t\tgeometry.vertices.push( new THREE.Vector3() );\r\n\t\t\tgeometry.vertices.push( new THREE.Vector3() );\r\n\t\t\tgeometry.colors.push( new THREE.Color( 0, 0, 1 ) );\r\n\t\t\tgeometry.colors.push( new THREE.Color( 0, 1, 0 ) );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tgeometry.dynamic = true;\r\n\r\n\tvar material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors, depthTest: false, depthWrite: false, transparent: true } );\r\n\r\n\tTHREE.LineSegments.call( this, geometry, material );\r\n\r\n\tthis.root = object;\r\n\r\n\tthis.matrix = object.matrixWorld;\r\n\tthis.matrixAutoUpdate = false;\r\n\r\n\tthis.update();\r\n\r\n};\r\n\r\n\r\nTHREE.SkeletonHelper.prototype = Object.create( THREE.LineSegments.prototype );\r\nTHREE.SkeletonHelper.prototype.constructor = THREE.SkeletonHelper;\r\n\r\nTHREE.SkeletonHelper.prototype.getBoneList = function( object ) {\r\n\r\n\tvar boneList = [];\r\n\r\n\tif ( object instanceof THREE.Bone ) {\r\n\r\n\t\tboneList.push( object );\r\n\r\n\t}\r\n\r\n\tfor ( var i = 0; i < object.children.length; i ++ ) {\r\n\r\n\t\tboneList.push.apply( boneList, this.getBoneList( object.children[ i ] ) );\r\n\r\n\t}\r\n\r\n\treturn boneList;\r\n\r\n};\r\n\r\nTHREE.SkeletonHelper.prototype.update = function () {\r\n\r\n\tvar geometry = this.geometry;\r\n\r\n\tvar matrixWorldInv = new THREE.Matrix4().getInverse( this.root.matrixWorld );\r\n\r\n\tvar boneMatrix = new THREE.Matrix4();\r\n\r\n\tvar j = 0;\r\n\r\n\tfor ( var i = 0; i < this.bones.length; i ++ ) {\r\n\r\n\t\tvar bone = this.bones[ i ];\r\n\r\n\t\tif ( bone.parent instanceof THREE.Bone ) {\r\n\r\n\t\t\tboneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );\r\n\t\t\tgeometry.vertices[ j ].setFromMatrixPosition( boneMatrix );\r\n\r\n\t\t\tboneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );\r\n\t\t\tgeometry.vertices[ j + 1 ].setFromMatrixPosition( boneMatrix );\r\n\r\n\t\t\tj += 2;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tgeometry.verticesNeedUpdate = true;\r\n\r\n\tgeometry.computeBoundingSphere();\r\n\r\n};\r\n\r\n// File:src/extras/helpers/SpotLightHelper.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n*/\r\n\r\nTHREE.SpotLightHelper = function ( light ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.light = light;\r\n\tthis.light.updateMatrixWorld();\r\n\r\n\tthis.matrix = light.matrixWorld;\r\n\tthis.matrixAutoUpdate = false;\r\n\r\n\tvar geometry = new THREE.BufferGeometry();\r\n\r\n\tvar positions = [\r\n\t\t0, 0, 0,   0,   0,   1,\r\n\t\t0, 0, 0,   1,   0,   1,\r\n\t\t0, 0, 0, - 1,   0,   1,\r\n\t\t0, 0, 0,   0,   1,   1,\r\n\t\t0, 0, 0,   0, - 1,   1\r\n\t];\r\n\r\n\tfor ( var i = 0, j = 1, l = 32; i < l; i ++, j ++ ) {\r\n\r\n\t\tvar p1 = ( i / l ) * Math.PI * 2;\r\n\t\tvar p2 = ( j / l ) * Math.PI * 2;\r\n\r\n\t\tpositions.push(\r\n\t\t\tMath.cos( p1 ), Math.sin( p1 ), 1,\r\n\t\t\tMath.cos( p2 ), Math.sin( p2 ), 1\r\n\t\t);\r\n\r\n\t}\r\n\r\n\tgeometry.addAttribute( 'position', new THREE.Float32Attribute( positions, 3 ) );\r\n\r\n\tvar material = new THREE.LineBasicMaterial( { fog: false } );\r\n\r\n\tthis.cone = new THREE.LineSegments( geometry, material );\r\n\tthis.add( this.cone );\r\n\r\n\tthis.update();\r\n\r\n};\r\n\r\nTHREE.SpotLightHelper.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.SpotLightHelper.prototype.constructor = THREE.SpotLightHelper;\r\n\r\nTHREE.SpotLightHelper.prototype.dispose = function () {\r\n\r\n\tthis.cone.geometry.dispose();\r\n\tthis.cone.material.dispose();\r\n\r\n};\r\n\r\nTHREE.SpotLightHelper.prototype.update = function () {\r\n\r\n\tvar vector = new THREE.Vector3();\r\n\tvar vector2 = new THREE.Vector3();\r\n\r\n\treturn function () {\r\n\r\n\t\tvar coneLength = this.light.distance ? this.light.distance : 1000;\r\n\t\tvar coneWidth = coneLength * Math.tan( this.light.angle );\r\n\r\n\t\tthis.cone.scale.set( coneWidth, coneWidth, coneLength );\r\n\r\n\t\tvector.setFromMatrixPosition( this.light.matrixWorld );\r\n\t\tvector2.setFromMatrixPosition( this.light.target.matrixWorld );\r\n\r\n\t\tthis.cone.lookAt( vector2.sub( vector ) );\r\n\r\n\t\tthis.cone.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\r\n\t};\r\n\r\n}();\r\n\r\n// File:src/extras/helpers/VertexNormalsHelper.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n*/\r\n\r\nTHREE.VertexNormalsHelper = function ( object, size, hex, linewidth ) {\r\n\r\n\tthis.object = object;\r\n\r\n\tthis.size = ( size !== undefined ) ? size : 1;\r\n\r\n\tvar color = ( hex !== undefined ) ? hex : 0xff0000;\r\n\r\n\tvar width = ( linewidth !== undefined ) ? linewidth : 1;\r\n\r\n\t//\r\n\r\n\tvar nNormals = 0;\r\n\r\n\tvar objGeometry = this.object.geometry;\r\n\r\n\tif ( objGeometry instanceof THREE.Geometry ) {\r\n\r\n\t\tnNormals = objGeometry.faces.length * 3;\r\n\r\n\t} else if ( objGeometry instanceof THREE.BufferGeometry ) {\r\n\r\n\t\tnNormals = objGeometry.attributes.normal.count\r\n\r\n\t}\r\n\r\n\t//\r\n\r\n\tvar geometry = new THREE.BufferGeometry();\r\n\r\n\tvar positions = new THREE.Float32Attribute( nNormals * 2 * 3, 3 );\r\n\r\n\tgeometry.addAttribute( 'position', positions );\r\n\r\n\tTHREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ) );\r\n\r\n\t//\r\n\r\n\tthis.matrixAutoUpdate = false;\r\n\r\n\tthis.update();\r\n\r\n};\r\n\r\nTHREE.VertexNormalsHelper.prototype = Object.create( THREE.LineSegments.prototype );\r\nTHREE.VertexNormalsHelper.prototype.constructor = THREE.VertexNormalsHelper;\r\n\r\nTHREE.VertexNormalsHelper.prototype.update = ( function () {\r\n\r\n\tvar v1 = new THREE.Vector3();\r\n\tvar v2 = new THREE.Vector3();\r\n\tvar normalMatrix = new THREE.Matrix3();\r\n\r\n\treturn function update() {\r\n\r\n\t\tvar keys = [ 'a', 'b', 'c' ];\r\n\r\n\t\tthis.object.updateMatrixWorld( true );\r\n\r\n\t\tnormalMatrix.getNormalMatrix( this.object.matrixWorld );\r\n\r\n\t\tvar matrixWorld = this.object.matrixWorld;\r\n\r\n\t\tvar position = this.geometry.attributes.position;\r\n\r\n\t\t//\r\n\r\n\t\tvar objGeometry = this.object.geometry;\r\n\r\n\t\tif ( objGeometry instanceof THREE.Geometry ) {\r\n\r\n\t\t\tvar vertices = objGeometry.vertices;\r\n\r\n\t\t\tvar faces = objGeometry.faces;\r\n\r\n\t\t\tvar idx = 0;\r\n\r\n\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar face = faces[ i ];\r\n\r\n\t\t\t\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\tvar vertex = vertices[ face[ keys[ j ] ] ];\r\n\r\n\t\t\t\t\tvar normal = face.vertexNormals[ j ];\r\n\r\n\t\t\t\t\tv1.copy( vertex ).applyMatrix4( matrixWorld );\r\n\r\n\t\t\t\t\tv2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\r\n\r\n\t\t\t\t\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\r\n\r\n\t\t\t\t\tidx = idx + 1;\r\n\r\n\t\t\t\t\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\r\n\r\n\t\t\t\t\tidx = idx + 1;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( objGeometry instanceof THREE.BufferGeometry ) {\r\n\r\n\t\t\tvar objPos = objGeometry.attributes.position;\r\n\r\n\t\t\tvar objNorm = objGeometry.attributes.normal;\r\n\r\n\t\t\tvar idx = 0;\r\n\r\n\t\t\t// for simplicity, ignore index and drawcalls, and render every normal\r\n\r\n\t\t\tfor ( var j = 0, jl = objPos.count; j < jl; j ++ ) {\r\n\r\n\t\t\t\tv1.set( objPos.getX( j ), objPos.getY( j ), objPos.getZ( j ) ).applyMatrix4( matrixWorld );\r\n\r\n\t\t\t\tv2.set( objNorm.getX( j ), objNorm.getY( j ), objNorm.getZ( j ) );\r\n\r\n\t\t\t\tv2.applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\r\n\r\n\t\t\t\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\r\n\r\n\t\t\t\tidx = idx + 1;\r\n\r\n\t\t\t\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\r\n\r\n\t\t\t\tidx = idx + 1;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tposition.needsUpdate = true;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n}() );\r\n\r\n// File:src/extras/helpers/WireframeHelper.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.WireframeHelper = function ( object, hex ) {\r\n\r\n\tvar color = ( hex !== undefined ) ? hex : 0xffffff;\r\n\r\n\tTHREE.LineSegments.call( this, new THREE.WireframeGeometry( object.geometry ), new THREE.LineBasicMaterial( { color: color } ) );\r\n\r\n\tthis.matrix = object.matrixWorld;\r\n\tthis.matrixAutoUpdate = false;\r\n\r\n};\r\n\r\nTHREE.WireframeHelper.prototype = Object.create( THREE.LineSegments.prototype );\r\nTHREE.WireframeHelper.prototype.constructor = THREE.WireframeHelper;\r\n\r\n// File:src/extras/objects/ImmediateRenderObject.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.ImmediateRenderObject = function ( material ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.material = material;\r\n\tthis.render = function ( renderCallback ) {};\r\n\r\n};\r\n\r\nTHREE.ImmediateRenderObject.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.ImmediateRenderObject.prototype.constructor = THREE.ImmediateRenderObject;\r\n\r\n// File:src/extras/objects/MorphBlendMesh.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.MorphBlendMesh = function( geometry, material ) {\r\n\r\n\tTHREE.Mesh.call( this, geometry, material );\r\n\r\n\tthis.animationsMap = {};\r\n\tthis.animationsList = [];\r\n\r\n\t// prepare default animation\r\n\t// (all frames played together in 1 second)\r\n\r\n\tvar numFrames = this.geometry.morphTargets.length;\r\n\r\n\tvar name = \"__default\";\r\n\r\n\tvar startFrame = 0;\r\n\tvar endFrame = numFrames - 1;\r\n\r\n\tvar fps = numFrames / 1;\r\n\r\n\tthis.createAnimation( name, startFrame, endFrame, fps );\r\n\tthis.setAnimationWeight( name, 1 );\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype = Object.create( THREE.Mesh.prototype );\r\nTHREE.MorphBlendMesh.prototype.constructor = THREE.MorphBlendMesh;\r\n\r\nTHREE.MorphBlendMesh.prototype.createAnimation = function ( name, start, end, fps ) {\r\n\r\n\tvar animation = {\r\n\r\n\t\tstart: start,\r\n\t\tend: end,\r\n\r\n\t\tlength: end - start + 1,\r\n\r\n\t\tfps: fps,\r\n\t\tduration: ( end - start ) / fps,\r\n\r\n\t\tlastFrame: 0,\r\n\t\tcurrentFrame: 0,\r\n\r\n\t\tactive: false,\r\n\r\n\t\ttime: 0,\r\n\t\tdirection: 1,\r\n\t\tweight: 1,\r\n\r\n\t\tdirectionBackwards: false,\r\n\t\tmirroredLoop: false\r\n\r\n\t};\r\n\r\n\tthis.animationsMap[ name ] = animation;\r\n\tthis.animationsList.push( animation );\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.autoCreateAnimations = function ( fps ) {\r\n\r\n\tvar pattern = /([a-z]+)_?(\\d+)/i;\r\n\r\n\tvar firstAnimation, frameRanges = {};\r\n\r\n\tvar geometry = this.geometry;\r\n\r\n\tfor ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {\r\n\r\n\t\tvar morph = geometry.morphTargets[ i ];\r\n\t\tvar chunks = morph.name.match( pattern );\r\n\r\n\t\tif ( chunks && chunks.length > 1 ) {\r\n\r\n\t\t\tvar name = chunks[ 1 ];\r\n\r\n\t\t\tif ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: - Infinity };\r\n\r\n\t\t\tvar range = frameRanges[ name ];\r\n\r\n\t\t\tif ( i < range.start ) range.start = i;\r\n\t\t\tif ( i > range.end ) range.end = i;\r\n\r\n\t\t\tif ( ! firstAnimation ) firstAnimation = name;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfor ( var name in frameRanges ) {\r\n\r\n\t\tvar range = frameRanges[ name ];\r\n\t\tthis.createAnimation( name, range.start, range.end, fps );\r\n\r\n\t}\r\n\r\n\tthis.firstAnimation = firstAnimation;\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function ( name ) {\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tanimation.direction = 1;\r\n\t\tanimation.directionBackwards = false;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function ( name ) {\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tanimation.direction = - 1;\r\n\t\tanimation.directionBackwards = true;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.setAnimationFPS = function ( name, fps ) {\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tanimation.fps = fps;\r\n\t\tanimation.duration = ( animation.end - animation.start ) / animation.fps;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.setAnimationDuration = function ( name, duration ) {\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tanimation.duration = duration;\r\n\t\tanimation.fps = ( animation.end - animation.start ) / animation.duration;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.setAnimationWeight = function ( name, weight ) {\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tanimation.weight = weight;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.setAnimationTime = function ( name, time ) {\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tanimation.time = time;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.getAnimationTime = function ( name ) {\r\n\r\n\tvar time = 0;\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\ttime = animation.time;\r\n\r\n\t}\r\n\r\n\treturn time;\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.getAnimationDuration = function ( name ) {\r\n\r\n\tvar duration = - 1;\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tduration = animation.duration;\r\n\r\n\t}\r\n\r\n\treturn duration;\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.playAnimation = function ( name ) {\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tanimation.time = 0;\r\n\t\tanimation.active = true;\r\n\r\n\t} else {\r\n\r\n\t\tconsole.warn( \"THREE.MorphBlendMesh: animation[\" + name + \"] undefined in .playAnimation()\" );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.stopAnimation = function ( name ) {\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tanimation.active = false;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.update = function ( delta ) {\r\n\r\n\tfor ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {\r\n\r\n\t\tvar animation = this.animationsList[ i ];\r\n\r\n\t\tif ( ! animation.active ) continue;\r\n\r\n\t\tvar frameTime = animation.duration / animation.length;\r\n\r\n\t\tanimation.time += animation.direction * delta;\r\n\r\n\t\tif ( animation.mirroredLoop ) {\r\n\r\n\t\t\tif ( animation.time > animation.duration || animation.time < 0 ) {\r\n\r\n\t\t\t\tanimation.direction *= - 1;\r\n\r\n\t\t\t\tif ( animation.time > animation.duration ) {\r\n\r\n\t\t\t\t\tanimation.time = animation.duration;\r\n\t\t\t\t\tanimation.directionBackwards = true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( animation.time < 0 ) {\r\n\r\n\t\t\t\t\tanimation.time = 0;\r\n\t\t\t\t\tanimation.directionBackwards = false;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tanimation.time = animation.time % animation.duration;\r\n\r\n\t\t\tif ( animation.time < 0 ) animation.time += animation.duration;\r\n\r\n\t\t}\r\n\r\n\t\tvar keyframe = animation.start + THREE.Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );\r\n\t\tvar weight = animation.weight;\r\n\r\n\t\tif ( keyframe !== animation.currentFrame ) {\r\n\r\n\t\t\tthis.morphTargetInfluences[ animation.lastFrame ] = 0;\r\n\t\t\tthis.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;\r\n\r\n\t\t\tthis.morphTargetInfluences[ keyframe ] = 0;\r\n\r\n\t\t\tanimation.lastFrame = animation.currentFrame;\r\n\t\t\tanimation.currentFrame = keyframe;\r\n\r\n\t\t}\r\n\r\n\t\tvar mix = ( animation.time % frameTime ) / frameTime;\r\n\r\n\t\tif ( animation.directionBackwards ) mix = 1 - mix;\r\n\r\n\t\tif ( animation.currentFrame !== animation.lastFrame ) {\r\n\r\n\t\t\tthis.morphTargetInfluences[ animation.currentFrame ] = mix * weight;\r\n\t\t\tthis.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.morphTargetInfluences[ animation.currentFrame ] = weight;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\n\r\n// Export the THREE object for **Node.js**, with\r\n// backwards-compatibility for the old `require()` API. If we're in\r\n// the browser, add `_` as a global object via a string identifier,\r\n// for Closure Compiler \"advanced\" mode.\r\nif (typeof exports !== 'undefined') {\r\n  if (typeof module !== 'undefined' && module.exports) {\r\n    exports = module.exports = THREE;\r\n  }\r\n  exports.THREE = THREE;\r\n} else {\r\n  this['THREE'] = THREE;\r\n}\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/three/three.js\n ** module id = 61\n ** module chunks = 0\n **/","import THREE from 'three';\nconst bump = require('../textures/crystal.jpg');\nimport refractionF from '../shaders/refractionF';\n\nclass Particle extends THREE.Mesh {\n\n    constructor() {\n        const geo = new THREE.CylinderBufferGeometry(0, 30, 500, 30, 30, true);\n        geo.translate(0, 250, 0);\n\n        const renderTarget = new THREE.WebGLRenderTarget(512, 512, { depthBuffer: false, stencilBuffer: false });\n\n        const mat = new THREE.ShaderMaterial({\n            uniforms: {\n                tex_bump: { value: new THREE.TextureLoader().load(bump) },\n                tex_scene: { value: renderTarget },\n                vScale: { value: new THREE.Vector2(0.03, 0.03) },\n                resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },\n                emissive: { value: new THREE.Color(0xFF4400) },\n                emissiveMap: { value: new THREE.TextureLoader().load(bump) },\n                refraction: { value: 0.45 },\n                opacity: { value: 0.9 },\n                offset: { value: new THREE.Vector2(0, 0) },\n                fresnelMix: { value: 1 },\n                fresnelBias: { value: 0.2 },\n                fresnelPow: { value: 5 },\n            },\n            vertexShader: [\n                'varying vec2 vUv;',\n                'varying vec3 vEye;',\n                'varying vec3 vWorldNormal;',\n                'void main() {',\n                'vUv = uv;',\n                'vec4 p = vec4( position, 1. );',\n                'vEye = normalize( vec3( modelViewMatrix * p ));',\n                'vWorldNormal = normalize( normalMatrix * normal );',\n                'gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n                '}',\n            ].join('\\n'),\n            fragmentShader: refractionF,\n        });\n        mat.transparent = true;\n\n        super(geo, mat);\n\n        this.renderTarget = renderTarget;\n        this.material = mat;\n    }\n}\n\nexport default Particle;\n\n\n\n/** WEBPACK FOOTER **\n ** ./web/js/particle.js\n **/","module.exports = { \"default\": require(\"core-js/library/fn/object/get-prototype-of\"), __esModule: true };\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/core-js/object/get-prototype-of.js\n ** module id = 63\n ** module chunks = 0\n **/","require('../../modules/es6.object.get-prototype-of');\nmodule.exports = require('../../modules/_core').Object.getPrototypeOf;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/fn/object/get-prototype-of.js\n ** module id = 64\n ** module chunks = 0\n **/","// 19.1.2.9 Object.getPrototypeOf(O)\nvar toObject        = require('./_to-object')\n  , $getPrototypeOf = require('./_object-gpo');\n\nrequire('./_object-sap')('getPrototypeOf', function(){\n  return function getPrototypeOf(it){\n    return $getPrototypeOf(toObject(it));\n  };\n});\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/es6.object.get-prototype-of.js\n ** module id = 65\n ** module chunks = 0\n **/","// most Object methods by ES6 should accept primitives\nvar $export = require('./_export')\n  , core    = require('./_core')\n  , fails   = require('./_fails');\nmodule.exports = function(KEY, exec){\n  var fn  = (core.Object || {})[KEY] || Object[KEY]\n    , exp = {};\n  exp[KEY] = exec(fn);\n  $export($export.S + $export.F * fails(function(){ fn(1); }), 'Object', exp);\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_object-sap.js\n ** module id = 66\n ** module chunks = 0\n **/","\"use strict\";\n\nexports.__esModule = true;\n\nvar _typeof2 = require(\"babel-runtime/helpers/typeof\");\n\nvar _typeof3 = _interopRequireDefault(_typeof2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && ((typeof call === \"undefined\" ? \"undefined\" : (0, _typeof3.default)(call)) === \"object\" || typeof call === \"function\") ? call : self;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/helpers/possibleConstructorReturn.js\n ** module id = 67\n ** module chunks = 0\n **/","\"use strict\";\n\nexports.__esModule = true;\n\nvar _iterator = require(\"babel-runtime/core-js/symbol/iterator\");\n\nvar _iterator2 = _interopRequireDefault(_iterator);\n\nvar _symbol = require(\"babel-runtime/core-js/symbol\");\n\nvar _symbol2 = _interopRequireDefault(_symbol);\n\nvar _typeof = typeof _symbol2.default === \"function\" && typeof _iterator2.default === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === \"function\" && obj.constructor === _symbol2.default ? \"symbol\" : typeof obj; };\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = typeof _symbol2.default === \"function\" && _typeof(_iterator2.default) === \"symbol\" ? function (obj) {\n  return typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj);\n} : function (obj) {\n  return obj && typeof _symbol2.default === \"function\" && obj.constructor === _symbol2.default ? \"symbol\" : typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj);\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/helpers/typeof.js\n ** module id = 68\n ** module chunks = 0\n **/","module.exports = { \"default\": require(\"core-js/library/fn/symbol/iterator\"), __esModule: true };\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/core-js/symbol/iterator.js\n ** module id = 69\n ** module chunks = 0\n **/","require('../../modules/es6.string.iterator');\nrequire('../../modules/web.dom.iterable');\nmodule.exports = require('../../modules/_wks-ext').f('iterator');\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/fn/symbol/iterator.js\n ** module id = 70\n ** module chunks = 0\n **/","exports.f = require('./_wks');\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_wks-ext.js\n ** module id = 71\n ** module chunks = 0\n **/","module.exports = { \"default\": require(\"core-js/library/fn/symbol\"), __esModule: true };\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/core-js/symbol.js\n ** module id = 72\n ** module chunks = 0\n **/","require('../../modules/es6.symbol');\nrequire('../../modules/es6.object.to-string');\nrequire('../../modules/es7.symbol.async-iterator');\nrequire('../../modules/es7.symbol.observable');\nmodule.exports = require('../../modules/_core').Symbol;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/fn/symbol/index.js\n ** module id = 73\n ** module chunks = 0\n **/","'use strict';\n// ECMAScript 6 symbols shim\nvar global         = require('./_global')\n  , has            = require('./_has')\n  , DESCRIPTORS    = require('./_descriptors')\n  , $export        = require('./_export')\n  , redefine       = require('./_redefine')\n  , META           = require('./_meta').KEY\n  , $fails         = require('./_fails')\n  , shared         = require('./_shared')\n  , setToStringTag = require('./_set-to-string-tag')\n  , uid            = require('./_uid')\n  , wks            = require('./_wks')\n  , wksExt         = require('./_wks-ext')\n  , wksDefine      = require('./_wks-define')\n  , keyOf          = require('./_keyof')\n  , enumKeys       = require('./_enum-keys')\n  , isArray        = require('./_is-array')\n  , anObject       = require('./_an-object')\n  , toIObject      = require('./_to-iobject')\n  , toPrimitive    = require('./_to-primitive')\n  , createDesc     = require('./_property-desc')\n  , _create        = require('./_object-create')\n  , gOPNExt        = require('./_object-gopn-ext')\n  , $GOPD          = require('./_object-gopd')\n  , $DP            = require('./_object-dp')\n  , $keys          = require('./_object-keys')\n  , gOPD           = $GOPD.f\n  , dP             = $DP.f\n  , gOPN           = gOPNExt.f\n  , $Symbol        = global.Symbol\n  , $JSON          = global.JSON\n  , _stringify     = $JSON && $JSON.stringify\n  , PROTOTYPE      = 'prototype'\n  , HIDDEN         = wks('_hidden')\n  , TO_PRIMITIVE   = wks('toPrimitive')\n  , isEnum         = {}.propertyIsEnumerable\n  , SymbolRegistry = shared('symbol-registry')\n  , AllSymbols     = shared('symbols')\n  , OPSymbols      = shared('op-symbols')\n  , ObjectProto    = Object[PROTOTYPE]\n  , USE_NATIVE     = typeof $Symbol == 'function'\n  , QObject        = global.QObject;\n// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173\nvar setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;\n\n// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687\nvar setSymbolDesc = DESCRIPTORS && $fails(function(){\n  return _create(dP({}, 'a', {\n    get: function(){ return dP(this, 'a', {value: 7}).a; }\n  })).a != 7;\n}) ? function(it, key, D){\n  var protoDesc = gOPD(ObjectProto, key);\n  if(protoDesc)delete ObjectProto[key];\n  dP(it, key, D);\n  if(protoDesc && it !== ObjectProto)dP(ObjectProto, key, protoDesc);\n} : dP;\n\nvar wrap = function(tag){\n  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);\n  sym._k = tag;\n  return sym;\n};\n\nvar isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function(it){\n  return typeof it == 'symbol';\n} : function(it){\n  return it instanceof $Symbol;\n};\n\nvar $defineProperty = function defineProperty(it, key, D){\n  if(it === ObjectProto)$defineProperty(OPSymbols, key, D);\n  anObject(it);\n  key = toPrimitive(key, true);\n  anObject(D);\n  if(has(AllSymbols, key)){\n    if(!D.enumerable){\n      if(!has(it, HIDDEN))dP(it, HIDDEN, createDesc(1, {}));\n      it[HIDDEN][key] = true;\n    } else {\n      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;\n      D = _create(D, {enumerable: createDesc(0, false)});\n    } return setSymbolDesc(it, key, D);\n  } return dP(it, key, D);\n};\nvar $defineProperties = function defineProperties(it, P){\n  anObject(it);\n  var keys = enumKeys(P = toIObject(P))\n    , i    = 0\n    , l = keys.length\n    , key;\n  while(l > i)$defineProperty(it, key = keys[i++], P[key]);\n  return it;\n};\nvar $create = function create(it, P){\n  return P === undefined ? _create(it) : $defineProperties(_create(it), P);\n};\nvar $propertyIsEnumerable = function propertyIsEnumerable(key){\n  var E = isEnum.call(this, key = toPrimitive(key, true));\n  if(this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return false;\n  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;\n};\nvar $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){\n  it  = toIObject(it);\n  key = toPrimitive(key, true);\n  if(it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return;\n  var D = gOPD(it, key);\n  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;\n  return D;\n};\nvar $getOwnPropertyNames = function getOwnPropertyNames(it){\n  var names  = gOPN(toIObject(it))\n    , result = []\n    , i      = 0\n    , key;\n  while(names.length > i){\n    if(!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META)result.push(key);\n  } return result;\n};\nvar $getOwnPropertySymbols = function getOwnPropertySymbols(it){\n  var IS_OP  = it === ObjectProto\n    , names  = gOPN(IS_OP ? OPSymbols : toIObject(it))\n    , result = []\n    , i      = 0\n    , key;\n  while(names.length > i){\n    if(has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true))result.push(AllSymbols[key]);\n  } return result;\n};\n\n// 19.4.1.1 Symbol([description])\nif(!USE_NATIVE){\n  $Symbol = function Symbol(){\n    if(this instanceof $Symbol)throw TypeError('Symbol is not a constructor!');\n    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);\n    var $set = function(value){\n      if(this === ObjectProto)$set.call(OPSymbols, value);\n      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;\n      setSymbolDesc(this, tag, createDesc(1, value));\n    };\n    if(DESCRIPTORS && setter)setSymbolDesc(ObjectProto, tag, {configurable: true, set: $set});\n    return wrap(tag);\n  };\n  redefine($Symbol[PROTOTYPE], 'toString', function toString(){\n    return this._k;\n  });\n\n  $GOPD.f = $getOwnPropertyDescriptor;\n  $DP.f   = $defineProperty;\n  require('./_object-gopn').f = gOPNExt.f = $getOwnPropertyNames;\n  require('./_object-pie').f  = $propertyIsEnumerable;\n  require('./_object-gops').f = $getOwnPropertySymbols;\n\n  if(DESCRIPTORS && !require('./_library')){\n    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);\n  }\n\n  wksExt.f = function(name){\n    return wrap(wks(name));\n  }\n}\n\n$export($export.G + $export.W + $export.F * !USE_NATIVE, {Symbol: $Symbol});\n\nfor(var symbols = (\n  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14\n  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'\n).split(','), i = 0; symbols.length > i; )wks(symbols[i++]);\n\nfor(var symbols = $keys(wks.store), i = 0; symbols.length > i; )wksDefine(symbols[i++]);\n\n$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {\n  // 19.4.2.1 Symbol.for(key)\n  'for': function(key){\n    return has(SymbolRegistry, key += '')\n      ? SymbolRegistry[key]\n      : SymbolRegistry[key] = $Symbol(key);\n  },\n  // 19.4.2.5 Symbol.keyFor(sym)\n  keyFor: function keyFor(key){\n    if(isSymbol(key))return keyOf(SymbolRegistry, key);\n    throw TypeError(key + ' is not a symbol!');\n  },\n  useSetter: function(){ setter = true; },\n  useSimple: function(){ setter = false; }\n});\n\n$export($export.S + $export.F * !USE_NATIVE, 'Object', {\n  // 19.1.2.2 Object.create(O [, Properties])\n  create: $create,\n  // 19.1.2.4 Object.defineProperty(O, P, Attributes)\n  defineProperty: $defineProperty,\n  // 19.1.2.3 Object.defineProperties(O, Properties)\n  defineProperties: $defineProperties,\n  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)\n  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,\n  // 19.1.2.7 Object.getOwnPropertyNames(O)\n  getOwnPropertyNames: $getOwnPropertyNames,\n  // 19.1.2.8 Object.getOwnPropertySymbols(O)\n  getOwnPropertySymbols: $getOwnPropertySymbols\n});\n\n// 24.3.2 JSON.stringify(value [, replacer [, space]])\n$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function(){\n  var S = $Symbol();\n  // MS Edge converts symbol values to JSON as {}\n  // WebKit converts symbol values to JSON as null\n  // V8 throws on boxed symbols\n  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';\n})), 'JSON', {\n  stringify: function stringify(it){\n    if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined\n    var args = [it]\n      , i    = 1\n      , replacer, $replacer;\n    while(arguments.length > i)args.push(arguments[i++]);\n    replacer = args[1];\n    if(typeof replacer == 'function')$replacer = replacer;\n    if($replacer || !isArray(replacer))replacer = function(key, value){\n      if($replacer)value = $replacer.call(this, key, value);\n      if(!isSymbol(value))return value;\n    };\n    args[1] = replacer;\n    return _stringify.apply($JSON, args);\n  }\n});\n\n// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)\n$Symbol[PROTOTYPE][TO_PRIMITIVE] || require('./_hide')($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);\n// 19.4.3.5 Symbol.prototype[@@toStringTag]\nsetToStringTag($Symbol, 'Symbol');\n// 20.2.1.9 Math[@@toStringTag]\nsetToStringTag(Math, 'Math', true);\n// 24.3.3 JSON[@@toStringTag]\nsetToStringTag(global.JSON, 'JSON', true);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/es6.symbol.js\n ** module id = 74\n ** module chunks = 0\n **/","var META     = require('./_uid')('meta')\n  , isObject = require('./_is-object')\n  , has      = require('./_has')\n  , setDesc  = require('./_object-dp').f\n  , id       = 0;\nvar isExtensible = Object.isExtensible || function(){\n  return true;\n};\nvar FREEZE = !require('./_fails')(function(){\n  return isExtensible(Object.preventExtensions({}));\n});\nvar setMeta = function(it){\n  setDesc(it, META, {value: {\n    i: 'O' + ++id, // object ID\n    w: {}          // weak collections IDs\n  }});\n};\nvar fastKey = function(it, create){\n  // return primitive with prefix\n  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;\n  if(!has(it, META)){\n    // can't set metadata to uncaught frozen object\n    if(!isExtensible(it))return 'F';\n    // not necessary to add metadata\n    if(!create)return 'E';\n    // add missing metadata\n    setMeta(it);\n  // return object ID\n  } return it[META].i;\n};\nvar getWeak = function(it, create){\n  if(!has(it, META)){\n    // can't set metadata to uncaught frozen object\n    if(!isExtensible(it))return true;\n    // not necessary to add metadata\n    if(!create)return false;\n    // add missing metadata\n    setMeta(it);\n  // return hash weak collections IDs\n  } return it[META].w;\n};\n// add metadata on freeze-family methods calling\nvar onFreeze = function(it){\n  if(FREEZE && meta.NEED && isExtensible(it) && !has(it, META))setMeta(it);\n  return it;\n};\nvar meta = module.exports = {\n  KEY:      META,\n  NEED:     false,\n  fastKey:  fastKey,\n  getWeak:  getWeak,\n  onFreeze: onFreeze\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_meta.js\n ** module id = 75\n ** module chunks = 0\n **/","var global         = require('./_global')\r\n  , core           = require('./_core')\r\n  , LIBRARY        = require('./_library')\r\n  , wksExt         = require('./_wks-ext')\r\n  , defineProperty = require('./_object-dp').f;\r\nmodule.exports = function(name){\r\n  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});\r\n  if(name.charAt(0) != '_' && !(name in $Symbol))defineProperty($Symbol, name, {value: wksExt.f(name)});\r\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_wks-define.js\n ** module id = 76\n ** module chunks = 0\n **/","var getKeys   = require('./_object-keys')\n  , toIObject = require('./_to-iobject');\nmodule.exports = function(object, el){\n  var O      = toIObject(object)\n    , keys   = getKeys(O)\n    , length = keys.length\n    , index  = 0\n    , key;\n  while(length > index)if(O[key = keys[index++]] === el)return key;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_keyof.js\n ** module id = 77\n ** module chunks = 0\n **/","// all enumerable object keys, includes symbols\nvar getKeys = require('./_object-keys')\n  , gOPS    = require('./_object-gops')\n  , pIE     = require('./_object-pie');\nmodule.exports = function(it){\n  var result     = getKeys(it)\n    , getSymbols = gOPS.f;\n  if(getSymbols){\n    var symbols = getSymbols(it)\n      , isEnum  = pIE.f\n      , i       = 0\n      , key;\n    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))result.push(key);\n  } return result;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_enum-keys.js\n ** module id = 78\n ** module chunks = 0\n **/","exports.f = Object.getOwnPropertySymbols;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_object-gops.js\n ** module id = 79\n ** module chunks = 0\n **/","exports.f = {}.propertyIsEnumerable;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_object-pie.js\n ** module id = 80\n ** module chunks = 0\n **/","// 7.2.2 IsArray(argument)\nvar cof = require('./_cof');\nmodule.exports = Array.isArray || function isArray(arg){\n  return cof(arg) == 'Array';\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_is-array.js\n ** module id = 81\n ** module chunks = 0\n **/","// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window\nvar toIObject = require('./_to-iobject')\n  , gOPN      = require('./_object-gopn').f\n  , toString  = {}.toString;\n\nvar windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames\n  ? Object.getOwnPropertyNames(window) : [];\n\nvar getWindowNames = function(it){\n  try {\n    return gOPN(it);\n  } catch(e){\n    return windowNames.slice();\n  }\n};\n\nmodule.exports.f = function getOwnPropertyNames(it){\n  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_object-gopn-ext.js\n ** module id = 82\n ** module chunks = 0\n **/","// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)\r\nvar $keys      = require('./_object-keys-internal')\r\n  , hiddenKeys = require('./_enum-bug-keys').concat('length', 'prototype');\r\n\r\nexports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O){\r\n  return $keys(O, hiddenKeys);\r\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_object-gopn.js\n ** module id = 83\n ** module chunks = 0\n **/","var pIE            = require('./_object-pie')\r\n  , createDesc     = require('./_property-desc')\r\n  , toIObject      = require('./_to-iobject')\r\n  , toPrimitive    = require('./_to-primitive')\r\n  , has            = require('./_has')\r\n  , IE8_DOM_DEFINE = require('./_ie8-dom-define')\r\n  , gOPD           = Object.getOwnPropertyDescriptor;\r\n\r\nexports.f = require('./_descriptors') ? gOPD : function getOwnPropertyDescriptor(O, P){\r\n  O = toIObject(O);\r\n  P = toPrimitive(P, true);\r\n  if(IE8_DOM_DEFINE)try {\r\n    return gOPD(O, P);\r\n  } catch(e){ /* empty */ }\r\n  if(has(O, P))return createDesc(!pIE.f.call(O, P), O[P]);\r\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_object-gopd.js\n ** module id = 84\n ** module chunks = 0\n **/","require('./_wks-define')('asyncIterator');\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/es7.symbol.async-iterator.js\n ** module id = 86\n ** module chunks = 0\n **/","require('./_wks-define')('observable');\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/es7.symbol.observable.js\n ** module id = 87\n ** module chunks = 0\n **/","\"use strict\";\n\nexports.__esModule = true;\n\nvar _setPrototypeOf = require(\"babel-runtime/core-js/object/set-prototype-of\");\n\nvar _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);\n\nvar _create = require(\"babel-runtime/core-js/object/create\");\n\nvar _create2 = _interopRequireDefault(_create);\n\nvar _typeof2 = require(\"babel-runtime/helpers/typeof\");\n\nvar _typeof3 = _interopRequireDefault(_typeof2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + (typeof superClass === \"undefined\" ? \"undefined\" : (0, _typeof3.default)(superClass)));\n  }\n\n  subClass.prototype = (0, _create2.default)(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf2.default ? (0, _setPrototypeOf2.default)(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/helpers/inherits.js\n ** module id = 88\n ** module chunks = 0\n **/","module.exports = { \"default\": require(\"core-js/library/fn/object/set-prototype-of\"), __esModule: true };\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/core-js/object/set-prototype-of.js\n ** module id = 89\n ** module chunks = 0\n **/","require('../../modules/es6.object.set-prototype-of');\nmodule.exports = require('../../modules/_core').Object.setPrototypeOf;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/fn/object/set-prototype-of.js\n ** module id = 90\n ** module chunks = 0\n **/","// 19.1.3.19 Object.setPrototypeOf(O, proto)\nvar $export = require('./_export');\n$export($export.S, 'Object', {setPrototypeOf: require('./_set-proto').set});\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/es6.object.set-prototype-of.js\n ** module id = 91\n ** module chunks = 0\n **/","// Works with __proto__ only. Old v8 can't work with null proto objects.\n/* eslint-disable no-proto */\nvar isObject = require('./_is-object')\n  , anObject = require('./_an-object');\nvar check = function(O, proto){\n  anObject(O);\n  if(!isObject(proto) && proto !== null)throw TypeError(proto + \": can't set as prototype!\");\n};\nmodule.exports = {\n  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line\n    function(test, buggy, set){\n      try {\n        set = require('./_ctx')(Function.call, require('./_object-gopd').f(Object.prototype, '__proto__').set, 2);\n        set(test, []);\n        buggy = !(test instanceof Array);\n      } catch(e){ buggy = true; }\n      return function setPrototypeOf(O, proto){\n        check(O, proto);\n        if(buggy)O.__proto__ = proto;\n        else set(O, proto);\n        return O;\n      };\n    }({}, false) : undefined),\n  check: check\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_set-proto.js\n ** module id = 92\n ** module chunks = 0\n **/","module.exports = { \"default\": require(\"core-js/library/fn/object/create\"), __esModule: true };\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/core-js/object/create.js\n ** module id = 93\n ** module chunks = 0\n **/","require('../../modules/es6.object.create');\nvar $Object = require('../../modules/_core').Object;\nmodule.exports = function create(P, D){\n  return $Object.create(P, D);\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/fn/object/create.js\n ** module id = 94\n ** module chunks = 0\n **/","var $export = require('./_export')\r\n// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\r\n$export($export.S, 'Object', {create: require('./_object-create')});\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/es6.object.create.js\n ** module id = 95\n ** module chunks = 0\n **/","module.exports = __webpack_public_path__ + \"textures/crystal-b40baa88da921fc8383f334d76573135.jpg\";\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./web/textures/crystal.jpg\n ** module id = 97\n ** module chunks = 0\n **/","// stats.js - http://github.com/mrdoob/stats.js\r\nvar Stats=function(){function h(a){c.appendChild(a.dom);return a}function k(a){for(var d=0;d<c.children.length;d++)c.children[d].style.display=d===a?\"block\":\"none\";l=a}var l=0,c=document.createElement(\"div\");c.style.cssText=\"position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000\";c.addEventListener(\"click\",function(a){a.preventDefault();k(++l%c.children.length)},!1);var g=(performance||Date).now(),e=g,a=0,r=h(new Stats.Panel(\"FPS\",\"#0ff\",\"#002\")),f=h(new Stats.Panel(\"MS\",\"#0f0\",\"#020\"));\r\nif(self.performance&&self.performance.memory)var t=h(new Stats.Panel(\"MB\",\"#f08\",\"#201\"));k(0);return{REVISION:16,dom:c,addPanel:h,showPanel:k,begin:function(){g=(performance||Date).now()},end:function(){a++;var c=(performance||Date).now();f.update(c-g,200);if(c>e+1E3&&(r.update(1E3*a/(c-e),100),e=c,a=0,t)){var d=performance.memory;t.update(d.usedJSHeapSize/1048576,d.jsHeapSizeLimit/1048576)}return c},update:function(){g=this.end()},domElement:c,setMode:k}};\r\nStats.Panel=function(h,k,l){var c=Infinity,g=0,e=Math.round,a=e(window.devicePixelRatio||1),r=80*a,f=48*a,t=3*a,u=2*a,d=3*a,m=15*a,n=74*a,p=30*a,q=document.createElement(\"canvas\");q.width=r;q.height=f;q.style.cssText=\"width:80px;height:48px\";var b=q.getContext(\"2d\");b.font=\"bold \"+9*a+\"px Helvetica,Arial,sans-serif\";b.textBaseline=\"top\";b.fillStyle=l;b.fillRect(0,0,r,f);b.fillStyle=k;b.fillText(h,t,u);b.fillRect(d,m,n,p);b.fillStyle=l;b.globalAlpha=.9;b.fillRect(d,m,n,p);return{dom:q,update:function(f,\r\nv){c=Math.min(c,f);g=Math.max(g,f);b.fillStyle=l;b.globalAlpha=1;b.fillRect(0,0,r,m);b.fillStyle=k;b.fillText(e(f)+\" \"+h+\" (\"+e(c)+\"-\"+e(g)+\")\",t,u);b.drawImage(q,d+a,m,n-a,p,d,m,n-a,p);b.fillRect(d+n-a,m,a,p);b.fillStyle=l;b.globalAlpha=.9;b.fillRect(d+n-a,m,a,e((1-f/v)*p))}}};\"object\"===typeof module&&(module.exports=Stats);\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/three/examples/js/libs/stats.min.js\n ** module id = 98\n ** module chunks = 0\n **/","module.exports = __webpack_public_path__ + \"textures/checkerboard-8aacea3931a7790b21a29179bfaad52c.png\";\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./web/textures/checkerboard.png\n ** module id = 99\n ** module chunks = 0\n **/","/**\r\n * @author qiao / https://github.com/qiao\r\n * @author mrdoob / http://mrdoob.com\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n * @author erich666 / http://erichaines.com\r\n */\r\n\r\n// This set of controls performs orbiting, dollying (zooming), and panning.\r\n// Unlike TrackballControls, it maintains the \"up\" direction object.up (+Y by default).\r\n//\r\n//    Orbit - left mouse / touch: one finger move\r\n//    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish\r\n//    Pan - right mouse, or arrow keys / touch: three finter swipe\r\n\r\nTHREE.OrbitControls = function ( object, domElement ) {\r\n\r\n\tthis.object = object;\r\n\r\n\tthis.domElement = ( domElement !== undefined ) ? domElement : document;\r\n\r\n\t// Set to false to disable this control\r\n\tthis.enabled = true;\r\n\r\n\t// \"target\" sets the location of focus, where the object orbits around\r\n\tthis.target = new THREE.Vector3();\r\n\r\n\t// How far you can dolly in and out ( PerspectiveCamera only )\r\n\tthis.minDistance = 0;\r\n\tthis.maxDistance = Infinity;\r\n\r\n\t// How far you can zoom in and out ( OrthographicCamera only )\r\n\tthis.minZoom = 0;\r\n\tthis.maxZoom = Infinity;\r\n\r\n\t// How far you can orbit vertically, upper and lower limits.\r\n\t// Range is 0 to Math.PI radians.\r\n\tthis.minPolarAngle = 0; // radians\r\n\tthis.maxPolarAngle = Math.PI; // radians\r\n\r\n\t// How far you can orbit horizontally, upper and lower limits.\r\n\t// If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].\r\n\tthis.minAzimuthAngle = - Infinity; // radians\r\n\tthis.maxAzimuthAngle = Infinity; // radians\r\n\r\n\t// Set to true to enable damping (inertia)\r\n\t// If damping is enabled, you must call controls.update() in your animation loop\r\n\tthis.enableDamping = false;\r\n\tthis.dampingFactor = 0.25;\r\n\r\n\t// This option actually enables dollying in and out; left as \"zoom\" for backwards compatibility.\r\n\t// Set to false to disable zooming\r\n\tthis.enableZoom = true;\r\n\tthis.zoomSpeed = 1.0;\r\n\r\n\t// Set to false to disable rotating\r\n\tthis.enableRotate = true;\r\n\tthis.rotateSpeed = 1.0;\r\n\r\n\t// Set to false to disable panning\r\n\tthis.enablePan = true;\r\n\tthis.keyPanSpeed = 7.0;\t// pixels moved per arrow key push\r\n\r\n\t// Set to true to automatically rotate around the target\r\n\t// If auto-rotate is enabled, you must call controls.update() in your animation loop\r\n\tthis.autoRotate = false;\r\n\tthis.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60\r\n\r\n\t// Set to false to disable use of the keys\r\n\tthis.enableKeys = true;\r\n\r\n\t// The four arrow keys\r\n\tthis.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };\r\n\r\n\t// Mouse buttons\r\n\tthis.mouseButtons = { ORBIT: THREE.MOUSE.LEFT, ZOOM: THREE.MOUSE.MIDDLE, PAN: THREE.MOUSE.RIGHT };\r\n\r\n\t// for reset\r\n\tthis.target0 = this.target.clone();\r\n\tthis.position0 = this.object.position.clone();\r\n\tthis.zoom0 = this.object.zoom;\r\n\r\n\t//\r\n\t// public methods\r\n\t//\r\n\r\n\tthis.getPolarAngle = function () {\r\n\r\n\t\treturn phi;\r\n\r\n\t};\r\n\r\n\tthis.getAzimuthalAngle = function () {\r\n\r\n\t\treturn theta;\r\n\r\n\t};\r\n\r\n\tthis.reset = function () {\r\n\r\n\t\tscope.target.copy( scope.target0 );\r\n\t\tscope.object.position.copy( scope.position0 );\r\n\t\tscope.object.zoom = scope.zoom0;\r\n\r\n\t\tscope.object.updateProjectionMatrix();\r\n\t\tscope.dispatchEvent( changeEvent );\r\n\r\n\t\tscope.update();\r\n\r\n\t\tstate = STATE.NONE;\r\n\r\n\t};\r\n\r\n\t// this method is exposed, but perhaps it would be better if we can make it private...\r\n\tthis.update = function() {\r\n\r\n\t\tvar offset = new THREE.Vector3();\r\n\r\n\t\t// so camera.up is the orbit axis\r\n\t\tvar quat = new THREE.Quaternion().setFromUnitVectors( object.up, new THREE.Vector3( 0, 1, 0 ) );\r\n\t\tvar quatInverse = quat.clone().inverse();\r\n\r\n\t\tvar lastPosition = new THREE.Vector3();\r\n\t\tvar lastQuaternion = new THREE.Quaternion();\r\n\r\n\t\treturn function () {\r\n\r\n\t\t\tvar position = scope.object.position;\r\n\r\n\t\t\toffset.copy( position ).sub( scope.target );\r\n\r\n\t\t\t// rotate offset to \"y-axis-is-up\" space\r\n\t\t\toffset.applyQuaternion( quat );\r\n\r\n\t\t\t// angle from z-axis around y-axis\r\n\t\t\tspherical.setFromVector3( offset );\r\n\r\n\t\t\tif ( scope.autoRotate && state === STATE.NONE ) {\r\n\r\n\t\t\t\trotateLeft( getAutoRotationAngle() );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tspherical.theta += sphericalDelta.theta;\r\n\t\t\tspherical.phi += sphericalDelta.phi;\r\n\r\n\t\t\t// restrict theta to be between desired limits\r\n\t\t\tspherical.theta = Math.max( scope.minAzimuthAngle, Math.min( scope.maxAzimuthAngle, spherical.theta ) );\r\n\r\n\t\t\t// restrict phi to be between desired limits\r\n\t\t\tspherical.phi = Math.max( scope.minPolarAngle, Math.min( scope.maxPolarAngle, spherical.phi ) );\r\n\r\n\t\t\tspherical.makeSafe();\r\n\r\n\r\n\t\t\tspherical.radius *= scale;\r\n\r\n\t\t\t// restrict radius to be between desired limits\r\n\t\t\tspherical.radius = Math.max( scope.minDistance, Math.min( scope.maxDistance, spherical.radius ) );\r\n\r\n\t\t\t// move target to panned location\r\n\t\t\tscope.target.add( panOffset );\r\n\r\n\t\t\toffset.setFromSpherical( spherical );\r\n\r\n\t\t\t// rotate offset back to \"camera-up-vector-is-up\" space\r\n\t\t\toffset.applyQuaternion( quatInverse );\r\n\r\n\t\t\tposition.copy( scope.target ).add( offset );\r\n\r\n\t\t\tscope.object.lookAt( scope.target );\r\n\r\n\t\t\tif ( scope.enableDamping === true ) {\r\n\r\n\t\t\t\tsphericalDelta.theta *= ( 1 - scope.dampingFactor );\r\n\t\t\t\tsphericalDelta.phi *= ( 1 - scope.dampingFactor );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tsphericalDelta.set( 0, 0, 0 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tscale = 1;\r\n\t\t\tpanOffset.set( 0, 0, 0 );\r\n\r\n\t\t\t// update condition is:\r\n\t\t\t// min(camera displacement, camera rotation in radians)^2 > EPS\r\n\t\t\t// using small-angle approximation cos(x/2) = 1 - x^2 / 8\r\n\r\n\t\t\tif ( zoomChanged ||\r\n\t\t\t\tlastPosition.distanceToSquared( scope.object.position ) > EPS ||\r\n\t\t\t\t8 * ( 1 - lastQuaternion.dot( scope.object.quaternion ) ) > EPS ) {\r\n\r\n\t\t\t\tscope.dispatchEvent( changeEvent );\r\n\r\n\t\t\t\tlastPosition.copy( scope.object.position );\r\n\t\t\t\tlastQuaternion.copy( scope.object.quaternion );\r\n\t\t\t\tzoomChanged = false;\r\n\r\n\t\t\t\treturn true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn false;\r\n\r\n\t\t};\r\n\r\n\t}();\r\n\r\n\tthis.dispose = function() {\r\n\r\n\t\tscope.domElement.removeEventListener( 'contextmenu', onContextMenu, false );\r\n\t\tscope.domElement.removeEventListener( 'mousedown', onMouseDown, false );\r\n\t\tscope.domElement.removeEventListener( 'mousewheel', onMouseWheel, false );\r\n\t\tscope.domElement.removeEventListener( 'MozMousePixelScroll', onMouseWheel, false ); // firefox\r\n\r\n\t\tscope.domElement.removeEventListener( 'touchstart', onTouchStart, false );\r\n\t\tscope.domElement.removeEventListener( 'touchend', onTouchEnd, false );\r\n\t\tscope.domElement.removeEventListener( 'touchmove', onTouchMove, false );\r\n\r\n\t\tdocument.removeEventListener( 'mousemove', onMouseMove, false );\r\n\t\tdocument.removeEventListener( 'mouseup', onMouseUp, false );\r\n\t\tdocument.removeEventListener( 'mouseout', onMouseUp, false );\r\n\r\n\t\twindow.removeEventListener( 'keydown', onKeyDown, false );\r\n\r\n\t\t//scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?\r\n\r\n\t};\r\n\r\n\t//\r\n\t// internals\r\n\t//\r\n\r\n\tvar scope = this;\r\n\r\n\tvar changeEvent = { type: 'change' };\r\n\tvar startEvent = { type: 'start' };\r\n\tvar endEvent = { type: 'end' };\r\n\r\n\tvar STATE = { NONE : - 1, ROTATE : 0, DOLLY : 1, PAN : 2, TOUCH_ROTATE : 3, TOUCH_DOLLY : 4, TOUCH_PAN : 5 };\r\n\r\n\tvar state = STATE.NONE;\r\n\r\n\tvar EPS = 0.000001;\r\n\r\n\t// current position in spherical coordinates\r\n\tvar spherical = new THREE.Spherical();\r\n\tvar sphericalDelta = new THREE.Spherical();\r\n\r\n\tvar scale = 1;\r\n\tvar panOffset = new THREE.Vector3();\r\n\tvar zoomChanged = false;\r\n\r\n\tvar rotateStart = new THREE.Vector2();\r\n\tvar rotateEnd = new THREE.Vector2();\r\n\tvar rotateDelta = new THREE.Vector2();\r\n\r\n\tvar panStart = new THREE.Vector2();\r\n\tvar panEnd = new THREE.Vector2();\r\n\tvar panDelta = new THREE.Vector2();\r\n\r\n\tvar dollyStart = new THREE.Vector2();\r\n\tvar dollyEnd = new THREE.Vector2();\r\n\tvar dollyDelta = new THREE.Vector2();\r\n\r\n\tfunction getAutoRotationAngle() {\r\n\r\n\t\treturn 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\r\n\r\n\t}\r\n\r\n\tfunction getZoomScale() {\r\n\r\n\t\treturn Math.pow( 0.95, scope.zoomSpeed );\r\n\r\n\t}\r\n\r\n\tfunction rotateLeft( angle ) {\r\n\r\n\t\tsphericalDelta.theta -= angle;\r\n\r\n\t}\r\n\r\n\tfunction rotateUp( angle ) {\r\n\r\n\t\tsphericalDelta.phi -= angle;\r\n\r\n\t}\r\n\r\n\tvar panLeft = function() {\r\n\r\n\t\tvar v = new THREE.Vector3();\r\n\r\n\t\treturn function panLeft( distance, objectMatrix ) {\r\n\r\n\t\t\tv.setFromMatrixColumn( objectMatrix, 0 ); // get X column of objectMatrix\r\n\t\t\tv.multiplyScalar( - distance );\r\n\r\n\t\t\tpanOffset.add( v );\r\n\r\n\t\t};\r\n\r\n\t}();\r\n\r\n\tvar panUp = function() {\r\n\r\n\t\tvar v = new THREE.Vector3();\r\n\r\n\t\treturn function panUp( distance, objectMatrix ) {\r\n\r\n\t\t\tv.setFromMatrixColumn( objectMatrix, 1 ); // get Y column of objectMatrix\r\n\t\t\tv.multiplyScalar( distance );\r\n\r\n\t\t\tpanOffset.add( v );\r\n\r\n\t\t};\r\n\r\n\t}();\r\n\r\n\t// deltaX and deltaY are in pixels; right and down are positive\r\n\tvar pan = function() {\r\n\r\n\t\tvar offset = new THREE.Vector3();\r\n\r\n\t\treturn function( deltaX, deltaY ) {\r\n\r\n\t\t\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\r\n\r\n\t\t\tif ( scope.object instanceof THREE.PerspectiveCamera ) {\r\n\r\n\t\t\t\t// perspective\r\n\t\t\t\tvar position = scope.object.position;\r\n\t\t\t\toffset.copy( position ).sub( scope.target );\r\n\t\t\t\tvar targetDistance = offset.length();\r\n\r\n\t\t\t\t// half of the fov is center to top of screen\r\n\t\t\t\ttargetDistance *= Math.tan( ( scope.object.fov / 2 ) * Math.PI / 180.0 );\r\n\r\n\t\t\t\t// we actually don't use screenWidth, since perspective camera is fixed to screen height\r\n\t\t\t\tpanLeft( 2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix );\r\n\t\t\t\tpanUp( 2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix );\r\n\r\n\t\t\t} else if ( scope.object instanceof THREE.OrthographicCamera ) {\r\n\r\n\t\t\t\t// orthographic\r\n\t\t\t\tpanLeft( deltaX * ( scope.object.right - scope.object.left ) / scope.object.zoom / element.clientWidth, scope.object.matrix );\r\n\t\t\t\tpanUp( deltaY * ( scope.object.top - scope.object.bottom ) / scope.object.zoom / element.clientHeight, scope.object.matrix );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// camera neither orthographic nor perspective\r\n\t\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );\r\n\t\t\t\tscope.enablePan = false;\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t}();\r\n\r\n\tfunction dollyIn( dollyScale ) {\r\n\r\n\t\tif ( scope.object instanceof THREE.PerspectiveCamera ) {\r\n\r\n\t\t\tscale /= dollyScale;\r\n\r\n\t\t} else if ( scope.object instanceof THREE.OrthographicCamera ) {\r\n\r\n\t\t\tscope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom * dollyScale ) );\r\n\t\t\tscope.object.updateProjectionMatrix();\r\n\t\t\tzoomChanged = true;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );\r\n\t\t\tscope.enableZoom = false;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction dollyOut( dollyScale ) {\r\n\r\n\t\tif ( scope.object instanceof THREE.PerspectiveCamera ) {\r\n\r\n\t\t\tscale *= dollyScale;\r\n\r\n\t\t} else if ( scope.object instanceof THREE.OrthographicCamera ) {\r\n\r\n\t\t\tscope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom / dollyScale ) );\r\n\t\t\tscope.object.updateProjectionMatrix();\r\n\t\t\tzoomChanged = true;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );\r\n\t\t\tscope.enableZoom = false;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t//\r\n\t// event callbacks - update the object state\r\n\t//\r\n\r\n\tfunction handleMouseDownRotate( event ) {\r\n\r\n\t\t//console.log( 'handleMouseDownRotate' );\r\n\r\n\t\trotateStart.set( event.clientX, event.clientY );\r\n\r\n\t}\r\n\r\n\tfunction handleMouseDownDolly( event ) {\r\n\r\n\t\t//console.log( 'handleMouseDownDolly' );\r\n\r\n\t\tdollyStart.set( event.clientX, event.clientY );\r\n\r\n\t}\r\n\r\n\tfunction handleMouseDownPan( event ) {\r\n\r\n\t\t//console.log( 'handleMouseDownPan' );\r\n\r\n\t\tpanStart.set( event.clientX, event.clientY );\r\n\r\n\t}\r\n\r\n\tfunction handleMouseMoveRotate( event ) {\r\n\r\n\t\t//console.log( 'handleMouseMoveRotate' );\r\n\r\n\t\trotateEnd.set( event.clientX, event.clientY );\r\n\t\trotateDelta.subVectors( rotateEnd, rotateStart );\r\n\r\n\t\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\r\n\r\n\t\t// rotating across whole screen goes 360 degrees around\r\n\t\trotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );\r\n\r\n\t\t// rotating up and down along whole screen attempts to go 360, but limited to 180\r\n\t\trotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );\r\n\r\n\t\trotateStart.copy( rotateEnd );\r\n\r\n\t\tscope.update();\r\n\r\n\t}\r\n\r\n\tfunction handleMouseMoveDolly( event ) {\r\n\r\n\t\t//console.log( 'handleMouseMoveDolly' );\r\n\r\n\t\tdollyEnd.set( event.clientX, event.clientY );\r\n\r\n\t\tdollyDelta.subVectors( dollyEnd, dollyStart );\r\n\r\n\t\tif ( dollyDelta.y > 0 ) {\r\n\r\n\t\t\tdollyIn( getZoomScale() );\r\n\r\n\t\t} else if ( dollyDelta.y < 0 ) {\r\n\r\n\t\t\tdollyOut( getZoomScale() );\r\n\r\n\t\t}\r\n\r\n\t\tdollyStart.copy( dollyEnd );\r\n\r\n\t\tscope.update();\r\n\r\n\t}\r\n\r\n\tfunction handleMouseMovePan( event ) {\r\n\r\n\t\t//console.log( 'handleMouseMovePan' );\r\n\r\n\t\tpanEnd.set( event.clientX, event.clientY );\r\n\r\n\t\tpanDelta.subVectors( panEnd, panStart );\r\n\r\n\t\tpan( panDelta.x, panDelta.y );\r\n\r\n\t\tpanStart.copy( panEnd );\r\n\r\n\t\tscope.update();\r\n\r\n\t}\r\n\r\n\tfunction handleMouseUp( event ) {\r\n\r\n\t\t//console.log( 'handleMouseUp' );\r\n\r\n\t}\r\n\r\n\tfunction handleMouseWheel( event ) {\r\n\r\n\t\t//console.log( 'handleMouseWheel' );\r\n\r\n\t\tvar delta = 0;\r\n\r\n\t\tif ( event.wheelDelta !== undefined ) {\r\n\r\n\t\t\t// WebKit / Opera / Explorer 9\r\n\r\n\t\t\tdelta = event.wheelDelta;\r\n\r\n\t\t} else if ( event.detail !== undefined ) {\r\n\r\n\t\t\t// Firefox\r\n\r\n\t\t\tdelta = - event.detail;\r\n\r\n\t\t}\r\n\r\n\t\tif ( delta > 0 ) {\r\n\r\n\t\t\tdollyOut( getZoomScale() );\r\n\r\n\t\t} else if ( delta < 0 ) {\r\n\r\n\t\t\tdollyIn( getZoomScale() );\r\n\r\n\t\t}\r\n\r\n\t\tscope.update();\r\n\r\n\t}\r\n\r\n\tfunction handleKeyDown( event ) {\r\n\r\n\t\t//console.log( 'handleKeyDown' );\r\n\r\n\t\tswitch ( event.keyCode ) {\r\n\r\n\t\t\tcase scope.keys.UP:\r\n\t\t\t\tpan( 0, scope.keyPanSpeed );\r\n\t\t\t\tscope.update();\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase scope.keys.BOTTOM:\r\n\t\t\t\tpan( 0, - scope.keyPanSpeed );\r\n\t\t\t\tscope.update();\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase scope.keys.LEFT:\r\n\t\t\t\tpan( scope.keyPanSpeed, 0 );\r\n\t\t\t\tscope.update();\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase scope.keys.RIGHT:\r\n\t\t\t\tpan( - scope.keyPanSpeed, 0 );\r\n\t\t\t\tscope.update();\r\n\t\t\t\tbreak;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction handleTouchStartRotate( event ) {\r\n\r\n\t\t//console.log( 'handleTouchStartRotate' );\r\n\r\n\t\trotateStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\r\n\r\n\t}\r\n\r\n\tfunction handleTouchStartDolly( event ) {\r\n\r\n\t\t//console.log( 'handleTouchStartDolly' );\r\n\r\n\t\tvar dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\r\n\t\tvar dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\r\n\r\n\t\tvar distance = Math.sqrt( dx * dx + dy * dy );\r\n\r\n\t\tdollyStart.set( 0, distance );\r\n\r\n\t}\r\n\r\n\tfunction handleTouchStartPan( event ) {\r\n\r\n\t\t//console.log( 'handleTouchStartPan' );\r\n\r\n\t\tpanStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\r\n\r\n\t}\r\n\r\n\tfunction handleTouchMoveRotate( event ) {\r\n\r\n\t\t//console.log( 'handleTouchMoveRotate' );\r\n\r\n\t\trotateEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\r\n\t\trotateDelta.subVectors( rotateEnd, rotateStart );\r\n\r\n\t\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\r\n\r\n\t\t// rotating across whole screen goes 360 degrees around\r\n\t\trotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );\r\n\r\n\t\t// rotating up and down along whole screen attempts to go 360, but limited to 180\r\n\t\trotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );\r\n\r\n\t\trotateStart.copy( rotateEnd );\r\n\r\n\t\tscope.update();\r\n\r\n\t}\r\n\r\n\tfunction handleTouchMoveDolly( event ) {\r\n\r\n\t\t//console.log( 'handleTouchMoveDolly' );\r\n\r\n\t\tvar dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\r\n\t\tvar dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\r\n\r\n\t\tvar distance = Math.sqrt( dx * dx + dy * dy );\r\n\r\n\t\tdollyEnd.set( 0, distance );\r\n\r\n\t\tdollyDelta.subVectors( dollyEnd, dollyStart );\r\n\r\n\t\tif ( dollyDelta.y > 0 ) {\r\n\r\n\t\t\tdollyOut( getZoomScale() );\r\n\r\n\t\t} else if ( dollyDelta.y < 0 ) {\r\n\r\n\t\t\tdollyIn( getZoomScale() );\r\n\r\n\t\t}\r\n\r\n\t\tdollyStart.copy( dollyEnd );\r\n\r\n\t\tscope.update();\r\n\r\n\t}\r\n\r\n\tfunction handleTouchMovePan( event ) {\r\n\r\n\t\t//console.log( 'handleTouchMovePan' );\r\n\r\n\t\tpanEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\r\n\r\n\t\tpanDelta.subVectors( panEnd, panStart );\r\n\r\n\t\tpan( panDelta.x, panDelta.y );\r\n\r\n\t\tpanStart.copy( panEnd );\r\n\r\n\t\tscope.update();\r\n\r\n\t}\r\n\r\n\tfunction handleTouchEnd( event ) {\r\n\r\n\t\t//console.log( 'handleTouchEnd' );\r\n\r\n\t}\r\n\r\n\t//\r\n\t// event handlers - FSM: listen for events and reset state\r\n\t//\r\n\r\n\tfunction onMouseDown( event ) {\r\n\r\n\t\tif ( scope.enabled === false ) return;\r\n\r\n\t\tevent.preventDefault();\r\n\r\n\t\tif ( event.button === scope.mouseButtons.ORBIT ) {\r\n\r\n\t\t\tif ( scope.enableRotate === false ) return;\r\n\r\n\t\t\thandleMouseDownRotate( event );\r\n\r\n\t\t\tstate = STATE.ROTATE;\r\n\r\n\t\t} else if ( event.button === scope.mouseButtons.ZOOM ) {\r\n\r\n\t\t\tif ( scope.enableZoom === false ) return;\r\n\r\n\t\t\thandleMouseDownDolly( event );\r\n\r\n\t\t\tstate = STATE.DOLLY;\r\n\r\n\t\t} else if ( event.button === scope.mouseButtons.PAN ) {\r\n\r\n\t\t\tif ( scope.enablePan === false ) return;\r\n\r\n\t\t\thandleMouseDownPan( event );\r\n\r\n\t\t\tstate = STATE.PAN;\r\n\r\n\t\t}\r\n\r\n\t\tif ( state !== STATE.NONE ) {\r\n\r\n\t\t\tdocument.addEventListener( 'mousemove', onMouseMove, false );\r\n\t\t\tdocument.addEventListener( 'mouseup', onMouseUp, false );\r\n\t\t\tdocument.addEventListener( 'mouseout', onMouseUp, false );\r\n\r\n\t\t\tscope.dispatchEvent( startEvent );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction onMouseMove( event ) {\r\n\r\n\t\tif ( scope.enabled === false ) return;\r\n\r\n\t\tevent.preventDefault();\r\n\r\n\t\tif ( state === STATE.ROTATE ) {\r\n\r\n\t\t\tif ( scope.enableRotate === false ) return;\r\n\r\n\t\t\thandleMouseMoveRotate( event );\r\n\r\n\t\t} else if ( state === STATE.DOLLY ) {\r\n\r\n\t\t\tif ( scope.enableZoom === false ) return;\r\n\r\n\t\t\thandleMouseMoveDolly( event );\r\n\r\n\t\t} else if ( state === STATE.PAN ) {\r\n\r\n\t\t\tif ( scope.enablePan === false ) return;\r\n\r\n\t\t\thandleMouseMovePan( event );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction onMouseUp( event ) {\r\n\r\n\t\tif ( scope.enabled === false ) return;\r\n\r\n\t\thandleMouseUp( event );\r\n\r\n\t\tdocument.removeEventListener( 'mousemove', onMouseMove, false );\r\n\t\tdocument.removeEventListener( 'mouseup', onMouseUp, false );\r\n\t\tdocument.removeEventListener( 'mouseout', onMouseUp, false );\r\n\r\n\t\tscope.dispatchEvent( endEvent );\r\n\r\n\t\tstate = STATE.NONE;\r\n\r\n\t}\r\n\r\n\tfunction onMouseWheel( event ) {\r\n\r\n\t\tif ( scope.enabled === false || scope.enableZoom === false || ( state !== STATE.NONE && state !== STATE.ROTATE ) ) return;\r\n\r\n\t\tevent.preventDefault();\r\n\t\tevent.stopPropagation();\r\n\r\n\t\thandleMouseWheel( event );\r\n\r\n\t\tscope.dispatchEvent( startEvent ); // not sure why these are here...\r\n\t\tscope.dispatchEvent( endEvent );\r\n\r\n\t}\r\n\r\n\tfunction onKeyDown( event ) {\r\n\r\n\t\tif ( scope.enabled === false || scope.enableKeys === false || scope.enablePan === false ) return;\r\n\r\n\t\thandleKeyDown( event );\r\n\r\n\t}\r\n\r\n\tfunction onTouchStart( event ) {\r\n\r\n\t\tif ( scope.enabled === false ) return;\r\n\r\n\t\tswitch ( event.touches.length ) {\r\n\r\n\t\t\tcase 1:\t// one-fingered touch: rotate\r\n\r\n\t\t\t\tif ( scope.enableRotate === false ) return;\r\n\r\n\t\t\t\thandleTouchStartRotate( event );\r\n\r\n\t\t\t\tstate = STATE.TOUCH_ROTATE;\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 2:\t// two-fingered touch: dolly\r\n\r\n\t\t\t\tif ( scope.enableZoom === false ) return;\r\n\r\n\t\t\t\thandleTouchStartDolly( event );\r\n\r\n\t\t\t\tstate = STATE.TOUCH_DOLLY;\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 3: // three-fingered touch: pan\r\n\r\n\t\t\t\tif ( scope.enablePan === false ) return;\r\n\r\n\t\t\t\thandleTouchStartPan( event );\r\n\r\n\t\t\t\tstate = STATE.TOUCH_PAN;\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tdefault:\r\n\r\n\t\t\t\tstate = STATE.NONE;\r\n\r\n\t\t}\r\n\r\n\t\tif ( state !== STATE.NONE ) {\r\n\r\n\t\t\tscope.dispatchEvent( startEvent );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction onTouchMove( event ) {\r\n\r\n\t\tif ( scope.enabled === false ) return;\r\n\r\n\t\tevent.preventDefault();\r\n\t\tevent.stopPropagation();\r\n\r\n\t\tswitch ( event.touches.length ) {\r\n\r\n\t\t\tcase 1: // one-fingered touch: rotate\r\n\r\n\t\t\t\tif ( scope.enableRotate === false ) return;\r\n\t\t\t\tif ( state !== STATE.TOUCH_ROTATE ) return; // is this needed?...\r\n\r\n\t\t\t\thandleTouchMoveRotate( event );\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 2: // two-fingered touch: dolly\r\n\r\n\t\t\t\tif ( scope.enableZoom === false ) return;\r\n\t\t\t\tif ( state !== STATE.TOUCH_DOLLY ) return; // is this needed?...\r\n\r\n\t\t\t\thandleTouchMoveDolly( event );\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 3: // three-fingered touch: pan\r\n\r\n\t\t\t\tif ( scope.enablePan === false ) return;\r\n\t\t\t\tif ( state !== STATE.TOUCH_PAN ) return; // is this needed?...\r\n\r\n\t\t\t\thandleTouchMovePan( event );\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tdefault:\r\n\r\n\t\t\t\tstate = STATE.NONE;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction onTouchEnd( event ) {\r\n\r\n\t\tif ( scope.enabled === false ) return;\r\n\r\n\t\thandleTouchEnd( event );\r\n\r\n\t\tscope.dispatchEvent( endEvent );\r\n\r\n\t\tstate = STATE.NONE;\r\n\r\n\t}\r\n\r\n\tfunction onContextMenu( event ) {\r\n\r\n\t\tevent.preventDefault();\r\n\r\n\t}\r\n\r\n\t//\r\n\r\n\tscope.domElement.addEventListener( 'contextmenu', onContextMenu, false );\r\n\r\n\tscope.domElement.addEventListener( 'mousedown', onMouseDown, false );\r\n\tscope.domElement.addEventListener( 'mousewheel', onMouseWheel, false );\r\n\tscope.domElement.addEventListener( 'MozMousePixelScroll', onMouseWheel, false ); // firefox\r\n\r\n\tscope.domElement.addEventListener( 'touchstart', onTouchStart, false );\r\n\tscope.domElement.addEventListener( 'touchend', onTouchEnd, false );\r\n\tscope.domElement.addEventListener( 'touchmove', onTouchMove, false );\r\n\r\n\twindow.addEventListener( 'keydown', onKeyDown, false );\r\n\r\n\t// force an update at start\r\n\r\n\tthis.update();\r\n\r\n};\r\n\r\nTHREE.OrbitControls.prototype = Object.create( THREE.EventDispatcher.prototype );\r\nTHREE.OrbitControls.prototype.constructor = THREE.OrbitControls;\r\n\r\nObject.defineProperties( THREE.OrbitControls.prototype, {\r\n\r\n\tcenter: {\r\n\r\n\t\tget: function () {\r\n\r\n\t\t\tconsole.warn( 'THREE.OrbitControls: .center has been renamed to .target' );\r\n\t\t\treturn this.target;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\t// backward compatibility\r\n\r\n\tnoZoom: {\r\n\r\n\t\tget: function () {\r\n\r\n\t\t\tconsole.warn( 'THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.' );\r\n\t\t\treturn ! this.enableZoom;\r\n\r\n\t\t},\r\n\r\n\t\tset: function ( value ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.' );\r\n\t\t\tthis.enableZoom = ! value;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tnoRotate: {\r\n\r\n\t\tget: function () {\r\n\r\n\t\t\tconsole.warn( 'THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.' );\r\n\t\t\treturn ! this.enableRotate;\r\n\r\n\t\t},\r\n\r\n\t\tset: function ( value ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.' );\r\n\t\t\tthis.enableRotate = ! value;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tnoPan: {\r\n\r\n\t\tget: function () {\r\n\r\n\t\t\tconsole.warn( 'THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.' );\r\n\t\t\treturn ! this.enablePan;\r\n\r\n\t\t},\r\n\r\n\t\tset: function ( value ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.' );\r\n\t\t\tthis.enablePan = ! value;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tnoKeys: {\r\n\r\n\t\tget: function () {\r\n\r\n\t\t\tconsole.warn( 'THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.' );\r\n\t\t\treturn ! this.enableKeys;\r\n\r\n\t\t},\r\n\r\n\t\tset: function ( value ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.' );\r\n\t\t\tthis.enableKeys = ! value;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tstaticMoving : {\r\n\r\n\t\tget: function () {\r\n\r\n\t\t\tconsole.warn( 'THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.' );\r\n\t\t\treturn ! this.constraint.enableDamping;\r\n\r\n\t\t},\r\n\r\n\t\tset: function ( value ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.' );\r\n\t\t\tthis.constraint.enableDamping = ! value;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tdynamicDampingFactor : {\r\n\r\n\t\tget: function () {\r\n\r\n\t\t\tconsole.warn( 'THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.' );\r\n\t\t\treturn this.constraint.dampingFactor;\r\n\r\n\t\t},\r\n\r\n\t\tset: function ( value ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.' );\r\n\t\t\tthis.constraint.dampingFactor = value;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n} );\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/three/examples/js/controls/OrbitControls.js\n ** module id = 100\n ** module chunks = 0\n **/","/**\r\n * dat-gui JavaScript Controller Library\r\n * http://code.google.com/p/dat-gui\r\n *\r\n * Copyright 2011 Data Arts Team, Google Creative Lab\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n */\r\nvar dat=dat||{};dat.gui=dat.gui||{};dat.utils=dat.utils||{};dat.controllers=dat.controllers||{};dat.dom=dat.dom||{};dat.color=dat.color||{};dat.utils.css=function(){return{load:function(e,a){var a=a||document,c=a.createElement(\"link\");c.type=\"text/css\";c.rel=\"stylesheet\";c.href=e;a.getElementsByTagName(\"head\")[0].appendChild(c)},inject:function(e,a){var a=a||document,c=document.createElement(\"style\");c.type=\"text/css\";c.innerHTML=e;a.getElementsByTagName(\"head\")[0].appendChild(c)}}}();\r\ndat.utils.common=function(){var e=Array.prototype.forEach,a=Array.prototype.slice;return{BREAK:{},extend:function(c){this.each(a.call(arguments,1),function(a){for(var f in a)this.isUndefined(a[f])||(c[f]=a[f])},this);return c},defaults:function(c){this.each(a.call(arguments,1),function(a){for(var f in a)this.isUndefined(c[f])&&(c[f]=a[f])},this);return c},compose:function(){var c=a.call(arguments);return function(){for(var d=a.call(arguments),f=c.length-1;f>=0;f--)d=[c[f].apply(this,d)];return d[0]}},\r\neach:function(a,d,f){if(e&&a.forEach===e)a.forEach(d,f);else if(a.length===a.length+0)for(var b=0,n=a.length;b<n;b++){if(b in a&&d.call(f,a[b],b)===this.BREAK)break}else for(b in a)if(d.call(f,a[b],b)===this.BREAK)break},defer:function(a){setTimeout(a,0)},toArray:function(c){return c.toArray?c.toArray():a.call(c)},isUndefined:function(a){return a===void 0},isNull:function(a){return a===null},isNaN:function(a){return a!==a},isArray:Array.isArray||function(a){return a.constructor===Array},isObject:function(a){return a===\r\nObject(a)},isNumber:function(a){return a===a+0},isString:function(a){return a===a+\"\"},isBoolean:function(a){return a===false||a===true},isFunction:function(a){return Object.prototype.toString.call(a)===\"[object Function]\"}}}();\r\ndat.controllers.Controller=function(e){var a=function(a,d){this.initialValue=a[d];this.domElement=document.createElement(\"div\");this.object=a;this.property=d;this.__onFinishChange=this.__onChange=void 0};e.extend(a.prototype,{onChange:function(a){this.__onChange=a;return this},onFinishChange:function(a){this.__onFinishChange=a;return this},setValue:function(a){this.object[this.property]=a;this.__onChange&&this.__onChange.call(this,a);this.updateDisplay();return this},getValue:function(){return this.object[this.property]},\r\nupdateDisplay:function(){return this},isModified:function(){return this.initialValue!==this.getValue()}});return a}(dat.utils.common);\r\ndat.dom.dom=function(e){function a(b){if(b===\"0\"||e.isUndefined(b))return 0;b=b.match(d);return!e.isNull(b)?parseFloat(b[1]):0}var c={};e.each({HTMLEvents:[\"change\"],MouseEvents:[\"click\",\"mousemove\",\"mousedown\",\"mouseup\",\"mouseover\"],KeyboardEvents:[\"keydown\"]},function(b,a){e.each(b,function(b){c[b]=a})});var d=/(\\d+(\\.\\d+)?)px/,f={makeSelectable:function(b,a){if(!(b===void 0||b.style===void 0))b.onselectstart=a?function(){return false}:function(){},b.style.MozUserSelect=a?\"auto\":\"none\",b.style.KhtmlUserSelect=\r\na?\"auto\":\"none\",b.unselectable=a?\"on\":\"off\"},makeFullscreen:function(b,a,d){e.isUndefined(a)&&(a=true);e.isUndefined(d)&&(d=true);b.style.position=\"absolute\";if(a)b.style.left=0,b.style.right=0;if(d)b.style.top=0,b.style.bottom=0},fakeEvent:function(b,a,d,f){var d=d||{},m=c[a];if(!m)throw Error(\"Event type \"+a+\" not supported.\");var l=document.createEvent(m);switch(m){case \"MouseEvents\":l.initMouseEvent(a,d.bubbles||false,d.cancelable||true,window,d.clickCount||1,0,0,d.x||d.clientX||0,d.y||d.clientY||\r\n0,false,false,false,false,0,null);break;case \"KeyboardEvents\":m=l.initKeyboardEvent||l.initKeyEvent;e.defaults(d,{cancelable:true,ctrlKey:false,altKey:false,shiftKey:false,metaKey:false,keyCode:void 0,charCode:void 0});m(a,d.bubbles||false,d.cancelable,window,d.ctrlKey,d.altKey,d.shiftKey,d.metaKey,d.keyCode,d.charCode);break;default:l.initEvent(a,d.bubbles||false,d.cancelable||true)}e.defaults(l,f);b.dispatchEvent(l)},bind:function(b,a,d,c){b.addEventListener?b.addEventListener(a,d,c||false):b.attachEvent&&\r\nb.attachEvent(\"on\"+a,d);return f},unbind:function(b,a,d,c){b.removeEventListener?b.removeEventListener(a,d,c||false):b.detachEvent&&b.detachEvent(\"on\"+a,d);return f},addClass:function(b,a){if(b.className===void 0)b.className=a;else if(b.className!==a){var d=b.className.split(/ +/);if(d.indexOf(a)==-1)d.push(a),b.className=d.join(\" \").replace(/^\\s+/,\"\").replace(/\\s+$/,\"\")}return f},removeClass:function(b,a){if(a){if(b.className!==void 0)if(b.className===a)b.removeAttribute(\"class\");else{var d=b.className.split(/ +/),\r\nc=d.indexOf(a);if(c!=-1)d.splice(c,1),b.className=d.join(\" \")}}else b.className=void 0;return f},hasClass:function(a,d){return RegExp(\"(?:^|\\\\s+)\"+d+\"(?:\\\\s+|$)\").test(a.className)||false},getWidth:function(b){b=getComputedStyle(b);return a(b[\"border-left-width\"])+a(b[\"border-right-width\"])+a(b[\"padding-left\"])+a(b[\"padding-right\"])+a(b.width)},getHeight:function(b){b=getComputedStyle(b);return a(b[\"border-top-width\"])+a(b[\"border-bottom-width\"])+a(b[\"padding-top\"])+a(b[\"padding-bottom\"])+a(b.height)},\r\ngetOffset:function(a){var d={left:0,top:0};if(a.offsetParent){do d.left+=a.offsetLeft,d.top+=a.offsetTop;while(a=a.offsetParent)}return d},isActive:function(a){return a===document.activeElement&&(a.type||a.href)}};return f}(dat.utils.common);\r\ndat.controllers.OptionController=function(e,a,c){var d=function(f,b,e){d.superclass.call(this,f,b);var h=this;this.__select=document.createElement(\"select\");if(c.isArray(e)){var j={};c.each(e,function(a){j[a]=a});e=j}c.each(e,function(a,b){var d=document.createElement(\"option\");d.innerHTML=b;d.setAttribute(\"value\",a);h.__select.appendChild(d)});this.updateDisplay();a.bind(this.__select,\"change\",function(){h.setValue(this.options[this.selectedIndex].value)});this.domElement.appendChild(this.__select)};\r\nd.superclass=e;c.extend(d.prototype,e.prototype,{setValue:function(a){a=d.superclass.prototype.setValue.call(this,a);this.__onFinishChange&&this.__onFinishChange.call(this,this.getValue());return a},updateDisplay:function(){this.__select.value=this.getValue();return d.superclass.prototype.updateDisplay.call(this)}});return d}(dat.controllers.Controller,dat.dom.dom,dat.utils.common);\r\ndat.controllers.NumberController=function(e,a){var c=function(d,f,b){c.superclass.call(this,d,f);b=b||{};this.__min=b.min;this.__max=b.max;this.__step=b.step;d=this.__impliedStep=a.isUndefined(this.__step)?this.initialValue==0?1:Math.pow(10,Math.floor(Math.log(this.initialValue)/Math.LN10))/10:this.__step;d=d.toString();this.__precision=d.indexOf(\".\")>-1?d.length-d.indexOf(\".\")-1:0};c.superclass=e;a.extend(c.prototype,e.prototype,{setValue:function(a){if(this.__min!==void 0&&a<this.__min)a=this.__min;\r\nelse if(this.__max!==void 0&&a>this.__max)a=this.__max;this.__step!==void 0&&a%this.__step!=0&&(a=Math.round(a/this.__step)*this.__step);return c.superclass.prototype.setValue.call(this,a)},min:function(a){this.__min=a;return this},max:function(a){this.__max=a;return this},step:function(a){this.__step=a;return this}});return c}(dat.controllers.Controller,dat.utils.common);\r\ndat.controllers.NumberControllerBox=function(e,a,c){var d=function(f,b,e){function h(){var a=parseFloat(l.__input.value);c.isNaN(a)||l.setValue(a)}function j(a){var b=o-a.clientY;l.setValue(l.getValue()+b*l.__impliedStep);o=a.clientY}function m(){a.unbind(window,\"mousemove\",j);a.unbind(window,\"mouseup\",m)}this.__truncationSuspended=false;d.superclass.call(this,f,b,e);var l=this,o;this.__input=document.createElement(\"input\");this.__input.setAttribute(\"type\",\"text\");a.bind(this.__input,\"change\",h);\r\na.bind(this.__input,\"blur\",function(){h();l.__onFinishChange&&l.__onFinishChange.call(l,l.getValue())});a.bind(this.__input,\"mousedown\",function(b){a.bind(window,\"mousemove\",j);a.bind(window,\"mouseup\",m);o=b.clientY});a.bind(this.__input,\"keydown\",function(a){if(a.keyCode===13)l.__truncationSuspended=true,this.blur(),l.__truncationSuspended=false});this.updateDisplay();this.domElement.appendChild(this.__input)};d.superclass=e;c.extend(d.prototype,e.prototype,{updateDisplay:function(){var a=this.__input,\r\nb;if(this.__truncationSuspended)b=this.getValue();else{b=this.getValue();var c=Math.pow(10,this.__precision);b=Math.round(b*c)/c}a.value=b;return d.superclass.prototype.updateDisplay.call(this)}});return d}(dat.controllers.NumberController,dat.dom.dom,dat.utils.common);\r\ndat.controllers.NumberControllerSlider=function(e,a,c,d,f){var b=function(d,c,f,e,l){function o(b){b.preventDefault();var d=a.getOffset(g.__background),c=a.getWidth(g.__background);g.setValue(g.__min+(g.__max-g.__min)*((b.clientX-d.left)/(d.left+c-d.left)));return false}function y(){a.unbind(window,\"mousemove\",o);a.unbind(window,\"mouseup\",y);g.__onFinishChange&&g.__onFinishChange.call(g,g.getValue())}b.superclass.call(this,d,c,{min:f,max:e,step:l});var g=this;this.__background=document.createElement(\"div\");\r\nthis.__foreground=document.createElement(\"div\");a.bind(this.__background,\"mousedown\",function(b){a.bind(window,\"mousemove\",o);a.bind(window,\"mouseup\",y);o(b)});a.addClass(this.__background,\"slider\");a.addClass(this.__foreground,\"slider-fg\");this.updateDisplay();this.__background.appendChild(this.__foreground);this.domElement.appendChild(this.__background)};b.superclass=e;b.useDefaultStyles=function(){c.inject(f)};d.extend(b.prototype,e.prototype,{updateDisplay:function(){this.__foreground.style.width=\r\n(this.getValue()-this.__min)/(this.__max-this.__min)*100+\"%\";return b.superclass.prototype.updateDisplay.call(this)}});return b}(dat.controllers.NumberController,dat.dom.dom,dat.utils.css,dat.utils.common,\".slider {\\n  box-shadow: inset 0 2px 4px rgba(0,0,0,0.15);\\n  height: 1em;\\n  border-radius: 1em;\\n  background-color: #eee;\\n  padding: 0 0.5em;\\n  overflow: hidden;\\n}\\n\\n.slider-fg {\\n  padding: 1px 0 2px 0;\\n  background-color: #aaa;\\n  height: 1em;\\n  margin-left: -0.5em;\\n  padding-right: 0.5em;\\n  border-radius: 1em 0 0 1em;\\n}\\n\\n.slider-fg:after {\\n  display: inline-block;\\n  border-radius: 1em;\\n  background-color: #fff;\\n  border:  1px solid #aaa;\\n  content: '';\\n  float: right;\\n  margin-right: -1em;\\n  margin-top: -1px;\\n  height: 0.9em;\\n  width: 0.9em;\\n}\");\r\ndat.controllers.FunctionController=function(e,a,c){var d=function(c,b,e){d.superclass.call(this,c,b);var h=this;this.__button=document.createElement(\"div\");this.__button.innerHTML=e===void 0?\"Fire\":e;a.bind(this.__button,\"click\",function(a){a.preventDefault();h.fire();return false});a.addClass(this.__button,\"button\");this.domElement.appendChild(this.__button)};d.superclass=e;c.extend(d.prototype,e.prototype,{fire:function(){this.__onChange&&this.__onChange.call(this);this.__onFinishChange&&this.__onFinishChange.call(this,\r\nthis.getValue());this.getValue().call(this.object)}});return d}(dat.controllers.Controller,dat.dom.dom,dat.utils.common);\r\ndat.controllers.BooleanController=function(e,a,c){var d=function(c,b){d.superclass.call(this,c,b);var e=this;this.__prev=this.getValue();this.__checkbox=document.createElement(\"input\");this.__checkbox.setAttribute(\"type\",\"checkbox\");a.bind(this.__checkbox,\"change\",function(){e.setValue(!e.__prev)},false);this.domElement.appendChild(this.__checkbox);this.updateDisplay()};d.superclass=e;c.extend(d.prototype,e.prototype,{setValue:function(a){a=d.superclass.prototype.setValue.call(this,a);this.__onFinishChange&&\r\nthis.__onFinishChange.call(this,this.getValue());this.__prev=this.getValue();return a},updateDisplay:function(){this.getValue()===true?(this.__checkbox.setAttribute(\"checked\",\"checked\"),this.__checkbox.checked=true):this.__checkbox.checked=false;return d.superclass.prototype.updateDisplay.call(this)}});return d}(dat.controllers.Controller,dat.dom.dom,dat.utils.common);\r\ndat.color.toString=function(e){return function(a){if(a.a==1||e.isUndefined(a.a)){for(a=a.hex.toString(16);a.length<6;)a=\"0\"+a;return\"#\"+a}else return\"rgba(\"+Math.round(a.r)+\",\"+Math.round(a.g)+\",\"+Math.round(a.b)+\",\"+a.a+\")\"}}(dat.utils.common);\r\ndat.color.interpret=function(e,a){var c,d,f=[{litmus:a.isString,conversions:{THREE_CHAR_HEX:{read:function(a){a=a.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);return a===null?false:{space:\"HEX\",hex:parseInt(\"0x\"+a[1].toString()+a[1].toString()+a[2].toString()+a[2].toString()+a[3].toString()+a[3].toString())}},write:e},SIX_CHAR_HEX:{read:function(a){a=a.match(/^#([A-F0-9]{6})$/i);return a===null?false:{space:\"HEX\",hex:parseInt(\"0x\"+a[1].toString())}},write:e},CSS_RGB:{read:function(a){a=a.match(/^rgb\\(\\s*(.+)\\s*,\\s*(.+)\\s*,\\s*(.+)\\s*\\)/);\r\nreturn a===null?false:{space:\"RGB\",r:parseFloat(a[1]),g:parseFloat(a[2]),b:parseFloat(a[3])}},write:e},CSS_RGBA:{read:function(a){a=a.match(/^rgba\\(\\s*(.+)\\s*,\\s*(.+)\\s*,\\s*(.+)\\s*\\,\\s*(.+)\\s*\\)/);return a===null?false:{space:\"RGB\",r:parseFloat(a[1]),g:parseFloat(a[2]),b:parseFloat(a[3]),a:parseFloat(a[4])}},write:e}}},{litmus:a.isNumber,conversions:{HEX:{read:function(a){return{space:\"HEX\",hex:a,conversionName:\"HEX\"}},write:function(a){return a.hex}}}},{litmus:a.isArray,conversions:{RGB_ARRAY:{read:function(a){return a.length!=\r\n3?false:{space:\"RGB\",r:a[0],g:a[1],b:a[2]}},write:function(a){return[a.r,a.g,a.b]}},RGBA_ARRAY:{read:function(a){return a.length!=4?false:{space:\"RGB\",r:a[0],g:a[1],b:a[2],a:a[3]}},write:function(a){return[a.r,a.g,a.b,a.a]}}}},{litmus:a.isObject,conversions:{RGBA_OBJ:{read:function(b){return a.isNumber(b.r)&&a.isNumber(b.g)&&a.isNumber(b.b)&&a.isNumber(b.a)?{space:\"RGB\",r:b.r,g:b.g,b:b.b,a:b.a}:false},write:function(a){return{r:a.r,g:a.g,b:a.b,a:a.a}}},RGB_OBJ:{read:function(b){return a.isNumber(b.r)&&\r\na.isNumber(b.g)&&a.isNumber(b.b)?{space:\"RGB\",r:b.r,g:b.g,b:b.b}:false},write:function(a){return{r:a.r,g:a.g,b:a.b}}},HSVA_OBJ:{read:function(b){return a.isNumber(b.h)&&a.isNumber(b.s)&&a.isNumber(b.v)&&a.isNumber(b.a)?{space:\"HSV\",h:b.h,s:b.s,v:b.v,a:b.a}:false},write:function(a){return{h:a.h,s:a.s,v:a.v,a:a.a}}},HSV_OBJ:{read:function(b){return a.isNumber(b.h)&&a.isNumber(b.s)&&a.isNumber(b.v)?{space:\"HSV\",h:b.h,s:b.s,v:b.v}:false},write:function(a){return{h:a.h,s:a.s,v:a.v}}}}}];return function(){d=\r\nfalse;var b=arguments.length>1?a.toArray(arguments):arguments[0];a.each(f,function(e){if(e.litmus(b))return a.each(e.conversions,function(e,f){c=e.read(b);if(d===false&&c!==false)return d=c,c.conversionName=f,c.conversion=e,a.BREAK}),a.BREAK});return d}}(dat.color.toString,dat.utils.common);\r\ndat.GUI=dat.gui.GUI=function(e,a,c,d,f,b,n,h,j,m,l,o,y,g,i){function q(a,b,r,c){if(b[r]===void 0)throw Error(\"Object \"+b+' has no property \"'+r+'\"');c.color?b=new l(b,r):(b=[b,r].concat(c.factoryArgs),b=d.apply(a,b));if(c.before instanceof f)c.before=c.before.__li;t(a,b);g.addClass(b.domElement,\"c\");r=document.createElement(\"span\");g.addClass(r,\"property-name\");r.innerHTML=b.property;var e=document.createElement(\"div\");e.appendChild(r);e.appendChild(b.domElement);c=s(a,e,c.before);g.addClass(c,k.CLASS_CONTROLLER_ROW);\r\ng.addClass(c,typeof b.getValue());p(a,c,b);a.__controllers.push(b);return b}function s(a,b,d){var c=document.createElement(\"li\");b&&c.appendChild(b);d?a.__ul.insertBefore(c,params.before):a.__ul.appendChild(c);a.onResize();return c}function p(a,d,c){c.__li=d;c.__gui=a;i.extend(c,{options:function(b){if(arguments.length>1)return c.remove(),q(a,c.object,c.property,{before:c.__li.nextElementSibling,factoryArgs:[i.toArray(arguments)]});if(i.isArray(b)||i.isObject(b))return c.remove(),q(a,c.object,c.property,\r\n{before:c.__li.nextElementSibling,factoryArgs:[b]})},name:function(a){c.__li.firstElementChild.firstElementChild.innerHTML=a;return c},listen:function(){c.__gui.listen(c);return c},remove:function(){c.__gui.remove(c);return c}});if(c instanceof j){var e=new h(c.object,c.property,{min:c.__min,max:c.__max,step:c.__step});i.each([\"updateDisplay\",\"onChange\",\"onFinishChange\"],function(a){var b=c[a],H=e[a];c[a]=e[a]=function(){var a=Array.prototype.slice.call(arguments);b.apply(c,a);return H.apply(e,a)}});\r\ng.addClass(d,\"has-slider\");c.domElement.insertBefore(e.domElement,c.domElement.firstElementChild)}else if(c instanceof h){var f=function(b){return i.isNumber(c.__min)&&i.isNumber(c.__max)?(c.remove(),q(a,c.object,c.property,{before:c.__li.nextElementSibling,factoryArgs:[c.__min,c.__max,c.__step]})):b};c.min=i.compose(f,c.min);c.max=i.compose(f,c.max)}else if(c instanceof b)g.bind(d,\"click\",function(){g.fakeEvent(c.__checkbox,\"click\")}),g.bind(c.__checkbox,\"click\",function(a){a.stopPropagation()});\r\nelse if(c instanceof n)g.bind(d,\"click\",function(){g.fakeEvent(c.__button,\"click\")}),g.bind(d,\"mouseover\",function(){g.addClass(c.__button,\"hover\")}),g.bind(d,\"mouseout\",function(){g.removeClass(c.__button,\"hover\")});else if(c instanceof l)g.addClass(d,\"color\"),c.updateDisplay=i.compose(function(a){d.style.borderLeftColor=c.__color.toString();return a},c.updateDisplay),c.updateDisplay();c.setValue=i.compose(function(b){a.getRoot().__preset_select&&c.isModified()&&B(a.getRoot(),true);return b},c.setValue)}\r\nfunction t(a,b){var c=a.getRoot(),d=c.__rememberedObjects.indexOf(b.object);if(d!=-1){var e=c.__rememberedObjectIndecesToControllers[d];e===void 0&&(e={},c.__rememberedObjectIndecesToControllers[d]=e);e[b.property]=b;if(c.load&&c.load.remembered){c=c.load.remembered;if(c[a.preset])c=c[a.preset];else if(c[w])c=c[w];else return;if(c[d]&&c[d][b.property]!==void 0)d=c[d][b.property],b.initialValue=d,b.setValue(d)}}}function I(a){var b=a.__save_row=document.createElement(\"li\");g.addClass(a.domElement,\r\n\"has-save\");a.__ul.insertBefore(b,a.__ul.firstChild);g.addClass(b,\"save-row\");var c=document.createElement(\"span\");c.innerHTML=\"&nbsp;\";g.addClass(c,\"button gears\");var d=document.createElement(\"span\");d.innerHTML=\"Save\";g.addClass(d,\"button\");g.addClass(d,\"save\");var e=document.createElement(\"span\");e.innerHTML=\"New\";g.addClass(e,\"button\");g.addClass(e,\"save-as\");var f=document.createElement(\"span\");f.innerHTML=\"Revert\";g.addClass(f,\"button\");g.addClass(f,\"revert\");var m=a.__preset_select=document.createElement(\"select\");\r\na.load&&a.load.remembered?i.each(a.load.remembered,function(b,c){C(a,c,c==a.preset)}):C(a,w,false);g.bind(m,\"change\",function(){for(var b=0;b<a.__preset_select.length;b++)a.__preset_select[b].innerHTML=a.__preset_select[b].value;a.preset=this.value});b.appendChild(m);b.appendChild(c);b.appendChild(d);b.appendChild(e);b.appendChild(f);if(u){var b=document.getElementById(\"dg-save-locally\"),l=document.getElementById(\"dg-local-explain\");b.style.display=\"block\";b=document.getElementById(\"dg-local-storage\");\r\nlocalStorage.getItem(document.location.href+\".isLocal\")===\"true\"&&b.setAttribute(\"checked\",\"checked\");var o=function(){l.style.display=a.useLocalStorage?\"block\":\"none\"};o();g.bind(b,\"change\",function(){a.useLocalStorage=!a.useLocalStorage;o()})}var h=document.getElementById(\"dg-new-constructor\");g.bind(h,\"keydown\",function(a){a.metaKey&&(a.which===67||a.keyCode==67)&&x.hide()});g.bind(c,\"click\",function(){h.innerHTML=JSON.stringify(a.getSaveObject(),void 0,2);x.show();h.focus();h.select()});g.bind(d,\r\n\"click\",function(){a.save()});g.bind(e,\"click\",function(){var b=prompt(\"Enter a new preset name.\");b&&a.saveAs(b)});g.bind(f,\"click\",function(){a.revert()})}function J(a){function b(f){f.preventDefault();e=f.clientX;g.addClass(a.__closeButton,k.CLASS_DRAG);g.bind(window,\"mousemove\",c);g.bind(window,\"mouseup\",d);return false}function c(b){b.preventDefault();a.width+=e-b.clientX;a.onResize();e=b.clientX;return false}function d(){g.removeClass(a.__closeButton,k.CLASS_DRAG);g.unbind(window,\"mousemove\",\r\nc);g.unbind(window,\"mouseup\",d)}a.__resize_handle=document.createElement(\"div\");i.extend(a.__resize_handle.style,{width:\"6px\",marginLeft:\"-3px\",height:\"200px\",cursor:\"ew-resize\",position:\"absolute\"});var e;g.bind(a.__resize_handle,\"mousedown\",b);g.bind(a.__closeButton,\"mousedown\",b);a.domElement.insertBefore(a.__resize_handle,a.domElement.firstElementChild)}function D(a,b){a.domElement.style.width=b+\"px\";if(a.__save_row&&a.autoPlace)a.__save_row.style.width=b+\"px\";if(a.__closeButton)a.__closeButton.style.width=\r\nb+\"px\"}function z(a,b){var c={};i.each(a.__rememberedObjects,function(d,e){var f={};i.each(a.__rememberedObjectIndecesToControllers[e],function(a,c){f[c]=b?a.initialValue:a.getValue()});c[e]=f});return c}function C(a,b,c){var d=document.createElement(\"option\");d.innerHTML=b;d.value=b;a.__preset_select.appendChild(d);if(c)a.__preset_select.selectedIndex=a.__preset_select.length-1}function B(a,b){var c=a.__preset_select[a.__preset_select.selectedIndex];c.innerHTML=b?c.value+\"*\":c.value}function E(a){a.length!=\r\n0&&o(function(){E(a)});i.each(a,function(a){a.updateDisplay()})}e.inject(c);var w=\"Default\",u;try{u=\"localStorage\"in window&&window.localStorage!==null}catch(K){u=false}var x,F=true,v,A=false,G=[],k=function(a){function b(){localStorage.setItem(document.location.href+\".gui\",JSON.stringify(d.getSaveObject()))}function c(){var a=d.getRoot();a.width+=1;i.defer(function(){a.width-=1})}var d=this;this.domElement=document.createElement(\"div\");this.__ul=document.createElement(\"ul\");this.domElement.appendChild(this.__ul);\r\ng.addClass(this.domElement,\"dg\");this.__folders={};this.__controllers=[];this.__rememberedObjects=[];this.__rememberedObjectIndecesToControllers=[];this.__listening=[];a=a||{};a=i.defaults(a,{autoPlace:true,width:k.DEFAULT_WIDTH});a=i.defaults(a,{resizable:a.autoPlace,hideable:a.autoPlace});if(i.isUndefined(a.load))a.load={preset:w};else if(a.preset)a.load.preset=a.preset;i.isUndefined(a.parent)&&a.hideable&&G.push(this);a.resizable=i.isUndefined(a.parent)&&a.resizable;if(a.autoPlace&&i.isUndefined(a.scrollable))a.scrollable=\r\ntrue;var e=u&&localStorage.getItem(document.location.href+\".isLocal\")===\"true\";Object.defineProperties(this,{parent:{get:function(){return a.parent}},scrollable:{get:function(){return a.scrollable}},autoPlace:{get:function(){return a.autoPlace}},preset:{get:function(){return d.parent?d.getRoot().preset:a.load.preset},set:function(b){d.parent?d.getRoot().preset=b:a.load.preset=b;for(b=0;b<this.__preset_select.length;b++)if(this.__preset_select[b].value==this.preset)this.__preset_select.selectedIndex=\r\nb;d.revert()}},width:{get:function(){return a.width},set:function(b){a.width=b;D(d,b)}},name:{get:function(){return a.name},set:function(b){a.name=b;if(m)m.innerHTML=a.name}},closed:{get:function(){return a.closed},set:function(b){a.closed=b;a.closed?g.addClass(d.__ul,k.CLASS_CLOSED):g.removeClass(d.__ul,k.CLASS_CLOSED);this.onResize();if(d.__closeButton)d.__closeButton.innerHTML=b?k.TEXT_OPEN:k.TEXT_CLOSED}},load:{get:function(){return a.load}},useLocalStorage:{get:function(){return e},set:function(a){u&&\r\n((e=a)?g.bind(window,\"unload\",b):g.unbind(window,\"unload\",b),localStorage.setItem(document.location.href+\".isLocal\",a))}}});if(i.isUndefined(a.parent)){a.closed=false;g.addClass(this.domElement,k.CLASS_MAIN);g.makeSelectable(this.domElement,false);if(u&&e){d.useLocalStorage=true;var f=localStorage.getItem(document.location.href+\".gui\");if(f)a.load=JSON.parse(f)}this.__closeButton=document.createElement(\"div\");this.__closeButton.innerHTML=k.TEXT_CLOSED;g.addClass(this.__closeButton,k.CLASS_CLOSE_BUTTON);\r\nthis.domElement.appendChild(this.__closeButton);g.bind(this.__closeButton,\"click\",function(){d.closed=!d.closed})}else{if(a.closed===void 0)a.closed=true;var m=document.createTextNode(a.name);g.addClass(m,\"controller-name\");f=s(d,m);g.addClass(this.__ul,k.CLASS_CLOSED);g.addClass(f,\"title\");g.bind(f,\"click\",function(a){a.preventDefault();d.closed=!d.closed;return false});if(!a.closed)this.closed=false}a.autoPlace&&(i.isUndefined(a.parent)&&(F&&(v=document.createElement(\"div\"),g.addClass(v,\"dg\"),g.addClass(v,\r\nk.CLASS_AUTO_PLACE_CONTAINER),document.body.appendChild(v),F=false),v.appendChild(this.domElement),g.addClass(this.domElement,k.CLASS_AUTO_PLACE)),this.parent||D(d,a.width));g.bind(window,\"resize\",function(){d.onResize()});g.bind(this.__ul,\"webkitTransitionEnd\",function(){d.onResize()});g.bind(this.__ul,\"transitionend\",function(){d.onResize()});g.bind(this.__ul,\"oTransitionEnd\",function(){d.onResize()});this.onResize();a.resizable&&J(this);d.getRoot();a.parent||c()};k.toggleHide=function(){A=!A;i.each(G,\r\nfunction(a){a.domElement.style.zIndex=A?-999:999;a.domElement.style.opacity=A?0:1})};k.CLASS_AUTO_PLACE=\"a\";k.CLASS_AUTO_PLACE_CONTAINER=\"ac\";k.CLASS_MAIN=\"main\";k.CLASS_CONTROLLER_ROW=\"cr\";k.CLASS_TOO_TALL=\"taller-than-window\";k.CLASS_CLOSED=\"closed\";k.CLASS_CLOSE_BUTTON=\"close-button\";k.CLASS_DRAG=\"drag\";k.DEFAULT_WIDTH=245;k.TEXT_CLOSED=\"Close Controls\";k.TEXT_OPEN=\"Open Controls\";g.bind(window,\"keydown\",function(a){document.activeElement.type!==\"text\"&&(a.which===72||a.keyCode==72)&&k.toggleHide()},\r\nfalse);i.extend(k.prototype,{add:function(a,b){return q(this,a,b,{factoryArgs:Array.prototype.slice.call(arguments,2)})},addColor:function(a,b){return q(this,a,b,{color:true})},remove:function(a){this.__ul.removeChild(a.__li);this.__controllers.slice(this.__controllers.indexOf(a),1);var b=this;i.defer(function(){b.onResize()})},destroy:function(){this.autoPlace&&v.removeChild(this.domElement)},addFolder:function(a){if(this.__folders[a]!==void 0)throw Error('You already have a folder in this GUI by the name \"'+\r\na+'\"');var b={name:a,parent:this};b.autoPlace=this.autoPlace;if(this.load&&this.load.folders&&this.load.folders[a])b.closed=this.load.folders[a].closed,b.load=this.load.folders[a];b=new k(b);this.__folders[a]=b;a=s(this,b.domElement);g.addClass(a,\"folder\");return b},open:function(){this.closed=false},close:function(){this.closed=true},onResize:function(){var a=this.getRoot();if(a.scrollable){var b=g.getOffset(a.__ul).top,c=0;i.each(a.__ul.childNodes,function(b){a.autoPlace&&b===a.__save_row||(c+=\r\ng.getHeight(b))});window.innerHeight-b-20<c?(g.addClass(a.domElement,k.CLASS_TOO_TALL),a.__ul.style.height=window.innerHeight-b-20+\"px\"):(g.removeClass(a.domElement,k.CLASS_TOO_TALL),a.__ul.style.height=\"auto\")}a.__resize_handle&&i.defer(function(){a.__resize_handle.style.height=a.__ul.offsetHeight+\"px\"});if(a.__closeButton)a.__closeButton.style.width=a.width+\"px\"},remember:function(){if(i.isUndefined(x))x=new y,x.domElement.innerHTML=a;if(this.parent)throw Error(\"You can only call remember on a top level GUI.\");\r\nvar b=this;i.each(Array.prototype.slice.call(arguments),function(a){b.__rememberedObjects.length==0&&I(b);b.__rememberedObjects.indexOf(a)==-1&&b.__rememberedObjects.push(a)});this.autoPlace&&D(this,this.width)},getRoot:function(){for(var a=this;a.parent;)a=a.parent;return a},getSaveObject:function(){var a=this.load;a.closed=this.closed;if(this.__rememberedObjects.length>0){a.preset=this.preset;if(!a.remembered)a.remembered={};a.remembered[this.preset]=z(this)}a.folders={};i.each(this.__folders,function(b,\r\nc){a.folders[c]=b.getSaveObject()});return a},save:function(){if(!this.load.remembered)this.load.remembered={};this.load.remembered[this.preset]=z(this);B(this,false)},saveAs:function(a){if(!this.load.remembered)this.load.remembered={},this.load.remembered[w]=z(this,true);this.load.remembered[a]=z(this);this.preset=a;C(this,a,true)},revert:function(a){i.each(this.__controllers,function(b){this.getRoot().load.remembered?t(a||this.getRoot(),b):b.setValue(b.initialValue)},this);i.each(this.__folders,\r\nfunction(a){a.revert(a)});a||B(this.getRoot(),false)},listen:function(a){var b=this.__listening.length==0;this.__listening.push(a);b&&E(this.__listening)}});return k}(dat.utils.css,'<div id=\"dg-save\" class=\"dg dialogue\">\\n\\n  Here\\'s the new load parameter for your <code>GUI</code>\\'s constructor:\\n\\n  <textarea id=\"dg-new-constructor\"></textarea>\\n\\n  <div id=\"dg-save-locally\">\\n\\n    <input id=\"dg-local-storage\" type=\"checkbox\"/> Automatically save\\n    values to <code>localStorage</code> on exit.\\n\\n    <div id=\"dg-local-explain\">The values saved to <code>localStorage</code> will\\n      override those passed to <code>dat.GUI</code>\\'s constructor. This makes it\\n      easier to work incrementally, but <code>localStorage</code> is fragile,\\n      and your friends may not see the same values you do.\\n      \\n    </div>\\n    \\n  </div>\\n\\n</div>',\r\n\".dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity 0.1s linear;-o-transition:opacity 0.1s linear;-moz-transition:opacity 0.1s linear;transition:opacity 0.1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity 0.1s linear;-o-transition:opacity 0.1s linear;-moz-transition:opacity 0.1s linear;transition:opacity 0.1s linear;border:0;position:absolute;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-x:hidden}.dg.a.has-save ul{margin-top:27px}.dg.a.has-save ul.closed{margin-top:0}.dg.a .save-row{position:fixed;top:0;z-index:1002}.dg li{-webkit-transition:height 0.1s ease-out;-o-transition:height 0.1s ease-out;-moz-transition:height 0.1s ease-out;transition:height 0.1s ease-out}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;overflow:hidden;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li > *{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .c{float:left;width:60%}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:9px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2fa1d6}.dg .cr.number input[type=text]{color:#2fa1d6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2fa1d6}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}\\n\",\r\ndat.controllers.factory=function(e,a,c,d,f,b,n){return function(h,j,m,l){var o=h[j];if(n.isArray(m)||n.isObject(m))return new e(h,j,m);if(n.isNumber(o))return n.isNumber(m)&&n.isNumber(l)?new c(h,j,m,l):new a(h,j,{min:m,max:l});if(n.isString(o))return new d(h,j);if(n.isFunction(o))return new f(h,j,\"\");if(n.isBoolean(o))return new b(h,j)}}(dat.controllers.OptionController,dat.controllers.NumberControllerBox,dat.controllers.NumberControllerSlider,dat.controllers.StringController=function(e,a,c){var d=\r\nfunction(c,b){function e(){h.setValue(h.__input.value)}d.superclass.call(this,c,b);var h=this;this.__input=document.createElement(\"input\");this.__input.setAttribute(\"type\",\"text\");a.bind(this.__input,\"keyup\",e);a.bind(this.__input,\"change\",e);a.bind(this.__input,\"blur\",function(){h.__onFinishChange&&h.__onFinishChange.call(h,h.getValue())});a.bind(this.__input,\"keydown\",function(a){a.keyCode===13&&this.blur()});this.updateDisplay();this.domElement.appendChild(this.__input)};d.superclass=e;c.extend(d.prototype,\r\ne.prototype,{updateDisplay:function(){if(!a.isActive(this.__input))this.__input.value=this.getValue();return d.superclass.prototype.updateDisplay.call(this)}});return d}(dat.controllers.Controller,dat.dom.dom,dat.utils.common),dat.controllers.FunctionController,dat.controllers.BooleanController,dat.utils.common),dat.controllers.Controller,dat.controllers.BooleanController,dat.controllers.FunctionController,dat.controllers.NumberControllerBox,dat.controllers.NumberControllerSlider,dat.controllers.OptionController,\r\ndat.controllers.ColorController=function(e,a,c,d,f){function b(a,b,c,d){a.style.background=\"\";f.each(j,function(e){a.style.cssText+=\"background: \"+e+\"linear-gradient(\"+b+\", \"+c+\" 0%, \"+d+\" 100%); \"})}function n(a){a.style.background=\"\";a.style.cssText+=\"background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);\";a.style.cssText+=\"background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);\";\r\na.style.cssText+=\"background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);\";a.style.cssText+=\"background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);\";a.style.cssText+=\"background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);\"}var h=function(e,l){function o(b){q(b);a.bind(window,\"mousemove\",q);a.bind(window,\r\n\"mouseup\",j)}function j(){a.unbind(window,\"mousemove\",q);a.unbind(window,\"mouseup\",j)}function g(){var a=d(this.value);a!==false?(p.__color.__state=a,p.setValue(p.__color.toOriginal())):this.value=p.__color.toString()}function i(){a.unbind(window,\"mousemove\",s);a.unbind(window,\"mouseup\",i)}function q(b){b.preventDefault();var c=a.getWidth(p.__saturation_field),d=a.getOffset(p.__saturation_field),e=(b.clientX-d.left+document.body.scrollLeft)/c,b=1-(b.clientY-d.top+document.body.scrollTop)/c;b>1?b=\r\n1:b<0&&(b=0);e>1?e=1:e<0&&(e=0);p.__color.v=b;p.__color.s=e;p.setValue(p.__color.toOriginal());return false}function s(b){b.preventDefault();var c=a.getHeight(p.__hue_field),d=a.getOffset(p.__hue_field),b=1-(b.clientY-d.top+document.body.scrollTop)/c;b>1?b=1:b<0&&(b=0);p.__color.h=b*360;p.setValue(p.__color.toOriginal());return false}h.superclass.call(this,e,l);this.__color=new c(this.getValue());this.__temp=new c(0);var p=this;this.domElement=document.createElement(\"div\");a.makeSelectable(this.domElement,\r\nfalse);this.__selector=document.createElement(\"div\");this.__selector.className=\"selector\";this.__saturation_field=document.createElement(\"div\");this.__saturation_field.className=\"saturation-field\";this.__field_knob=document.createElement(\"div\");this.__field_knob.className=\"field-knob\";this.__field_knob_border=\"2px solid \";this.__hue_knob=document.createElement(\"div\");this.__hue_knob.className=\"hue-knob\";this.__hue_field=document.createElement(\"div\");this.__hue_field.className=\"hue-field\";this.__input=\r\ndocument.createElement(\"input\");this.__input.type=\"text\";this.__input_textShadow=\"0 1px 1px \";a.bind(this.__input,\"keydown\",function(a){a.keyCode===13&&g.call(this)});a.bind(this.__input,\"blur\",g);a.bind(this.__selector,\"mousedown\",function(){a.addClass(this,\"drag\").bind(window,\"mouseup\",function(){a.removeClass(p.__selector,\"drag\")})});var t=document.createElement(\"div\");f.extend(this.__selector.style,{width:\"122px\",height:\"102px\",padding:\"3px\",backgroundColor:\"#222\",boxShadow:\"0px 1px 3px rgba(0,0,0,0.3)\"});\r\nf.extend(this.__field_knob.style,{position:\"absolute\",width:\"12px\",height:\"12px\",border:this.__field_knob_border+(this.__color.v<0.5?\"#fff\":\"#000\"),boxShadow:\"0px 1px 3px rgba(0,0,0,0.5)\",borderRadius:\"12px\",zIndex:1});f.extend(this.__hue_knob.style,{position:\"absolute\",width:\"15px\",height:\"2px\",borderRight:\"4px solid #fff\",zIndex:1});f.extend(this.__saturation_field.style,{width:\"100px\",height:\"100px\",border:\"1px solid #555\",marginRight:\"3px\",display:\"inline-block\",cursor:\"pointer\"});f.extend(t.style,\r\n{width:\"100%\",height:\"100%\",background:\"none\"});b(t,\"top\",\"rgba(0,0,0,0)\",\"#000\");f.extend(this.__hue_field.style,{width:\"15px\",height:\"100px\",display:\"inline-block\",border:\"1px solid #555\",cursor:\"ns-resize\"});n(this.__hue_field);f.extend(this.__input.style,{outline:\"none\",textAlign:\"center\",color:\"#fff\",border:0,fontWeight:\"bold\",textShadow:this.__input_textShadow+\"rgba(0,0,0,0.7)\"});a.bind(this.__saturation_field,\"mousedown\",o);a.bind(this.__field_knob,\"mousedown\",o);a.bind(this.__hue_field,\"mousedown\",\r\nfunction(b){s(b);a.bind(window,\"mousemove\",s);a.bind(window,\"mouseup\",i)});this.__saturation_field.appendChild(t);this.__selector.appendChild(this.__field_knob);this.__selector.appendChild(this.__saturation_field);this.__selector.appendChild(this.__hue_field);this.__hue_field.appendChild(this.__hue_knob);this.domElement.appendChild(this.__input);this.domElement.appendChild(this.__selector);this.updateDisplay()};h.superclass=e;f.extend(h.prototype,e.prototype,{updateDisplay:function(){var a=d(this.getValue());\r\nif(a!==false){var e=false;f.each(c.COMPONENTS,function(b){if(!f.isUndefined(a[b])&&!f.isUndefined(this.__color.__state[b])&&a[b]!==this.__color.__state[b])return e=true,{}},this);e&&f.extend(this.__color.__state,a)}f.extend(this.__temp.__state,this.__color.__state);this.__temp.a=1;var h=this.__color.v<0.5||this.__color.s>0.5?255:0,j=255-h;f.extend(this.__field_knob.style,{marginLeft:100*this.__color.s-7+\"px\",marginTop:100*(1-this.__color.v)-7+\"px\",backgroundColor:this.__temp.toString(),border:this.__field_knob_border+\r\n\"rgb(\"+h+\",\"+h+\",\"+h+\")\"});this.__hue_knob.style.marginTop=(1-this.__color.h/360)*100+\"px\";this.__temp.s=1;this.__temp.v=1;b(this.__saturation_field,\"left\",\"#fff\",this.__temp.toString());f.extend(this.__input.style,{backgroundColor:this.__input.value=this.__color.toString(),color:\"rgb(\"+h+\",\"+h+\",\"+h+\")\",textShadow:this.__input_textShadow+\"rgba(\"+j+\",\"+j+\",\"+j+\",.7)\"})}});var j=[\"-moz-\",\"-o-\",\"-webkit-\",\"-ms-\",\"\"];return h}(dat.controllers.Controller,dat.dom.dom,dat.color.Color=function(e,a,c,d){function f(a,\r\nb,c){Object.defineProperty(a,b,{get:function(){if(this.__state.space===\"RGB\")return this.__state[b];n(this,b,c);return this.__state[b]},set:function(a){if(this.__state.space!==\"RGB\")n(this,b,c),this.__state.space=\"RGB\";this.__state[b]=a}})}function b(a,b){Object.defineProperty(a,b,{get:function(){if(this.__state.space===\"HSV\")return this.__state[b];h(this);return this.__state[b]},set:function(a){if(this.__state.space!==\"HSV\")h(this),this.__state.space=\"HSV\";this.__state[b]=a}})}function n(b,c,e){if(b.__state.space===\r\n\"HEX\")b.__state[c]=a.component_from_hex(b.__state.hex,e);else if(b.__state.space===\"HSV\")d.extend(b.__state,a.hsv_to_rgb(b.__state.h,b.__state.s,b.__state.v));else throw\"Corrupted color state\";}function h(b){var c=a.rgb_to_hsv(b.r,b.g,b.b);d.extend(b.__state,{s:c.s,v:c.v});if(d.isNaN(c.h)){if(d.isUndefined(b.__state.h))b.__state.h=0}else b.__state.h=c.h}var j=function(){this.__state=e.apply(this,arguments);if(this.__state===false)throw\"Failed to interpret color arguments\";this.__state.a=this.__state.a||\r\n1};j.COMPONENTS=\"r,g,b,h,s,v,hex,a\".split(\",\");d.extend(j.prototype,{toString:function(){return c(this)},toOriginal:function(){return this.__state.conversion.write(this)}});f(j.prototype,\"r\",2);f(j.prototype,\"g\",1);f(j.prototype,\"b\",0);b(j.prototype,\"h\");b(j.prototype,\"s\");b(j.prototype,\"v\");Object.defineProperty(j.prototype,\"a\",{get:function(){return this.__state.a},set:function(a){this.__state.a=a}});Object.defineProperty(j.prototype,\"hex\",{get:function(){if(!this.__state.space!==\"HEX\")this.__state.hex=\r\na.rgb_to_hex(this.r,this.g,this.b);return this.__state.hex},set:function(a){this.__state.space=\"HEX\";this.__state.hex=a}});return j}(dat.color.interpret,dat.color.math=function(){var e;return{hsv_to_rgb:function(a,c,d){var e=a/60-Math.floor(a/60),b=d*(1-c),n=d*(1-e*c),c=d*(1-(1-e)*c),a=[[d,c,b],[n,d,b],[b,d,c],[b,n,d],[c,b,d],[d,b,n]][Math.floor(a/60)%6];return{r:a[0]*255,g:a[1]*255,b:a[2]*255}},rgb_to_hsv:function(a,c,d){var e=Math.min(a,c,d),b=Math.max(a,c,d),e=b-e;if(b==0)return{h:NaN,s:0,v:0};\r\na=a==b?(c-d)/e:c==b?2+(d-a)/e:4+(a-c)/e;a/=6;a<0&&(a+=1);return{h:a*360,s:e/b,v:b/255}},rgb_to_hex:function(a,c,d){a=this.hex_with_component(0,2,a);a=this.hex_with_component(a,1,c);return a=this.hex_with_component(a,0,d)},component_from_hex:function(a,c){return a>>c*8&255},hex_with_component:function(a,c,d){return d<<(e=c*8)|a&~(255<<e)}}}(),dat.color.toString,dat.utils.common),dat.color.interpret,dat.utils.common),dat.utils.requestAnimationFrame=function(){return window.requestAnimationFrame||window.webkitRequestAnimationFrame||\r\nwindow.mozRequestAnimationFrame||window.oRequestAnimationFrame||window.msRequestAnimationFrame||function(e){window.setTimeout(e,1E3/60)}}(),dat.dom.CenteredDiv=function(e,a){var c=function(){this.backgroundElement=document.createElement(\"div\");a.extend(this.backgroundElement.style,{backgroundColor:\"rgba(0,0,0,0.8)\",top:0,left:0,display:\"none\",zIndex:\"1000\",opacity:0,WebkitTransition:\"opacity 0.2s linear\"});e.makeFullscreen(this.backgroundElement);this.backgroundElement.style.position=\"fixed\";this.domElement=\r\ndocument.createElement(\"div\");a.extend(this.domElement.style,{position:\"fixed\",display:\"none\",zIndex:\"1001\",opacity:0,WebkitTransition:\"-webkit-transform 0.2s ease-out, opacity 0.2s linear\"});document.body.appendChild(this.backgroundElement);document.body.appendChild(this.domElement);var c=this;e.bind(this.backgroundElement,\"click\",function(){c.hide()})};c.prototype.show=function(){var c=this;this.backgroundElement.style.display=\"block\";this.domElement.style.display=\"block\";this.domElement.style.opacity=\r\n0;this.domElement.style.webkitTransform=\"scale(1.1)\";this.layout();a.defer(function(){c.backgroundElement.style.opacity=1;c.domElement.style.opacity=1;c.domElement.style.webkitTransform=\"scale(1)\"})};c.prototype.hide=function(){var a=this,c=function(){a.domElement.style.display=\"none\";a.backgroundElement.style.display=\"none\";e.unbind(a.domElement,\"webkitTransitionEnd\",c);e.unbind(a.domElement,\"transitionend\",c);e.unbind(a.domElement,\"oTransitionEnd\",c)};e.bind(this.domElement,\"webkitTransitionEnd\",\r\nc);e.bind(this.domElement,\"transitionend\",c);e.bind(this.domElement,\"oTransitionEnd\",c);this.backgroundElement.style.opacity=0;this.domElement.style.opacity=0;this.domElement.style.webkitTransform=\"scale(1.1)\"};c.prototype.layout=function(){this.domElement.style.left=window.innerWidth/2-e.getWidth(this.domElement)/2+\"px\";this.domElement.style.top=window.innerHeight/2-e.getHeight(this.domElement)/2+\"px\"};return c}(dat.dom.dom,dat.utils.common),dat.dom.dom,dat.utils.common);\n\n/*** EXPORTS FROM exports-loader ***/\nmodule.exports = dat;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/exports-loader?dat!./~/three/examples/js/libs/dat.gui.min.js\n ** module id = 101\n ** module chunks = 0\n **/"],"sourceRoot":""}